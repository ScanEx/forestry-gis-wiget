'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var L$1 = _interopDefault(require('leaflet'));
var moment = _interopDefault(require('moment'));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global_1 =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  // eslint-disable-next-line no-new-func
  Function('return this')();

var fails = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var descriptors = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

var objectPropertyIsEnumerable = {
	f: f
};

var createPropertyDescriptor = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var toString = {}.toString;

var classofRaw = function (it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings



var toIndexedObject = function (it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var document$1 = global_1.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document$1) && isObject(document$1.createElement);

var documentCreateElement = function (it) {
  return EXISTS ? document$1.createElement(it) : {};
};

// Thank's IE8 for his funny defineProperty
var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};

var objectGetOwnPropertyDescriptor = {
	f: f$1
};

var anObject = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var objectDefineProperty = {
	f: f$2
};

var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function (key, value) {
  try {
    createNonEnumerableProperty(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  } return value;
};

var SHARED = '__core-js_shared__';
var store = global_1[SHARED] || setGlobal(SHARED, {});

var sharedStore = store;

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof sharedStore.inspectSource != 'function') {
  sharedStore.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

var inspectSource = sharedStore.inspectSource;

var WeakMap = global_1.WeakMap;

var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

var isPure = false;

var shared = createCommonjsModule(function (module) {
(module.exports = function (key, value) {
  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.5',
  mode:  'global',
  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});
});

var id = 0;
var postfix = Math.random();

var uid = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};

var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function (it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (nativeWeakMap) {
  var store$1 = new WeakMap$1();
  var wmget = store$1.get;
  var wmhas = store$1.has;
  var wmset = store$1.set;
  set = function (it, metadata) {
    wmset.call(store$1, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store$1, it) || {};
  };
  has$1 = function (it) {
    return wmhas.call(store$1, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return has(it, STATE) ? it[STATE] : {};
  };
  has$1 = function (it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor
};

var redefine = createCommonjsModule(function (module) {
var getInternalState = internalState.get;
var enforceInternalState = internalState.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global_1) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});
});

var path = global_1;

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
var toInteger = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
var toLength = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

var indexOf = arrayIncludes.indexOf;


var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
	f: f$3
};

var f$4 = Object.getOwnPropertySymbols;

var objectGetOwnPropertySymbols = {
	f: f$4
};

// all object keys, includes non-enumerable and symbols
var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

var isForced_1 = isForced;

var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

var aFunction$1 = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};

// optional / simple context binding
var functionBindContext = function (fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
var toObject = function (argument) {
  return Object(requireObjectCoercible(argument));
};

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
};

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

var useSymbolAsUid = nativeSymbol
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';

var WellKnownSymbolsStore = shared('wks');
var Symbol$1 = global_1.Symbol;
var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

var wellKnownSymbol = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod$1 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = functionBindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod$1(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod$1(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod$1(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod$1(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod$1(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1(6)
};

var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

var process = global_1.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (engineUserAgent) {
  match = engineUserAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = engineUserAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

var engineV8Version = version && +version;

var SPECIES$1 = wellKnownSymbol('species');

var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return engineV8Version >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$1] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

var arrayMethodUsesToLength = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !descriptors) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};

var $filter = arrayIteration.filter;



var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var arrayMethodIsStrict = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};

var $forEach = arrayIteration.forEach;



var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH$1 = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
var arrayForEach = (!STRICT_METHOD || !USES_TO_LENGTH$1) ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
  forEach: arrayForEach
});

var $indexOf = arrayIncludes.indexOf;



var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD$1 = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$2 }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var $map = arrayIteration.map;



var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH$3 = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$3 }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod$2 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction$1(callbackfn);
    var O = toObject(that);
    var self = indexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod$2(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod$2(true)
};

var $reduce = arrayReduce.left;



var STRICT_METHOD$2 = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH$4 = arrayMethodUsesToLength('reduce', { 1: 0 });

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$2 || !USES_TO_LENGTH$4 }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
};

var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return objectKeys(toObject(it));
  }
});

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof = toStringTagSupport ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
var objectToString = toStringTagSupport ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (!toStringTagSupport) {
  redefine(Object.prototype, 'toString', objectToString, { unsafe: true });
}

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

for (var COLLECTION_NAME in domIterables) {
  var Collection = global_1[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
  } catch (error) {
    CollectionPrototype.forEach = arrayForEach;
  }
}

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
  return O;
};

var html = getBuiltIn('document', 'documentElement');

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

var toString$1 = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var f$5 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};

var objectGetOwnPropertyNamesExternal = {
	f: f$5
};

var f$6 = wellKnownSymbol;

var wellKnownSymbolWrapped = {
	f: f$6
};

var defineProperty$1 = objectDefineProperty.f;

var defineWellKnownSymbol = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty$1(Symbol, NAME, {
    value: wellKnownSymbolWrapped.f(NAME)
  });
};

var defineProperty$2 = objectDefineProperty.f;



var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

var setToStringTag = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
    defineProperty$2(it, TO_STRING_TAG$2, { configurable: true, value: TAG });
  }
};

var $forEach$1 = arrayIteration.forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE$1 = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = internalState.set;
var getInternalState = internalState.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE$1];
var $Symbol = global_1.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var nativeDefineProperty$1 = objectDefineProperty.f;
var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore$1 = shared('wks');
var QObject = global_1.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = descriptors && fails(function () {
  return objectCreate(nativeDefineProperty$1({}, 'a', {
    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty$1(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty$1;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!descriptors) symbol.description = description;
  return symbol;
};

var isSymbol = useSymbolAsUid ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty$1(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach$1(keys, function (key) {
    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach$1(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!nativeSymbol) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
  objectDefineProperty.f = $defineProperty;
  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

  wellKnownSymbolWrapped.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (descriptors) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
  Symbol: $Symbol
});

$forEach$1(objectKeys(WellKnownSymbolsStore$1), function (name) {
  defineWellKnownSymbol(name);
});

_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return objectGetOwnPropertySymbols.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;

var defineProperty$3 = objectDefineProperty.f;


var NativeSymbol = global_1.Symbol;

if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty$3(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  _export({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}

// `Symbol.asyncIterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');

// `Symbol.toStringTag` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: objectCreate(null)
  });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

var iterators = {};

var correctPrototypeGetter = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var IE_PROTO$1 = sharedKey('IE_PROTO');
var ObjectPrototype$1 = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype$1 : null;
};

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ( !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





var returnThis$1 = function () { return this; };

var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
  iterators[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var aPossiblePrototype = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis$2 = function () { return this; };

var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
  }
  iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$1 = internalState.set;
var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState$1(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
iterators.Arguments = iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

var createProperty = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};

var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH$5 = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

var SPECIES$2 = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max$1 = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$5 }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES$2];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});

var defineProperty$4 = objectDefineProperty.f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (descriptors && !(NAME in FunctionPrototype)) {
  defineProperty$4(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

// JSON[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
setToStringTag(global_1.JSON, 'JSON', true);

// Math[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);

var FAILS_ON_PRIMITIVES$1 = fails(function () { objectGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$1, sham: !correctPrototypeGetter }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return objectGetPrototypeOf(toObject(it));
  }
});

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
_export({ target: 'Object', stat: true }, {
  setPrototypeOf: objectSetPrototypeOf
});

var nativePromiseConstructor = global_1.Promise;

var redefineAll = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};

var SPECIES$3 = wellKnownSymbol('species');

var setSpecies = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
    defineProperty(Constructor, SPECIES$3, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

var anInstance = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};

var ITERATOR$2 = wellKnownSymbol('iterator');
var ArrayPrototype$1 = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod = function (it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);
};

var ITERATOR$3 = wellKnownSymbol('iterator');

var getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$3]
    || it['@@iterator']
    || iterators[classof(it)];
};

// call something on iterator step with safe closing on error
var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

var iterate_1 = createCommonjsModule(function (module) {
var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES
          ? boundFunction(anObject(step = iterable[index])[0], step[1])
          : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};
});

var ITERATOR$4 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$4] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$4] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

var SPECIES$4 = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
var speciesConstructor = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$4]) == undefined ? defaultConstructor : aFunction$1(S);
};

var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

var location$1 = global_1.location;
var set$1 = global_1.setImmediate;
var clear = global_1.clearImmediate;
var process$1 = global_1.process;
var MessageChannel = global_1.MessageChannel;
var Dispatch = global_1.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set$1 || !clear) {
  set$1 = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classofRaw(process$1) == 'process') {
    defer = function (id) {
      process$1.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !engineIsIos) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = functionBindContext(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global_1.addEventListener &&
    typeof postMessage == 'function' &&
    !global_1.importScripts &&
    !fails(post) &&
    location$1.protocol !== 'file:'
  ) {
    defer = post;
    global_1.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
    defer = function (id) {
      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task = {
  set: set$1,
  clear: clear
};

var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;

var macrotask = task.set;


var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
var process$2 = global_1.process;
var Promise$1 = global_1.Promise;
var IS_NODE = classofRaw(process$2) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process$2.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process$2.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver$1 && !engineIsIos) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver$1(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise$1 && Promise$1.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$1.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global_1, flush);
    };
  }
}

var microtask = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction$1(resolve);
  this.reject = aFunction$1(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
var f$7 = function (C) {
  return new PromiseCapability(C);
};

var newPromiseCapability = {
	f: f$7
};

var promiseResolve = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var hostReportErrors = function (a, b) {
  var console = global_1.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

var perform = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

var task$1 = task.set;










var SPECIES$5 = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState$2 = internalState.get;
var setInternalState$2 = internalState.set;
var getInternalPromiseState = internalState.getterFor(PROMISE);
var PromiseConstructor = nativePromiseConstructor;
var TypeError$1 = global_1.TypeError;
var document$2 = global_1.document;
var process$3 = global_1.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability$1 = newPromiseCapability.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var IS_NODE$1 = classofRaw(process$3) == 'process';
var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced_1(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (engineV8Version === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
  }
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES$5] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify$1 = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$2.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global_1.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global_1['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task$1.call(global_1, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE$1) {
          process$3.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task$1.call(global_1, function () {
    if (IS_NODE$1) {
      process$3.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify$1(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify$1(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction$1(executor);
    Internal.call(this);
    var state = getInternalState$2(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState$2(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify$1(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState$2(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if ( typeof nativePromiseConstructor == 'function') {
    nativeThen = nativePromiseConstructor.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
      }
    });
  }
}

_export({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
_export({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability$1(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

_export({ target: PROMISE, stat: true, forced:  FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve( this, x);
  }
});

_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction$1(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate_1(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction$1(C.resolve);
      iterate_1(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod$3 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$3(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$3(true)
};

var charAt = stringMultibyte.charAt;



var STRING_ITERATOR = 'String Iterator';
var setInternalState$3 = internalState.set;
var getInternalState$3 = internalState.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$3(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});

var ITERATOR$5 = wellKnownSymbol('iterator');
var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
var ArrayValues = es_array_iterator.values;

for (var COLLECTION_NAME$1 in domIterables) {
  var Collection$1 = global_1[COLLECTION_NAME$1];
  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
  if (CollectionPrototype$1) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype$1[ITERATOR$5] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$5, ArrayValues);
    } catch (error) {
      CollectionPrototype$1[ITERATOR$5] = ArrayValues;
    }
    if (!CollectionPrototype$1[TO_STRING_TAG$3]) {
      createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$3, COLLECTION_NAME$1);
    }
    if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
      }
    }
  }
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH$6 = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

var max$2 = Math.max;
var min$2 = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$6 }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$2(max$2(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var EventTarget = /*#__PURE__*/function () {
  function EventTarget() {
    _classCallCheck(this, EventTarget);

    this.listeners = {};
  }

  _createClass(EventTarget, [{
    key: "addEventListener",
    value: function addEventListener(type, callback) {
      if (!(type in this.listeners)) {
        this.listeners[type] = [];
      }

      this.listeners[type].push(callback);
    }
  }, {
    key: "on",
    value: function on(type, callback) {
      this.addEventListener(type, callback);
      return this;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, callback) {
      if (!(type in this.listeners)) {
        return;
      }

      var stack = this.listeners[type];

      for (var i = 0, l = stack.length; i < l; i++) {
        if (stack[i] === callback) {
          stack.splice(i, 1);
          return this.removeEventListener(type, callback);
        }
      }
    }
  }, {
    key: "off",
    value: function off(type, callback) {
      this.removeEventListener(type, callback);
      return this;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (!(event.type in this.listeners)) {
        return;
      }

      var stack = this.listeners[event.type];
      Object.defineProperty(event, 'target', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: this
      });

      for (var i = 0, l = stack.length; i < l; i++) {
        stack[i].call(this, event);
      }
    }
  }]);

  return EventTarget;
}();

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
_export({ target: 'Array', proto: true, forced: FORCED$1 }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER$1) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER$1) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});

var min$3 = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min$3((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

// `Array.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
_export({ target: 'Array', proto: true }, {
  copyWithin: arrayCopyWithin
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('copyWithin');

var $every = arrayIteration.every;



var STRICT_METHOD$3 = arrayMethodIsStrict('every');
var USES_TO_LENGTH$7 = arrayMethodUsesToLength('every');

// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 || !USES_TO_LENGTH$7 }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
var arrayFill = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
_export({ target: 'Array', proto: true }, {
  fill: arrayFill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');

var $find = arrayIteration.find;



var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH$8 = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$8 }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);

var $findIndex = arrayIteration.findIndex;



var FIND_INDEX = 'findIndex';
var SKIPS_HOLES$1 = true;

var USES_TO_LENGTH$9 = arrayMethodUsesToLength(FIND_INDEX);

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; });

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$9 }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};

var INCORRECT_ITERATION$1 = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION$1 }, {
  from: arrayFrom
});

var $includes = arrayIncludes.includes;



var USES_TO_LENGTH$a = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$a }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

var nativeJoin = [].join;

var ES3_STRINGS = indexedObject != Object;
var STRICT_METHOD$4 = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
_export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$4 }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

var min$4 = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO$1 = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD$5 = arrayMethodIsStrict('lastIndexOf');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH$b = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
var FORCED$2 = NEGATIVE_ZERO$1 || !STRICT_METHOD$5 || !USES_TO_LENGTH$b;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
var arrayLastIndexOf = FORCED$2 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO$1) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min$4(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;

// `Array.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
_export({ target: 'Array', proto: true, forced: arrayLastIndexOf !== [].lastIndexOf }, {
  lastIndexOf: arrayLastIndexOf
});

var $some = arrayIteration.some;



var STRICT_METHOD$6 = arrayMethodIsStrict('some');
var USES_TO_LENGTH$c = arrayMethodUsesToLength('some');

// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$6 || !USES_TO_LENGTH$c }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
var toIndex = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity$1 = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor$1 = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity$1) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$1(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var ieee754 = {
  pack: pack,
  unpack: unpack
};

var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var defineProperty$5 = objectDefineProperty.f;




var getInternalState$4 = internalState.get;
var setInternalState$4 = internalState.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE$2 = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global_1[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global_1[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$2];
var ObjectPrototype$2 = Object.prototype;
var RangeError$1 = global_1.RangeError;

var packIEEE754 = ieee754.pack;
var unpackIEEE754 = ieee754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty$5(Constructor[PROTOTYPE$2], key, { get: function () { return getInternalState$4(this)[key]; } });
};

var get$1 = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState$4(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState$4(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set$2 = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState$4(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState$4(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!arrayBufferNative) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState$4(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!descriptors) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState$4(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
    setInternalState$4(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!descriptors) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (descriptors) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE$2], {
    getInt8: function getInt8(byteOffset) {
      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get$1(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set$2(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set$2(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set$2(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set$2(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$2] = NativeArrayBuffer[PROTOTYPE$2];
    for (var keys$1 = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys$1.length > j;) {
      if (!((key = keys$1[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$2) {
    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$2);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

var ARRAY_BUFFER$1 = 'ArrayBuffer';
var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER$1];
var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];

// `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
_export({ global: true, forced: NativeArrayBuffer$1 !== ArrayBuffer$1 }, {
  ArrayBuffer: ArrayBuffer$1
});

setSpecies(ARRAY_BUFFER$1);

var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
var DataView$1 = arrayBuffer.DataView;
var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
_export({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
    var viewSource = new DataView$1(this);
    var viewTarget = new DataView$1(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});

// `globalThis` object
// https://github.com/tc39/proposal-global
_export({ global: true }, {
  globalThis: global_1
});

// makes subclassing work correct for wrapped built-ins
var inheritIfRequired = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    objectSetPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) objectSetPrototypeOf($this, NewTargetPrototype);
  return $this;
};

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod$4 = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod$4(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod$4(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod$4(3)
};

var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
var defineProperty$6 = objectDefineProperty.f;
var trim = stringTrim.trim;

var NUMBER = 'Number';
var NativeNumber = global_1[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys$2 = descriptors ? getOwnPropertyNames$1(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j$1 = 0, key$1; keys$2.length > j$1; j$1++) {
    if (has(NativeNumber, key$1 = keys$2[j$1]) && !has(NumberWrapper, key$1)) {
      defineProperty$6(NumberWrapper, key$1, getOwnPropertyDescriptor$3(NativeNumber, key$1));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global_1, NUMBER, NumberWrapper);
}

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
var thisNumberValue = function (value) {
  if (typeof value != 'number' && classofRaw(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
var stringRepeat = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};

var nativeToFixed = 1.0.toFixed;
var floor$2 = Math.floor;

var pow$1 = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow$1(x, n - 1, acc * x) : pow$1(x * x, n / 2, acc);
};

var log$1 = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var FORCED$3 = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
_export({ target: 'Number', proto: true, forced: FORCED$3 }, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function (n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor$2(c2 / 1e7);
      }
    };

    var divide = function (n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor$2(c / n);
        c = (c % n) * 1e7;
      }
    };

    var dataToString = function () {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
        }
      } return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log$1(number * pow$1(2, 69, 1)) - 69;
      z = e < 0 ? number * pow$1(2, -e, 1) : number / pow$1(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow$1(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + stringRepeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + stringRepeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});

var nativeAssign = Object.assign;
var defineProperty$7 = Object.defineProperty;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
var objectAssign = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$7({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty$7(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
  while (argumentsLength > index) {
    var S = indexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
  assign: objectAssign
});

var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;


var FAILS_ON_PRIMITIVES$2 = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });
var FORCED$4 = !descriptors || FAILS_ON_PRIMITIVES$2;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
_export({ target: 'Object', stat: true, forced: FORCED$4, sham: !descriptors }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
  }
});

var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;

var FAILS_ON_PRIMITIVES$3 = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$3 }, {
  getOwnPropertyNames: nativeGetOwnPropertyNames$2
});

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
var sameValue = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

// `Object.is` method
// https://tc39.github.io/ecma262/#sec-object.is
_export({ target: 'Object', stat: true }, {
  is: sameValue
});

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
var isRegexp = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
};

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

var UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

var BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

var regexpStickyHelpers = {
	UNSUPPORTED_Y: UNSUPPORTED_Y,
	BROKEN_CARET: BROKEN_CARET
};

var defineProperty$8 = objectDefineProperty.f;
var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;





var setInternalState$5 = internalState.set;



var MATCH$1 = wellKnownSymbol('match');
var NativeRegExp = global_1.RegExp;
var RegExpPrototype$1 = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y;

var FORCED$5 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y$1 || fails(function () {
  re2[MATCH$1] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED$5) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegexp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = regexpFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y$1) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(
      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
      thisIsRegExp ? this : RegExpPrototype$1,
      RegExpWrapper
    );

    if (UNSUPPORTED_Y$1 && sticky) setInternalState$5(result, { sticky: sticky });

    return result;
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty$8(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys$3 = getOwnPropertyNames$2(NativeRegExp);
  var index = 0;
  while (keys$3.length > index) proxy(keys$3[index++]);
  RegExpPrototype$1.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype$1;
  redefine(global_1, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$2;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y$2 && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var regexpExec = patchedExec;

_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
  exec: regexpExec
});

var UNSUPPORTED_Y$3 = regexpStickyHelpers.UNSUPPORTED_Y;

// `RegExp.prototype.flags` getter
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
if (descriptors && (/./g.flags != 'g' || UNSUPPORTED_Y$3)) {
  objectDefineProperty.f(RegExp.prototype, 'flags', {
    configurable: true,
    get: regexpFlags
  });
}

var notARegexp = function (it) {
  if (isRegexp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};

var MATCH$2 = wellKnownSymbol('match');

var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH$2] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) { /* empty */ }
  } return false;
};

// `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes
_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

// TODO: Remove from `core-js@4` since it's moved to entry points







var SPECIES$6 = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES$6] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};

var charAt$1 = stringMultibyte.charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
var advanceStringIndex = function (S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
};

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
var regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classofRaw(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

// @@match logic
fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regexpExecAbstract(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regexpExecAbstract(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

// `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
_export({ target: 'String', proto: true }, {
  repeat: stringRepeat
});

var max$3 = Math.max;
var min$5 = Math.min;
var floor$3 = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regexpExecAbstract(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max$3(min$5(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor$3(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

// @@search logic
fixRegexpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative(nativeSearch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regexpExecAbstract(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

var arrayPush = [].push;
var min$6 = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegexp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min$6(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
var stringTrimForced = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $trim = stringTrim.trim;


// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});

var defineProperty$9 = objectDefineProperty.f;





var Int8Array$1 = global_1.Int8Array;
var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
var Uint8ClampedArray = global_1.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype$3 = Object.prototype;
var isPrototypeOf = ObjectPrototype$3.isPrototypeOf;

var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME$1;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (objectSetPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME$1)) {
    var TypedArrayConstructor = global_1[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!descriptors) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global_1[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!descriptors) return;
  if (objectSetPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global_1[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global_1[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME$1 in TypedArrayConstructorsList) {
  if (!global_1[NAME$1]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$3) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$4)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty$9(TypedArrayPrototype, TO_STRING_TAG$4, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME$1 in TypedArrayConstructorsList) if (global_1[NAME$1]) {
    createNonEnumerableProperty(global_1[NAME$1], TYPED_ARRAY_TAG, NAME$1);
  }
}

var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};

/* eslint-disable no-new */



var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer$3 = global_1.ArrayBuffer;
var Int8Array$2 = global_1.Int8Array;

var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
  Int8Array$2(1);
}) || !fails(function () {
  new Int8Array$2(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array$2();
  new Int8Array$2(null);
  new Int8Array$2(1.5);
  new Int8Array$2(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array$2(new ArrayBuffer$3(2), 1, undefined).length !== 1;
});

var toPositiveInteger = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};

var toOffset = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = functionBindContext(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor$1(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};

var typedArrayConstructor = createCommonjsModule(function (module) {


















var getOwnPropertyNames = objectGetOwnPropertyNames.f;

var forEach = arrayIteration.forEach;






var getInternalState = internalState.get;
var setInternalState = internalState.set;
var nativeDefineProperty = objectDefineProperty.f;
var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var round = Math.round;
var RangeError = global_1.RangeError;
var ArrayBuffer = arrayBuffer.ArrayBuffer;
var DataView = arrayBuffer.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = arrayBufferViewCore.TypedArray;
var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = arrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (descriptors) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
    objectDefineProperty.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
    } else if (typedArrayConstructorsRequireWrappers) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    _export({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };
});

// `Float32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Float64Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// `Int8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start /* , end */) {
  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

var $every$1 = arrayIteration.every;

var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod$2('every', function every(callbackfn /* , thisArg */) {
  return $every$1(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {
  return arrayFill.apply(aTypedArray$3(this), arguments);
});

var $filter$1 = arrayIteration.filter;


var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod$4('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor$2(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});

var $find$1 = arrayIteration.find;

var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod$5('find', function find(predicate /* , thisArg */) {
  return $find$1(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var $findIndex$1 = arrayIteration.findIndex;

var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod$6('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex$1(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var $forEach$2 = arrayIteration.forEach;

var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod$7('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach$2(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var $includes$1 = arrayIncludes.includes;

var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod$8('includes', function includes(searchElement /* , fromIndex */) {
  return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

var $indexOf$1 = arrayIncludes.indexOf;

var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod$9('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf$1(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

var ITERATOR$6 = wellKnownSymbol('iterator');
var Uint8Array = global_1.Uint8Array;
var arrayValues = es_array_iterator.values;
var arrayKeys = es_array_iterator.keys;
var arrayEntries = es_array_iterator.entries;
var aTypedArray$a = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR$6];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray$a(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod$a('entries', function entries() {
  return arrayEntries.call(aTypedArray$a(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod$a('keys', function keys() {
  return arrayKeys.call(aTypedArray$a(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod$a(ITERATOR$6, typedArrayValues, !CORRECT_ITER_NAME);

var aTypedArray$b = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod$b('join', function join(separator) {
  return $join.apply(aTypedArray$b(this), arguments);
});

var aTypedArray$c = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
});

var $map$1 = arrayIteration.map;


var aTypedArray$d = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod$d('map', function map(mapfn /* , thisArg */) {
  return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
  });
});

var $reduce$1 = arrayReduce.left;

var aTypedArray$e = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod$e('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce$1(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

var $reduceRight = arrayReduce.right;

var aTypedArray$f = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$g = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
var floor$4 = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod$g('reverse', function reverse() {
  var that = this;
  var length = aTypedArray$g(that).length;
  var middle = floor$4(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});

var aTypedArray$h = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;

var FORCED$6 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod$h('set', function set(arrayLike /* , offset */) {
  aTypedArray$h(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED$6);

var aTypedArray$i = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;

var FORCED$7 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod$i('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray$i(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor$4(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED$7);

var $some$1 = arrayIteration.some;

var aTypedArray$j = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod$j('some', function some(callbackfn /* , thisArg */) {
  return $some$1(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$k = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod$k('sort', function sort(comparefn) {
  return $sort.call(aTypedArray$k(this), comparefn);
});

var aTypedArray$l = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
  var O = aTypedArray$l(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});

var Int8Array$3 = global_1.Int8Array;
var aTypedArray$m = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice$1 = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
  $toLocaleString.call(new Int8Array$3(1));
});

var FORCED$8 = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array$3.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
}, FORCED$8);

var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;



var Uint8Array$1 = global_1.Uint8Array;
var Uint8ArrayPrototype = Uint8Array$1 && Uint8Array$1.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

var ITERATOR$7 = wellKnownSymbol('iterator');

var nativeUrl = !fails(function () {
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return (isPure && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?a=1&c=3'
    || searchParams.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR$7]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://ÑÐµÑÑ').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#Ð±').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('http://x', undefined).host !== 'x';
});

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor$5 = Math.floor;
var stringFromCharCode = String.fromCharCode;

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor$5(delta / damp) : delta >> 1;
  delta += floor$5(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor$5(delta / baseMinusTMin);
  }
  return floor$5(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line  max-statements
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor$5((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        for (var k = base; /* no condition */; k += base) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor$5(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;
  }
  return output.join('');
};

var stringPunycodeToAscii = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }
  return encoded.join('.');
};

var getIterator = function (it) {
  var iteratorMethod = getIteratorMethod(it);
  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  } return anObject(iteratorMethod.call(it));
};

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`





















var $fetch$1 = getBuiltIn('fetch');
var Headers = getBuiltIn('Headers');
var ITERATOR$8 = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState$6 = internalState.set;
var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = result.replace(percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};

var find = /[!'()~]|%20/g;

var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replace[match];
};

var serialize = function (it) {
  return encodeURIComponent(it).replace(find, replacer);
};

var parseSearchParams = function (result, query) {
  if (query) {
    var attributes = query.split('&');
    var index = 0;
    var attribute, entry;
    while (index < attributes.length) {
      attribute = attributes[index++];
      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  }
};

var updateSearchParams = function (query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};

var validateArgumentsLength = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState$6(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
});

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;

  setInternalState$6(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: function () { /* empty */ },
    updateSearchParams: updateSearchParams
  });

  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);
      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        next = iterator.next;
        while (!(step = next.call(iterator)).done) {
          entryIterator = getIterator(anObject(step.value));
          entryNext = entryIterator.next;
          if (
            (first = entryNext.call(entryIterator)).done ||
            (second = entryNext.call(entryIterator)).done ||
            !entryNext.call(entryIterator).done
          ) throw TypeError('Expected sequence with length 2');
          entries.push({ key: first.value + '', value: second.value + '' });
        }
      } else for (key in init) if (has(init, key)) entries.push({ key: key, value: init[key] + '' });
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.appent` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({ key: name + '', value: value + '' });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index].key === key) entries.splice(index, 1);
      else index++;
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) result.push(entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) entries.splice(index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) entries.push({ key: key, value: val });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries;
    // Array#sort is not stable in some engines
    var slice = entries.slice();
    var entry, entriesIndex, sliceIndex;
    entries.length = 0;
    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
      entry = slice[sliceIndex];
      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
        if (entries[entriesIndex].key > entry.key) {
          entries.splice(entriesIndex, 0, entry);
          break;
        }
      }
      if (entriesIndex === sliceIndex) entries.push(entry);
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR$8, URLSearchParamsPrototype.entries);

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var index = 0;
  var entry;
  while (index < entries.length) {
    entry = entries[index++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  } return result.join('&');
}, { enumerable: true });

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

_export({ global: true, forced: !nativeUrl }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
// https://github.com/zloirock/core-js/issues/674
if (!nativeUrl && typeof $fetch$1 == 'function' && typeof Headers == 'function') {
  _export({ global: true, enumerable: true, forced: true }, {
    fetch: function fetch(input /* , init */) {
      var args = [input];
      var init, body, headers;
      if (arguments.length > 1) {
        init = arguments[1];
        if (isObject(init)) {
          body = init.body;
          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers(init.headers) : new Headers();
            if (!headers.has('content-type')) {
              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }
            init = objectCreate(init, {
              body: createPropertyDescriptor(0, String(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }
        args.push(init);
      } return $fetch$1.apply(this, args);
    }
  });
}

var web_urlSearchParams = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`











var codeAt = stringMultibyte.codeAt;





var NativeURL = global_1.URL;
var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
var getInternalSearchParamsState = web_urlSearchParams.getState;
var setInternalState$7 = internalState.set;
var getInternalURLState = internalState.getterFor('URL');
var floor$6 = Math.floor;
var pow$2 = Math.pow;

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
// eslint-disable-next-line no-control-regex
var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
var EOF;

var parseHost = function (url, input) {
  var result, codePoints, index;
  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result;
  // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);
    for (index = 0; index < codePoints.length; index++) {
      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
    }
    url.host = result;
  } else {
    input = stringPunycodeToAscii(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};

var parseIPv4 = function (input) {
  var parts = input.split('.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == '') {
    parts.pop();
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;
    if (part.length > 1 && part.charAt(0) == '0') {
      radix = HEX_START.test(part) ? 16 : 8;
      part = part.slice(radix == 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
      number = parseInt(part, radix);
    }
    numbers.push(number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow$2(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = numbers.pop();
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow$2(256, 3 - index);
  }
  return ipv4;
};

// eslint-disable-next-line max-statements
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var char = function () {
    return input.charAt(pointer);
  };

  if (char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (char()) {
    if (pieceIndex == 8) return;
    if (char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }
    if (char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (char()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (char() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!DIGIT.test(char())) return;
        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (char() == ':') {
      pointer++;
      if (!char()) return;
    } else if (char()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

var serializeHost = function (host) {
  var result, index, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      result.unshift(host % 256);
      host = floor$6(host / 256);
    } return result.join('.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[index].toString(16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (char, set) {
  var code = codeAt(char, 0);
  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};

var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

var isSpecial = function (url) {
  return has(specialSchemes, url.scheme);
};

var includesCredentials = function (url) {
  return url.username != '' || url.password != '';
};

var cannotHaveUsernamePasswordPort = function (url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};

var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0))
    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
};

var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
    string.length == 2 ||
    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

var shortenURLsPath = function (url) {
  var path = url.path;
  var pathSize = path.length;
  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};

var isSingleDot = function (segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};

var isDoubleDot = function (segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

// eslint-disable-next-line max-statements
var parseURL = function (url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;

  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }

  input = input.replace(TAB_AND_NEW_LINE, '');

  codePoints = arrayFrom(input);

  while (pointer <= codePoints.length) {
    char = codePoints[pointer];
    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;
        break;

      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
          buffer += char.toLowerCase();
        } else if (char == ':') {
          if (stateOverride && (
            (isSpecial(url) != has(specialSchemes, buffer)) ||
            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
            (url.scheme == 'file' && !url.host)
          )) return;
          url.scheme = buffer;
          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }
          buffer = '';
          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;
        break;

      case NO_SCHEME:
        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
        if (base.cannotBeABaseURL && char == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }
        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;

      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        } break;

      case PATH_OR_AUTHORITY:
        if (char == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }

      case RELATIVE:
        url.scheme = base.scheme;
        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
          state = RELATIVE_SLASH;
        } else if (char == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        } break;

      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == '/' || char == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        } break;

      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;

      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != '/' && char != '\\') {
          state = AUTHORITY;
          continue;
        } break;

      case AUTHORITY:
        if (char == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);
          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];
            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }
            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;
            else url.username += encodedCodePoints;
          }
          buffer = '';
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += char;
        break;

      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (char == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (char == '[') seenBracket = true;
          else if (char == ']') seenBracket = false;
          buffer += char;
        } break;

      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url)) ||
          stateOverride
        ) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
            buffer = '';
          }
          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;
        break;

      case FILE:
        url.scheme = 'file';
        if (char == '/' || char == '\\') state = FILE_SLASH;
        else if (base && base.scheme == 'file') {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }
            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        } break;

      case FILE_SLASH:
        if (char == '/' || char == '\\') {
          state = FILE_HOST;
          break;
        }
        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
          else url.host = base.host;
        }
        state = PATH;
        continue;

      case FILE_HOST:
        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          } continue;
        } else buffer += char;
        break;

      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != '/' && char != '\\') continue;
        } else if (!stateOverride && char == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != '/') continue;
        } break;

      case PATH:
        if (
          char == EOF || char == '/' ||
          (char == '\\' && isSpecial(url)) ||
          (!stateOverride && (char == '?' || char == '#'))
        ) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }
            url.path.push(buffer);
          }
          buffer = '';
          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }
          if (char == '?') {
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        } break;

      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == '?') {
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case QUERY:
        if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url)) url.query += '%27';
          else if (char == '#') url.query += '%23';
          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case FRAGMENT:
        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }

    pointer++;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState$7(that, { type: 'URL' });
  var baseState, failure;
  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
    else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }
  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams$1();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);
  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };
  if (!descriptors) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};

var URLPrototype = URLConstructor.prototype;

var serializeURL = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';
  if (host !== null) {
    output += '//';
    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }
    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';
  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};

var getOrigin = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};

var getProtocol = function () {
  return getInternalURLState(this).scheme + ':';
};

var getUsername = function () {
  return getInternalURLState(this).username;
};

var getPassword = function () {
  return getInternalURLState(this).password;
};

var getHost = function () {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? ''
    : port === null ? serializeHost(host)
    : serializeHost(host) + ':' + port;
};

var getHostname = function () {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};

var getPort = function () {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};

var getPathname = function () {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};

var getSearch = function () {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};

var getSearchParams = function () {
  return getInternalURLState(this).searchParams;
};

var getHash = function () {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};

var accessorDescriptor = function (getter, setter) {
  return { get: getter, set: setter, configurable: true, enumerable: true };
};

if (descriptors) {
  objectDefineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;
      else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);
      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);
      if (hash == '') {
        url.fragment = null;
        return;
      }
      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  });
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}

setToStringTag(URLConstructor, 'URL');

_export({ global: true, forced: !nativeUrl, sham: !descriptors }, {
  URL: URLConstructor
});

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
_export({ target: 'URL', proto: true, enumerable: true }, {
  toJSON: function toJSON() {
    return URL.prototype.toString.call(this);
  }
});

var commonjsGlobal$1=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof commonjsGlobal!=='undefined'?commonjsGlobal:typeof self!=='undefined'?self:{};function createCommonjsModule$1(fn,basedir,module){return module={path:basedir,exports:{},require:function require(path,base){return commonjsRequire(path,base===undefined||base===null?module.path:base);}},fn(module,module.exports),module.exports;}function commonjsRequire(){throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');}var check$1=function check(it){return it&&it.Math==Math&&it;};// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global_1$1=// eslint-disable-next-line no-undef
check$1((typeof globalThis==="undefined"?"undefined":_typeof(globalThis))=='object'&&globalThis)||check$1((typeof window==="undefined"?"undefined":_typeof(window))=='object'&&window)||check$1((typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self)||check$1(_typeof(commonjsGlobal$1)=='object'&&commonjsGlobal$1)||// eslint-disable-next-line no-new-func
Function('return this')();var fails$1=function fails(exec){try{return !!exec();}catch(error){return true;}};// Thank's IE8 for his funny defineProperty
var descriptors$1=!fails$1(function(){return Object.defineProperty({},1,{get:function get(){return 7;}})[1]!=7;});var nativePropertyIsEnumerable$2={}.propertyIsEnumerable;var getOwnPropertyDescriptor$4=Object.getOwnPropertyDescriptor;// Nashorn ~ JDK8 bug
var NASHORN_BUG$1=getOwnPropertyDescriptor$4&&!nativePropertyIsEnumerable$2.call({1:2},1);// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
var f$8=NASHORN_BUG$1?function propertyIsEnumerable(V){var descriptor=getOwnPropertyDescriptor$4(this,V);return !!descriptor&&descriptor.enumerable;}:nativePropertyIsEnumerable$2;var objectPropertyIsEnumerable$1={f:f$8};var createPropertyDescriptor$1=function createPropertyDescriptor(bitmap,value){return {enumerable:!(bitmap&1),configurable:!(bitmap&2),writable:!(bitmap&4),value:value};};var toString$2={}.toString;var classofRaw$1=function classofRaw(it){return toString$2.call(it).slice(8,-1);};var split$1=''.split;// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject$1=fails$1(function(){// throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
// eslint-disable-next-line no-prototype-builtins
return !Object('z').propertyIsEnumerable(0);})?function(it){return classofRaw$1(it)=='String'?split$1.call(it,''):Object(it);}:Object;// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$1=function requireObjectCoercible(it){if(it==undefined)throw TypeError("Can't call method on "+it);return it;};// toObject with fallback for non-array-like ES3 strings
var toIndexedObject$1=function toIndexedObject(it){return indexedObject$1(requireObjectCoercible$1(it));};var isObject$1=function isObject(it){return _typeof(it)==='object'?it!==null:typeof it==='function';};// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive$1=function toPrimitive(input,PREFERRED_STRING){if(!isObject$1(input))return input;var fn,val;if(PREFERRED_STRING&&typeof(fn=input.toString)=='function'&&!isObject$1(val=fn.call(input)))return val;if(typeof(fn=input.valueOf)=='function'&&!isObject$1(val=fn.call(input)))return val;if(!PREFERRED_STRING&&typeof(fn=input.toString)=='function'&&!isObject$1(val=fn.call(input)))return val;throw TypeError("Can't convert object to primitive value");};var hasOwnProperty$1={}.hasOwnProperty;var has$2=function has(it,key){return hasOwnProperty$1.call(it,key);};var document$1$1=global_1$1.document;// typeof document.createElement is 'object' in old IE
var EXISTS$1=isObject$1(document$1$1)&&isObject$1(document$1$1.createElement);var documentCreateElement$1=function documentCreateElement(it){return EXISTS$1?document$1$1.createElement(it):{};};// Thank's IE8 for his funny defineProperty
var ie8DomDefine$1=!descriptors$1&&!fails$1(function(){return Object.defineProperty(documentCreateElement$1('div'),'a',{get:function get(){return 7;}}).a!=7;});var nativeGetOwnPropertyDescriptor$3=Object.getOwnPropertyDescriptor;// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
var f$1$1=descriptors$1?nativeGetOwnPropertyDescriptor$3:function getOwnPropertyDescriptor(O,P){O=toIndexedObject$1(O);P=toPrimitive$1(P,true);if(ie8DomDefine$1)try{return nativeGetOwnPropertyDescriptor$3(O,P);}catch(error){/* empty */}if(has$2(O,P))return createPropertyDescriptor$1(!objectPropertyIsEnumerable$1.f.call(O,P),O[P]);};var objectGetOwnPropertyDescriptor$1={f:f$1$1};var anObject$1=function anObject(it){if(!isObject$1(it)){throw TypeError(String(it)+' is not an object');}return it;};var nativeDefineProperty$2=Object.defineProperty;// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
var f$2$1=descriptors$1?nativeDefineProperty$2:function defineProperty(O,P,Attributes){anObject$1(O);P=toPrimitive$1(P,true);anObject$1(Attributes);if(ie8DomDefine$1)try{return nativeDefineProperty$2(O,P,Attributes);}catch(error){/* empty */}if('get'in Attributes||'set'in Attributes)throw TypeError('Accessors not supported');if('value'in Attributes)O[P]=Attributes.value;return O;};var objectDefineProperty$1={f:f$2$1};var createNonEnumerableProperty$1=descriptors$1?function(object,key,value){return objectDefineProperty$1.f(object,key,createPropertyDescriptor$1(1,value));}:function(object,key,value){object[key]=value;return object;};var setGlobal$1=function setGlobal(key,value){try{createNonEnumerableProperty$1(global_1$1,key,value);}catch(error){global_1$1[key]=value;}return value;};var SHARED$1='__core-js_shared__';var store$2=global_1$1[SHARED$1]||setGlobal$1(SHARED$1,{});var sharedStore$1=store$2;var functionToString$1=Function.toString;// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if(typeof sharedStore$1.inspectSource!='function'){sharedStore$1.inspectSource=function(it){return functionToString$1.call(it);};}var inspectSource$1=sharedStore$1.inspectSource;var WeakMap$2=global_1$1.WeakMap;var nativeWeakMap$1=typeof WeakMap$2==='function'&&/native code/.test(inspectSource$1(WeakMap$2));var isPure$1=false;var shared$1=createCommonjsModule$1(function(module){(module.exports=function(key,value){return sharedStore$1[key]||(sharedStore$1[key]=value!==undefined?value:{});})('versions',[]).push({version:'3.6.5',mode:'global',copyright:'Â© 2020 Denis Pushkarev (zloirock.ru)'});});var id$1=0;var postfix$1=Math.random();var uid$1=function uid(key){return 'Symbol('+String(key===undefined?'':key)+')_'+(++id$1+postfix$1).toString(36);};var keys$4=shared$1('keys');var sharedKey$1=function sharedKey(key){return keys$4[key]||(keys$4[key]=uid$1(key));};var hiddenKeys$2={};var WeakMap$1$1=global_1$1.WeakMap;var set$3,get$2,has$1$1;var enforce$1=function enforce(it){return has$1$1(it)?get$2(it):set$3(it,{});};var getterFor$1=function getterFor(TYPE){return function(it){var state;if(!isObject$1(it)||(state=get$2(it)).type!==TYPE){throw TypeError('Incompatible receiver, '+TYPE+' required');}return state;};};if(nativeWeakMap$1){var store$1$1=new WeakMap$1$1();var wmget$1=store$1$1.get;var wmhas$1=store$1$1.has;var wmset$1=store$1$1.set;set$3=function set(it,metadata){wmset$1.call(store$1$1,it,metadata);return metadata;};get$2=function get(it){return wmget$1.call(store$1$1,it)||{};};has$1$1=function has$1(it){return wmhas$1.call(store$1$1,it);};}else {var STATE$1=sharedKey$1('state');hiddenKeys$2[STATE$1]=true;set$3=function set(it,metadata){createNonEnumerableProperty$1(it,STATE$1,metadata);return metadata;};get$2=function get(it){return has$2(it,STATE$1)?it[STATE$1]:{};};has$1$1=function has$1(it){return has$2(it,STATE$1);};}var internalState$1={set:set$3,get:get$2,has:has$1$1,enforce:enforce$1,getterFor:getterFor$1};var redefine$1=createCommonjsModule$1(function(module){var getInternalState=internalState$1.get;var enforceInternalState=internalState$1.enforce;var TEMPLATE=String(String).split('String');(module.exports=function(O,key,value,options){var unsafe=options?!!options.unsafe:false;var simple=options?!!options.enumerable:false;var noTargetGet=options?!!options.noTargetGet:false;if(typeof value=='function'){if(typeof key=='string'&&!has$2(value,'name'))createNonEnumerableProperty$1(value,'name',key);enforceInternalState(value).source=TEMPLATE.join(typeof key=='string'?key:'');}if(O===global_1$1){if(simple)O[key]=value;else setGlobal$1(key,value);return;}else if(!unsafe){delete O[key];}else if(!noTargetGet&&O[key]){simple=true;}if(simple)O[key]=value;else createNonEnumerableProperty$1(O,key,value);// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype,'toString',function toString(){return typeof this=='function'&&getInternalState(this).source||inspectSource$1(this);});});var path$1=global_1$1;var aFunction$2=function aFunction(variable){return typeof variable=='function'?variable:undefined;};var getBuiltIn$1=function getBuiltIn(namespace,method){return arguments.length<2?aFunction$2(path$1[namespace])||aFunction$2(global_1$1[namespace]):path$1[namespace]&&path$1[namespace][method]||global_1$1[namespace]&&global_1$1[namespace][method];};var ceil$1=Math.ceil;var floor$7=Math.floor;// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
var toInteger$1=function toInteger(argument){return isNaN(argument=+argument)?0:(argument>0?floor$7:ceil$1)(argument);};var min$7=Math.min;// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
var toLength$1=function toLength(argument){return argument>0?min$7(toInteger$1(argument),0x1FFFFFFFFFFFFF):0;// 2 ** 53 - 1 == 9007199254740991
};var max$4=Math.max;var min$1$1=Math.min;// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$1=function toAbsoluteIndex(index,length){var integer=toInteger$1(index);return integer<0?max$4(integer+length,0):min$1$1(integer,length);};// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$5=function createMethod(IS_INCLUDES){return function($this,el,fromIndex){var O=toIndexedObject$1($this);var length=toLength$1(O.length);var index=toAbsoluteIndex$1(fromIndex,length);var value;// Array#includes uses SameValueZero equality algorithm
// eslint-disable-next-line no-self-compare
if(IS_INCLUDES&&el!=el)while(length>index){value=O[index++];// eslint-disable-next-line no-self-compare
if(value!=value)return true;// Array#indexOf ignores holes, Array#includes - not
}else for(;length>index;index++){if((IS_INCLUDES||index in O)&&O[index]===el)return IS_INCLUDES||index||0;}return !IS_INCLUDES&&-1;};};var arrayIncludes$1={// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
includes:createMethod$5(true),// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
indexOf:createMethod$5(false)};var indexOf$1=arrayIncludes$1.indexOf;var objectKeysInternal$1=function objectKeysInternal(object,names){var O=toIndexedObject$1(object);var i=0;var result=[];var key;for(key in O){!has$2(hiddenKeys$2,key)&&has$2(O,key)&&result.push(key);}// Don't enum bug & hidden keys
while(names.length>i){if(has$2(O,key=names[i++])){~indexOf$1(result,key)||result.push(key);}}return result;};// IE8- don't enum bug keys
var enumBugKeys$1=['constructor','hasOwnProperty','isPrototypeOf','propertyIsEnumerable','toLocaleString','toString','valueOf'];var hiddenKeys$1$1=enumBugKeys$1.concat('length','prototype');// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
var f$3$1=Object.getOwnPropertyNames||function getOwnPropertyNames(O){return objectKeysInternal$1(O,hiddenKeys$1$1);};var objectGetOwnPropertyNames$1={f:f$3$1};var f$4$1=Object.getOwnPropertySymbols;var objectGetOwnPropertySymbols$1={f:f$4$1};// all object keys, includes non-enumerable and symbols
var ownKeys$2=getBuiltIn$1('Reflect','ownKeys')||function ownKeys(it){var keys=objectGetOwnPropertyNames$1.f(anObject$1(it));var getOwnPropertySymbols=objectGetOwnPropertySymbols$1.f;return getOwnPropertySymbols?keys.concat(getOwnPropertySymbols(it)):keys;};var copyConstructorProperties$1=function copyConstructorProperties(target,source){var keys=ownKeys$2(source);var defineProperty=objectDefineProperty$1.f;var getOwnPropertyDescriptor=objectGetOwnPropertyDescriptor$1.f;for(var i=0;i<keys.length;i++){var key=keys[i];if(!has$2(target,key))defineProperty(target,key,getOwnPropertyDescriptor(source,key));}};var replacement$1=/#|\.prototype\./;var isForced$1=function isForced(feature,detection){var value=data$1[normalize$1(feature)];return value==POLYFILL$1?true:value==NATIVE$1?false:typeof detection=='function'?fails$1(detection):!!detection;};var normalize$1=isForced$1.normalize=function(string){return String(string).replace(replacement$1,'.').toLowerCase();};var data$1=isForced$1.data={};var NATIVE$1=isForced$1.NATIVE='N';var POLYFILL$1=isForced$1.POLYFILL='P';var isForced_1$1=isForced$1;var getOwnPropertyDescriptor$1$1=objectGetOwnPropertyDescriptor$1.f;/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/var _export$1=function _export(options,source){var TARGET=options.target;var GLOBAL=options.global;var STATIC=options.stat;var FORCED,target,key,targetProperty,sourceProperty,descriptor;if(GLOBAL){target=global_1$1;}else if(STATIC){target=global_1$1[TARGET]||setGlobal$1(TARGET,{});}else {target=(global_1$1[TARGET]||{}).prototype;}if(target)for(key in source){sourceProperty=source[key];if(options.noTargetGet){descriptor=getOwnPropertyDescriptor$1$1(target,key);targetProperty=descriptor&&descriptor.value;}else targetProperty=target[key];FORCED=isForced_1$1(GLOBAL?key:TARGET+(STATIC?'.':'#')+key,options.forced);// contained in target
if(!FORCED&&targetProperty!==undefined){if(_typeof(sourceProperty)===_typeof(targetProperty))continue;copyConstructorProperties$1(sourceProperty,targetProperty);}// add a flag to not completely full polyfills
if(options.sham||targetProperty&&targetProperty.sham){createNonEnumerableProperty$1(sourceProperty,'sham',true);}// extend global
redefine$1(target,key,sourceProperty,options);}};// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
var isArray$1=Array.isArray||function isArray(arg){return classofRaw$1(arg)=='Array';};// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
var toObject$1=function toObject(argument){return Object(requireObjectCoercible$1(argument));};var createProperty$1=function createProperty(object,key,value){var propertyKey=toPrimitive$1(key);if(propertyKey in object)objectDefineProperty$1.f(object,propertyKey,createPropertyDescriptor$1(0,value));else object[propertyKey]=value;};var nativeSymbol$1=!!Object.getOwnPropertySymbols&&!fails$1(function(){// Chrome 38 Symbol has incorrect toString conversion
// eslint-disable-next-line no-undef
return !String(Symbol());});var useSymbolAsUid$1=nativeSymbol$1// eslint-disable-next-line no-undef
&&!Symbol.sham// eslint-disable-next-line no-undef
&&_typeof(Symbol.iterator)=='symbol';var WellKnownSymbolsStore$2=shared$1('wks');var Symbol$1$1=global_1$1.Symbol;var createWellKnownSymbol$1=useSymbolAsUid$1?Symbol$1$1:Symbol$1$1&&Symbol$1$1.withoutSetter||uid$1;var wellKnownSymbol$1=function wellKnownSymbol(name){if(!has$2(WellKnownSymbolsStore$2,name)){if(nativeSymbol$1&&has$2(Symbol$1$1,name))WellKnownSymbolsStore$2[name]=Symbol$1$1[name];else WellKnownSymbolsStore$2[name]=createWellKnownSymbol$1('Symbol.'+name);}return WellKnownSymbolsStore$2[name];};var SPECIES$7=wellKnownSymbol$1('species');// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate$1=function arraySpeciesCreate(originalArray,length){var C;if(isArray$1(originalArray)){C=originalArray.constructor;// cross-realm fallback
if(typeof C=='function'&&(C===Array||isArray$1(C.prototype)))C=undefined;else if(isObject$1(C)){C=C[SPECIES$7];if(C===null)C=undefined;}}return new(C===undefined?Array:C)(length===0?0:length);};var engineUserAgent$1=getBuiltIn$1('navigator','userAgent')||'';var process$4=global_1$1.process;var versions$1=process$4&&process$4.versions;var v8$1=versions$1&&versions$1.v8;var match$1,version$1;if(v8$1){match$1=v8$1.split('.');version$1=match$1[0]+match$1[1];}else if(engineUserAgent$1){match$1=engineUserAgent$1.match(/Edge\/(\d+)/);if(!match$1||match$1[1]>=74){match$1=engineUserAgent$1.match(/Chrome\/(\d+)/);if(match$1)version$1=match$1[1];}}var engineV8Version$1=version$1&&+version$1;var SPECIES$1$1=wellKnownSymbol$1('species');var arrayMethodHasSpeciesSupport$1=function arrayMethodHasSpeciesSupport(METHOD_NAME){// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/677
return engineV8Version$1>=51||!fails$1(function(){var array=[];var constructor=array.constructor={};constructor[SPECIES$1$1]=function(){return {foo:1};};return array[METHOD_NAME](Boolean).foo!==1;});};var IS_CONCAT_SPREADABLE$1=wellKnownSymbol$1('isConcatSpreadable');var MAX_SAFE_INTEGER$2=0x1FFFFFFFFFFFFF;var MAXIMUM_ALLOWED_INDEX_EXCEEDED$1='Maximum allowed index exceeded';// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT$1=engineV8Version$1>=51||!fails$1(function(){var array=[];array[IS_CONCAT_SPREADABLE$1]=false;return array.concat()[0]!==array;});var SPECIES_SUPPORT$1=arrayMethodHasSpeciesSupport$1('concat');var isConcatSpreadable$1=function isConcatSpreadable(O){if(!isObject$1(O))return false;var spreadable=O[IS_CONCAT_SPREADABLE$1];return spreadable!==undefined?!!spreadable:isArray$1(O);};var FORCED$9=!IS_CONCAT_SPREADABLE_SUPPORT$1||!SPECIES_SUPPORT$1;// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
_export$1({target:'Array',proto:true,forced:FORCED$9},{concat:function concat(arg){// eslint-disable-line no-unused-vars
var O=toObject$1(this);var A=arraySpeciesCreate$1(O,0);var n=0;var i,k,length,len,E;for(i=-1,length=arguments.length;i<length;i++){E=i===-1?O:arguments[i];if(isConcatSpreadable$1(E)){len=toLength$1(E.length);if(n+len>MAX_SAFE_INTEGER$2)throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED$1);for(k=0;k<len;k++,n++){if(k in E)createProperty$1(A,n,E[k]);}}else {if(n>=MAX_SAFE_INTEGER$2)throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED$1);createProperty$1(A,n++,E);}}A.length=n;return A;}});// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
var arrayFill$1=function fill(value/* , start = 0, end = @length */){var O=toObject$1(this);var length=toLength$1(O.length);var argumentsLength=arguments.length;var index=toAbsoluteIndex$1(argumentsLength>1?arguments[1]:undefined,length);var end=argumentsLength>2?arguments[2]:undefined;var endPos=end===undefined?length:toAbsoluteIndex$1(end,length);while(endPos>index){O[index++]=value;}return O;};// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
var objectKeys$1=Object.keys||function keys(O){return objectKeysInternal$1(O,enumBugKeys$1);};// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
var objectDefineProperties$1=descriptors$1?Object.defineProperties:function defineProperties(O,Properties){anObject$1(O);var keys=objectKeys$1(Properties);var length=keys.length;var index=0;var key;while(length>index){objectDefineProperty$1.f(O,key=keys[index++],Properties[key]);}return O;};var html$1=getBuiltIn$1('document','documentElement');var GT$1='>';var LT$1='<';var PROTOTYPE$3='prototype';var SCRIPT$1='script';var IE_PROTO$2=sharedKey$1('IE_PROTO');var EmptyConstructor$1=function EmptyConstructor(){/* empty */};var scriptTag$1=function scriptTag(content){return LT$1+SCRIPT$1+GT$1+content+LT$1+'/'+SCRIPT$1+GT$1;};// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX$1=function NullProtoObjectViaActiveX(activeXDocument){activeXDocument.write(scriptTag$1(''));activeXDocument.close();var temp=activeXDocument.parentWindow.Object;activeXDocument=null;// avoid memory leak
return temp;};// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame$1=function NullProtoObjectViaIFrame(){// Thrash, waste and sodomy: IE GC bug
var iframe=documentCreateElement$1('iframe');var JS='java'+SCRIPT$1+':';var iframeDocument;iframe.style.display='none';html$1.appendChild(iframe);// https://github.com/zloirock/core-js/issues/475
iframe.src=String(JS);iframeDocument=iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(scriptTag$1('document.F=Object'));iframeDocument.close();return iframeDocument.F;};// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument$1;var _NullProtoObject=function NullProtoObject(){try{/* global ActiveXObject */activeXDocument$1=document.domain&&new ActiveXObject('htmlfile');}catch(error){/* ignore */}_NullProtoObject=activeXDocument$1?NullProtoObjectViaActiveX$1(activeXDocument$1):NullProtoObjectViaIFrame$1();var length=enumBugKeys$1.length;while(length--){delete _NullProtoObject[PROTOTYPE$3][enumBugKeys$1[length]];}return _NullProtoObject();};hiddenKeys$2[IE_PROTO$2]=true;// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
var objectCreate$1=Object.create||function create(O,Properties){var result;if(O!==null){EmptyConstructor$1[PROTOTYPE$3]=anObject$1(O);result=new EmptyConstructor$1();EmptyConstructor$1[PROTOTYPE$3]=null;// add "__proto__" for Object.getPrototypeOf polyfill
result[IE_PROTO$2]=O;}else result=_NullProtoObject();return Properties===undefined?result:objectDefineProperties$1(result,Properties);};var UNSCOPABLES$1=wellKnownSymbol$1('unscopables');var ArrayPrototype$2=Array.prototype;// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if(ArrayPrototype$2[UNSCOPABLES$1]==undefined){objectDefineProperty$1.f(ArrayPrototype$2,UNSCOPABLES$1,{configurable:true,value:objectCreate$1(null)});}// add a key to Array.prototype[@@unscopables]
var addToUnscopables$1=function addToUnscopables(key){ArrayPrototype$2[UNSCOPABLES$1][key]=true;};// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
_export$1({target:'Array',proto:true},{fill:arrayFill$1});// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables$1('fill');var aFunction$1$1=function aFunction$1(it){if(typeof it!='function'){throw TypeError(String(it)+' is not a function');}return it;};// optional / simple context binding
var functionBindContext$1=function functionBindContext(fn,that,length){aFunction$1$1(fn);if(that===undefined)return fn;switch(length){case 0:return function(){return fn.call(that);};case 1:return function(a){return fn.call(that,a);};case 2:return function(a,b){return fn.call(that,a,b);};case 3:return function(a,b,c){return fn.call(that,a,b,c);};}return function()/* ...args */{return fn.apply(that,arguments);};};var push$1=[].push;// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod$1$1=function createMethod$1(TYPE){var IS_MAP=TYPE==1;var IS_FILTER=TYPE==2;var IS_SOME=TYPE==3;var IS_EVERY=TYPE==4;var IS_FIND_INDEX=TYPE==6;var NO_HOLES=TYPE==5||IS_FIND_INDEX;return function($this,callbackfn,that,specificCreate){var O=toObject$1($this);var self=indexedObject$1(O);var boundFunction=functionBindContext$1(callbackfn,that,3);var length=toLength$1(self.length);var index=0;var create=specificCreate||arraySpeciesCreate$1;var target=IS_MAP?create($this,length):IS_FILTER?create($this,0):undefined;var value,result;for(;length>index;index++){if(NO_HOLES||index in self){value=self[index];result=boundFunction(value,index,O);if(TYPE){if(IS_MAP)target[index]=result;// map
else if(result)switch(TYPE){case 3:return true;// some
case 5:return value;// find
case 6:return index;// findIndex
case 2:push$1.call(target,value);// filter
}else if(IS_EVERY)return false;// every
}}}return IS_FIND_INDEX?-1:IS_SOME||IS_EVERY?IS_EVERY:target;};};var arrayIteration$1={// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
forEach:createMethod$1$1(0),// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
map:createMethod$1$1(1),// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
filter:createMethod$1$1(2),// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
some:createMethod$1$1(3),// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
every:createMethod$1$1(4),// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
find:createMethod$1$1(5),// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
findIndex:createMethod$1$1(6)};var arrayMethodIsStrict$1=function arrayMethodIsStrict(METHOD_NAME,argument){var method=[][METHOD_NAME];return !!method&&fails$1(function(){// eslint-disable-next-line no-useless-call,no-throw-literal
method.call(null,argument||function(){throw 1;},1);});};var defineProperty$a=Object.defineProperty;var cache$1={};var thrower$1=function thrower(it){throw it;};var arrayMethodUsesToLength$1=function arrayMethodUsesToLength(METHOD_NAME,options){if(has$2(cache$1,METHOD_NAME))return cache$1[METHOD_NAME];if(!options)options={};var method=[][METHOD_NAME];var ACCESSORS=has$2(options,'ACCESSORS')?options.ACCESSORS:false;var argument0=has$2(options,0)?options[0]:thrower$1;var argument1=has$2(options,1)?options[1]:undefined;return cache$1[METHOD_NAME]=!!method&&!fails$1(function(){if(ACCESSORS&&!descriptors$1)return true;var O={length:-1};if(ACCESSORS)defineProperty$a(O,1,{enumerable:true,get:thrower$1});else O[1]=1;method.call(O,argument0,argument1);});};var $forEach$3=arrayIteration$1.forEach;var STRICT_METHOD$7=arrayMethodIsStrict$1('forEach');var USES_TO_LENGTH$d=arrayMethodUsesToLength$1('forEach');// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
var arrayForEach$1=!STRICT_METHOD$7||!USES_TO_LENGTH$d?function forEach(callbackfn/* , thisArg */){return $forEach$3(this,callbackfn,arguments.length>1?arguments[1]:undefined);}:[].forEach;// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
_export$1({target:'Array',proto:true,forced:[].forEach!=arrayForEach$1},{forEach:arrayForEach$1});var $indexOf$2=arrayIncludes$1.indexOf;var nativeIndexOf$1=[].indexOf;var NEGATIVE_ZERO$2=!!nativeIndexOf$1&&1/[1].indexOf(1,-0)<0;var STRICT_METHOD$1$1=arrayMethodIsStrict$1('indexOf');var USES_TO_LENGTH$1$1=arrayMethodUsesToLength$1('indexOf',{ACCESSORS:true,1:0});// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
_export$1({target:'Array',proto:true,forced:NEGATIVE_ZERO$2||!STRICT_METHOD$1$1||!USES_TO_LENGTH$1$1},{indexOf:function indexOf(searchElement/* , fromIndex = 0 */){return NEGATIVE_ZERO$2// convert -0 to +0
?nativeIndexOf$1.apply(this,arguments)||0:$indexOf$2(this,searchElement,arguments.length>1?arguments[1]:undefined);}});var iterators$1={};var correctPrototypeGetter$1=!fails$1(function(){function F(){/* empty */}F.prototype.constructor=null;return Object.getPrototypeOf(new F())!==F.prototype;});var IE_PROTO$1$1=sharedKey$1('IE_PROTO');var ObjectPrototype$4=Object.prototype;// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf$1=correctPrototypeGetter$1?Object.getPrototypeOf:function(O){O=toObject$1(O);if(has$2(O,IE_PROTO$1$1))return O[IE_PROTO$1$1];if(typeof O.constructor=='function'&&O instanceof O.constructor){return O.constructor.prototype;}return O instanceof Object?ObjectPrototype$4:null;};var ITERATOR$9=wellKnownSymbol$1('iterator');var BUGGY_SAFARI_ITERATORS$2=false;var returnThis$3=function returnThis(){return this;};// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$3,PrototypeOfArrayIteratorPrototype$1,arrayIterator$1;if([].keys){arrayIterator$1=[].keys();// Safari 8 has buggy iterators w/o `next`
if(!('next'in arrayIterator$1))BUGGY_SAFARI_ITERATORS$2=true;else {PrototypeOfArrayIteratorPrototype$1=objectGetPrototypeOf$1(objectGetPrototypeOf$1(arrayIterator$1));if(PrototypeOfArrayIteratorPrototype$1!==Object.prototype)IteratorPrototype$3=PrototypeOfArrayIteratorPrototype$1;}}if(IteratorPrototype$3==undefined)IteratorPrototype$3={};// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if(!has$2(IteratorPrototype$3,ITERATOR$9)){createNonEnumerableProperty$1(IteratorPrototype$3,ITERATOR$9,returnThis$3);}var iteratorsCore$1={IteratorPrototype:IteratorPrototype$3,BUGGY_SAFARI_ITERATORS:BUGGY_SAFARI_ITERATORS$2};var defineProperty$1$1=objectDefineProperty$1.f;var TO_STRING_TAG$5=wellKnownSymbol$1('toStringTag');var setToStringTag$1=function setToStringTag(it,TAG,STATIC){if(it&&!has$2(it=STATIC?it:it.prototype,TO_STRING_TAG$5)){defineProperty$1$1(it,TO_STRING_TAG$5,{configurable:true,value:TAG});}};var IteratorPrototype$1$1=iteratorsCore$1.IteratorPrototype;var returnThis$1$1=function returnThis$1(){return this;};var createIteratorConstructor$1=function createIteratorConstructor(IteratorConstructor,NAME,next){var TO_STRING_TAG=NAME+' Iterator';IteratorConstructor.prototype=objectCreate$1(IteratorPrototype$1$1,{next:createPropertyDescriptor$1(1,next)});setToStringTag$1(IteratorConstructor,TO_STRING_TAG,false);iterators$1[TO_STRING_TAG]=returnThis$1$1;return IteratorConstructor;};var aPossiblePrototype$1=function aPossiblePrototype(it){if(!isObject$1(it)&&it!==null){throw TypeError("Can't set "+String(it)+' as a prototype');}return it;};// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */var objectSetPrototypeOf$1=Object.setPrototypeOf||('__proto__'in{}?function(){var CORRECT_SETTER=false;var test={};var setter;try{setter=Object.getOwnPropertyDescriptor(Object.prototype,'__proto__').set;setter.call(test,[]);CORRECT_SETTER=test instanceof Array;}catch(error){/* empty */}return function setPrototypeOf(O,proto){anObject$1(O);aPossiblePrototype$1(proto);if(CORRECT_SETTER)setter.call(O,proto);else O.__proto__=proto;return O;};}():undefined);var IteratorPrototype$2$1=iteratorsCore$1.IteratorPrototype;var BUGGY_SAFARI_ITERATORS$1$1=iteratorsCore$1.BUGGY_SAFARI_ITERATORS;var ITERATOR$1$1=wellKnownSymbol$1('iterator');var KEYS$1='keys';var VALUES$1='values';var ENTRIES$1='entries';var returnThis$2$1=function returnThis$2(){return this;};var defineIterator$1=function defineIterator(Iterable,NAME,IteratorConstructor,next,DEFAULT,IS_SET,FORCED){createIteratorConstructor$1(IteratorConstructor,NAME,next);var getIterationMethod=function getIterationMethod(KIND){if(KIND===DEFAULT&&defaultIterator)return defaultIterator;if(!BUGGY_SAFARI_ITERATORS$1$1&&KIND in IterablePrototype)return IterablePrototype[KIND];switch(KIND){case KEYS$1:return function keys(){return new IteratorConstructor(this,KIND);};case VALUES$1:return function values(){return new IteratorConstructor(this,KIND);};case ENTRIES$1:return function entries(){return new IteratorConstructor(this,KIND);};}return function(){return new IteratorConstructor(this);};};var TO_STRING_TAG=NAME+' Iterator';var INCORRECT_VALUES_NAME=false;var IterablePrototype=Iterable.prototype;var nativeIterator=IterablePrototype[ITERATOR$1$1]||IterablePrototype['@@iterator']||DEFAULT&&IterablePrototype[DEFAULT];var defaultIterator=!BUGGY_SAFARI_ITERATORS$1$1&&nativeIterator||getIterationMethod(DEFAULT);var anyNativeIterator=NAME=='Array'?IterablePrototype.entries||nativeIterator:nativeIterator;var CurrentIteratorPrototype,methods,KEY;// fix native
if(anyNativeIterator){CurrentIteratorPrototype=objectGetPrototypeOf$1(anyNativeIterator.call(new Iterable()));if(IteratorPrototype$2$1!==Object.prototype&&CurrentIteratorPrototype.next){if(objectGetPrototypeOf$1(CurrentIteratorPrototype)!==IteratorPrototype$2$1){if(objectSetPrototypeOf$1){objectSetPrototypeOf$1(CurrentIteratorPrototype,IteratorPrototype$2$1);}else if(typeof CurrentIteratorPrototype[ITERATOR$1$1]!='function'){createNonEnumerableProperty$1(CurrentIteratorPrototype,ITERATOR$1$1,returnThis$2$1);}}// Set @@toStringTag to native iterators
setToStringTag$1(CurrentIteratorPrototype,TO_STRING_TAG,true);}}// fix Array#{values, @@iterator}.name in V8 / FF
if(DEFAULT==VALUES$1&&nativeIterator&&nativeIterator.name!==VALUES$1){INCORRECT_VALUES_NAME=true;defaultIterator=function values(){return nativeIterator.call(this);};}// define iterator
if(IterablePrototype[ITERATOR$1$1]!==defaultIterator){createNonEnumerableProperty$1(IterablePrototype,ITERATOR$1$1,defaultIterator);}iterators$1[NAME]=defaultIterator;// export additional methods
if(DEFAULT){methods={values:getIterationMethod(VALUES$1),keys:IS_SET?defaultIterator:getIterationMethod(KEYS$1),entries:getIterationMethod(ENTRIES$1)};if(FORCED)for(KEY in methods){if(BUGGY_SAFARI_ITERATORS$1$1||INCORRECT_VALUES_NAME||!(KEY in IterablePrototype)){redefine$1(IterablePrototype,KEY,methods[KEY]);}}else _export$1({target:NAME,proto:true,forced:BUGGY_SAFARI_ITERATORS$1$1||INCORRECT_VALUES_NAME},methods);}return methods;};var ARRAY_ITERATOR$1='Array Iterator';var setInternalState$8=internalState$1.set;var getInternalState$5=internalState$1.getterFor(ARRAY_ITERATOR$1);// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
var es_array_iterator$1=defineIterator$1(Array,'Array',function(iterated,kind){setInternalState$8(this,{type:ARRAY_ITERATOR$1,target:toIndexedObject$1(iterated),// target
index:0,// next index
kind:kind// kind
});// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
},function(){var state=getInternalState$5(this);var target=state.target;var kind=state.kind;var index=state.index++;if(!target||index>=target.length){state.target=undefined;return {value:undefined,done:true};}if(kind=='keys')return {value:index,done:false};if(kind=='values')return {value:target[index],done:false};return {value:[index,target[index]],done:false};},'values');// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
iterators$1.Arguments=iterators$1.Array;// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables$1('keys');addToUnscopables$1('values');addToUnscopables$1('entries');var nativeJoin$1=[].join;var ES3_STRINGS$1=indexedObject$1!=Object;var STRICT_METHOD$2$1=arrayMethodIsStrict$1('join',',');// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
_export$1({target:'Array',proto:true,forced:ES3_STRINGS$1||!STRICT_METHOD$2$1},{join:function join(separator){return nativeJoin$1.call(toIndexedObject$1(this),separator===undefined?',':separator);}});var min$2$1=Math.min;var nativeLastIndexOf$1=[].lastIndexOf;var NEGATIVE_ZERO$1$1=!!nativeLastIndexOf$1&&1/[1].lastIndexOf(1,-0)<0;var STRICT_METHOD$3$1=arrayMethodIsStrict$1('lastIndexOf');// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH$2$1=arrayMethodUsesToLength$1('indexOf',{ACCESSORS:true,1:0});var FORCED$1$1=NEGATIVE_ZERO$1$1||!STRICT_METHOD$3$1||!USES_TO_LENGTH$2$1;// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
var arrayLastIndexOf$1=FORCED$1$1?function lastIndexOf(searchElement/* , fromIndex = @[*-1] */){// convert -0 to +0
if(NEGATIVE_ZERO$1$1)return nativeLastIndexOf$1.apply(this,arguments)||0;var O=toIndexedObject$1(this);var length=toLength$1(O.length);var index=length-1;if(arguments.length>1)index=min$2$1(index,toInteger$1(arguments[1]));if(index<0)index=length+index;for(;index>=0;index--){if(index in O&&O[index]===searchElement)return index||0;}return -1;}:nativeLastIndexOf$1;// `Array.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
_export$1({target:'Array',proto:true,forced:arrayLastIndexOf$1!==[].lastIndexOf},{lastIndexOf:arrayLastIndexOf$1});var $map$2=arrayIteration$1.map;var HAS_SPECIES_SUPPORT$4=arrayMethodHasSpeciesSupport$1('map');// FF49- issue
var USES_TO_LENGTH$3$1=arrayMethodUsesToLength$1('map');// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
_export$1({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT$4||!USES_TO_LENGTH$3$1},{map:function map(callbackfn/* , thisArg */){return $map$2(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});var nativeReverse=[].reverse;var test$1=[1,2];// `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
_export$1({target:'Array',proto:true,forced:String(test$1)===String(test$1.reverse())},{reverse:function reverse(){// eslint-disable-next-line no-self-assign
if(isArray$1(this))this.length=this.length;return nativeReverse.call(this);}});var HAS_SPECIES_SUPPORT$1$1=arrayMethodHasSpeciesSupport$1('slice');var USES_TO_LENGTH$4$1=arrayMethodUsesToLength$1('slice',{ACCESSORS:true,0:0,1:2});var SPECIES$2$1=wellKnownSymbol$1('species');var nativeSlice$1=[].slice;var max$1$1=Math.max;// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
_export$1({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT$1$1||!USES_TO_LENGTH$4$1},{slice:function slice(start,end){var O=toIndexedObject$1(this);var length=toLength$1(O.length);var k=toAbsoluteIndex$1(start,length);var fin=toAbsoluteIndex$1(end===undefined?length:end,length);// inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
var Constructor,result,n;if(isArray$1(O)){Constructor=O.constructor;// cross-realm fallback
if(typeof Constructor=='function'&&(Constructor===Array||isArray$1(Constructor.prototype))){Constructor=undefined;}else if(isObject$1(Constructor)){Constructor=Constructor[SPECIES$2$1];if(Constructor===null)Constructor=undefined;}if(Constructor===Array||Constructor===undefined){return nativeSlice$1.call(O,k,fin);}}result=new(Constructor===undefined?Array:Constructor)(max$1$1(fin-k,0));for(n=0;k<fin;k++,n++){if(k in O)createProperty$1(result,n,O[k]);}result.length=n;return result;}});var test$1$1=[];var nativeSort=test$1$1.sort;// IE8-
var FAILS_ON_UNDEFINED=fails$1(function(){test$1$1.sort(undefined);});// V8 bug
var FAILS_ON_NULL=fails$1(function(){test$1$1.sort(null);});// Old WebKit
var STRICT_METHOD$4$1=arrayMethodIsStrict$1('sort');var FORCED$2$1=FAILS_ON_UNDEFINED||!FAILS_ON_NULL||!STRICT_METHOD$4$1;// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
_export$1({target:'Array',proto:true,forced:FORCED$2$1},{sort:function sort(comparefn){return comparefn===undefined?nativeSort.call(toObject$1(this)):nativeSort.call(toObject$1(this),aFunction$1$1(comparefn));}});var arrayBufferNative$1=typeof ArrayBuffer!=='undefined'&&typeof DataView!=='undefined';var redefineAll$1=function redefineAll(target,src,options){for(var key in src){redefine$1(target,key,src[key],options);}return target;};var anInstance$1=function anInstance(it,Constructor,name){if(!(it instanceof Constructor)){throw TypeError('Incorrect '+(name?name+' ':'')+'invocation');}return it;};// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
var toIndex$1=function toIndex(it){if(it===undefined)return 0;var number=toInteger$1(it);var length=toLength$1(number);if(number!==length)throw RangeError('Wrong length or index');return length;};// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity$1$1=1/0;var abs$1=Math.abs;var pow$3=Math.pow;var floor$1$1=Math.floor;var log$2=Math.log;var LN2$1=Math.LN2;var pack$1=function pack(number,mantissaLength,bytes){var buffer=new Array(bytes);var exponentLength=bytes*8-mantissaLength-1;var eMax=(1<<exponentLength)-1;var eBias=eMax>>1;var rt=mantissaLength===23?pow$3(2,-24)-pow$3(2,-77):0;var sign=number<0||number===0&&1/number<0?1:0;var index=0;var exponent,mantissa,c;number=abs$1(number);// eslint-disable-next-line no-self-compare
if(number!=number||number===Infinity$1$1){// eslint-disable-next-line no-self-compare
mantissa=number!=number?1:0;exponent=eMax;}else {exponent=floor$1$1(log$2(number)/LN2$1);if(number*(c=pow$3(2,-exponent))<1){exponent--;c*=2;}if(exponent+eBias>=1){number+=rt/c;}else {number+=rt*pow$3(2,1-eBias);}if(number*c>=2){exponent++;c/=2;}if(exponent+eBias>=eMax){mantissa=0;exponent=eMax;}else if(exponent+eBias>=1){mantissa=(number*c-1)*pow$3(2,mantissaLength);exponent=exponent+eBias;}else {mantissa=number*pow$3(2,eBias-1)*pow$3(2,mantissaLength);exponent=0;}}for(;mantissaLength>=8;buffer[index++]=mantissa&255,mantissa/=256,mantissaLength-=8){}exponent=exponent<<mantissaLength|mantissa;exponentLength+=mantissaLength;for(;exponentLength>0;buffer[index++]=exponent&255,exponent/=256,exponentLength-=8){}buffer[--index]|=sign*128;return buffer;};var unpack$1=function unpack(buffer,mantissaLength){var bytes=buffer.length;var exponentLength=bytes*8-mantissaLength-1;var eMax=(1<<exponentLength)-1;var eBias=eMax>>1;var nBits=exponentLength-7;var index=bytes-1;var sign=buffer[index--];var exponent=sign&127;var mantissa;sign>>=7;for(;nBits>0;exponent=exponent*256+buffer[index],index--,nBits-=8){}mantissa=exponent&(1<<-nBits)-1;exponent>>=-nBits;nBits+=mantissaLength;for(;nBits>0;mantissa=mantissa*256+buffer[index],index--,nBits-=8){}if(exponent===0){exponent=1-eBias;}else if(exponent===eMax){return mantissa?NaN:sign?-Infinity$1$1:Infinity$1$1;}else {mantissa=mantissa+pow$3(2,mantissaLength);exponent=exponent-eBias;}return (sign?-1:1)*mantissa*pow$3(2,exponent-mantissaLength);};var ieee754$1={pack:pack$1,unpack:unpack$1};var getOwnPropertyNames$3=objectGetOwnPropertyNames$1.f;var defineProperty$2$1=objectDefineProperty$1.f;var getInternalState$1$1=internalState$1.get;var setInternalState$1$1=internalState$1.set;var ARRAY_BUFFER$2='ArrayBuffer';var DATA_VIEW$1='DataView';var PROTOTYPE$1$1='prototype';var WRONG_LENGTH$1='Wrong length';var WRONG_INDEX$1='Wrong index';var NativeArrayBuffer$2=global_1$1[ARRAY_BUFFER$2];var $ArrayBuffer$1=NativeArrayBuffer$2;var $DataView$1=global_1$1[DATA_VIEW$1];var $DataViewPrototype$1=$DataView$1&&$DataView$1[PROTOTYPE$1$1];var ObjectPrototype$1$1=Object.prototype;var RangeError$1$1=global_1$1.RangeError;var packIEEE754$1=ieee754$1.pack;var unpackIEEE754$1=ieee754$1.unpack;var packInt8$1=function packInt8(number){return [number&0xFF];};var packInt16$1=function packInt16(number){return [number&0xFF,number>>8&0xFF];};var packInt32$1=function packInt32(number){return [number&0xFF,number>>8&0xFF,number>>16&0xFF,number>>24&0xFF];};var unpackInt32$1=function unpackInt32(buffer){return buffer[3]<<24|buffer[2]<<16|buffer[1]<<8|buffer[0];};var packFloat32$1=function packFloat32(number){return packIEEE754$1(number,23,4);};var packFloat64$1=function packFloat64(number){return packIEEE754$1(number,52,8);};var addGetter$1=function addGetter(Constructor,key){defineProperty$2$1(Constructor[PROTOTYPE$1$1],key,{get:function get(){return getInternalState$1$1(this)[key];}});};var get$1$1=function get$1(view,count,index,isLittleEndian){var intIndex=toIndex$1(index);var store=getInternalState$1$1(view);if(intIndex+count>store.byteLength)throw RangeError$1$1(WRONG_INDEX$1);var bytes=getInternalState$1$1(store.buffer).bytes;var start=intIndex+store.byteOffset;var pack=bytes.slice(start,start+count);return isLittleEndian?pack:pack.reverse();};var set$1$1=function set$1(view,count,index,conversion,value,isLittleEndian){var intIndex=toIndex$1(index);var store=getInternalState$1$1(view);if(intIndex+count>store.byteLength)throw RangeError$1$1(WRONG_INDEX$1);var bytes=getInternalState$1$1(store.buffer).bytes;var start=intIndex+store.byteOffset;var pack=conversion(+value);for(var i=0;i<count;i++){bytes[start+i]=pack[isLittleEndian?i:count-i-1];}};if(!arrayBufferNative$1){$ArrayBuffer$1=function ArrayBuffer(length){anInstance$1(this,$ArrayBuffer$1,ARRAY_BUFFER$2);var byteLength=toIndex$1(length);setInternalState$1$1(this,{bytes:arrayFill$1.call(new Array(byteLength),0),byteLength:byteLength});if(!descriptors$1)this.byteLength=byteLength;};$DataView$1=function DataView(buffer,byteOffset,byteLength){anInstance$1(this,$DataView$1,DATA_VIEW$1);anInstance$1(buffer,$ArrayBuffer$1,DATA_VIEW$1);var bufferLength=getInternalState$1$1(buffer).byteLength;var offset=toInteger$1(byteOffset);if(offset<0||offset>bufferLength)throw RangeError$1$1('Wrong offset');byteLength=byteLength===undefined?bufferLength-offset:toLength$1(byteLength);if(offset+byteLength>bufferLength)throw RangeError$1$1(WRONG_LENGTH$1);setInternalState$1$1(this,{buffer:buffer,byteLength:byteLength,byteOffset:offset});if(!descriptors$1){this.buffer=buffer;this.byteLength=byteLength;this.byteOffset=offset;}};if(descriptors$1){addGetter$1($ArrayBuffer$1,'byteLength');addGetter$1($DataView$1,'buffer');addGetter$1($DataView$1,'byteLength');addGetter$1($DataView$1,'byteOffset');}redefineAll$1($DataView$1[PROTOTYPE$1$1],{getInt8:function getInt8(byteOffset){return get$1$1(this,1,byteOffset)[0]<<24>>24;},getUint8:function getUint8(byteOffset){return get$1$1(this,1,byteOffset)[0];},getInt16:function getInt16(byteOffset/* , littleEndian */){var bytes=get$1$1(this,2,byteOffset,arguments.length>1?arguments[1]:undefined);return (bytes[1]<<8|bytes[0])<<16>>16;},getUint16:function getUint16(byteOffset/* , littleEndian */){var bytes=get$1$1(this,2,byteOffset,arguments.length>1?arguments[1]:undefined);return bytes[1]<<8|bytes[0];},getInt32:function getInt32(byteOffset/* , littleEndian */){return unpackInt32$1(get$1$1(this,4,byteOffset,arguments.length>1?arguments[1]:undefined));},getUint32:function getUint32(byteOffset/* , littleEndian */){return unpackInt32$1(get$1$1(this,4,byteOffset,arguments.length>1?arguments[1]:undefined))>>>0;},getFloat32:function getFloat32(byteOffset/* , littleEndian */){return unpackIEEE754$1(get$1$1(this,4,byteOffset,arguments.length>1?arguments[1]:undefined),23);},getFloat64:function getFloat64(byteOffset/* , littleEndian */){return unpackIEEE754$1(get$1$1(this,8,byteOffset,arguments.length>1?arguments[1]:undefined),52);},setInt8:function setInt8(byteOffset,value){set$1$1(this,1,byteOffset,packInt8$1,value);},setUint8:function setUint8(byteOffset,value){set$1$1(this,1,byteOffset,packInt8$1,value);},setInt16:function setInt16(byteOffset,value/* , littleEndian */){set$1$1(this,2,byteOffset,packInt16$1,value,arguments.length>2?arguments[2]:undefined);},setUint16:function setUint16(byteOffset,value/* , littleEndian */){set$1$1(this,2,byteOffset,packInt16$1,value,arguments.length>2?arguments[2]:undefined);},setInt32:function setInt32(byteOffset,value/* , littleEndian */){set$1$1(this,4,byteOffset,packInt32$1,value,arguments.length>2?arguments[2]:undefined);},setUint32:function setUint32(byteOffset,value/* , littleEndian */){set$1$1(this,4,byteOffset,packInt32$1,value,arguments.length>2?arguments[2]:undefined);},setFloat32:function setFloat32(byteOffset,value/* , littleEndian */){set$1$1(this,4,byteOffset,packFloat32$1,value,arguments.length>2?arguments[2]:undefined);},setFloat64:function setFloat64(byteOffset,value/* , littleEndian */){set$1$1(this,8,byteOffset,packFloat64$1,value,arguments.length>2?arguments[2]:undefined);}});}else {if(!fails$1(function(){NativeArrayBuffer$2(1);})||!fails$1(function(){new NativeArrayBuffer$2(-1);// eslint-disable-line no-new
})||fails$1(function(){new NativeArrayBuffer$2();// eslint-disable-line no-new
new NativeArrayBuffer$2(1.5);// eslint-disable-line no-new
new NativeArrayBuffer$2(NaN);// eslint-disable-line no-new
return NativeArrayBuffer$2.name!=ARRAY_BUFFER$2;})){$ArrayBuffer$1=function ArrayBuffer(length){anInstance$1(this,$ArrayBuffer$1);return new NativeArrayBuffer$2(toIndex$1(length));};var ArrayBufferPrototype$1=$ArrayBuffer$1[PROTOTYPE$1$1]=NativeArrayBuffer$2[PROTOTYPE$1$1];for(var keys$1$1=getOwnPropertyNames$3(NativeArrayBuffer$2),j$2=0,key$2;keys$1$1.length>j$2;){if(!((key$2=keys$1$1[j$2++])in $ArrayBuffer$1)){createNonEnumerableProperty$1($ArrayBuffer$1,key$2,NativeArrayBuffer$2[key$2]);}}ArrayBufferPrototype$1.constructor=$ArrayBuffer$1;}// WebKit bug - the same parent prototype for typed arrays and data view
if(objectSetPrototypeOf$1&&objectGetPrototypeOf$1($DataViewPrototype$1)!==ObjectPrototype$1$1){objectSetPrototypeOf$1($DataViewPrototype$1,ObjectPrototype$1$1);}// iOS Safari 7.x bug
var testView$1=new $DataView$1(new $ArrayBuffer$1(2));var nativeSetInt8$1=$DataViewPrototype$1.setInt8;testView$1.setInt8(0,2147483648);testView$1.setInt8(1,2147483649);if(testView$1.getInt8(0)||!testView$1.getInt8(1))redefineAll$1($DataViewPrototype$1,{setInt8:function setInt8(byteOffset,value){nativeSetInt8$1.call(this,byteOffset,value<<24>>24);},setUint8:function setUint8(byteOffset,value){nativeSetInt8$1.call(this,byteOffset,value<<24>>24);}},{unsafe:true});}setToStringTag$1($ArrayBuffer$1,ARRAY_BUFFER$2);setToStringTag$1($DataView$1,DATA_VIEW$1);var arrayBuffer$1={ArrayBuffer:$ArrayBuffer$1,DataView:$DataView$1};var SPECIES$3$1=wellKnownSymbol$1('species');// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
var speciesConstructor$1=function speciesConstructor(O,defaultConstructor){var C=anObject$1(O).constructor;var S;return C===undefined||(S=anObject$1(C)[SPECIES$3$1])==undefined?defaultConstructor:aFunction$1$1(S);};var ArrayBuffer$1$1=arrayBuffer$1.ArrayBuffer;var DataView$1$1=arrayBuffer$1.DataView;var nativeArrayBufferSlice$1=ArrayBuffer$1$1.prototype.slice;var INCORRECT_SLICE$1=fails$1(function(){return !new ArrayBuffer$1$1(2).slice(1,undefined).byteLength;});// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
_export$1({target:'ArrayBuffer',proto:true,unsafe:true,forced:INCORRECT_SLICE$1},{slice:function slice(start,end){if(nativeArrayBufferSlice$1!==undefined&&end===undefined){return nativeArrayBufferSlice$1.call(anObject$1(this),start);// FF fix
}var length=anObject$1(this).byteLength;var first=toAbsoluteIndex$1(start,length);var fin=toAbsoluteIndex$1(end===undefined?length:end,length);var result=new(speciesConstructor$1(this,ArrayBuffer$1$1))(toLength$1(fin-first));var viewSource=new DataView$1$1(this);var viewTarget=new DataView$1$1(result);var index=0;while(first<fin){viewTarget.setUint8(index++,viewSource.getUint8(first++));}return result;}});var defineProperty$3$1=objectDefineProperty$1.f;var FunctionPrototype$1=Function.prototype;var FunctionPrototypeToString$1=FunctionPrototype$1.toString;var nameRE$1=/^\s*function ([^ (]*)/;var NAME$2='name';// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if(descriptors$1&&!(NAME$2 in FunctionPrototype$1)){defineProperty$3$1(FunctionPrototype$1,NAME$2,{configurable:true,get:function get(){try{return FunctionPrototypeToString$1.call(this).match(nameRE$1)[1];}catch(error){return '';}}});}// makes subclassing work correct for wrapped built-ins
var inheritIfRequired$1=function inheritIfRequired($this,dummy,Wrapper){var NewTarget,NewTargetPrototype;if(// it can work only with native `setPrototypeOf`
objectSetPrototypeOf$1&&// we haven't completely correct pre-ES6 way for getting `new.target`, so use this
typeof(NewTarget=dummy.constructor)=='function'&&NewTarget!==Wrapper&&isObject$1(NewTargetPrototype=NewTarget.prototype)&&NewTargetPrototype!==Wrapper.prototype)objectSetPrototypeOf$1($this,NewTargetPrototype);return $this;};// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
var whitespaces$1="\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";var whitespace$1='['+whitespaces$1+']';var ltrim$1=RegExp('^'+whitespace$1+whitespace$1+'*');var rtrim$1=RegExp(whitespace$1+whitespace$1+'*$');// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod$2$1=function createMethod$2(TYPE){return function($this){var string=String(requireObjectCoercible$1($this));if(TYPE&1)string=string.replace(ltrim$1,'');if(TYPE&2)string=string.replace(rtrim$1,'');return string;};};var stringTrim$1={// `String.prototype.{ trimLeft, trimStart }` methods
// https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
start:createMethod$2$1(1),// `String.prototype.{ trimRight, trimEnd }` methods
// https://tc39.github.io/ecma262/#sec-string.prototype.trimend
end:createMethod$2$1(2),// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
trim:createMethod$2$1(3)};var getOwnPropertyNames$1$1=objectGetOwnPropertyNames$1.f;var getOwnPropertyDescriptor$2$1=objectGetOwnPropertyDescriptor$1.f;var defineProperty$4$1=objectDefineProperty$1.f;var trim$1=stringTrim$1.trim;var NUMBER$1='Number';var NativeNumber$1=global_1$1[NUMBER$1];var NumberPrototype$1=NativeNumber$1.prototype;// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF$1=classofRaw$1(objectCreate$1(NumberPrototype$1))==NUMBER$1;// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber$1=function toNumber(argument){var it=toPrimitive$1(argument,false);var first,third,radix,maxCode,digits,length,index,code;if(typeof it=='string'&&it.length>2){it=trim$1(it);first=it.charCodeAt(0);if(first===43||first===45){third=it.charCodeAt(2);if(third===88||third===120)return NaN;// Number('+0x1') should be NaN, old V8 fix
}else if(first===48){switch(it.charCodeAt(1)){case 66:case 98:radix=2;maxCode=49;break;// fast equal of /^0b[01]+$/i
case 79:case 111:radix=8;maxCode=55;break;// fast equal of /^0o[0-7]+$/i
default:return +it;}digits=it.slice(2);length=digits.length;for(index=0;index<length;index++){code=digits.charCodeAt(index);// parseInt parses a string to a first unavailable symbol
// but ToNumber should return NaN if a string contains unavailable symbols
if(code<48||code>maxCode)return NaN;}return parseInt(digits,radix);}}return +it;};// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if(isForced_1$1(NUMBER$1,!NativeNumber$1(' 0o1')||!NativeNumber$1('0b1')||NativeNumber$1('+0x1'))){var NumberWrapper$1=function Number(value){var it=arguments.length<1?0:value;var dummy=this;return dummy instanceof NumberWrapper$1// check on 1..constructor(foo) case
&&(BROKEN_CLASSOF$1?fails$1(function(){NumberPrototype$1.valueOf.call(dummy);}):classofRaw$1(dummy)!=NUMBER$1)?inheritIfRequired$1(new NativeNumber$1(toNumber$1(it)),dummy,NumberWrapper$1):toNumber$1(it);};for(var keys$2$1=descriptors$1?getOwnPropertyNames$1$1(NativeNumber$1):(// ES3:
'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,'+// ES2015 (in case, if modules with ES2015 Number statics required before):
'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,'+'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','),j$1$1=0,key$1$1;keys$2$1.length>j$1$1;j$1$1++){if(has$2(NativeNumber$1,key$1$1=keys$2$1[j$1$1])&&!has$2(NumberWrapper$1,key$1$1)){defineProperty$4$1(NumberWrapper$1,key$1$1,getOwnPropertyDescriptor$2$1(NativeNumber$1,key$1$1));}}NumberWrapper$1.prototype=NumberPrototype$1;NumberPrototype$1.constructor=NumberWrapper$1;redefine$1(global_1$1,NUMBER$1,NumberWrapper$1);}var TO_STRING_TAG$1$1=wellKnownSymbol$1('toStringTag');var test$2={};test$2[TO_STRING_TAG$1$1]='z';var toStringTagSupport$1=String(test$2)==='[object z]';var TO_STRING_TAG$2$1=wellKnownSymbol$1('toStringTag');// ES3 wrong here
var CORRECT_ARGUMENTS$1=classofRaw$1(function(){return arguments;}())=='Arguments';// fallback for IE11 Script Access Denied error
var tryGet$1=function tryGet(it,key){try{return it[key];}catch(error){/* empty */}};// getting tag from ES6+ `Object.prototype.toString`
var classof$1=toStringTagSupport$1?classofRaw$1:function(it){var O,tag,result;return it===undefined?'Undefined':it===null?'Null'// @@toStringTag case
:typeof(tag=tryGet$1(O=Object(it),TO_STRING_TAG$2$1))=='string'?tag// builtinTag case
:CORRECT_ARGUMENTS$1?classofRaw$1(O)// ES3 arguments fallback
:(result=classofRaw$1(O))=='Object'&&typeof O.callee=='function'?'Arguments':result;};// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
var objectToString$1=toStringTagSupport$1?{}.toString:function toString(){return '[object '+classof$1(this)+']';};// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if(!toStringTagSupport$1){redefine$1(Object.prototype,'toString',objectToString$1,{unsafe:true});}var nativePromiseConstructor$1=global_1$1.Promise;var SPECIES$4$1=wellKnownSymbol$1('species');var setSpecies$1=function setSpecies(CONSTRUCTOR_NAME){var Constructor=getBuiltIn$1(CONSTRUCTOR_NAME);var defineProperty=objectDefineProperty$1.f;if(descriptors$1&&Constructor&&!Constructor[SPECIES$4$1]){defineProperty(Constructor,SPECIES$4$1,{configurable:true,get:function get(){return this;}});}};var ITERATOR$2$1=wellKnownSymbol$1('iterator');var ArrayPrototype$1$1=Array.prototype;// check on default Array iterator
var isArrayIteratorMethod$1=function isArrayIteratorMethod(it){return it!==undefined&&(iterators$1.Array===it||ArrayPrototype$1$1[ITERATOR$2$1]===it);};var ITERATOR$3$1=wellKnownSymbol$1('iterator');var getIteratorMethod$1=function getIteratorMethod(it){if(it!=undefined)return it[ITERATOR$3$1]||it['@@iterator']||iterators$1[classof$1(it)];};// call something on iterator step with safe closing on error
var callWithSafeIterationClosing$1=function callWithSafeIterationClosing(iterator,fn,value,ENTRIES){try{return ENTRIES?fn(anObject$1(value)[0],value[1]):fn(value);// 7.4.6 IteratorClose(iterator, completion)
}catch(error){var returnMethod=iterator['return'];if(returnMethod!==undefined)anObject$1(returnMethod.call(iterator));throw error;}};var iterate_1$1=createCommonjsModule$1(function(module){var Result=function Result(stopped,result){this.stopped=stopped;this.result=result;};var iterate=module.exports=function(iterable,fn,that,AS_ENTRIES,IS_ITERATOR){var boundFunction=functionBindContext$1(fn,that,AS_ENTRIES?2:1);var iterator,iterFn,index,length,result,next,step;if(IS_ITERATOR){iterator=iterable;}else {iterFn=getIteratorMethod$1(iterable);if(typeof iterFn!='function')throw TypeError('Target is not iterable');// optimisation for array iterators
if(isArrayIteratorMethod$1(iterFn)){for(index=0,length=toLength$1(iterable.length);length>index;index++){result=AS_ENTRIES?boundFunction(anObject$1(step=iterable[index])[0],step[1]):boundFunction(iterable[index]);if(result&&result instanceof Result)return result;}return new Result(false);}iterator=iterFn.call(iterable);}next=iterator.next;while(!(step=next.call(iterator)).done){result=callWithSafeIterationClosing$1(iterator,boundFunction,step.value,AS_ENTRIES);if(_typeof(result)=='object'&&result&&result instanceof Result)return result;}return new Result(false);};iterate.stop=function(result){return new Result(true,result);};});var ITERATOR$4$1=wellKnownSymbol$1('iterator');var SAFE_CLOSING$1=false;try{var called$1=0;var iteratorWithReturn$1={next:function next(){return {done:!!called$1++};},'return':function _return(){SAFE_CLOSING$1=true;}};iteratorWithReturn$1[ITERATOR$4$1]=function(){return this;};// eslint-disable-next-line no-throw-literal
Array.from(iteratorWithReturn$1,function(){throw 2;});}catch(error){/* empty */}var checkCorrectnessOfIteration$1=function checkCorrectnessOfIteration(exec,SKIP_CLOSING){if(!SKIP_CLOSING&&!SAFE_CLOSING$1)return false;var ITERATION_SUPPORT=false;try{var object={};object[ITERATOR$4$1]=function(){return {next:function next(){return {done:ITERATION_SUPPORT=true};}};};exec(object);}catch(error){/* empty */}return ITERATION_SUPPORT;};var engineIsIos$1=/(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent$1);var location$1$1=global_1$1.location;var set$2$1=global_1$1.setImmediate;var clear$1=global_1$1.clearImmediate;var process$1$1=global_1$1.process;var MessageChannel$1=global_1$1.MessageChannel;var Dispatch$1=global_1$1.Dispatch;var counter$1=0;var queue$1={};var ONREADYSTATECHANGE$1='onreadystatechange';var defer$1,channel$1,port$1;var run$1=function run(id){// eslint-disable-next-line no-prototype-builtins
if(queue$1.hasOwnProperty(id)){var fn=queue$1[id];delete queue$1[id];fn();}};var runner$1=function runner(id){return function(){run$1(id);};};var listener$1=function listener(event){run$1(event.data);};var post$1=function post(id){// old engines have not location.origin
global_1$1.postMessage(id+'',location$1$1.protocol+'//'+location$1$1.host);};// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!set$2$1||!clear$1){set$2$1=function setImmediate(fn){var args=[];var i=1;while(arguments.length>i){args.push(arguments[i++]);}queue$1[++counter$1]=function(){// eslint-disable-next-line no-new-func
(typeof fn=='function'?fn:Function(fn)).apply(undefined,args);};defer$1(counter$1);return counter$1;};clear$1=function clearImmediate(id){delete queue$1[id];};// Node.js 0.8-
if(classofRaw$1(process$1$1)=='process'){defer$1=function defer(id){process$1$1.nextTick(runner$1(id));};// Sphere (JS game engine) Dispatch API
}else if(Dispatch$1&&Dispatch$1.now){defer$1=function defer(id){Dispatch$1.now(runner$1(id));};// Browsers with MessageChannel, includes WebWorkers
// except iOS - https://github.com/zloirock/core-js/issues/624
}else if(MessageChannel$1&&!engineIsIos$1){channel$1=new MessageChannel$1();port$1=channel$1.port2;channel$1.port1.onmessage=listener$1;defer$1=functionBindContext$1(port$1.postMessage,port$1,1);// Browsers with postMessage, skip WebWorkers
// IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
}else if(global_1$1.addEventListener&&typeof postMessage=='function'&&!global_1$1.importScripts&&!fails$1(post$1)&&location$1$1.protocol!=='file:'){defer$1=post$1;global_1$1.addEventListener('message',listener$1,false);// IE8-
}else if(ONREADYSTATECHANGE$1 in documentCreateElement$1('script')){defer$1=function defer(id){html$1.appendChild(documentCreateElement$1('script'))[ONREADYSTATECHANGE$1]=function(){html$1.removeChild(this);run$1(id);};};// Rest old browsers
}else {defer$1=function defer(id){setTimeout(runner$1(id),0);};}}var task$2={set:set$2$1,clear:clear$1};var getOwnPropertyDescriptor$3$1=objectGetOwnPropertyDescriptor$1.f;var macrotask$1=task$2.set;var MutationObserver$2=global_1$1.MutationObserver||global_1$1.WebKitMutationObserver;var process$2$1=global_1$1.process;var Promise$1$1=global_1$1.Promise;var IS_NODE$2=classofRaw$1(process$2$1)=='process';// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor$1=getOwnPropertyDescriptor$3$1(global_1$1,'queueMicrotask');var queueMicrotask$1=queueMicrotaskDescriptor$1&&queueMicrotaskDescriptor$1.value;var flush$1,head$1,last$1,notify$2,toggle$1,node$1,promise$1,then$1;// modern engines have queueMicrotask method
if(!queueMicrotask$1){flush$1=function flush(){var parent,fn;if(IS_NODE$2&&(parent=process$2$1.domain))parent.exit();while(head$1){fn=head$1.fn;head$1=head$1.next;try{fn();}catch(error){if(head$1)notify$2();else last$1=undefined;throw error;}}last$1=undefined;if(parent)parent.enter();};// Node.js
if(IS_NODE$2){notify$2=function notify(){process$2$1.nextTick(flush$1);};// browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
}else if(MutationObserver$2&&!engineIsIos$1){toggle$1=true;node$1=document.createTextNode('');new MutationObserver$2(flush$1).observe(node$1,{characterData:true});notify$2=function notify(){node$1.data=toggle$1=!toggle$1;};// environments with maybe non-completely correct, but existent Promise
}else if(Promise$1$1&&Promise$1$1.resolve){// Promise.resolve without an argument throws an error in LG WebOS 2
promise$1=Promise$1$1.resolve(undefined);then$1=promise$1.then;notify$2=function notify(){then$1.call(promise$1,flush$1);};// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
}else {notify$2=function notify(){// strange IE + webpack dev server bug - use .call(global)
macrotask$1.call(global_1$1,flush$1);};}}var microtask$1=queueMicrotask$1||function(fn){var task={fn:fn,next:undefined};if(last$1)last$1.next=task;if(!head$1){head$1=task;notify$2();}last$1=task;};var PromiseCapability$1=function PromiseCapability(C){var resolve,reject;this.promise=new C(function($$resolve,$$reject){if(resolve!==undefined||reject!==undefined)throw TypeError('Bad Promise constructor');resolve=$$resolve;reject=$$reject;});this.resolve=aFunction$1$1(resolve);this.reject=aFunction$1$1(reject);};// 25.4.1.5 NewPromiseCapability(C)
var f$5$1=function f$5(C){return new PromiseCapability$1(C);};var newPromiseCapability$2={f:f$5$1};var promiseResolve$1=function promiseResolve(C,x){anObject$1(C);if(isObject$1(x)&&x.constructor===C)return x;var promiseCapability=newPromiseCapability$2.f(C);var resolve=promiseCapability.resolve;resolve(x);return promiseCapability.promise;};var hostReportErrors$1=function hostReportErrors(a,b){var console=global_1$1.console;if(console&&console.error){arguments.length===1?console.error(a):console.error(a,b);}};var perform$1=function perform(exec){try{return {error:false,value:exec()};}catch(error){return {error:true,value:error};}};var task$1$1=task$2.set;var SPECIES$5$1=wellKnownSymbol$1('species');var PROMISE$1='Promise';var getInternalState$2$1=internalState$1.get;var setInternalState$2$1=internalState$1.set;var getInternalPromiseState$1=internalState$1.getterFor(PROMISE$1);var PromiseConstructor$1=nativePromiseConstructor$1;var TypeError$1$1=global_1$1.TypeError;var document$2$1=global_1$1.document;var process$3$1=global_1$1.process;var $fetch$2=getBuiltIn$1('fetch');var newPromiseCapability$1$1=newPromiseCapability$2.f;var newGenericPromiseCapability$1=newPromiseCapability$1$1;var IS_NODE$1$1=classofRaw$1(process$3$1)=='process';var DISPATCH_EVENT$1=!!(document$2$1&&document$2$1.createEvent&&global_1$1.dispatchEvent);var UNHANDLED_REJECTION$1='unhandledrejection';var REJECTION_HANDLED$1='rejectionhandled';var PENDING$1=0;var FULFILLED$1=1;var REJECTED$1=2;var HANDLED$1=1;var UNHANDLED$1=2;var Internal$1,OwnPromiseCapability$1,PromiseWrapper$1,nativeThen$1;var FORCED$3$1=isForced_1$1(PROMISE$1,function(){var GLOBAL_CORE_JS_PROMISE=inspectSource$1(PromiseConstructor$1)!==String(PromiseConstructor$1);if(!GLOBAL_CORE_JS_PROMISE){// V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
// https://bugs.chromium.org/p/chromium/issues/detail?id=830565
// We can't detect it synchronously, so just check versions
if(engineV8Version$1===66)return true;// Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
if(!IS_NODE$1$1&&typeof PromiseRejectionEvent!='function')return true;}// We can't use @@species feature detection in V8 since it causes
// deoptimization and performance degradation
// https://github.com/zloirock/core-js/issues/679
if(engineV8Version$1>=51&&/native code/.test(PromiseConstructor$1))return false;// Detect correctness of subclassing with @@species support
var promise=PromiseConstructor$1.resolve(1);var FakePromise=function FakePromise(exec){exec(function(){/* empty */},function(){/* empty */});};var constructor=promise.constructor={};constructor[SPECIES$5$1]=FakePromise;return !(promise.then(function(){/* empty */})instanceof FakePromise);});var INCORRECT_ITERATION$2=FORCED$3$1||!checkCorrectnessOfIteration$1(function(iterable){PromiseConstructor$1.all(iterable)['catch'](function(){/* empty */});});// helpers
var isThenable$1=function isThenable(it){var then;return isObject$1(it)&&typeof(then=it.then)=='function'?then:false;};var notify$1$1=function notify$1(promise,state,isReject){if(state.notified)return;state.notified=true;var chain=state.reactions;microtask$1(function(){var value=state.value;var ok=state.state==FULFILLED$1;var index=0;// variable length - can't use forEach
while(chain.length>index){var reaction=chain[index++];var handler=ok?reaction.ok:reaction.fail;var resolve=reaction.resolve;var reject=reaction.reject;var domain=reaction.domain;var result,then,exited;try{if(handler){if(!ok){if(state.rejection===UNHANDLED$1)onHandleUnhandled$1(promise,state);state.rejection=HANDLED$1;}if(handler===true)result=value;else {if(domain)domain.enter();result=handler(value);// can throw
if(domain){domain.exit();exited=true;}}if(result===reaction.promise){reject(TypeError$1$1('Promise-chain cycle'));}else if(then=isThenable$1(result)){then.call(result,resolve,reject);}else resolve(result);}else reject(value);}catch(error){if(domain&&!exited)domain.exit();reject(error);}}state.reactions=[];state.notified=false;if(isReject&&!state.rejection)onUnhandled$1(promise,state);});};var dispatchEvent$1=function dispatchEvent(name,promise,reason){var event,handler;if(DISPATCH_EVENT$1){event=document$2$1.createEvent('Event');event.promise=promise;event.reason=reason;event.initEvent(name,false,true);global_1$1.dispatchEvent(event);}else event={promise:promise,reason:reason};if(handler=global_1$1['on'+name])handler(event);else if(name===UNHANDLED_REJECTION$1)hostReportErrors$1('Unhandled promise rejection',reason);};var onUnhandled$1=function onUnhandled(promise,state){task$1$1.call(global_1$1,function(){var value=state.value;var IS_UNHANDLED=isUnhandled$1(state);var result;if(IS_UNHANDLED){result=perform$1(function(){if(IS_NODE$1$1){process$3$1.emit('unhandledRejection',value,promise);}else dispatchEvent$1(UNHANDLED_REJECTION$1,promise,value);});// Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
state.rejection=IS_NODE$1$1||isUnhandled$1(state)?UNHANDLED$1:HANDLED$1;if(result.error)throw result.value;}});};var isUnhandled$1=function isUnhandled(state){return state.rejection!==HANDLED$1&&!state.parent;};var onHandleUnhandled$1=function onHandleUnhandled(promise,state){task$1$1.call(global_1$1,function(){if(IS_NODE$1$1){process$3$1.emit('rejectionHandled',promise);}else dispatchEvent$1(REJECTION_HANDLED$1,promise,state.value);});};var bind$1=function bind(fn,promise,state,unwrap){return function(value){fn(promise,state,value,unwrap);};};var internalReject$1=function internalReject(promise,state,value,unwrap){if(state.done)return;state.done=true;if(unwrap)state=unwrap;state.value=value;state.state=REJECTED$1;notify$1$1(promise,state,true);};var internalResolve$1=function internalResolve(promise,state,value,unwrap){if(state.done)return;state.done=true;if(unwrap)state=unwrap;try{if(promise===value)throw TypeError$1$1("Promise can't be resolved itself");var then=isThenable$1(value);if(then){microtask$1(function(){var wrapper={done:false};try{then.call(value,bind$1(internalResolve,promise,wrapper,state),bind$1(internalReject$1,promise,wrapper,state));}catch(error){internalReject$1(promise,wrapper,error,state);}});}else {state.value=value;state.state=FULFILLED$1;notify$1$1(promise,state,false);}}catch(error){internalReject$1(promise,{done:false},error,state);}};// constructor polyfill
if(FORCED$3$1){// 25.4.3.1 Promise(executor)
PromiseConstructor$1=function Promise(executor){anInstance$1(this,PromiseConstructor$1,PROMISE$1);aFunction$1$1(executor);Internal$1.call(this);var state=getInternalState$2$1(this);try{executor(bind$1(internalResolve$1,this,state),bind$1(internalReject$1,this,state));}catch(error){internalReject$1(this,state,error);}};// eslint-disable-next-line no-unused-vars
Internal$1=function Promise(executor){setInternalState$2$1(this,{type:PROMISE$1,done:false,notified:false,parent:false,reactions:[],rejection:false,state:PENDING$1,value:undefined});};Internal$1.prototype=redefineAll$1(PromiseConstructor$1.prototype,{// `Promise.prototype.then` method
// https://tc39.github.io/ecma262/#sec-promise.prototype.then
then:function then(onFulfilled,onRejected){var state=getInternalPromiseState$1(this);var reaction=newPromiseCapability$1$1(speciesConstructor$1(this,PromiseConstructor$1));reaction.ok=typeof onFulfilled=='function'?onFulfilled:true;reaction.fail=typeof onRejected=='function'&&onRejected;reaction.domain=IS_NODE$1$1?process$3$1.domain:undefined;state.parent=true;state.reactions.push(reaction);if(state.state!=PENDING$1)notify$1$1(this,state,false);return reaction.promise;},// `Promise.prototype.catch` method
// https://tc39.github.io/ecma262/#sec-promise.prototype.catch
'catch':function _catch(onRejected){return this.then(undefined,onRejected);}});OwnPromiseCapability$1=function OwnPromiseCapability(){var promise=new Internal$1();var state=getInternalState$2$1(promise);this.promise=promise;this.resolve=bind$1(internalResolve$1,promise,state);this.reject=bind$1(internalReject$1,promise,state);};newPromiseCapability$2.f=newPromiseCapability$1$1=function newPromiseCapability$1(C){return C===PromiseConstructor$1||C===PromiseWrapper$1?new OwnPromiseCapability$1(C):newGenericPromiseCapability$1(C);};if(typeof nativePromiseConstructor$1=='function'){nativeThen$1=nativePromiseConstructor$1.prototype.then;// wrap native Promise#then for native async functions
redefine$1(nativePromiseConstructor$1.prototype,'then',function then(onFulfilled,onRejected){var that=this;return new PromiseConstructor$1(function(resolve,reject){nativeThen$1.call(that,resolve,reject);}).then(onFulfilled,onRejected);// https://github.com/zloirock/core-js/issues/640
},{unsafe:true});// wrap fetch result
if(typeof $fetch$2=='function')_export$1({global:true,enumerable:true,forced:true},{// eslint-disable-next-line no-unused-vars
fetch:function fetch(input/* , init */){return promiseResolve$1(PromiseConstructor$1,$fetch$2.apply(global_1$1,arguments));}});}}_export$1({global:true,wrap:true,forced:FORCED$3$1},{Promise:PromiseConstructor$1});setToStringTag$1(PromiseConstructor$1,PROMISE$1,false);setSpecies$1(PROMISE$1);PromiseWrapper$1=getBuiltIn$1(PROMISE$1);// statics
_export$1({target:PROMISE$1,stat:true,forced:FORCED$3$1},{// `Promise.reject` method
// https://tc39.github.io/ecma262/#sec-promise.reject
reject:function reject(r){var capability=newPromiseCapability$1$1(this);capability.reject.call(undefined,r);return capability.promise;}});_export$1({target:PROMISE$1,stat:true,forced:FORCED$3$1},{// `Promise.resolve` method
// https://tc39.github.io/ecma262/#sec-promise.resolve
resolve:function resolve(x){return promiseResolve$1(this,x);}});_export$1({target:PROMISE$1,stat:true,forced:INCORRECT_ITERATION$2},{// `Promise.all` method
// https://tc39.github.io/ecma262/#sec-promise.all
all:function all(iterable){var C=this;var capability=newPromiseCapability$1$1(C);var resolve=capability.resolve;var reject=capability.reject;var result=perform$1(function(){var $promiseResolve=aFunction$1$1(C.resolve);var values=[];var counter=0;var remaining=1;iterate_1$1(iterable,function(promise){var index=counter++;var alreadyCalled=false;values.push(undefined);remaining++;$promiseResolve.call(C,promise).then(function(value){if(alreadyCalled)return;alreadyCalled=true;values[index]=value;--remaining||resolve(values);},reject);});--remaining||resolve(values);});if(result.error)reject(result.value);return capability.promise;},// `Promise.race` method
// https://tc39.github.io/ecma262/#sec-promise.race
race:function race(iterable){var C=this;var capability=newPromiseCapability$1$1(C);var reject=capability.reject;var result=perform$1(function(){var $promiseResolve=aFunction$1$1(C.resolve);iterate_1$1(iterable,function(promise){$promiseResolve.call(C,promise).then(capability.resolve,reject);});});if(result.error)reject(result.value);return capability.promise;}});var MATCH$3=wellKnownSymbol$1('match');// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
var isRegexp$1=function isRegexp(it){var isRegExp;return isObject$1(it)&&((isRegExp=it[MATCH$3])!==undefined?!!isRegExp:classofRaw$1(it)=='RegExp');};// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags$1=function regexpFlags(){var that=anObject$1(this);var result='';if(that.global)result+='g';if(that.ignoreCase)result+='i';if(that.multiline)result+='m';if(that.dotAll)result+='s';if(that.unicode)result+='u';if(that.sticky)result+='y';return result;};// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE$1(s,f){return RegExp(s,f);}var UNSUPPORTED_Y$4=fails$1(function(){// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var re=RE$1('a','y');re.lastIndex=2;return re.exec('abcd')!=null;});var BROKEN_CARET$1=fails$1(function(){// https://bugzilla.mozilla.org/show_bug.cgi?id=773687
var re=RE$1('^r','gy');re.lastIndex=2;return re.exec('str')!=null;});var regexpStickyHelpers$1={UNSUPPORTED_Y:UNSUPPORTED_Y$4,BROKEN_CARET:BROKEN_CARET$1};var defineProperty$5$1=objectDefineProperty$1.f;var getOwnPropertyNames$2$1=objectGetOwnPropertyNames$1.f;var setInternalState$3$1=internalState$1.set;var MATCH$1$1=wellKnownSymbol$1('match');var NativeRegExp$1=global_1$1.RegExp;var RegExpPrototype$2=NativeRegExp$1.prototype;var re1$1=/a/g;var re2$1=/a/g;// "new" should create a new object, old webkit bug
var CORRECT_NEW$1=new NativeRegExp$1(re1$1)!==re1$1;var UNSUPPORTED_Y$1$1=regexpStickyHelpers$1.UNSUPPORTED_Y;var FORCED$4$1=descriptors$1&&isForced_1$1('RegExp',!CORRECT_NEW$1||UNSUPPORTED_Y$1$1||fails$1(function(){re2$1[MATCH$1$1]=false;// RegExp constructor can alter flags and IsRegExp works correct with @@match
return NativeRegExp$1(re1$1)!=re1$1||NativeRegExp$1(re2$1)==re2$1||NativeRegExp$1(re1$1,'i')!='/a/i';}));// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if(FORCED$4$1){var RegExpWrapper$1=function RegExp(pattern,flags){var thisIsRegExp=this instanceof RegExpWrapper$1;var patternIsRegExp=isRegexp$1(pattern);var flagsAreUndefined=flags===undefined;var sticky;if(!thisIsRegExp&&patternIsRegExp&&pattern.constructor===RegExpWrapper$1&&flagsAreUndefined){return pattern;}if(CORRECT_NEW$1){if(patternIsRegExp&&!flagsAreUndefined)pattern=pattern.source;}else if(pattern instanceof RegExpWrapper$1){if(flagsAreUndefined)flags=regexpFlags$1.call(pattern);pattern=pattern.source;}if(UNSUPPORTED_Y$1$1){sticky=!!flags&&flags.indexOf('y')>-1;if(sticky)flags=flags.replace(/y/g,'');}var result=inheritIfRequired$1(CORRECT_NEW$1?new NativeRegExp$1(pattern,flags):NativeRegExp$1(pattern,flags),thisIsRegExp?this:RegExpPrototype$2,RegExpWrapper$1);if(UNSUPPORTED_Y$1$1&&sticky)setInternalState$3$1(result,{sticky:sticky});return result;};var proxy$1=function proxy(key){key in RegExpWrapper$1||defineProperty$5$1(RegExpWrapper$1,key,{configurable:true,get:function get(){return NativeRegExp$1[key];},set:function set(it){NativeRegExp$1[key]=it;}});};var keys$3$1=getOwnPropertyNames$2$1(NativeRegExp$1);var index$1=0;while(keys$3$1.length>index$1){proxy$1(keys$3$1[index$1++]);}RegExpPrototype$2.constructor=RegExpWrapper$1;RegExpWrapper$1.prototype=RegExpPrototype$2;redefine$1(global_1$1,'RegExp',RegExpWrapper$1);}// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies$1('RegExp');var nativeExec$1=RegExp.prototype.exec;// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace$1=String.prototype.replace;var patchedExec$1=nativeExec$1;var UPDATES_LAST_INDEX_WRONG$1=function(){var re1=/a/;var re2=/b*/g;nativeExec$1.call(re1,'a');nativeExec$1.call(re2,'a');return re1.lastIndex!==0||re2.lastIndex!==0;}();var UNSUPPORTED_Y$2$1=regexpStickyHelpers$1.UNSUPPORTED_Y||regexpStickyHelpers$1.BROKEN_CARET;// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED$1=/()??/.exec('')[1]!==undefined;var PATCH$1=UPDATES_LAST_INDEX_WRONG$1||NPCG_INCLUDED$1||UNSUPPORTED_Y$2$1;if(PATCH$1){patchedExec$1=function exec(str){var re=this;var lastIndex,reCopy,match,i;var sticky=UNSUPPORTED_Y$2$1&&re.sticky;var flags=regexpFlags$1.call(re);var source=re.source;var charsAdded=0;var strCopy=str;if(sticky){flags=flags.replace('y','');if(flags.indexOf('g')===-1){flags+='g';}strCopy=String(str).slice(re.lastIndex);// Support anchored sticky behavior.
if(re.lastIndex>0&&(!re.multiline||re.multiline&&str[re.lastIndex-1]!=='\n')){source='(?: '+source+')';strCopy=' '+strCopy;charsAdded++;}// ^(? + rx + ) is needed, in combination with some str slicing, to
// simulate the 'y' flag.
reCopy=new RegExp('^(?:'+source+')',flags);}if(NPCG_INCLUDED$1){reCopy=new RegExp('^'+source+'$(?!\\s)',flags);}if(UPDATES_LAST_INDEX_WRONG$1)lastIndex=re.lastIndex;match=nativeExec$1.call(sticky?reCopy:re,strCopy);if(sticky){if(match){match.input=match.input.slice(charsAdded);match[0]=match[0].slice(charsAdded);match.index=re.lastIndex;re.lastIndex+=match[0].length;}else re.lastIndex=0;}else if(UPDATES_LAST_INDEX_WRONG$1&&match){re.lastIndex=re.global?match.index+match[0].length:lastIndex;}if(NPCG_INCLUDED$1&&match&&match.length>1){// Fix browsers whose `exec` methods don't consistently return `undefined`
// for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
nativeReplace$1.call(match[0],reCopy,function(){for(i=1;i<arguments.length-2;i++){if(arguments[i]===undefined)match[i]=undefined;}});}return match;};}var regexpExec$1=patchedExec$1;_export$1({target:'RegExp',proto:true,forced:/./.exec!==regexpExec$1},{exec:regexpExec$1});var TO_STRING$1='toString';var RegExpPrototype$1$1=RegExp.prototype;var nativeToString$1=RegExpPrototype$1$1[TO_STRING$1];var NOT_GENERIC$1=fails$1(function(){return nativeToString$1.call({source:'a',flags:'b'})!='/a/b';});// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME$1=nativeToString$1.name!=TO_STRING$1;// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if(NOT_GENERIC$1||INCORRECT_NAME$1){redefine$1(RegExp.prototype,TO_STRING$1,function toString(){var R=anObject$1(this);var p=String(R.source);var rf=R.flags;var f=String(rf===undefined&&R instanceof RegExp&&!('flags'in RegExpPrototype$1$1)?regexpFlags$1.call(R):rf);return '/'+p+'/'+f;},{unsafe:true});}// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod$3$1=function createMethod$3(CONVERT_TO_STRING){return function($this,pos){var S=String(requireObjectCoercible$1($this));var position=toInteger$1(pos);var size=S.length;var first,second;if(position<0||position>=size)return CONVERT_TO_STRING?'':undefined;first=S.charCodeAt(position);return first<0xD800||first>0xDBFF||position+1===size||(second=S.charCodeAt(position+1))<0xDC00||second>0xDFFF?CONVERT_TO_STRING?S.charAt(position):first:CONVERT_TO_STRING?S.slice(position,position+2):(first-0xD800<<10)+(second-0xDC00)+0x10000;};};var stringMultibyte$1={// `String.prototype.codePointAt` method
// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
codeAt:createMethod$3$1(false),// `String.prototype.at` method
// https://github.com/mathiasbynens/String.prototype.at
charAt:createMethod$3$1(true)};var charAt$2=stringMultibyte$1.charAt;var STRING_ITERATOR$1='String Iterator';var setInternalState$4$1=internalState$1.set;var getInternalState$3$1=internalState$1.getterFor(STRING_ITERATOR$1);// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator$1(String,'String',function(iterated){setInternalState$4$1(this,{type:STRING_ITERATOR$1,string:String(iterated),index:0});// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
},function next(){var state=getInternalState$3$1(this);var string=state.string;var index=state.index;var point;if(index>=string.length)return {value:undefined,done:true};point=charAt$2(string,index);state.index+=point.length;return {value:point,done:false};});// TODO: Remove from `core-js@4` since it's moved to entry points
var SPECIES$6$1=wellKnownSymbol$1('species');var REPLACE_SUPPORTS_NAMED_GROUPS$1=!fails$1(function(){// #replace needs built-in support for named groups.
// #match works fine because it just return the exec results, even if it has
// a "grops" property.
var re=/./;re.exec=function(){var result=[];result.groups={a:'7'};return result;};return ''.replace(re,'$<a>')!=='7';});// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0$1=function(){return 'a'.replace(/./,'$0')==='$0';}();var REPLACE$1=wellKnownSymbol$1('replace');// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE$1=function(){if(/./[REPLACE$1]){return /./[REPLACE$1]('a','$0')==='';}return false;}();// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC$1=!fails$1(function(){var re=/(?:)/;var originalExec=re.exec;re.exec=function(){return originalExec.apply(this,arguments);};var result='ab'.split(re);return result.length!==2||result[0]!=='a'||result[1]!=='b';});var fixRegexpWellKnownSymbolLogic$1=function fixRegexpWellKnownSymbolLogic(KEY,length,exec,sham){var SYMBOL=wellKnownSymbol$1(KEY);var DELEGATES_TO_SYMBOL=!fails$1(function(){// String methods call symbol-named RegEp methods
var O={};O[SYMBOL]=function(){return 7;};return ''[KEY](O)!=7;});var DELEGATES_TO_EXEC=DELEGATES_TO_SYMBOL&&!fails$1(function(){// Symbol-named RegExp methods call .exec
var execCalled=false;var re=/a/;if(KEY==='split'){// We can't use real regex here since it causes deoptimization
// and serious performance degradation in V8
// https://github.com/zloirock/core-js/issues/306
re={};// RegExp[@@split] doesn't call the regex's exec method, but first creates
// a new one. We need to return the patched regex when creating the new one.
re.constructor={};re.constructor[SPECIES$6$1]=function(){return re;};re.flags='';re[SYMBOL]=/./[SYMBOL];}re.exec=function(){execCalled=true;return null;};re[SYMBOL]('');return !execCalled;});if(!DELEGATES_TO_SYMBOL||!DELEGATES_TO_EXEC||KEY==='replace'&&!(REPLACE_SUPPORTS_NAMED_GROUPS$1&&REPLACE_KEEPS_$0$1&&!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE$1)||KEY==='split'&&!SPLIT_WORKS_WITH_OVERWRITTEN_EXEC$1){var nativeRegExpMethod=/./[SYMBOL];var methods=exec(SYMBOL,''[KEY],function(nativeMethod,regexp,str,arg2,forceStringMethod){if(regexp.exec===regexpExec$1){if(DELEGATES_TO_SYMBOL&&!forceStringMethod){// The native String method already delegates to @@method (this
// polyfilled function), leasing to infinite recursion.
// We avoid it by directly calling the native @@method method.
return {done:true,value:nativeRegExpMethod.call(regexp,str,arg2)};}return {done:true,value:nativeMethod.call(str,regexp,arg2)};}return {done:false};},{REPLACE_KEEPS_$0:REPLACE_KEEPS_$0$1,REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE$1});var stringMethod=methods[0];var regexMethod=methods[1];redefine$1(String.prototype,KEY,stringMethod);redefine$1(RegExp.prototype,SYMBOL,length==2// 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
// 21.2.5.11 RegExp.prototype[@@split](string, limit)
?function(string,arg){return regexMethod.call(string,this,arg);}// 21.2.5.6 RegExp.prototype[@@match](string)
// 21.2.5.9 RegExp.prototype[@@search](string)
:function(string){return regexMethod.call(string,this);});}if(sham)createNonEnumerableProperty$1(RegExp.prototype[SYMBOL],'sham',true);};var charAt$1$1=stringMultibyte$1.charAt;// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
var advanceStringIndex$1=function advanceStringIndex(S,index,unicode){return index+(unicode?charAt$1$1(S,index).length:1);};// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
var regexpExecAbstract$1=function regexpExecAbstract(R,S){var exec=R.exec;if(typeof exec==='function'){var result=exec.call(R,S);if(_typeof(result)!=='object'){throw TypeError('RegExp exec method returned something other than an Object or null');}return result;}if(classofRaw$1(R)!=='RegExp'){throw TypeError('RegExp#exec called on incompatible receiver');}return regexpExec$1.call(R,S);};// @@match logic
fixRegexpWellKnownSymbolLogic$1('match',1,function(MATCH,nativeMatch,maybeCallNative){return [// `String.prototype.match` method
// https://tc39.github.io/ecma262/#sec-string.prototype.match
function match(regexp){var O=requireObjectCoercible$1(this);var matcher=regexp==undefined?undefined:regexp[MATCH];return matcher!==undefined?matcher.call(regexp,O):new RegExp(regexp)[MATCH](String(O));},// `RegExp.prototype[@@match]` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
function(regexp){var res=maybeCallNative(nativeMatch,regexp,this);if(res.done)return res.value;var rx=anObject$1(regexp);var S=String(this);if(!rx.global)return regexpExecAbstract$1(rx,S);var fullUnicode=rx.unicode;rx.lastIndex=0;var A=[];var n=0;var result;while((result=regexpExecAbstract$1(rx,S))!==null){var matchStr=String(result[0]);A[n]=matchStr;if(matchStr==='')rx.lastIndex=advanceStringIndex$1(S,toLength$1(rx.lastIndex),fullUnicode);n++;}return n===0?null:A;}];});var max$2$1=Math.max;var min$3$1=Math.min;var floor$2$1=Math.floor;var SUBSTITUTION_SYMBOLS$1=/\$([$&'`]|\d\d?|<[^>]*>)/g;var SUBSTITUTION_SYMBOLS_NO_NAMED$1=/\$([$&'`]|\d\d?)/g;var maybeToString$1=function maybeToString(it){return it===undefined?it:String(it);};// @@replace logic
fixRegexpWellKnownSymbolLogic$1('replace',2,function(REPLACE,nativeReplace,maybeCallNative,reason){var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE=reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;var REPLACE_KEEPS_$0=reason.REPLACE_KEEPS_$0;var UNSAFE_SUBSTITUTE=REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE?'$':'$0';return [// `String.prototype.replace` method
// https://tc39.github.io/ecma262/#sec-string.prototype.replace
function replace(searchValue,replaceValue){var O=requireObjectCoercible$1(this);var replacer=searchValue==undefined?undefined:searchValue[REPLACE];return replacer!==undefined?replacer.call(searchValue,O,replaceValue):nativeReplace.call(String(O),searchValue,replaceValue);},// `RegExp.prototype[@@replace]` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
function(regexp,replaceValue){if(!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE&&REPLACE_KEEPS_$0||typeof replaceValue==='string'&&replaceValue.indexOf(UNSAFE_SUBSTITUTE)===-1){var res=maybeCallNative(nativeReplace,regexp,this,replaceValue);if(res.done)return res.value;}var rx=anObject$1(regexp);var S=String(this);var functionalReplace=typeof replaceValue==='function';if(!functionalReplace)replaceValue=String(replaceValue);var global=rx.global;if(global){var fullUnicode=rx.unicode;rx.lastIndex=0;}var results=[];while(true){var result=regexpExecAbstract$1(rx,S);if(result===null)break;results.push(result);if(!global)break;var matchStr=String(result[0]);if(matchStr==='')rx.lastIndex=advanceStringIndex$1(S,toLength$1(rx.lastIndex),fullUnicode);}var accumulatedResult='';var nextSourcePosition=0;for(var i=0;i<results.length;i++){result=results[i];var matched=String(result[0]);var position=max$2$1(min$3$1(toInteger$1(result.index),S.length),0);var captures=[];// NOTE: This is equivalent to
//   captures = result.slice(1).map(maybeToString)
// but for some reason `nativeSlice.call(result, 1, result.length)` (called in
// the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
// causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
for(var j=1;j<result.length;j++){captures.push(maybeToString$1(result[j]));}var namedCaptures=result.groups;if(functionalReplace){var replacerArgs=[matched].concat(captures,position,S);if(namedCaptures!==undefined)replacerArgs.push(namedCaptures);var replacement=String(replaceValue.apply(undefined,replacerArgs));}else {replacement=getSubstitution(matched,S,position,captures,namedCaptures,replaceValue);}if(position>=nextSourcePosition){accumulatedResult+=S.slice(nextSourcePosition,position)+replacement;nextSourcePosition=position+matched.length;}}return accumulatedResult+S.slice(nextSourcePosition);}];// https://tc39.github.io/ecma262/#sec-getsubstitution
function getSubstitution(matched,str,position,captures,namedCaptures,replacement){var tailPos=position+matched.length;var m=captures.length;var symbols=SUBSTITUTION_SYMBOLS_NO_NAMED$1;if(namedCaptures!==undefined){namedCaptures=toObject$1(namedCaptures);symbols=SUBSTITUTION_SYMBOLS$1;}return nativeReplace.call(replacement,symbols,function(match,ch){var capture;switch(ch.charAt(0)){case'$':return '$';case'&':return matched;case'`':return str.slice(0,position);case"'":return str.slice(tailPos);case'<':capture=namedCaptures[ch.slice(1,-1)];break;default:// \d\d?
var n=+ch;if(n===0)return match;if(n>m){var f=floor$2$1(n/10);if(f===0)return match;if(f<=m)return captures[f-1]===undefined?ch.charAt(1):captures[f-1]+ch.charAt(1);return match;}capture=captures[n-1];}return capture===undefined?'':capture;});}});// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
var sameValue$1=Object.is||function is(x,y){// eslint-disable-next-line no-self-compare
return x===y?x!==0||1/x===1/y:x!=x&&y!=y;};// @@search logic
fixRegexpWellKnownSymbolLogic$1('search',1,function(SEARCH,nativeSearch,maybeCallNative){return [// `String.prototype.search` method
// https://tc39.github.io/ecma262/#sec-string.prototype.search
function search(regexp){var O=requireObjectCoercible$1(this);var searcher=regexp==undefined?undefined:regexp[SEARCH];return searcher!==undefined?searcher.call(regexp,O):new RegExp(regexp)[SEARCH](String(O));},// `RegExp.prototype[@@search]` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
function(regexp){var res=maybeCallNative(nativeSearch,regexp,this);if(res.done)return res.value;var rx=anObject$1(regexp);var S=String(this);var previousLastIndex=rx.lastIndex;if(!sameValue$1(previousLastIndex,0))rx.lastIndex=0;var result=regexpExecAbstract$1(rx,S);if(!sameValue$1(rx.lastIndex,previousLastIndex))rx.lastIndex=previousLastIndex;return result===null?-1:result.index;}];});var arrayPush$1=[].push;var min$4$1=Math.min;var MAX_UINT32$1=0xFFFFFFFF;// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y$1=!fails$1(function(){return !RegExp(MAX_UINT32$1,'y');});// @@split logic
fixRegexpWellKnownSymbolLogic$1('split',2,function(SPLIT,nativeSplit,maybeCallNative){var internalSplit;if('abbc'.split(/(b)*/)[1]=='c'||'test'.split(/(?:)/,-1).length!=4||'ab'.split(/(?:ab)*/).length!=2||'.'.split(/(.?)(.?)/).length!=4||'.'.split(/()()/).length>1||''.split(/.?/).length){// based on es5-shim implementation, need to rework it
internalSplit=function internalSplit(separator,limit){var string=String(requireObjectCoercible$1(this));var lim=limit===undefined?MAX_UINT32$1:limit>>>0;if(lim===0)return [];if(separator===undefined)return [string];// If `separator` is not a regex, use native split
if(!isRegexp$1(separator)){return nativeSplit.call(string,separator,lim);}var output=[];var flags=(separator.ignoreCase?'i':'')+(separator.multiline?'m':'')+(separator.unicode?'u':'')+(separator.sticky?'y':'');var lastLastIndex=0;// Make `global` and avoid `lastIndex` issues by working with a copy
var separatorCopy=new RegExp(separator.source,flags+'g');var match,lastIndex,lastLength;while(match=regexpExec$1.call(separatorCopy,string)){lastIndex=separatorCopy.lastIndex;if(lastIndex>lastLastIndex){output.push(string.slice(lastLastIndex,match.index));if(match.length>1&&match.index<string.length)arrayPush$1.apply(output,match.slice(1));lastLength=match[0].length;lastLastIndex=lastIndex;if(output.length>=lim)break;}if(separatorCopy.lastIndex===match.index)separatorCopy.lastIndex++;// Avoid an infinite loop
}if(lastLastIndex===string.length){if(lastLength||!separatorCopy.test(''))output.push('');}else output.push(string.slice(lastLastIndex));return output.length>lim?output.slice(0,lim):output;};// Chakra, V8
}else if('0'.split(undefined,0).length){internalSplit=function internalSplit(separator,limit){return separator===undefined&&limit===0?[]:nativeSplit.call(this,separator,limit);};}else internalSplit=nativeSplit;return [// `String.prototype.split` method
// https://tc39.github.io/ecma262/#sec-string.prototype.split
function split(separator,limit){var O=requireObjectCoercible$1(this);var splitter=separator==undefined?undefined:separator[SPLIT];return splitter!==undefined?splitter.call(separator,O,limit):internalSplit.call(String(O),separator,limit);},// `RegExp.prototype[@@split]` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
//
// NOTE: This cannot be properly polyfilled in engines that don't support
// the 'y' flag.
function(regexp,limit){var res=maybeCallNative(internalSplit,regexp,this,limit,internalSplit!==nativeSplit);if(res.done)return res.value;var rx=anObject$1(regexp);var S=String(this);var C=speciesConstructor$1(rx,RegExp);var unicodeMatching=rx.unicode;var flags=(rx.ignoreCase?'i':'')+(rx.multiline?'m':'')+(rx.unicode?'u':'')+(SUPPORTS_Y$1?'y':'g');// ^(? + rx + ) is needed, in combination with some S slicing, to
// simulate the 'y' flag.
var splitter=new C(SUPPORTS_Y$1?rx:'^(?:'+rx.source+')',flags);var lim=limit===undefined?MAX_UINT32$1:limit>>>0;if(lim===0)return [];if(S.length===0)return regexpExecAbstract$1(splitter,S)===null?[S]:[];var p=0;var q=0;var A=[];while(q<S.length){splitter.lastIndex=SUPPORTS_Y$1?q:0;var z=regexpExecAbstract$1(splitter,SUPPORTS_Y$1?S:S.slice(q));var e;if(z===null||(e=min$4$1(toLength$1(splitter.lastIndex+(SUPPORTS_Y$1?0:q)),S.length))===p){q=advanceStringIndex$1(S,q,unicodeMatching);}else {A.push(S.slice(p,q));if(A.length===lim)return A;for(var i=1;i<=z.length-1;i++){A.push(z[i]);if(A.length===lim)return A;}q=p=e;}}A.push(S.slice(p));return A;}];},!SUPPORTS_Y$1);var non$1="\u200B\x85\u180E";// check that a method works with the correct list
// of whitespaces and has a correct name
var stringTrimForced$1=function stringTrimForced(METHOD_NAME){return fails$1(function(){return !!whitespaces$1[METHOD_NAME]()||non$1[METHOD_NAME]()!=non$1||whitespaces$1[METHOD_NAME].name!==METHOD_NAME;});};var $trim$1=stringTrim$1.trim;// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
_export$1({target:'String',proto:true,forced:stringTrimForced$1('trim')},{trim:function trim(){return $trim$1(this);}});var defineProperty$6$1=objectDefineProperty$1.f;var Int8Array$1$1=global_1$1.Int8Array;var Int8ArrayPrototype$1=Int8Array$1$1&&Int8Array$1$1.prototype;var Uint8ClampedArray$1=global_1$1.Uint8ClampedArray;var Uint8ClampedArrayPrototype$1=Uint8ClampedArray$1&&Uint8ClampedArray$1.prototype;var TypedArray$1=Int8Array$1$1&&objectGetPrototypeOf$1(Int8Array$1$1);var TypedArrayPrototype$1=Int8ArrayPrototype$1&&objectGetPrototypeOf$1(Int8ArrayPrototype$1);var ObjectPrototype$2$1=Object.prototype;var isPrototypeOf$1=ObjectPrototype$2$1.isPrototypeOf;var TO_STRING_TAG$3$1=wellKnownSymbol$1('toStringTag');var TYPED_ARRAY_TAG$1=uid$1('TYPED_ARRAY_TAG');// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS$2=arrayBufferNative$1&&!!objectSetPrototypeOf$1&&classof$1(global_1$1.opera)!=='Opera';var TYPED_ARRAY_TAG_REQIRED$1=false;var NAME$1$1;var TypedArrayConstructorsList$1={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8};var isView$1=function isView(it){var klass=classof$1(it);return klass==='DataView'||has$2(TypedArrayConstructorsList$1,klass);};var isTypedArray$1=function isTypedArray(it){return isObject$1(it)&&has$2(TypedArrayConstructorsList$1,classof$1(it));};var aTypedArray$n=function aTypedArray(it){if(isTypedArray$1(it))return it;throw TypeError('Target is not a typed array');};var aTypedArrayConstructor$5=function aTypedArrayConstructor(C){if(objectSetPrototypeOf$1){if(isPrototypeOf$1.call(TypedArray$1,C))return C;}else for(var ARRAY in TypedArrayConstructorsList$1){if(has$2(TypedArrayConstructorsList$1,NAME$1$1)){var TypedArrayConstructor=global_1$1[ARRAY];if(TypedArrayConstructor&&(C===TypedArrayConstructor||isPrototypeOf$1.call(TypedArrayConstructor,C))){return C;}}}throw TypeError('Target is not a typed array constructor');};var exportTypedArrayMethod$o=function exportTypedArrayMethod(KEY,property,forced){if(!descriptors$1)return;if(forced)for(var ARRAY in TypedArrayConstructorsList$1){var TypedArrayConstructor=global_1$1[ARRAY];if(TypedArrayConstructor&&has$2(TypedArrayConstructor.prototype,KEY)){delete TypedArrayConstructor.prototype[KEY];}}if(!TypedArrayPrototype$1[KEY]||forced){redefine$1(TypedArrayPrototype$1,KEY,forced?property:NATIVE_ARRAY_BUFFER_VIEWS$2&&Int8ArrayPrototype$1[KEY]||property);}};var exportTypedArrayStaticMethod$1=function exportTypedArrayStaticMethod(KEY,property,forced){var ARRAY,TypedArrayConstructor;if(!descriptors$1)return;if(objectSetPrototypeOf$1){if(forced)for(ARRAY in TypedArrayConstructorsList$1){TypedArrayConstructor=global_1$1[ARRAY];if(TypedArrayConstructor&&has$2(TypedArrayConstructor,KEY)){delete TypedArrayConstructor[KEY];}}if(!TypedArray$1[KEY]||forced){// V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
try{return redefine$1(TypedArray$1,KEY,forced?property:NATIVE_ARRAY_BUFFER_VIEWS$2&&Int8Array$1$1[KEY]||property);}catch(error){/* empty */}}else return;}for(ARRAY in TypedArrayConstructorsList$1){TypedArrayConstructor=global_1$1[ARRAY];if(TypedArrayConstructor&&(!TypedArrayConstructor[KEY]||forced)){redefine$1(TypedArrayConstructor,KEY,property);}}};for(NAME$1$1 in TypedArrayConstructorsList$1){if(!global_1$1[NAME$1$1])NATIVE_ARRAY_BUFFER_VIEWS$2=false;}// WebKit bug - typed arrays constructors prototype is Object.prototype
if(!NATIVE_ARRAY_BUFFER_VIEWS$2||typeof TypedArray$1!='function'||TypedArray$1===Function.prototype){// eslint-disable-next-line no-shadow
TypedArray$1=function TypedArray(){throw TypeError('Incorrect invocation');};if(NATIVE_ARRAY_BUFFER_VIEWS$2)for(NAME$1$1 in TypedArrayConstructorsList$1){if(global_1$1[NAME$1$1])objectSetPrototypeOf$1(global_1$1[NAME$1$1],TypedArray$1);}}if(!NATIVE_ARRAY_BUFFER_VIEWS$2||!TypedArrayPrototype$1||TypedArrayPrototype$1===ObjectPrototype$2$1){TypedArrayPrototype$1=TypedArray$1.prototype;if(NATIVE_ARRAY_BUFFER_VIEWS$2)for(NAME$1$1 in TypedArrayConstructorsList$1){if(global_1$1[NAME$1$1])objectSetPrototypeOf$1(global_1$1[NAME$1$1].prototype,TypedArrayPrototype$1);}}// WebKit bug - one more object in Uint8ClampedArray prototype chain
if(NATIVE_ARRAY_BUFFER_VIEWS$2&&objectGetPrototypeOf$1(Uint8ClampedArrayPrototype$1)!==TypedArrayPrototype$1){objectSetPrototypeOf$1(Uint8ClampedArrayPrototype$1,TypedArrayPrototype$1);}if(descriptors$1&&!has$2(TypedArrayPrototype$1,TO_STRING_TAG$3$1)){TYPED_ARRAY_TAG_REQIRED$1=true;defineProperty$6$1(TypedArrayPrototype$1,TO_STRING_TAG$3$1,{get:function get(){return isObject$1(this)?this[TYPED_ARRAY_TAG$1]:undefined;}});for(NAME$1$1 in TypedArrayConstructorsList$1){if(global_1$1[NAME$1$1]){createNonEnumerableProperty$1(global_1$1[NAME$1$1],TYPED_ARRAY_TAG$1,NAME$1$1);}}}var arrayBufferViewCore$1={NATIVE_ARRAY_BUFFER_VIEWS:NATIVE_ARRAY_BUFFER_VIEWS$2,TYPED_ARRAY_TAG:TYPED_ARRAY_TAG_REQIRED$1&&TYPED_ARRAY_TAG$1,aTypedArray:aTypedArray$n,aTypedArrayConstructor:aTypedArrayConstructor$5,exportTypedArrayMethod:exportTypedArrayMethod$o,exportTypedArrayStaticMethod:exportTypedArrayStaticMethod$1,isView:isView$1,isTypedArray:isTypedArray$1,TypedArray:TypedArray$1,TypedArrayPrototype:TypedArrayPrototype$1};/* eslint-disable no-new */var NATIVE_ARRAY_BUFFER_VIEWS$1$1=arrayBufferViewCore$1.NATIVE_ARRAY_BUFFER_VIEWS;var ArrayBuffer$2$1=global_1$1.ArrayBuffer;var Int8Array$2$1=global_1$1.Int8Array;var typedArrayConstructorsRequireWrappers$1=!NATIVE_ARRAY_BUFFER_VIEWS$1$1||!fails$1(function(){Int8Array$2$1(1);})||!fails$1(function(){new Int8Array$2$1(-1);})||!checkCorrectnessOfIteration$1(function(iterable){new Int8Array$2$1();new Int8Array$2$1(null);new Int8Array$2$1(1.5);new Int8Array$2$1(iterable);},true)||fails$1(function(){// Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
return new Int8Array$2$1(new ArrayBuffer$2$1(2),1,undefined).length!==1;});var toPositiveInteger$1=function toPositiveInteger(it){var result=toInteger$1(it);if(result<0)throw RangeError("The argument can't be less than 0");return result;};var toOffset$1=function toOffset(it,BYTES){var offset=toPositiveInteger$1(it);if(offset%BYTES)throw RangeError('Wrong offset');return offset;};var aTypedArrayConstructor$1$1=arrayBufferViewCore$1.aTypedArrayConstructor;var typedArrayFrom$1=function from(source/* , mapfn, thisArg */){var O=toObject$1(source);var argumentsLength=arguments.length;var mapfn=argumentsLength>1?arguments[1]:undefined;var mapping=mapfn!==undefined;var iteratorMethod=getIteratorMethod$1(O);var i,length,result,step,iterator,next;if(iteratorMethod!=undefined&&!isArrayIteratorMethod$1(iteratorMethod)){iterator=iteratorMethod.call(O);next=iterator.next;O=[];while(!(step=next.call(iterator)).done){O.push(step.value);}}if(mapping&&argumentsLength>2){mapfn=functionBindContext$1(mapfn,arguments[2],2);}length=toLength$1(O.length);result=new(aTypedArrayConstructor$1$1(this))(length);for(i=0;length>i;i++){result[i]=mapping?mapfn(O[i],i):O[i];}return result;};var typedArrayConstructor$1=createCommonjsModule$1(function(module){var getOwnPropertyNames=objectGetOwnPropertyNames$1.f;var forEach=arrayIteration$1.forEach;var getInternalState=internalState$1.get;var setInternalState=internalState$1.set;var nativeDefineProperty=objectDefineProperty$1.f;var nativeGetOwnPropertyDescriptor=objectGetOwnPropertyDescriptor$1.f;var round=Math.round;var RangeError=global_1$1.RangeError;var ArrayBuffer=arrayBuffer$1.ArrayBuffer;var DataView=arrayBuffer$1.DataView;var NATIVE_ARRAY_BUFFER_VIEWS=arrayBufferViewCore$1.NATIVE_ARRAY_BUFFER_VIEWS;var TYPED_ARRAY_TAG=arrayBufferViewCore$1.TYPED_ARRAY_TAG;var TypedArray=arrayBufferViewCore$1.TypedArray;var TypedArrayPrototype=arrayBufferViewCore$1.TypedArrayPrototype;var aTypedArrayConstructor=arrayBufferViewCore$1.aTypedArrayConstructor;var isTypedArray=arrayBufferViewCore$1.isTypedArray;var BYTES_PER_ELEMENT='BYTES_PER_ELEMENT';var WRONG_LENGTH='Wrong length';var fromList=function fromList(C,list){var index=0;var length=list.length;var result=new(aTypedArrayConstructor(C))(length);while(length>index){result[index]=list[index++];}return result;};var addGetter=function addGetter(it,key){nativeDefineProperty(it,key,{get:function get(){return getInternalState(this)[key];}});};var isArrayBuffer=function isArrayBuffer(it){var klass;return it instanceof ArrayBuffer||(klass=classof$1(it))=='ArrayBuffer'||klass=='SharedArrayBuffer';};var isTypedArrayIndex=function isTypedArrayIndex(target,key){return isTypedArray(target)&&_typeof(key)!='symbol'&&key in target&&String(+key)==String(key);};var wrappedGetOwnPropertyDescriptor=function getOwnPropertyDescriptor(target,key){return isTypedArrayIndex(target,key=toPrimitive$1(key,true))?createPropertyDescriptor$1(2,target[key]):nativeGetOwnPropertyDescriptor(target,key);};var wrappedDefineProperty=function defineProperty(target,key,descriptor){if(isTypedArrayIndex(target,key=toPrimitive$1(key,true))&&isObject$1(descriptor)&&has$2(descriptor,'value')&&!has$2(descriptor,'get')&&!has$2(descriptor,'set')// TODO: add validation descriptor w/o calling accessors
&&!descriptor.configurable&&(!has$2(descriptor,'writable')||descriptor.writable)&&(!has$2(descriptor,'enumerable')||descriptor.enumerable)){target[key]=descriptor.value;return target;}return nativeDefineProperty(target,key,descriptor);};if(descriptors$1){if(!NATIVE_ARRAY_BUFFER_VIEWS){objectGetOwnPropertyDescriptor$1.f=wrappedGetOwnPropertyDescriptor;objectDefineProperty$1.f=wrappedDefineProperty;addGetter(TypedArrayPrototype,'buffer');addGetter(TypedArrayPrototype,'byteOffset');addGetter(TypedArrayPrototype,'byteLength');addGetter(TypedArrayPrototype,'length');}_export$1({target:'Object',stat:true,forced:!NATIVE_ARRAY_BUFFER_VIEWS},{getOwnPropertyDescriptor:wrappedGetOwnPropertyDescriptor,defineProperty:wrappedDefineProperty});module.exports=function(TYPE,wrapper,CLAMPED){var BYTES=TYPE.match(/\d+$/)[0]/8;var CONSTRUCTOR_NAME=TYPE+(CLAMPED?'Clamped':'')+'Array';var GETTER='get'+TYPE;var SETTER='set'+TYPE;var NativeTypedArrayConstructor=global_1$1[CONSTRUCTOR_NAME];var TypedArrayConstructor=NativeTypedArrayConstructor;var TypedArrayConstructorPrototype=TypedArrayConstructor&&TypedArrayConstructor.prototype;var exported={};var getter=function getter(that,index){var data=getInternalState(that);return data.view[GETTER](index*BYTES+data.byteOffset,true);};var setter=function setter(that,index,value){var data=getInternalState(that);if(CLAMPED)value=(value=round(value))<0?0:value>0xFF?0xFF:value&0xFF;data.view[SETTER](index*BYTES+data.byteOffset,value,true);};var addElement=function addElement(that,index){nativeDefineProperty(that,index,{get:function get(){return getter(this,index);},set:function set(value){return setter(this,index,value);},enumerable:true});};if(!NATIVE_ARRAY_BUFFER_VIEWS){TypedArrayConstructor=wrapper(function(that,data,offset,$length){anInstance$1(that,TypedArrayConstructor,CONSTRUCTOR_NAME);var index=0;var byteOffset=0;var buffer,byteLength,length;if(!isObject$1(data)){length=toIndex$1(data);byteLength=length*BYTES;buffer=new ArrayBuffer(byteLength);}else if(isArrayBuffer(data)){buffer=data;byteOffset=toOffset$1(offset,BYTES);var $len=data.byteLength;if($length===undefined){if($len%BYTES)throw RangeError(WRONG_LENGTH);byteLength=$len-byteOffset;if(byteLength<0)throw RangeError(WRONG_LENGTH);}else {byteLength=toLength$1($length)*BYTES;if(byteLength+byteOffset>$len)throw RangeError(WRONG_LENGTH);}length=byteLength/BYTES;}else if(isTypedArray(data)){return fromList(TypedArrayConstructor,data);}else {return typedArrayFrom$1.call(TypedArrayConstructor,data);}setInternalState(that,{buffer:buffer,byteOffset:byteOffset,byteLength:byteLength,length:length,view:new DataView(buffer)});while(index<length){addElement(that,index++);}});if(objectSetPrototypeOf$1)objectSetPrototypeOf$1(TypedArrayConstructor,TypedArray);TypedArrayConstructorPrototype=TypedArrayConstructor.prototype=objectCreate$1(TypedArrayPrototype);}else if(typedArrayConstructorsRequireWrappers$1){TypedArrayConstructor=wrapper(function(dummy,data,typedArrayOffset,$length){anInstance$1(dummy,TypedArrayConstructor,CONSTRUCTOR_NAME);return inheritIfRequired$1(function(){if(!isObject$1(data))return new NativeTypedArrayConstructor(toIndex$1(data));if(isArrayBuffer(data))return $length!==undefined?new NativeTypedArrayConstructor(data,toOffset$1(typedArrayOffset,BYTES),$length):typedArrayOffset!==undefined?new NativeTypedArrayConstructor(data,toOffset$1(typedArrayOffset,BYTES)):new NativeTypedArrayConstructor(data);if(isTypedArray(data))return fromList(TypedArrayConstructor,data);return typedArrayFrom$1.call(TypedArrayConstructor,data);}(),dummy,TypedArrayConstructor);});if(objectSetPrototypeOf$1)objectSetPrototypeOf$1(TypedArrayConstructor,TypedArray);forEach(getOwnPropertyNames(NativeTypedArrayConstructor),function(key){if(!(key in TypedArrayConstructor)){createNonEnumerableProperty$1(TypedArrayConstructor,key,NativeTypedArrayConstructor[key]);}});TypedArrayConstructor.prototype=TypedArrayConstructorPrototype;}if(TypedArrayConstructorPrototype.constructor!==TypedArrayConstructor){createNonEnumerableProperty$1(TypedArrayConstructorPrototype,'constructor',TypedArrayConstructor);}if(TYPED_ARRAY_TAG){createNonEnumerableProperty$1(TypedArrayConstructorPrototype,TYPED_ARRAY_TAG,CONSTRUCTOR_NAME);}exported[CONSTRUCTOR_NAME]=TypedArrayConstructor;_export$1({global:true,forced:TypedArrayConstructor!=NativeTypedArrayConstructor,sham:!NATIVE_ARRAY_BUFFER_VIEWS},exported);if(!(BYTES_PER_ELEMENT in TypedArrayConstructor)){createNonEnumerableProperty$1(TypedArrayConstructor,BYTES_PER_ELEMENT,BYTES);}if(!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)){createNonEnumerableProperty$1(TypedArrayConstructorPrototype,BYTES_PER_ELEMENT,BYTES);}setSpecies$1(CONSTRUCTOR_NAME);};}else module.exports=function(){/* empty */};});// `Float64Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor$1('Float64',function(init){return function Float64Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});var min$5$1=Math.min;// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
var arrayCopyWithin$1=[].copyWithin||function copyWithin(target/* = 0 */,start/* = 0, end = @length */){var O=toObject$1(this);var len=toLength$1(O.length);var to=toAbsoluteIndex$1(target,len);var from=toAbsoluteIndex$1(start,len);var end=arguments.length>2?arguments[2]:undefined;var count=min$5$1((end===undefined?len:toAbsoluteIndex$1(end,len))-from,len-to);var inc=1;if(from<to&&to<from+count){inc=-1;from+=count-1;to+=count-1;}while(count-->0){if(from in O)O[to]=O[from];else delete O[to];to+=inc;from+=inc;}return O;};var aTypedArray$1$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$1$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod$1$1('copyWithin',function copyWithin(target,start/* , end */){return arrayCopyWithin$1.call(aTypedArray$1$1(this),target,start,arguments.length>2?arguments[2]:undefined);});var $every$2=arrayIteration$1.every;var aTypedArray$2$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$2$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod$2$1('every',function every(callbackfn/* , thisArg */){return $every$2(aTypedArray$2$1(this),callbackfn,arguments.length>1?arguments[1]:undefined);});var aTypedArray$3$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$3$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod$3$1('fill',function fill(value/* , start, end */){return arrayFill$1.apply(aTypedArray$3$1(this),arguments);});var $filter$2=arrayIteration$1.filter;var aTypedArray$4$1=arrayBufferViewCore$1.aTypedArray;var aTypedArrayConstructor$2$1=arrayBufferViewCore$1.aTypedArrayConstructor;var exportTypedArrayMethod$4$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod$4$1('filter',function filter(callbackfn/* , thisArg */){var list=$filter$2(aTypedArray$4$1(this),callbackfn,arguments.length>1?arguments[1]:undefined);var C=speciesConstructor$1(this,this.constructor);var index=0;var length=list.length;var result=new(aTypedArrayConstructor$2$1(C))(length);while(length>index){result[index]=list[index++];}return result;});var $find$2=arrayIteration$1.find;var aTypedArray$5$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$5$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod$5$1('find',function find(predicate/* , thisArg */){return $find$2(aTypedArray$5$1(this),predicate,arguments.length>1?arguments[1]:undefined);});var $findIndex$2=arrayIteration$1.findIndex;var aTypedArray$6$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$6$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod$6$1('findIndex',function findIndex(predicate/* , thisArg */){return $findIndex$2(aTypedArray$6$1(this),predicate,arguments.length>1?arguments[1]:undefined);});var $forEach$1$1=arrayIteration$1.forEach;var aTypedArray$7$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$7$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod$7$1('forEach',function forEach(callbackfn/* , thisArg */){$forEach$1$1(aTypedArray$7$1(this),callbackfn,arguments.length>1?arguments[1]:undefined);});var $includes$2=arrayIncludes$1.includes;var aTypedArray$8$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$8$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod$8$1('includes',function includes(searchElement/* , fromIndex */){return $includes$2(aTypedArray$8$1(this),searchElement,arguments.length>1?arguments[1]:undefined);});var $indexOf$1$1=arrayIncludes$1.indexOf;var aTypedArray$9$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$9$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod$9$1('indexOf',function indexOf(searchElement/* , fromIndex */){return $indexOf$1$1(aTypedArray$9$1(this),searchElement,arguments.length>1?arguments[1]:undefined);});var ITERATOR$5$1=wellKnownSymbol$1('iterator');var Uint8Array$2=global_1$1.Uint8Array;var arrayValues$1=es_array_iterator$1.values;var arrayKeys$1=es_array_iterator$1.keys;var arrayEntries$1=es_array_iterator$1.entries;var aTypedArray$a$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$a$1=arrayBufferViewCore$1.exportTypedArrayMethod;var nativeTypedArrayIterator$1=Uint8Array$2&&Uint8Array$2.prototype[ITERATOR$5$1];var CORRECT_ITER_NAME$1=!!nativeTypedArrayIterator$1&&(nativeTypedArrayIterator$1.name=='values'||nativeTypedArrayIterator$1.name==undefined);var typedArrayValues$1=function values(){return arrayValues$1.call(aTypedArray$a$1(this));};// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod$a$1('entries',function entries(){return arrayEntries$1.call(aTypedArray$a$1(this));});// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod$a$1('keys',function keys(){return arrayKeys$1.call(aTypedArray$a$1(this));});// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod$a$1('values',typedArrayValues$1,!CORRECT_ITER_NAME$1);// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod$a$1(ITERATOR$5$1,typedArrayValues$1,!CORRECT_ITER_NAME$1);var aTypedArray$b$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$b$1=arrayBufferViewCore$1.exportTypedArrayMethod;var $join$1=[].join;// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod$b$1('join',function join(separator){return $join$1.apply(aTypedArray$b$1(this),arguments);});var aTypedArray$c$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$c$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod$c$1('lastIndexOf',function lastIndexOf(searchElement/* , fromIndex */){return arrayLastIndexOf$1.apply(aTypedArray$c$1(this),arguments);});var $map$1$1=arrayIteration$1.map;var aTypedArray$d$1=arrayBufferViewCore$1.aTypedArray;var aTypedArrayConstructor$3$1=arrayBufferViewCore$1.aTypedArrayConstructor;var exportTypedArrayMethod$d$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod$d$1('map',function map(mapfn/* , thisArg */){return $map$1$1(aTypedArray$d$1(this),mapfn,arguments.length>1?arguments[1]:undefined,function(O,length){return new(aTypedArrayConstructor$3$1(speciesConstructor$1(O,O.constructor)))(length);});});// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod$4$1=function createMethod$4(IS_RIGHT){return function(that,callbackfn,argumentsLength,memo){aFunction$1$1(callbackfn);var O=toObject$1(that);var self=indexedObject$1(O);var length=toLength$1(O.length);var index=IS_RIGHT?length-1:0;var i=IS_RIGHT?-1:1;if(argumentsLength<2)while(true){if(index in self){memo=self[index];index+=i;break;}index+=i;if(IS_RIGHT?index<0:length<=index){throw TypeError('Reduce of empty array with no initial value');}}for(;IS_RIGHT?index>=0:length>index;index+=i){if(index in self){memo=callbackfn(memo,self[index],index,O);}}return memo;};};var arrayReduce$1={// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
left:createMethod$4$1(false),// `Array.prototype.reduceRight` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
right:createMethod$4$1(true)};var $reduce$2=arrayReduce$1.left;var aTypedArray$e$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$e$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod$e$1('reduce',function reduce(callbackfn/* , initialValue */){return $reduce$2(aTypedArray$e$1(this),callbackfn,arguments.length,arguments.length>1?arguments[1]:undefined);});var $reduceRight$1=arrayReduce$1.right;var aTypedArray$f$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$f$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod$f$1('reduceRight',function reduceRight(callbackfn/* , initialValue */){return $reduceRight$1(aTypedArray$f$1(this),callbackfn,arguments.length,arguments.length>1?arguments[1]:undefined);});var aTypedArray$g$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$g$1=arrayBufferViewCore$1.exportTypedArrayMethod;var floor$3$1=Math.floor;// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod$g$1('reverse',function reverse(){var that=this;var length=aTypedArray$g$1(that).length;var middle=floor$3$1(length/2);var index=0;var value;while(index<middle){value=that[index];that[index++]=that[--length];that[length]=value;}return that;});var aTypedArray$h$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$h$1=arrayBufferViewCore$1.exportTypedArrayMethod;var FORCED$5$1=fails$1(function(){// eslint-disable-next-line no-undef
new Int8Array(1).set({});});// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod$h$1('set',function set(arrayLike/* , offset */){aTypedArray$h$1(this);var offset=toOffset$1(arguments.length>1?arguments[1]:undefined,1);var length=this.length;var src=toObject$1(arrayLike);var len=toLength$1(src.length);var index=0;if(len+offset>length)throw RangeError('Wrong length');while(index<len){this[offset+index]=src[index++];}},FORCED$5$1);var aTypedArray$i$1=arrayBufferViewCore$1.aTypedArray;var aTypedArrayConstructor$4$1=arrayBufferViewCore$1.aTypedArrayConstructor;var exportTypedArrayMethod$i$1=arrayBufferViewCore$1.exportTypedArrayMethod;var $slice$2=[].slice;var FORCED$6$1=fails$1(function(){// eslint-disable-next-line no-undef
new Int8Array(1).slice();});// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod$i$1('slice',function slice(start,end){var list=$slice$2.call(aTypedArray$i$1(this),start,end);var C=speciesConstructor$1(this,this.constructor);var index=0;var length=list.length;var result=new(aTypedArrayConstructor$4$1(C))(length);while(length>index){result[index]=list[index++];}return result;},FORCED$6$1);var $some$2=arrayIteration$1.some;var aTypedArray$j$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$j$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod$j$1('some',function some(callbackfn/* , thisArg */){return $some$2(aTypedArray$j$1(this),callbackfn,arguments.length>1?arguments[1]:undefined);});var aTypedArray$k$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$k$1=arrayBufferViewCore$1.exportTypedArrayMethod;var $sort$1=[].sort;// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod$k$1('sort',function sort(comparefn){return $sort$1.call(aTypedArray$k$1(this),comparefn);});var aTypedArray$l$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$l$1=arrayBufferViewCore$1.exportTypedArrayMethod;// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod$l$1('subarray',function subarray(begin,end){var O=aTypedArray$l$1(this);var length=O.length;var beginIndex=toAbsoluteIndex$1(begin,length);return new(speciesConstructor$1(O,O.constructor))(O.buffer,O.byteOffset+beginIndex*O.BYTES_PER_ELEMENT,toLength$1((end===undefined?length:toAbsoluteIndex$1(end,length))-beginIndex));});var Int8Array$3$1=global_1$1.Int8Array;var aTypedArray$m$1=arrayBufferViewCore$1.aTypedArray;var exportTypedArrayMethod$m$1=arrayBufferViewCore$1.exportTypedArrayMethod;var $toLocaleString$1=[].toLocaleString;var $slice$1$1=[].slice;// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG$1=!!Int8Array$3$1&&fails$1(function(){$toLocaleString$1.call(new Int8Array$3$1(1));});var FORCED$7$1=fails$1(function(){return [1,2].toLocaleString()!=new Int8Array$3$1([1,2]).toLocaleString();})||!fails$1(function(){Int8Array$3$1.prototype.toLocaleString.call([1,2]);});// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod$m$1('toLocaleString',function toLocaleString(){return $toLocaleString$1.apply(TO_LOCALE_STRING_BUG$1?$slice$1$1.call(aTypedArray$m$1(this)):aTypedArray$m$1(this),arguments);},FORCED$7$1);var exportTypedArrayMethod$n$1=arrayBufferViewCore$1.exportTypedArrayMethod;var Uint8Array$1$1=global_1$1.Uint8Array;var Uint8ArrayPrototype$1=Uint8Array$1$1&&Uint8Array$1$1.prototype||{};var arrayToString$1=[].toString;var arrayJoin$1=[].join;if(fails$1(function(){arrayToString$1.call({});})){arrayToString$1=function toString(){return arrayJoin$1.call(this);};}var IS_NOT_ARRAY_METHOD$1=Uint8ArrayPrototype$1.toString!=arrayToString$1;// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod$n$1('toString',arrayToString$1,IS_NOT_ARRAY_METHOD$1);// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables$1={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0};for(var COLLECTION_NAME$2 in domIterables$1){var Collection$2=global_1$1[COLLECTION_NAME$2];var CollectionPrototype$2=Collection$2&&Collection$2.prototype;// some Chrome versions have non-configurable methods on DOMTokenList
if(CollectionPrototype$2&&CollectionPrototype$2.forEach!==arrayForEach$1)try{createNonEnumerableProperty$1(CollectionPrototype$2,'forEach',arrayForEach$1);}catch(error){CollectionPrototype$2.forEach=arrayForEach$1;}}var ITERATOR$6$1=wellKnownSymbol$1('iterator');var TO_STRING_TAG$4$1=wellKnownSymbol$1('toStringTag');var ArrayValues$1=es_array_iterator$1.values;for(var COLLECTION_NAME$1$1 in domIterables$1){var Collection$1$1=global_1$1[COLLECTION_NAME$1$1];var CollectionPrototype$1$1=Collection$1$1&&Collection$1$1.prototype;if(CollectionPrototype$1$1){// some Chrome versions have non-configurable methods on DOMTokenList
if(CollectionPrototype$1$1[ITERATOR$6$1]!==ArrayValues$1)try{createNonEnumerableProperty$1(CollectionPrototype$1$1,ITERATOR$6$1,ArrayValues$1);}catch(error){CollectionPrototype$1$1[ITERATOR$6$1]=ArrayValues$1;}if(!CollectionPrototype$1$1[TO_STRING_TAG$4$1]){createNonEnumerableProperty$1(CollectionPrototype$1$1,TO_STRING_TAG$4$1,COLLECTION_NAME$1$1);}if(domIterables$1[COLLECTION_NAME$1$1])for(var METHOD_NAME$1 in es_array_iterator$1){// some Chrome versions have non-configurable methods on DOMTokenList
if(CollectionPrototype$1$1[METHOD_NAME$1]!==es_array_iterator$1[METHOD_NAME$1])try{createNonEnumerableProperty$1(CollectionPrototype$1$1,METHOD_NAME$1,es_array_iterator$1[METHOD_NAME$1]);}catch(error){CollectionPrototype$1$1[METHOD_NAME$1]=es_array_iterator$1[METHOD_NAME$1];}}}}var ITERATOR$7$1=wellKnownSymbol$1('iterator');var nativeUrl$1=!fails$1(function(){var url=new URL('b?a=1&b=2&c=3','http://a');var searchParams=url.searchParams;var result='';url.pathname='c%20d';searchParams.forEach(function(value,key){searchParams['delete']('b');result+=key+value;});return isPure$1&&!url.toJSON||!searchParams.sort||url.href!=='http://a/c%20d?a=1&c=3'||searchParams.get('c')!=='3'||String(new URLSearchParams('?a=1'))!=='a=1'||!searchParams[ITERATOR$7$1]// throws in Edge
||new URL('https://a@b').username!=='a'||new URLSearchParams(new URLSearchParams('a=b')).get('a')!=='b'// not punycoded in Edge
||new URL('http://ÑÐµÑÑ').host!=='xn--e1aybc'// not escaped in Chrome 62-
||new URL('http://a#Ð±').hash!=='#%D0%B1'// fails in Chrome 66-
||result!=='a1c3'// throws in Safari
||new URL('http://x',undefined).host!=='x';});var nativeAssign$1=Object.assign;var defineProperty$7$1=Object.defineProperty;// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
var objectAssign$1=!nativeAssign$1||fails$1(function(){// should have correct order of operations (Edge bug)
if(descriptors$1&&nativeAssign$1({b:1},nativeAssign$1(defineProperty$7$1({},'a',{enumerable:true,get:function get(){defineProperty$7$1(this,'b',{value:3,enumerable:false});}}),{b:2})).b!==1)return true;// should work with symbols and should have deterministic property order (V8 bug)
var A={};var B={};// eslint-disable-next-line no-undef
var symbol=Symbol();var alphabet='abcdefghijklmnopqrst';A[symbol]=7;alphabet.split('').forEach(function(chr){B[chr]=chr;});return nativeAssign$1({},A)[symbol]!=7||objectKeys$1(nativeAssign$1({},B)).join('')!=alphabet;})?function assign(target,source){// eslint-disable-line no-unused-vars
var T=toObject$1(target);var argumentsLength=arguments.length;var index=1;var getOwnPropertySymbols=objectGetOwnPropertySymbols$1.f;var propertyIsEnumerable=objectPropertyIsEnumerable$1.f;while(argumentsLength>index){var S=indexedObject$1(arguments[index++]);var keys=getOwnPropertySymbols?objectKeys$1(S).concat(getOwnPropertySymbols(S)):objectKeys$1(S);var length=keys.length;var j=0;var key;while(length>j){key=keys[j++];if(!descriptors$1||propertyIsEnumerable.call(S,key))T[key]=S[key];}}return T;}:nativeAssign$1;// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
var arrayFrom$1=function from(arrayLike/* , mapfn = undefined, thisArg = undefined */){var O=toObject$1(arrayLike);var C=typeof this=='function'?this:Array;var argumentsLength=arguments.length;var mapfn=argumentsLength>1?arguments[1]:undefined;var mapping=mapfn!==undefined;var iteratorMethod=getIteratorMethod$1(O);var index=0;var length,result,step,iterator,next,value;if(mapping)mapfn=functionBindContext$1(mapfn,argumentsLength>2?arguments[2]:undefined,2);// if the target is not iterable or it's an array with the default iterator - use a simple case
if(iteratorMethod!=undefined&&!(C==Array&&isArrayIteratorMethod$1(iteratorMethod))){iterator=iteratorMethod.call(O);next=iterator.next;result=new C();for(;!(step=next.call(iterator)).done;index++){value=mapping?callWithSafeIterationClosing$1(iterator,mapfn,[step.value,index],true):step.value;createProperty$1(result,index,value);}}else {length=toLength$1(O.length);result=new C(length);for(;length>index;index++){value=mapping?mapfn(O[index],index):O[index];createProperty$1(result,index,value);}}result.length=index;return result;};// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var maxInt$1=2147483647;// aka. 0x7FFFFFFF or 2^31-1
var base$1=36;var tMin$1=1;var tMax$1=26;var skew$1=38;var damp$1=700;var initialBias$1=72;var initialN$1=128;// 0x80
var delimiter$1='-';// '\x2D'
var regexNonASCII$1=/[^\0-\u007E]/;// non-ASCII chars
var regexSeparators$1=/[.\u3002\uFF0E\uFF61]/g;// RFC 3490 separators
var OVERFLOW_ERROR$1='Overflow: input needs wider integers to process';var baseMinusTMin$1=base$1-tMin$1;var floor$4$1=Math.floor;var stringFromCharCode$1=String.fromCharCode;/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */var ucs2decode$1=function ucs2decode(string){var output=[];var counter=0;var length=string.length;while(counter<length){var value=string.charCodeAt(counter++);if(value>=0xD800&&value<=0xDBFF&&counter<length){// It's a high surrogate, and there is a next character.
var extra=string.charCodeAt(counter++);if((extra&0xFC00)==0xDC00){// Low surrogate.
output.push(((value&0x3FF)<<10)+(extra&0x3FF)+0x10000);}else {// It's an unmatched surrogate; only append this code unit, in case the
// next code unit is the high surrogate of a surrogate pair.
output.push(value);counter--;}}else {output.push(value);}}return output;};/**
 * Converts a digit/integer into a basic code point.
 */var digitToBasic$1=function digitToBasic(digit){//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return digit+22+75*(digit<26);};/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */var adapt$1=function adapt(delta,numPoints,firstTime){var k=0;delta=firstTime?floor$4$1(delta/damp$1):delta>>1;delta+=floor$4$1(delta/numPoints);for(;delta>baseMinusTMin$1*tMax$1>>1;k+=base$1){delta=floor$4$1(delta/baseMinusTMin$1);}return floor$4$1(k+(baseMinusTMin$1+1)*delta/(delta+skew$1));};/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */ // eslint-disable-next-line  max-statements
var encode$1=function encode(input){var output=[];// Convert the input in UCS-2 to an array of Unicode code points.
input=ucs2decode$1(input);// Cache the length.
var inputLength=input.length;// Initialize the state.
var n=initialN$1;var delta=0;var bias=initialBias$1;var i,currentValue;// Handle the basic code points.
for(i=0;i<input.length;i++){currentValue=input[i];if(currentValue<0x80){output.push(stringFromCharCode$1(currentValue));}}var basicLength=output.length;// number of basic code points.
var handledCPCount=basicLength;// number of code points that have been handled;
// Finish the basic string with a delimiter unless it's empty.
if(basicLength){output.push(delimiter$1);}// Main encoding loop:
while(handledCPCount<inputLength){// All non-basic code points < n have been handled already. Find the next larger one:
var m=maxInt$1;for(i=0;i<input.length;i++){currentValue=input[i];if(currentValue>=n&&currentValue<m){m=currentValue;}}// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
var handledCPCountPlusOne=handledCPCount+1;if(m-n>floor$4$1((maxInt$1-delta)/handledCPCountPlusOne)){throw RangeError(OVERFLOW_ERROR$1);}delta+=(m-n)*handledCPCountPlusOne;n=m;for(i=0;i<input.length;i++){currentValue=input[i];if(currentValue<n&&++delta>maxInt$1){throw RangeError(OVERFLOW_ERROR$1);}if(currentValue==n){// Represent delta as a generalized variable-length integer.
var q=delta;for(var k=base$1;;/* no condition */k+=base$1){var t=k<=bias?tMin$1:k>=bias+tMax$1?tMax$1:k-bias;if(q<t)break;var qMinusT=q-t;var baseMinusT=base$1-t;output.push(stringFromCharCode$1(digitToBasic$1(t+qMinusT%baseMinusT)));q=floor$4$1(qMinusT/baseMinusT);}output.push(stringFromCharCode$1(digitToBasic$1(q)));bias=adapt$1(delta,handledCPCountPlusOne,handledCPCount==basicLength);delta=0;++handledCPCount;}}++delta;++n;}return output.join('');};var stringPunycodeToAscii$1=function stringPunycodeToAscii(input){var encoded=[];var labels=input.toLowerCase().replace(regexSeparators$1,".").split('.');var i,label;for(i=0;i<labels.length;i++){label=labels[i];encoded.push(regexNonASCII$1.test(label)?'xn--'+encode$1(label):label);}return encoded.join('.');};var getIterator$1=function getIterator(it){var iteratorMethod=getIteratorMethod$1(it);if(typeof iteratorMethod!='function'){throw TypeError(String(it)+' is not iterable');}return anObject$1(iteratorMethod.call(it));};// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
var $fetch$1$1=getBuiltIn$1('fetch');var Headers$1=getBuiltIn$1('Headers');var ITERATOR$8$1=wellKnownSymbol$1('iterator');var URL_SEARCH_PARAMS$1='URLSearchParams';var URL_SEARCH_PARAMS_ITERATOR$1=URL_SEARCH_PARAMS$1+'Iterator';var setInternalState$5$1=internalState$1.set;var getInternalParamsState$1=internalState$1.getterFor(URL_SEARCH_PARAMS$1);var getInternalIteratorState$1=internalState$1.getterFor(URL_SEARCH_PARAMS_ITERATOR$1);var plus$1=/\+/g;var sequences$1=Array(4);var percentSequence$1=function percentSequence(bytes){return sequences$1[bytes-1]||(sequences$1[bytes-1]=RegExp('((?:%[\\da-f]{2}){'+bytes+'})','gi'));};var percentDecode$1=function percentDecode(sequence){try{return decodeURIComponent(sequence);}catch(error){return sequence;}};var deserialize$1=function deserialize(it){var result=it.replace(plus$1,' ');var bytes=4;try{return decodeURIComponent(result);}catch(error){while(bytes){result=result.replace(percentSequence$1(bytes--),percentDecode$1);}return result;}};var find$1=/[!'()~]|%20/g;var replace$1={'!':'%21',"'":'%27','(':'%28',')':'%29','~':'%7E','%20':'+'};var replacer$1=function replacer(match){return replace$1[match];};var serialize$1=function serialize(it){return encodeURIComponent(it).replace(find$1,replacer$1);};var parseSearchParams$1=function parseSearchParams(result,query){if(query){var attributes=query.split('&');var index=0;var attribute,entry;while(index<attributes.length){attribute=attributes[index++];if(attribute.length){entry=attribute.split('=');result.push({key:deserialize$1(entry.shift()),value:deserialize$1(entry.join('='))});}}}};var updateSearchParams$1=function updateSearchParams(query){this.entries.length=0;parseSearchParams$1(this.entries,query);};var validateArgumentsLength$1=function validateArgumentsLength(passed,required){if(passed<required)throw TypeError('Not enough arguments');};var URLSearchParamsIterator$1=createIteratorConstructor$1(function Iterator(params,kind){setInternalState$5$1(this,{type:URL_SEARCH_PARAMS_ITERATOR$1,iterator:getIterator$1(getInternalParamsState$1(params).entries),kind:kind});},'Iterator',function next(){var state=getInternalIteratorState$1(this);var kind=state.kind;var step=state.iterator.next();var entry=step.value;if(!step.done){step.value=kind==='keys'?entry.key:kind==='values'?entry.value:[entry.key,entry.value];}return step;});// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor$1=function URLSearchParams()/* init */{anInstance$1(this,URLSearchParamsConstructor$1,URL_SEARCH_PARAMS$1);var init=arguments.length>0?arguments[0]:undefined;var that=this;var entries=[];var iteratorMethod,iterator,next,step,entryIterator,entryNext,first,second,key;setInternalState$5$1(that,{type:URL_SEARCH_PARAMS$1,entries:entries,updateURL:function updateURL(){/* empty */},updateSearchParams:updateSearchParams$1});if(init!==undefined){if(isObject$1(init)){iteratorMethod=getIteratorMethod$1(init);if(typeof iteratorMethod==='function'){iterator=iteratorMethod.call(init);next=iterator.next;while(!(step=next.call(iterator)).done){entryIterator=getIterator$1(anObject$1(step.value));entryNext=entryIterator.next;if((first=entryNext.call(entryIterator)).done||(second=entryNext.call(entryIterator)).done||!entryNext.call(entryIterator).done)throw TypeError('Expected sequence with length 2');entries.push({key:first.value+'',value:second.value+''});}}else for(key in init){if(has$2(init,key))entries.push({key:key,value:init[key]+''});}}else {parseSearchParams$1(entries,typeof init==='string'?init.charAt(0)==='?'?init.slice(1):init:init+'');}}};var URLSearchParamsPrototype$1=URLSearchParamsConstructor$1.prototype;redefineAll$1(URLSearchParamsPrototype$1,{// `URLSearchParams.prototype.appent` method
// https://url.spec.whatwg.org/#dom-urlsearchparams-append
append:function append(name,value){validateArgumentsLength$1(arguments.length,2);var state=getInternalParamsState$1(this);state.entries.push({key:name+'',value:value+''});state.updateURL();},// `URLSearchParams.prototype.delete` method
// https://url.spec.whatwg.org/#dom-urlsearchparams-delete
'delete':function _delete(name){validateArgumentsLength$1(arguments.length,1);var state=getInternalParamsState$1(this);var entries=state.entries;var key=name+'';var index=0;while(index<entries.length){if(entries[index].key===key)entries.splice(index,1);else index++;}state.updateURL();},// `URLSearchParams.prototype.get` method
// https://url.spec.whatwg.org/#dom-urlsearchparams-get
get:function get(name){validateArgumentsLength$1(arguments.length,1);var entries=getInternalParamsState$1(this).entries;var key=name+'';var index=0;for(;index<entries.length;index++){if(entries[index].key===key)return entries[index].value;}return null;},// `URLSearchParams.prototype.getAll` method
// https://url.spec.whatwg.org/#dom-urlsearchparams-getall
getAll:function getAll(name){validateArgumentsLength$1(arguments.length,1);var entries=getInternalParamsState$1(this).entries;var key=name+'';var result=[];var index=0;for(;index<entries.length;index++){if(entries[index].key===key)result.push(entries[index].value);}return result;},// `URLSearchParams.prototype.has` method
// https://url.spec.whatwg.org/#dom-urlsearchparams-has
has:function has(name){validateArgumentsLength$1(arguments.length,1);var entries=getInternalParamsState$1(this).entries;var key=name+'';var index=0;while(index<entries.length){if(entries[index++].key===key)return true;}return false;},// `URLSearchParams.prototype.set` method
// https://url.spec.whatwg.org/#dom-urlsearchparams-set
set:function set(name,value){validateArgumentsLength$1(arguments.length,1);var state=getInternalParamsState$1(this);var entries=state.entries;var found=false;var key=name+'';var val=value+'';var index=0;var entry;for(;index<entries.length;index++){entry=entries[index];if(entry.key===key){if(found)entries.splice(index--,1);else {found=true;entry.value=val;}}}if(!found)entries.push({key:key,value:val});state.updateURL();},// `URLSearchParams.prototype.sort` method
// https://url.spec.whatwg.org/#dom-urlsearchparams-sort
sort:function sort(){var state=getInternalParamsState$1(this);var entries=state.entries;// Array#sort is not stable in some engines
var slice=entries.slice();var entry,entriesIndex,sliceIndex;entries.length=0;for(sliceIndex=0;sliceIndex<slice.length;sliceIndex++){entry=slice[sliceIndex];for(entriesIndex=0;entriesIndex<sliceIndex;entriesIndex++){if(entries[entriesIndex].key>entry.key){entries.splice(entriesIndex,0,entry);break;}}if(entriesIndex===sliceIndex)entries.push(entry);}state.updateURL();},// `URLSearchParams.prototype.forEach` method
forEach:function forEach(callback/* , thisArg */){var entries=getInternalParamsState$1(this).entries;var boundFunction=functionBindContext$1(callback,arguments.length>1?arguments[1]:undefined,3);var index=0;var entry;while(index<entries.length){entry=entries[index++];boundFunction(entry.value,entry.key,this);}},// `URLSearchParams.prototype.keys` method
keys:function keys(){return new URLSearchParamsIterator$1(this,'keys');},// `URLSearchParams.prototype.values` method
values:function values(){return new URLSearchParamsIterator$1(this,'values');},// `URLSearchParams.prototype.entries` method
entries:function entries(){return new URLSearchParamsIterator$1(this,'entries');}},{enumerable:true});// `URLSearchParams.prototype[@@iterator]` method
redefine$1(URLSearchParamsPrototype$1,ITERATOR$8$1,URLSearchParamsPrototype$1.entries);// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine$1(URLSearchParamsPrototype$1,'toString',function toString(){var entries=getInternalParamsState$1(this).entries;var result=[];var index=0;var entry;while(index<entries.length){entry=entries[index++];result.push(serialize$1(entry.key)+'='+serialize$1(entry.value));}return result.join('&');},{enumerable:true});setToStringTag$1(URLSearchParamsConstructor$1,URL_SEARCH_PARAMS$1);_export$1({global:true,forced:!nativeUrl$1},{URLSearchParams:URLSearchParamsConstructor$1});// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
// https://github.com/zloirock/core-js/issues/674
if(!nativeUrl$1&&typeof $fetch$1$1=='function'&&typeof Headers$1=='function'){_export$1({global:true,enumerable:true,forced:true},{fetch:function fetch(input/* , init */){var args=[input];var init,body,headers;if(arguments.length>1){init=arguments[1];if(isObject$1(init)){body=init.body;if(classof$1(body)===URL_SEARCH_PARAMS$1){headers=init.headers?new Headers$1(init.headers):new Headers$1();if(!headers.has('content-type')){headers.set('content-type','application/x-www-form-urlencoded;charset=UTF-8');}init=objectCreate$1(init,{body:createPropertyDescriptor$1(0,String(body)),headers:createPropertyDescriptor$1(0,headers)});}}args.push(init);}return $fetch$1$1.apply(this,args);}});}var web_urlSearchParams$1={URLSearchParams:URLSearchParamsConstructor$1,getState:getInternalParamsState$1};// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
var codeAt$1=stringMultibyte$1.codeAt;var NativeURL$1=global_1$1.URL;var URLSearchParams$1$1=web_urlSearchParams$1.URLSearchParams;var getInternalSearchParamsState$1=web_urlSearchParams$1.getState;var setInternalState$6$1=internalState$1.set;var getInternalURLState$1=internalState$1.getterFor('URL');var floor$5$1=Math.floor;var pow$1$1=Math.pow;var INVALID_AUTHORITY$1='Invalid authority';var INVALID_SCHEME$1='Invalid scheme';var INVALID_HOST$1='Invalid host';var INVALID_PORT$1='Invalid port';var ALPHA$1=/[A-Za-z]/;var ALPHANUMERIC$1=/[\d+-.A-Za-z]/;var DIGIT$1=/\d/;var HEX_START$1=/^(0x|0X)/;var OCT$1=/^[0-7]+$/;var DEC$1=/^\d+$/;var HEX$1=/^[\dA-Fa-f]+$/;// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT$1=/[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT$1=/[\u0000\u0009\u000A\u000D #/:?@[\\]]/;// eslint-disable-next-line no-control-regex
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE$1=/^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;// eslint-disable-next-line no-control-regex
var TAB_AND_NEW_LINE$1=/[\u0009\u000A\u000D]/g;var EOF$1;var parseHost$1=function parseHost(url,input){var result,codePoints,index;if(input.charAt(0)=='['){if(input.charAt(input.length-1)!=']')return INVALID_HOST$1;result=parseIPv6$1(input.slice(1,-1));if(!result)return INVALID_HOST$1;url.host=result;// opaque host
}else if(!isSpecial$1(url)){if(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT$1.test(input))return INVALID_HOST$1;result='';codePoints=arrayFrom$1(input);for(index=0;index<codePoints.length;index++){result+=percentEncode$1(codePoints[index],C0ControlPercentEncodeSet$1);}url.host=result;}else {input=stringPunycodeToAscii$1(input);if(FORBIDDEN_HOST_CODE_POINT$1.test(input))return INVALID_HOST$1;result=parseIPv4$1(input);if(result===null)return INVALID_HOST$1;url.host=result;}};var parseIPv4$1=function parseIPv4(input){var parts=input.split('.');var partsLength,numbers,index,part,radix,number,ipv4;if(parts.length&&parts[parts.length-1]==''){parts.pop();}partsLength=parts.length;if(partsLength>4)return input;numbers=[];for(index=0;index<partsLength;index++){part=parts[index];if(part=='')return input;radix=10;if(part.length>1&&part.charAt(0)=='0'){radix=HEX_START$1.test(part)?16:8;part=part.slice(radix==8?1:2);}if(part===''){number=0;}else {if(!(radix==10?DEC$1:radix==8?OCT$1:HEX$1).test(part))return input;number=parseInt(part,radix);}numbers.push(number);}for(index=0;index<partsLength;index++){number=numbers[index];if(index==partsLength-1){if(number>=pow$1$1(256,5-partsLength))return null;}else if(number>255)return null;}ipv4=numbers.pop();for(index=0;index<numbers.length;index++){ipv4+=numbers[index]*pow$1$1(256,3-index);}return ipv4;};// eslint-disable-next-line max-statements
var parseIPv6$1=function parseIPv6(input){var address=[0,0,0,0,0,0,0,0];var pieceIndex=0;var compress=null;var pointer=0;var value,length,numbersSeen,ipv4Piece,number,swaps,swap;var char=function char(){return input.charAt(pointer);};if(char()==':'){if(input.charAt(1)!=':')return;pointer+=2;pieceIndex++;compress=pieceIndex;}while(char()){if(pieceIndex==8)return;if(char()==':'){if(compress!==null)return;pointer++;pieceIndex++;compress=pieceIndex;continue;}value=length=0;while(length<4&&HEX$1.test(char())){value=value*16+parseInt(char(),16);pointer++;length++;}if(char()=='.'){if(length==0)return;pointer-=length;if(pieceIndex>6)return;numbersSeen=0;while(char()){ipv4Piece=null;if(numbersSeen>0){if(char()=='.'&&numbersSeen<4)pointer++;else return;}if(!DIGIT$1.test(char()))return;while(DIGIT$1.test(char())){number=parseInt(char(),10);if(ipv4Piece===null)ipv4Piece=number;else if(ipv4Piece==0)return;else ipv4Piece=ipv4Piece*10+number;if(ipv4Piece>255)return;pointer++;}address[pieceIndex]=address[pieceIndex]*256+ipv4Piece;numbersSeen++;if(numbersSeen==2||numbersSeen==4)pieceIndex++;}if(numbersSeen!=4)return;break;}else if(char()==':'){pointer++;if(!char())return;}else if(char())return;address[pieceIndex++]=value;}if(compress!==null){swaps=pieceIndex-compress;pieceIndex=7;while(pieceIndex!=0&&swaps>0){swap=address[pieceIndex];address[pieceIndex--]=address[compress+swaps-1];address[compress+--swaps]=swap;}}else if(pieceIndex!=8)return;return address;};var findLongestZeroSequence$1=function findLongestZeroSequence(ipv6){var maxIndex=null;var maxLength=1;var currStart=null;var currLength=0;var index=0;for(;index<8;index++){if(ipv6[index]!==0){if(currLength>maxLength){maxIndex=currStart;maxLength=currLength;}currStart=null;currLength=0;}else {if(currStart===null)currStart=index;++currLength;}}if(currLength>maxLength){maxIndex=currStart;maxLength=currLength;}return maxIndex;};var serializeHost$1=function serializeHost(host){var result,index,compress,ignore0;// ipv4
if(typeof host=='number'){result=[];for(index=0;index<4;index++){result.unshift(host%256);host=floor$5$1(host/256);}return result.join('.');// ipv6
}else if(_typeof(host)=='object'){result='';compress=findLongestZeroSequence$1(host);for(index=0;index<8;index++){if(ignore0&&host[index]===0)continue;if(ignore0)ignore0=false;if(compress===index){result+=index?':':'::';ignore0=true;}else {result+=host[index].toString(16);if(index<7)result+=':';}}return '['+result+']';}return host;};var C0ControlPercentEncodeSet$1={};var fragmentPercentEncodeSet$1=objectAssign$1({},C0ControlPercentEncodeSet$1,{' ':1,'"':1,'<':1,'>':1,'`':1});var pathPercentEncodeSet$1=objectAssign$1({},fragmentPercentEncodeSet$1,{'#':1,'?':1,'{':1,'}':1});var userinfoPercentEncodeSet$1=objectAssign$1({},pathPercentEncodeSet$1,{'/':1,':':1,';':1,'=':1,'@':1,'[':1,'\\':1,']':1,'^':1,'|':1});var percentEncode$1=function percentEncode(char,set){var code=codeAt$1(char,0);return code>0x20&&code<0x7F&&!has$2(set,char)?char:encodeURIComponent(char);};var specialSchemes$1={ftp:21,file:null,http:80,https:443,ws:80,wss:443};var isSpecial$1=function isSpecial(url){return has$2(specialSchemes$1,url.scheme);};var includesCredentials$1=function includesCredentials(url){return url.username!=''||url.password!='';};var cannotHaveUsernamePasswordPort$1=function cannotHaveUsernamePasswordPort(url){return !url.host||url.cannotBeABaseURL||url.scheme=='file';};var isWindowsDriveLetter$1=function isWindowsDriveLetter(string,normalized){var second;return string.length==2&&ALPHA$1.test(string.charAt(0))&&((second=string.charAt(1))==':'||!normalized&&second=='|');};var startsWithWindowsDriveLetter$1=function startsWithWindowsDriveLetter(string){var third;return string.length>1&&isWindowsDriveLetter$1(string.slice(0,2))&&(string.length==2||(third=string.charAt(2))==='/'||third==='\\'||third==='?'||third==='#');};var shortenURLsPath$1=function shortenURLsPath(url){var path=url.path;var pathSize=path.length;if(pathSize&&(url.scheme!='file'||pathSize!=1||!isWindowsDriveLetter$1(path[0],true))){path.pop();}};var isSingleDot$1=function isSingleDot(segment){return segment==='.'||segment.toLowerCase()==='%2e';};var isDoubleDot$1=function isDoubleDot(segment){segment=segment.toLowerCase();return segment==='..'||segment==='%2e.'||segment==='.%2e'||segment==='%2e%2e';};// States:
var SCHEME_START$1={};var SCHEME$1={};var NO_SCHEME$1={};var SPECIAL_RELATIVE_OR_AUTHORITY$1={};var PATH_OR_AUTHORITY$1={};var RELATIVE$1={};var RELATIVE_SLASH$1={};var SPECIAL_AUTHORITY_SLASHES$1={};var SPECIAL_AUTHORITY_IGNORE_SLASHES$1={};var AUTHORITY$1={};var HOST$1={};var HOSTNAME$1={};var PORT$1={};var FILE$1={};var FILE_SLASH$1={};var FILE_HOST$1={};var PATH_START$1={};var PATH$1={};var CANNOT_BE_A_BASE_URL_PATH$1={};var QUERY$1={};var FRAGMENT$1={};// eslint-disable-next-line max-statements
var parseURL$1=function parseURL(url,input,stateOverride,base){var state=stateOverride||SCHEME_START$1;var pointer=0;var buffer='';var seenAt=false;var seenBracket=false;var seenPasswordToken=false;var codePoints,char,bufferCodePoints,failure;if(!stateOverride){url.scheme='';url.username='';url.password='';url.host=null;url.port=null;url.path=[];url.query=null;url.fragment=null;url.cannotBeABaseURL=false;input=input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE$1,'');}input=input.replace(TAB_AND_NEW_LINE$1,'');codePoints=arrayFrom$1(input);while(pointer<=codePoints.length){char=codePoints[pointer];switch(state){case SCHEME_START$1:if(char&&ALPHA$1.test(char)){buffer+=char.toLowerCase();state=SCHEME$1;}else if(!stateOverride){state=NO_SCHEME$1;continue;}else return INVALID_SCHEME$1;break;case SCHEME$1:if(char&&(ALPHANUMERIC$1.test(char)||char=='+'||char=='-'||char=='.')){buffer+=char.toLowerCase();}else if(char==':'){if(stateOverride&&(isSpecial$1(url)!=has$2(specialSchemes$1,buffer)||buffer=='file'&&(includesCredentials$1(url)||url.port!==null)||url.scheme=='file'&&!url.host))return;url.scheme=buffer;if(stateOverride){if(isSpecial$1(url)&&specialSchemes$1[url.scheme]==url.port)url.port=null;return;}buffer='';if(url.scheme=='file'){state=FILE$1;}else if(isSpecial$1(url)&&base&&base.scheme==url.scheme){state=SPECIAL_RELATIVE_OR_AUTHORITY$1;}else if(isSpecial$1(url)){state=SPECIAL_AUTHORITY_SLASHES$1;}else if(codePoints[pointer+1]=='/'){state=PATH_OR_AUTHORITY$1;pointer++;}else {url.cannotBeABaseURL=true;url.path.push('');state=CANNOT_BE_A_BASE_URL_PATH$1;}}else if(!stateOverride){buffer='';state=NO_SCHEME$1;pointer=0;continue;}else return INVALID_SCHEME$1;break;case NO_SCHEME$1:if(!base||base.cannotBeABaseURL&&char!='#')return INVALID_SCHEME$1;if(base.cannotBeABaseURL&&char=='#'){url.scheme=base.scheme;url.path=base.path.slice();url.query=base.query;url.fragment='';url.cannotBeABaseURL=true;state=FRAGMENT$1;break;}state=base.scheme=='file'?FILE$1:RELATIVE$1;continue;case SPECIAL_RELATIVE_OR_AUTHORITY$1:if(char=='/'&&codePoints[pointer+1]=='/'){state=SPECIAL_AUTHORITY_IGNORE_SLASHES$1;pointer++;}else {state=RELATIVE$1;continue;}break;case PATH_OR_AUTHORITY$1:if(char=='/'){state=AUTHORITY$1;break;}else {state=PATH$1;continue;}case RELATIVE$1:url.scheme=base.scheme;if(char==EOF$1){url.username=base.username;url.password=base.password;url.host=base.host;url.port=base.port;url.path=base.path.slice();url.query=base.query;}else if(char=='/'||char=='\\'&&isSpecial$1(url)){state=RELATIVE_SLASH$1;}else if(char=='?'){url.username=base.username;url.password=base.password;url.host=base.host;url.port=base.port;url.path=base.path.slice();url.query='';state=QUERY$1;}else if(char=='#'){url.username=base.username;url.password=base.password;url.host=base.host;url.port=base.port;url.path=base.path.slice();url.query=base.query;url.fragment='';state=FRAGMENT$1;}else {url.username=base.username;url.password=base.password;url.host=base.host;url.port=base.port;url.path=base.path.slice();url.path.pop();state=PATH$1;continue;}break;case RELATIVE_SLASH$1:if(isSpecial$1(url)&&(char=='/'||char=='\\')){state=SPECIAL_AUTHORITY_IGNORE_SLASHES$1;}else if(char=='/'){state=AUTHORITY$1;}else {url.username=base.username;url.password=base.password;url.host=base.host;url.port=base.port;state=PATH$1;continue;}break;case SPECIAL_AUTHORITY_SLASHES$1:state=SPECIAL_AUTHORITY_IGNORE_SLASHES$1;if(char!='/'||buffer.charAt(pointer+1)!='/')continue;pointer++;break;case SPECIAL_AUTHORITY_IGNORE_SLASHES$1:if(char!='/'&&char!='\\'){state=AUTHORITY$1;continue;}break;case AUTHORITY$1:if(char=='@'){if(seenAt)buffer='%40'+buffer;seenAt=true;bufferCodePoints=arrayFrom$1(buffer);for(var i=0;i<bufferCodePoints.length;i++){var codePoint=bufferCodePoints[i];if(codePoint==':'&&!seenPasswordToken){seenPasswordToken=true;continue;}var encodedCodePoints=percentEncode$1(codePoint,userinfoPercentEncodeSet$1);if(seenPasswordToken)url.password+=encodedCodePoints;else url.username+=encodedCodePoints;}buffer='';}else if(char==EOF$1||char=='/'||char=='?'||char=='#'||char=='\\'&&isSpecial$1(url)){if(seenAt&&buffer=='')return INVALID_AUTHORITY$1;pointer-=arrayFrom$1(buffer).length+1;buffer='';state=HOST$1;}else buffer+=char;break;case HOST$1:case HOSTNAME$1:if(stateOverride&&url.scheme=='file'){state=FILE_HOST$1;continue;}else if(char==':'&&!seenBracket){if(buffer=='')return INVALID_HOST$1;failure=parseHost$1(url,buffer);if(failure)return failure;buffer='';state=PORT$1;if(stateOverride==HOSTNAME$1)return;}else if(char==EOF$1||char=='/'||char=='?'||char=='#'||char=='\\'&&isSpecial$1(url)){if(isSpecial$1(url)&&buffer=='')return INVALID_HOST$1;if(stateOverride&&buffer==''&&(includesCredentials$1(url)||url.port!==null))return;failure=parseHost$1(url,buffer);if(failure)return failure;buffer='';state=PATH_START$1;if(stateOverride)return;continue;}else {if(char=='[')seenBracket=true;else if(char==']')seenBracket=false;buffer+=char;}break;case PORT$1:if(DIGIT$1.test(char)){buffer+=char;}else if(char==EOF$1||char=='/'||char=='?'||char=='#'||char=='\\'&&isSpecial$1(url)||stateOverride){if(buffer!=''){var port=parseInt(buffer,10);if(port>0xFFFF)return INVALID_PORT$1;url.port=isSpecial$1(url)&&port===specialSchemes$1[url.scheme]?null:port;buffer='';}if(stateOverride)return;state=PATH_START$1;continue;}else return INVALID_PORT$1;break;case FILE$1:url.scheme='file';if(char=='/'||char=='\\')state=FILE_SLASH$1;else if(base&&base.scheme=='file'){if(char==EOF$1){url.host=base.host;url.path=base.path.slice();url.query=base.query;}else if(char=='?'){url.host=base.host;url.path=base.path.slice();url.query='';state=QUERY$1;}else if(char=='#'){url.host=base.host;url.path=base.path.slice();url.query=base.query;url.fragment='';state=FRAGMENT$1;}else {if(!startsWithWindowsDriveLetter$1(codePoints.slice(pointer).join(''))){url.host=base.host;url.path=base.path.slice();shortenURLsPath$1(url);}state=PATH$1;continue;}}else {state=PATH$1;continue;}break;case FILE_SLASH$1:if(char=='/'||char=='\\'){state=FILE_HOST$1;break;}if(base&&base.scheme=='file'&&!startsWithWindowsDriveLetter$1(codePoints.slice(pointer).join(''))){if(isWindowsDriveLetter$1(base.path[0],true))url.path.push(base.path[0]);else url.host=base.host;}state=PATH$1;continue;case FILE_HOST$1:if(char==EOF$1||char=='/'||char=='\\'||char=='?'||char=='#'){if(!stateOverride&&isWindowsDriveLetter$1(buffer)){state=PATH$1;}else if(buffer==''){url.host='';if(stateOverride)return;state=PATH_START$1;}else {failure=parseHost$1(url,buffer);if(failure)return failure;if(url.host=='localhost')url.host='';if(stateOverride)return;buffer='';state=PATH_START$1;}continue;}else buffer+=char;break;case PATH_START$1:if(isSpecial$1(url)){state=PATH$1;if(char!='/'&&char!='\\')continue;}else if(!stateOverride&&char=='?'){url.query='';state=QUERY$1;}else if(!stateOverride&&char=='#'){url.fragment='';state=FRAGMENT$1;}else if(char!=EOF$1){state=PATH$1;if(char!='/')continue;}break;case PATH$1:if(char==EOF$1||char=='/'||char=='\\'&&isSpecial$1(url)||!stateOverride&&(char=='?'||char=='#')){if(isDoubleDot$1(buffer)){shortenURLsPath$1(url);if(char!='/'&&!(char=='\\'&&isSpecial$1(url))){url.path.push('');}}else if(isSingleDot$1(buffer)){if(char!='/'&&!(char=='\\'&&isSpecial$1(url))){url.path.push('');}}else {if(url.scheme=='file'&&!url.path.length&&isWindowsDriveLetter$1(buffer)){if(url.host)url.host='';buffer=buffer.charAt(0)+':';// normalize windows drive letter
}url.path.push(buffer);}buffer='';if(url.scheme=='file'&&(char==EOF$1||char=='?'||char=='#')){while(url.path.length>1&&url.path[0]===''){url.path.shift();}}if(char=='?'){url.query='';state=QUERY$1;}else if(char=='#'){url.fragment='';state=FRAGMENT$1;}}else {buffer+=percentEncode$1(char,pathPercentEncodeSet$1);}break;case CANNOT_BE_A_BASE_URL_PATH$1:if(char=='?'){url.query='';state=QUERY$1;}else if(char=='#'){url.fragment='';state=FRAGMENT$1;}else if(char!=EOF$1){url.path[0]+=percentEncode$1(char,C0ControlPercentEncodeSet$1);}break;case QUERY$1:if(!stateOverride&&char=='#'){url.fragment='';state=FRAGMENT$1;}else if(char!=EOF$1){if(char=="'"&&isSpecial$1(url))url.query+='%27';else if(char=='#')url.query+='%23';else url.query+=percentEncode$1(char,C0ControlPercentEncodeSet$1);}break;case FRAGMENT$1:if(char!=EOF$1)url.fragment+=percentEncode$1(char,fragmentPercentEncodeSet$1);break;}pointer++;}};// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor$1=function URL(url/* , base */){var that=anInstance$1(this,URLConstructor$1,'URL');var base=arguments.length>1?arguments[1]:undefined;var urlString=String(url);var state=setInternalState$6$1(that,{type:'URL'});var baseState,failure;if(base!==undefined){if(base instanceof URLConstructor$1)baseState=getInternalURLState$1(base);else {failure=parseURL$1(baseState={},String(base));if(failure)throw TypeError(failure);}}failure=parseURL$1(state,urlString,null,baseState);if(failure)throw TypeError(failure);var searchParams=state.searchParams=new URLSearchParams$1$1();var searchParamsState=getInternalSearchParamsState$1(searchParams);searchParamsState.updateSearchParams(state.query);searchParamsState.updateURL=function(){state.query=String(searchParams)||null;};if(!descriptors$1){that.href=serializeURL$1.call(that);that.origin=getOrigin$1.call(that);that.protocol=getProtocol$1.call(that);that.username=getUsername$1.call(that);that.password=getPassword$1.call(that);that.host=getHost$1.call(that);that.hostname=getHostname$1.call(that);that.port=getPort$1.call(that);that.pathname=getPathname$1.call(that);that.search=getSearch$1.call(that);that.searchParams=getSearchParams$1.call(that);that.hash=getHash$1.call(that);}};var URLPrototype$1=URLConstructor$1.prototype;var serializeURL$1=function serializeURL(){var url=getInternalURLState$1(this);var scheme=url.scheme;var username=url.username;var password=url.password;var host=url.host;var port=url.port;var path=url.path;var query=url.query;var fragment=url.fragment;var output=scheme+':';if(host!==null){output+='//';if(includesCredentials$1(url)){output+=username+(password?':'+password:'')+'@';}output+=serializeHost$1(host);if(port!==null)output+=':'+port;}else if(scheme=='file')output+='//';output+=url.cannotBeABaseURL?path[0]:path.length?'/'+path.join('/'):'';if(query!==null)output+='?'+query;if(fragment!==null)output+='#'+fragment;return output;};var getOrigin$1=function getOrigin(){var url=getInternalURLState$1(this);var scheme=url.scheme;var port=url.port;if(scheme=='blob')try{return new URL(scheme.path[0]).origin;}catch(error){return 'null';}if(scheme=='file'||!isSpecial$1(url))return 'null';return scheme+'://'+serializeHost$1(url.host)+(port!==null?':'+port:'');};var getProtocol$1=function getProtocol(){return getInternalURLState$1(this).scheme+':';};var getUsername$1=function getUsername(){return getInternalURLState$1(this).username;};var getPassword$1=function getPassword(){return getInternalURLState$1(this).password;};var getHost$1=function getHost(){var url=getInternalURLState$1(this);var host=url.host;var port=url.port;return host===null?'':port===null?serializeHost$1(host):serializeHost$1(host)+':'+port;};var getHostname$1=function getHostname(){var host=getInternalURLState$1(this).host;return host===null?'':serializeHost$1(host);};var getPort$1=function getPort(){var port=getInternalURLState$1(this).port;return port===null?'':String(port);};var getPathname$1=function getPathname(){var url=getInternalURLState$1(this);var path=url.path;return url.cannotBeABaseURL?path[0]:path.length?'/'+path.join('/'):'';};var getSearch$1=function getSearch(){var query=getInternalURLState$1(this).query;return query?'?'+query:'';};var getSearchParams$1=function getSearchParams(){return getInternalURLState$1(this).searchParams;};var getHash$1=function getHash(){var fragment=getInternalURLState$1(this).fragment;return fragment?'#'+fragment:'';};var accessorDescriptor$1=function accessorDescriptor(getter,setter){return {get:getter,set:setter,configurable:true,enumerable:true};};if(descriptors$1){objectDefineProperties$1(URLPrototype$1,{// `URL.prototype.href` accessors pair
// https://url.spec.whatwg.org/#dom-url-href
href:accessorDescriptor$1(serializeURL$1,function(href){var url=getInternalURLState$1(this);var urlString=String(href);var failure=parseURL$1(url,urlString);if(failure)throw TypeError(failure);getInternalSearchParamsState$1(url.searchParams).updateSearchParams(url.query);}),// `URL.prototype.origin` getter
// https://url.spec.whatwg.org/#dom-url-origin
origin:accessorDescriptor$1(getOrigin$1),// `URL.prototype.protocol` accessors pair
// https://url.spec.whatwg.org/#dom-url-protocol
protocol:accessorDescriptor$1(getProtocol$1,function(protocol){var url=getInternalURLState$1(this);parseURL$1(url,String(protocol)+':',SCHEME_START$1);}),// `URL.prototype.username` accessors pair
// https://url.spec.whatwg.org/#dom-url-username
username:accessorDescriptor$1(getUsername$1,function(username){var url=getInternalURLState$1(this);var codePoints=arrayFrom$1(String(username));if(cannotHaveUsernamePasswordPort$1(url))return;url.username='';for(var i=0;i<codePoints.length;i++){url.username+=percentEncode$1(codePoints[i],userinfoPercentEncodeSet$1);}}),// `URL.prototype.password` accessors pair
// https://url.spec.whatwg.org/#dom-url-password
password:accessorDescriptor$1(getPassword$1,function(password){var url=getInternalURLState$1(this);var codePoints=arrayFrom$1(String(password));if(cannotHaveUsernamePasswordPort$1(url))return;url.password='';for(var i=0;i<codePoints.length;i++){url.password+=percentEncode$1(codePoints[i],userinfoPercentEncodeSet$1);}}),// `URL.prototype.host` accessors pair
// https://url.spec.whatwg.org/#dom-url-host
host:accessorDescriptor$1(getHost$1,function(host){var url=getInternalURLState$1(this);if(url.cannotBeABaseURL)return;parseURL$1(url,String(host),HOST$1);}),// `URL.prototype.hostname` accessors pair
// https://url.spec.whatwg.org/#dom-url-hostname
hostname:accessorDescriptor$1(getHostname$1,function(hostname){var url=getInternalURLState$1(this);if(url.cannotBeABaseURL)return;parseURL$1(url,String(hostname),HOSTNAME$1);}),// `URL.prototype.port` accessors pair
// https://url.spec.whatwg.org/#dom-url-port
port:accessorDescriptor$1(getPort$1,function(port){var url=getInternalURLState$1(this);if(cannotHaveUsernamePasswordPort$1(url))return;port=String(port);if(port=='')url.port=null;else parseURL$1(url,port,PORT$1);}),// `URL.prototype.pathname` accessors pair
// https://url.spec.whatwg.org/#dom-url-pathname
pathname:accessorDescriptor$1(getPathname$1,function(pathname){var url=getInternalURLState$1(this);if(url.cannotBeABaseURL)return;url.path=[];parseURL$1(url,pathname+'',PATH_START$1);}),// `URL.prototype.search` accessors pair
// https://url.spec.whatwg.org/#dom-url-search
search:accessorDescriptor$1(getSearch$1,function(search){var url=getInternalURLState$1(this);search=String(search);if(search==''){url.query=null;}else {if('?'==search.charAt(0))search=search.slice(1);url.query='';parseURL$1(url,search,QUERY$1);}getInternalSearchParamsState$1(url.searchParams).updateSearchParams(url.query);}),// `URL.prototype.searchParams` getter
// https://url.spec.whatwg.org/#dom-url-searchparams
searchParams:accessorDescriptor$1(getSearchParams$1),// `URL.prototype.hash` accessors pair
// https://url.spec.whatwg.org/#dom-url-hash
hash:accessorDescriptor$1(getHash$1,function(hash){var url=getInternalURLState$1(this);hash=String(hash);if(hash==''){url.fragment=null;return;}if('#'==hash.charAt(0))hash=hash.slice(1);url.fragment='';parseURL$1(url,hash,FRAGMENT$1);})});}// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine$1(URLPrototype$1,'toJSON',function toJSON(){return serializeURL$1.call(this);},{enumerable:true});// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine$1(URLPrototype$1,'toString',function toString(){return serializeURL$1.call(this);},{enumerable:true});if(NativeURL$1){var nativeCreateObjectURL$1=NativeURL$1.createObjectURL;var nativeRevokeObjectURL$1=NativeURL$1.revokeObjectURL;// `URL.createObjectURL` method
// https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
// eslint-disable-next-line no-unused-vars
if(nativeCreateObjectURL$1)redefine$1(URLConstructor$1,'createObjectURL',function createObjectURL(blob){return nativeCreateObjectURL$1.apply(NativeURL$1,arguments);});// `URL.revokeObjectURL` method
// https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
// eslint-disable-next-line no-unused-vars
if(nativeRevokeObjectURL$1)redefine$1(URLConstructor$1,'revokeObjectURL',function revokeObjectURL(url){return nativeRevokeObjectURL$1.apply(NativeURL$1,arguments);});}setToStringTag$1(URLConstructor$1,'URL');_export$1({global:true,forced:!nativeUrl$1,sham:!descriptors$1},{URL:URLConstructor$1});function _typeof$1(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof$1=function _typeof(obj){return typeof obj;};}else {_typeof$1=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof$1(obj);}/**
* @name L.gmxUtil
* @namespace
*/var gmxAPIutils={lastMapId:0,debug:function(){var arr=/\bdebug=(\d)\b/.exec(location.search);return arr?Number(arr[1]):false;}(),fromWebMercY:function fromWebMercY(y){return 90*(4*Math.atan(Math.exp(y/gmxAPIutils.rMajor))/Math.PI-1);},newId:function newId(){gmxAPIutils.lastMapId+=1;return '_'+gmxAPIutils.lastMapId;},uniqueGlobalName:function uniqueGlobalName(thing){var id=gmxAPIutils.newId();window[id]=thing;return id;},_apiLoadedFrom:null,apiLoadedFrom:function apiLoadedFrom(scr){if(gmxAPIutils._apiLoadedFrom===null){var str=document.currentScript?document.currentScript.src:gmxAPIutils._searchApiScriptUrl(scr);gmxAPIutils._apiLoadedFrom=str?str.substring(0,str.lastIndexOf('/')):'';}return gmxAPIutils._apiLoadedFrom;},_searchApiScriptUrl:function _searchApiScriptUrl(scr){var scriptRegexp=scr?[new RegExp('\\b'+scr+'\\b')]:[/\bleaflet-geomixer(-\w*)?\.js\b/,/\bgeomixer(-\w*)?\.js\b/];var scripts=document.getElementsByTagName('script');for(var i=0,len=scripts.length;i<len;i++){var src=scripts[i].getAttribute('src');for(var j=0,len1=scriptRegexp.length;j<len1;j++){if(scriptRegexp[j].exec(src)){gmxAPIutils._apiLoadedFrom=src.split('?')[0];break;}}if(gmxAPIutils._apiLoadedFrom){break;}}return gmxAPIutils._apiLoadedFrom||'';},searchScriptAPIKey:function searchScriptAPIKey(){for(var i=0,params=gmxAPIutils._searchApiScriptUrl(),len=params.length;i<len;i++){var parsedParam=params[i].split('=');if(parsedParam[0]==='key'){return parsedParam[1];}}return '';},urlKeys:function urlKeys(url){var pars={},arr=url.split('?');if(arr.length>1){for(var i=0,arr1=arr[1].split('&'),len=arr1.length;i<len;i++){var arr2=arr1[i].split('='),key=arr2[0],val=arr2[1];if(arr2.length<2){val=key;key='_glob';}pars[key]=val;}}return pars;},searchScriptPars:function searchScriptPars(scr){var scriptRegexp=scr?[new RegExp('\\b'+scr+'\\b')]:[/\bleaflet-geomixer(-\w*)?\.js\b/,/\bgeomixer(-\w*)?\.js\b/];var scripts=document.getElementsByTagName('script');for(var i=0,len=scripts.length;i<len;i++){var src=scripts[i].getAttribute('src');for(var j=0,len1=scriptRegexp.length;j<len1;j++){if(scriptRegexp[j].exec(src)){return gmxAPIutils.urlKeys(src);}}}return null;},createWorker:function createWorker(url){// Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Worker-Ð°
return new Promise(function(resolve,reject){if('createImageBitmap'in window&&'Worker'in window){if(location.origin.substr(0,4)==='http'&&url.indexOf(location.origin)===0){resolve(new Worker(url));}else {fetch(url,{mode:'cors'}).then(function(resp){return resp.blob();}).then(function(blob){resolve(new Worker(window.URL.createObjectURL(blob,{type:'application/javascript; charset=utf-8'})));});}}else {reject({error:'Browser don`t support `createImageBitmap` or `Worker`'});}});},isPageHidden:function isPageHidden(){// ÐÐ¸Ð´Ð¸Ð¼Ð¾ÑÑÑ Ð¾ÐºÐ½Ð° Ð±ÑÐ°ÑÐ·ÐµÑÐ°
return document.hidden||document.msHidden||document.webkitHidden||document.mozHidden||false;},normalizeHostname:function normalizeHostname(hostName){if(hostName.indexOf('/')===-1){return hostName;}var parser=document.createElement('a');parser.href=hostName;return parser.host;},getLayerItemFromServer:function getLayerItemFromServer(options){var query=options.query?options.query:'['+options.field+']='+options.value,kosmosnimkiURL=L.gmxUtil.protocol+'//maps.kosmosnimki.ru/',req={WrapStyle:'func',geometry:true,layer:options.layerID,query:query};if(options.border){req.border=options.border;}return gmxAPIutils.requestJSONP(options.url||(window.serverBase||kosmosnimkiURL)+'VectorLayer/Search.ashx',req,options);},getCadastreFeatures:function getCadastreFeatures(options){// example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});
if(options.latlng){var latlng=options.latlng,req={WrapStyle:'func',text:(latlng.lat+' '+latlng.lng).replace(/\./g,','),tolerance:options.tolerance||0};return gmxAPIutils.requestJSONP(options.url||'http://pkk5.rosreestr.ru/api/features/',req,options);}else {return null;}},getFormData:function getFormData(json){var arr=[];for(var key in json){var val=json[key];arr.push(key+'='+(_typeof$1(val)==='object'?JSON.stringify(val):val));}return arr.join('&');},requestLink:function requestLink(url,params,options){options=options||{};return new Promise(function(resolve,reject){var script=null;if(url.indexOf('.css')===-1){script=document.createElement('script');script.setAttribute('charset','UTF-8');var urlParams=L.extend({},params,L.gmx.gmxMapManager.syncParams),paramsStringItems=[];for(var p in urlParams){paramsStringItems.push(p+'='+encodeURIComponent(urlParams[p]));}var src=url+(url.indexOf('?')===-1?'?':'&')+paramsStringItems.join('&'),clearTag=function clearTag(err){L.gmxUtil.loaderStatus(src,true);script.parentNode.removeChild(script);if(err){reject(url);console.warn('Not found script:',url);}else {resolve(url,params,options);}};script.onerror=clearTag;script.onload=function(){clearTag();};L.gmxUtil.loaderStatus(src,null,'vector');script.setAttribute('src',src);}else {script=document.createElement('link');script.rel='stylesheet';script.type='text/css';//link.media = options.media || 'screen';
script.href=url;resolve(url,params,options);}document.getElementsByTagName('head').item(0).appendChild(script);});},/** Sends JSONP requests
   * @memberof L.gmxUtil
   * @param {String} url - request URL
   * @param {Object} params - request params
   * @param {Object} [options] - additional request options
   * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.
     If callbackParamName is set to null, no params will be added (StaticJSONP)
   * @return {Deferred} Promise with server JSON response or with error status
  */requestJSONP:function requestJSONP(url,params,options){options=options||{};var def=new L.gmx.Deferred();var script=document.createElement('script');script.setAttribute('charset','UTF-8');var callbackParamName='callbackParamName'in options?options.callbackParamName:'CallbackName';var urlParams=L.extend({},params,L.gmx.gmxMapManager.syncParams);if(callbackParamName){var callbackName=gmxAPIutils.uniqueGlobalName(function(obj){delete window[callbackName];def.resolve(obj,options);});urlParams[callbackParamName]=callbackName;}var paramsStringItems=[];for(var p in urlParams){paramsStringItems.push(p+'='+encodeURIComponent(urlParams[p]));}var src=url+(url.indexOf('?')===-1?'?':'&')+paramsStringItems.join('&');script.onerror=function(e){def.reject(e);L.gmxUtil.loaderStatus(src,true);script.parentNode.removeChild(script);};script.onload=function(){L.gmxUtil.loaderStatus(src,true);script.parentNode.removeChild(script);};L.gmxUtil.loaderStatus(src,null,'vector');script.setAttribute('src',src);document.getElementsByTagName('head').item(0).appendChild(script);return def;},getXmlHttp:function getXmlHttp(){var xmlhttp;if(typeof XMLHttpRequest!=='undefined'){xmlhttp=new XMLHttpRequest();}else {try{xmlhttp=new window.ActiveXObject('Msxml2.XMLHTTP');}catch(e){try{xmlhttp=new window.ActiveXObject('Microsoft.XMLHTTP');}catch(E){xmlhttp=false;}}}return xmlhttp;},request:function request(ph){// {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}
var xhr=gmxAPIutils.getXmlHttp();if(xhr){xhr.open(ph.type?ph.type:'GET',ph.url,ph.async||false);if(ph.headers){for(var key in ph.headers){xhr.setRequestHeader(key,ph.headers[key]);}}var reqId=L.gmxUtil.loaderStatus(ph.url);if(ph.async){if(ph.withCredentials){xhr.withCredentials=true;}xhr.onreadystatechange=function(){if(xhr.readyState===4){L.gmxUtil.loaderStatus(reqId,true);if(xhr.status===200){ph.callback(xhr.responseText);xhr=null;}else if(ph.onError){ph.onError(xhr);}}};}var params=null;if(ph.params){params=ph.params;var syncParams=L.gmx.gmxMapManager.getSyncParams(true);if(syncParams){params+='&'+syncParams;}}xhr.send(params);if(!ph.async&&xhr.status===200){ph.callback(xhr.responseText);L.gmxUtil.loaderStatus(reqId,true);return xhr.status;}return true;}if(ph.onError){ph.onError({Error:'bad XMLHttpRequest!'});}return false;},tileSizes:[],// Ð Ð°Ð·Ð¼ÐµÑÑ ÑÐ°Ð¹Ð»Ð° Ð¿Ð¾ zoom
getTileNumFromLeaflet:function getTileNumFromLeaflet(tilePoint,zoom){if('z'in tilePoint){zoom=tilePoint.z;}var pz=Math.pow(2,zoom),tx=tilePoint.x%pz+(tilePoint.x<0?pz:0),ty=tilePoint.y%pz+(tilePoint.y<0?pz:0);return {z:zoom,x:tx%pz-pz/2,y:pz/2-1-ty%pz};},getTilePosZoomDelta:function getTilePosZoomDelta(tilePoint,zoomFrom,zoomTo){// Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ ÑÐ¼ÐµÑÐµÐ½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð° Ð½Ð° Ð¼ÐµÐ½ÑÑÐµÐ¼ zoom
var dz=Math.pow(2,zoomFrom-zoomTo),size=256/dz,dx=tilePoint.x%dz,dy=tilePoint.y%dz;return {size:size,zDelta:dz,x:size*dx,y:size*dy};},isItemIntersectBounds:function isItemIntersectBounds(geo,bounds){var type=geo.type,coords=geo.coordinates;if(type==='POLYGON'||type==='Polygon'){coords=[coords];}for(var j=0,len1=coords.length;j<len1;j++){for(var i=0,len=coords[j].length;i<len;i++){if(bounds.clipPolygon(coords[j][i]).length){return true;}}}return false;},geoItemBounds:function geoItemBounds(geo){// get item bounds array by geometry
if(!geo){return {bounds:null,boundsArr:[]};}var type=geo.type,coords=geo.coordinates,b=null,i=0,len=0,bounds=null,boundsArr=[];if(type==='MULTIPOLYGON'||type==='MultiPolygon'){bounds=gmxAPIutils.bounds();for(i=0,len=coords.length;i<len;i++){var arr1=[];for(var j=0,len1=coords[i].length;j<len1;j++){b=gmxAPIutils.bounds(coords[i][j]);arr1.push(b);if(j===0){bounds.extendBounds(b);}}boundsArr.push(arr1);}}else if(type==='POLYGON'||type==='Polygon'){bounds=gmxAPIutils.bounds();for(i=0,len=coords.length;i<len;i++){b=gmxAPIutils.bounds(coords[i]);boundsArr.push(b);if(i===0){bounds.extendBounds(b);}}}else if(type==='POINT'||type==='Point'){bounds=gmxAPIutils.bounds([coords]);}else if(type==='MULTIPOINT'||type==='MultiPoint'){bounds=gmxAPIutils.bounds();for(i=0,len=coords.length;i<len;i++){b=gmxAPIutils.bounds([coords[i]]);bounds.extendBounds(b);}}else if(type==='LINESTRING'||type==='LineString'){bounds=gmxAPIutils.bounds(coords);//boundsArr.push(bounds);
}else if(type==='MULTILINESTRING'||type==='MultiLineString'){bounds=gmxAPIutils.bounds();for(i=0,len=coords.length;i<len;i++){b=gmxAPIutils.bounds(coords[i]);bounds.extendBounds(b);//boundsArr.push(b);
}}return {bounds:bounds,boundsArr:boundsArr};},getUnFlattenGeo:function getUnFlattenGeo(geo){// get unFlatten geometry
var type=geo.type,isLikePolygon=type.indexOf('POLYGON')!==-1||type.indexOf('Polygon')!==-1,coords=geo.coordinates,coordsOut=coords;if(isLikePolygon){coordsOut=[];var isPolygon=type==='POLYGON'||type==='Polygon';if(isPolygon){coords=[coords];}for(var i=0,len=coords.length;i<len;i++){var ring=[];for(var j=0,len1=coords[i].length;j<len1;j++){ring[j]=gmxAPIutils.unFlattenRing(coords[i][j]);}coordsOut.push(ring);}if(isPolygon){coordsOut=coordsOut[0];}}return {type:type,coordinates:coordsOut};},unFlattenRing:function unFlattenRing(arr){if(typeof arr[0]!=='number'){return arr;}var len=arr.length,cnt=0,res=new Array(len/2);for(var i=0;i<len;i+=2){res[cnt++]=[arr[i],arr[i+1]];}return res;},geoFlatten:function geoFlatten(geo){// get flatten geometry
var type=geo.type,isLikePolygon=type.indexOf('POLYGON')!==-1||type.indexOf('Polygon')!==-1,isPolygon=type==='POLYGON'||type==='Polygon',coords=geo.coordinates;if(isLikePolygon){if(isPolygon){coords=[coords];}for(var i=0,len=coords.length;i<len;i++){for(var j=0,len1=coords[i].length;j<len1;j++){coords[i][j]=gmxAPIutils.flattenRing(coords[i][j]);}}}},flattenRing:function flattenRing(arr){var len=arr.length,cnt=0,CurArray=typeof Float64Array==='function'?Float64Array:Array,res=new CurArray(2*len);for(var i=0;i<len;i++){res[cnt++]=arr[i][0];res[cnt++]=arr[i][1];}return res;},/** Check rectangle type by coordinates
   * @memberof L.gmxUtil
   * @param {coordinates} coordinates - geoJSON coordinates data format
   * @return {Boolean}
  */isRectangle:function isRectangle(coords){return coords&&coords[0]&&(coords[0].length===5||coords[0].length===4)&&(coords[0][0][0]===coords[0][1][0]||coords[0][0][1]===coords[0][1][1])&&(coords[0][1][0]===coords[0][2][0]||coords[0][1][1]===coords[0][2][1])&&(coords[0][2][0]===coords[0][3][0]||coords[0][2][1]===coords[0][3][1])&&(coords[0][3][0]===coords[0][0][0]||coords[0][3][1]===coords[0][0][1]);},/** Get bounds from geometry
   * @memberof L.gmxUtil
   * @param {geometry} geometry - Geomixer or geoJSON data format
   * @return {Object} bounds
  */getGeometryBounds:function getGeometryBounds(geo){var pt=gmxAPIutils.geoItemBounds(geo);return pt.bounds;},getMarkerPolygon:function getMarkerPolygon(bounds,dx,dy){var x=(bounds.min.x+bounds.max.x)/2,y=(bounds.min.y+bounds.max.y)/2;return [[x-dx,y-dy],[x-dx,y+dy],[x+dx,y+dy],[x+dx,y-dy],[x-dx,y-dy]];},getQuicklookPointsFromProperties:function getQuicklookPointsFromProperties(pArr,gmx){var indexes=gmx.tileAttributeIndexes;var points={x1:gmxAPIutils.getPropItem(gmx.quicklookX1||('x1'in indexes?'x1':'X1'),pArr,indexes)||0,y1:gmxAPIutils.getPropItem(gmx.quicklookY1||('y1'in indexes?'y1':'Y1'),pArr,indexes)||0,x2:gmxAPIutils.getPropItem(gmx.quicklookX2||('x2'in indexes?'x2':'X2'),pArr,indexes)||0,y2:gmxAPIutils.getPropItem(gmx.quicklookY2||('y2'in indexes?'y2':'Y2'),pArr,indexes)||0,x3:gmxAPIutils.getPropItem(gmx.quicklookX3||('x3'in indexes?'x3':'X3'),pArr,indexes)||0,y3:gmxAPIutils.getPropItem(gmx.quicklookY3||('y3'in indexes?'y3':'Y3'),pArr,indexes)||0,x4:gmxAPIutils.getPropItem(gmx.quicklookX4||('x4'in indexes?'x4':'X4'),pArr,indexes)||0,y4:gmxAPIutils.getPropItem(gmx.quicklookY4||('y4'in indexes?'y4':'Y4'),pArr,indexes)||0},bounds=gmxAPIutils.bounds([[points.x1,points.y1],[points.x2,points.y2],[points.x3,points.y3],[points.x4,points.y4]]);if(bounds.max.x===bounds.min.x||bounds.max.y===bounds.min.y){return null;}if(!gmx.quicklookPlatform){var crs=gmx.srs==3857?L.CRS.EPSG3857:L.Projection.Mercator;var merc=crs.project(L.latLng(points.y1,points.x1));points.x1=merc.x;points.y1=merc.y;merc=crs.project(L.latLng(points.y2,points.x2));points.x2=merc.x;points.y2=merc.y;merc=crs.project(L.latLng(points.y3,points.x3));points.x3=merc.x;points.y3=merc.y;merc=crs.project(L.latLng(points.y4,points.x4));points.x4=merc.x;points.y4=merc.y;}return points;},/** Get hash properties from array properties
   * @memberof L.gmxUtil
   * @param {Array} properties in Array format
   * @param {Object} keys indexes
   * @return {Object} properties in Hash format
  */getPropertiesHash:function getPropertiesHash(arr,indexes){var properties={};for(var key in indexes){properties[key]=arr[indexes[key]];}return properties;},getPropItem:function getPropItem(key,arr,indexes){return key in indexes?arr[indexes[key]]:'';},dec2rgba:function dec2rgba(i,a){// convert decimal to rgb
var r=i>>16&255,g=i>>8&255,b=i&255;return 'rgba('+r+', '+g+', '+b+', '+a+')';},dec2hex:function dec2hex(i){// convert decimal to hex
return (i+0x1000000).toString(16).substr(-6);},dec2color:function dec2color(i,a){// convert decimal to canvas color
return a<1?this.dec2rgba(i,a):'#'+this.dec2hex(i);},oneDay:60*60*24,// Ð¾Ð´Ð¸Ð½ Ð´ÐµÐ½Ñ
isTileKeysIntersects:function isTileKeysIntersects(tk1,tk2){// Ð¿ÐµÑÐµÑÐµÑÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð½Ð¾Ð¼ÐµÑÐ°Ð¼ Ð´Ð²ÑÑ ÑÐ°Ð¹Ð»Ð¾Ð²
if(tk1.z<tk2.z){var t=tk1;tk1=tk2;tk2=t;}var dz=tk1.z-tk2.z;return tk1.x>>dz===tk2.x&&tk1.y>>dz===tk2.y;},rotatePoints:function rotatePoints(arr,angle,iconScale,center){// rotate - Ð¼Ð°ÑÑÐ¸Ð²Ð° ÑÐ¾ÑÐµÐº
var out=[];angle*=Math.PI/180.0;var sin=Math.sin(angle);var cos=Math.cos(angle);if(!iconScale){iconScale=1;}for(var i=0;i<arr.length;i++){var x=iconScale*arr[i].x-center.x;var y=iconScale*arr[i].y-center.y;out.push({'x':cos*x-sin*y+center.x,'y':sin*x+cos*y+center.y});}return out;},getPatternIcon:function getPatternIcon(item,style,indexes){// Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ bitmap ÑÑÐ¸Ð»Ñ pattern
if(!style.fillPattern){return null;}var notFunc=true,pattern=style.fillPattern,prop=item?item.properties:null,step=pattern.step>0?pattern.step:0,patternDefaults={minWidth:1,maxWidth:1000,minStep:0,maxStep:1000};if(pattern.patternStepFunction&&prop!==null){step=pattern.patternStepFunction(prop,indexes);notFunc=false;}if(step>patternDefaults.maxStep){step=patternDefaults.maxStep;}else if(step<patternDefaults.minStep){step=patternDefaults.minStep;}var size=pattern.width>0?pattern.width:8;if(pattern.patternWidthFunction&&prop!==null){size=pattern.patternWidthFunction(prop,indexes);notFunc=false;}if(size>patternDefaults.maxWidth){size=patternDefaults.maxWidth;}else if(size<patternDefaults.minWidth){size=patternDefaults.minWidth;}var op=style.fillOpacity;if(style.opacityFunction&&prop!==null){op=style.opacityFunction(prop,indexes)/100;notFunc=false;}var rgb=[0xff0000,0x00ff00,0x0000ff],arr=pattern.colors!=null?pattern.colors:rgb,count=arr.length,resColors=[],i=0;for(i=0;i<count;i++){var col=arr[i];if(pattern.patternColorsFunction&&pattern.patternColorsFunction[i]!==null){col=prop!==null?pattern.patternColorsFunction[i](prop,indexes):rgb[i%3];notFunc=false;}resColors.push(col);}if(count===0){resColors=[0];op=0;count=1;}// pattern without colors
var delta=size+step,allSize=delta*count,center=0,//radius,
rad=0,hh=allSize,// Ð²ÑÑÐ¾ÑÐ° Ð±Ð¸ÑÐ¼Ð°Ð¿Ð°
ww=allSize,// ÑÐ¸ÑÐ¸Ð½Ð° Ð±Ð¸ÑÐ¼Ð°Ð¿Ð°
type=pattern.style||'horizontal',flagRotate=false;if(type==='diagonal1'||type==='diagonal2'||type==='cross'||type==='cross1'){flagRotate=true;}else if(type==='circle'){ww=hh=2*delta;center=Math.floor(ww/2);// ÑÐµÐ½ÑÑ ÐºÑÑÐ³Ð°
//radius = Math.floor(size / 2);	// ÑÐ°Ð´Ð¸ÑÑ
rad=2*Math.PI/count;// ÑÐ³Ð¾Ð» Ð² ÑÐ°Ð´.
}else if(type==='vertical'){hh=1;}else if(type==='horizontal'){ww=1;}if(ww*hh>patternDefaults.maxWidth){console.log({'func':'getPatternIcon','Error':'MAX_PATTERN_SIZE','alert':'Bitmap from pattern is too big'});return null;}var canvas=document.createElement('canvas');canvas.width=ww;canvas.height=hh;var ptx=canvas.getContext('2d');ptx.clearRect(0,0,canvas.width,canvas.height);if(type==='diagonal2'||type==='vertical'){ptx.translate(ww,0);ptx.rotate(Math.PI/2);}for(i=0;i<count;i++){ptx.beginPath();var fillStyle=gmxAPIutils.dec2color(resColors[i],op);ptx.fillStyle=fillStyle;if(flagRotate){var x1=i*delta;var xx1=x1+size;ptx.moveTo(x1,0);ptx.lineTo(xx1,0);ptx.lineTo(0,xx1);ptx.lineTo(0,x1);ptx.lineTo(x1,0);x1+=allSize;xx1=x1+size;ptx.moveTo(x1,0);ptx.lineTo(xx1,0);ptx.lineTo(0,xx1);ptx.lineTo(0,x1);ptx.lineTo(x1,0);if(type==='cross'||type==='cross1'){x1=i*delta;xx1=x1+size;ptx.moveTo(ww,x1);ptx.lineTo(ww,xx1);ptx.lineTo(ww-xx1,0);ptx.lineTo(ww-x1,0);ptx.lineTo(ww,x1);x1+=allSize;xx1=x1+size;ptx.moveTo(ww,x1);ptx.lineTo(ww,xx1);ptx.lineTo(ww-xx1,0);ptx.lineTo(ww-x1,0);ptx.lineTo(ww,x1);}}else if(type==='circle'){ptx.arc(center,center,size,i*rad,(i+1)*rad);ptx.lineTo(center,center);}else {ptx.fillRect(0,i*delta,ww,size);}ptx.closePath();ptx.fill();}var canvas1=document.createElement('canvas');canvas1.width=ww;canvas1.height=hh;var ptx1=canvas1.getContext('2d');ptx1.drawImage(canvas,0,0,ww,hh);return {'notFunc':notFunc,'canvas':canvas1};},setSVGIcon:function setSVGIcon(id){return '<svg role="img" class="svgIcon"><use xlink:href="#'+id+'" href="#'+id+'"></use></svg>';},getSVGIcon:function getSVGIcon(options){var svg='<svg xmlns="'+L.Path.SVG_NS+'" xmlns:xlink="http://www.w3.org/1999/xlink"',type=options.type,fill=options.fillStyle||'rgba(255, 255, 255, 0.5)',stroke=options.strokeStyle||'#0000ff',strokeWidth=options.lineWidth||2,iconOptions={className:'gmx-svg-icon'};if(options.className){iconOptions.className=options.className;}var size=options.iconSize;iconOptions.iconSize=[size,size];svg+=' height = "'+size+'px"  width = "'+size+'px">';if(type==='circle'){if(options.fillRadialGradient){svg+='<defs><radialGradient id="myRadialGradient4" spreadMethod="pad">';var stopColor=options.fillRadialGradient.colorStop||options.fillRadialGradient.addColorStop||[// [%, color, opacity]
[0,'#ffff00',0.8],[1,'#ff0000',0.8]];for(var i=0,len=stopColor.length;i<len;i++){var it=stopColor[i];svg+='<stop offset="'+100*it[0]+'%"   stop-color="'+it[1]+'" stop-opacity="'+it[2]+'"/>';}svg+='</radialGradient></defs>';fill='url(#myRadialGradient4)';stroke=strokeWidth=null;}size/=2;svg+='<g><circle cx="'+size+'" cy="'+size+'" r="'+size+'" style="';if(fill){svg+=' fill:'+fill+';';}if(stroke){svg+=' stroke:"'+stroke+';';}if(strokeWidth){svg+=' stroke-width:"'+strokeWidth+';';}svg+=';" />';}else if(type==='square'){svg+='<g><rect width="'+size+'" height="'+size+'" style="';if(fill){svg+=' fill:'+fill+';';}if(stroke){svg+=' stroke:'+stroke+';';}if(strokeWidth){svg+=' stroke-width:'+2*strokeWidth+';';}svg+='" />';}if(options.text){var text=options.text;svg+='<text x="50%" y="50%" dy="0.4em"';for(var key in text){if(key!=='count'){svg+=' '+key+'="'+text[key]+'"';}}svg+='>'+text.count+'</text>';}svg+='</g></svg>';iconOptions.html=svg;return new L.DivIcon(iconOptions);},toPixels:function toPixels(p,tpx,tpy,mInPixel){// get pixel point	, topLeft
var px1=p[0]*mInPixel;px1=0.5+px1<<0;var py1=p[1]*mInPixel;py1=0.5+py1<<0;return [px1-tpx,tpy-py1].concat(p.slice(2));},getPixelPoint:function getPixelPoint(attr,coords){var topLeft=attr.topLeft,mInPixel=topLeft.mInPixel,item=attr.item,currentStyle=item.currentStyle||item.parsedStyleKeys||{},style=attr.style||{},iconScale=currentStyle.iconScale||1,iconCenter=currentStyle.iconCenter||false,sx=currentStyle.sx||style.sx||4,sy=currentStyle.sy||style.sy||4,weight=currentStyle.weight||style.weight||0,iconAnchor=currentStyle.iconAnchor||style.iconAnchor||null,px=attr.tpx,py=attr.tpy;if(!iconCenter&&iconAnchor){px1-=iconAnchor[0];py1-=iconAnchor[1];}sx*=iconScale;sy*=iconScale;sx+=weight;sy+=weight;var py1=py-coords[1]*mInPixel,px1=coords[0]*mInPixel-px;if(px1-sx>256){px1=(coords[0]-2*gmxAPIutils.worldWidthMerc)*mInPixel-px;}else if(px1<-sx){px1=(coords[0]+2*gmxAPIutils.worldWidthMerc)*mInPixel-px;}return py1-sy>256||px1-sx>256||px1+sx<0||py1+sy<0?null:{sx:sx,sy:sy,px1:0.5+px1<<0,py1:0.5+py1<<0};},getImageData:function getImageData(img){if(L.gmxUtil.isIE9||L.gmxUtil.isIE10){return null;}var canvas=document.createElement('canvas'),ww=img.width,hh=img.height;canvas.width=ww;canvas.height=hh;var ptx=canvas.getContext('2d');ptx.drawImage(img,0,0);return ptx.getImageData(0,0,ww,hh).data;},DEFAULT_REPLACEMENT_COLOR:0xff00ff,isIE:function isIE(v){return v===gmxAPIutils.getIEversion();},gtIE:function gtIE(v){return v<gmxAPIutils.getIEversion();},getIEversion:function getIEversion(){var ua=navigator.userAgent||'',msie=ua.indexOf('MSIE ');if(msie>0){// IE 10 or older => return version number
return parseInt(ua.substring(msie+5,ua.indexOf('.',msie)),10);}var trident=ua.indexOf('Trident/');if(trident>0){// IE 11 => return version number
var rv=ua.indexOf('rv:');return parseInt(ua.substring(rv+3,ua.indexOf('.',rv)),10);}var edge=ua.indexOf('Edge/');if(edge>0){// Edge (IE 12+) => return version number
return parseInt(ua.substring(edge+5,ua.indexOf('.',edge)),10);}// other browser
return -1;},replaceColor:function replaceColor(img,color,fromData){if(L.gmxUtil.isIE9||L.gmxUtil.isIE10){return img;}var canvas=document.createElement('canvas'),ww=img.width,hh=img.height;canvas.width=ww;canvas.height=hh;var flag=false,imageData,ptx=canvas.getContext('2d');if(typeof color==='string'){color=parseInt('0x'+color.replace(/#/,''));}if(color!==this.DEFAULT_REPLACEMENT_COLOR){var r=color>>16&255,g=color>>8&255,b=color&255;if(fromData){imageData=ptx.createImageData(ww,hh);}else {ptx.drawImage(img,0,0);imageData=ptx.getImageData(0,0,ww,hh);fromData=imageData.data;}var toData=imageData.data;for(var i=0,len=fromData.length;i<len;i+=4){if((fromData[i]===0xff||fromData[i]===238)&&fromData[i+1]===0&&fromData[i+2]===0xff){toData[i]=r;toData[i+1]=g;toData[i+2]=b;toData[i+3]=fromData[i+3];flag=true;}}}if(flag){ptx.putImageData(imageData,0,0);}else {ptx.drawImage(img,0,0);}return canvas;},drawIconPath:function drawIconPath(path,attr){// draw iconPath in canvas
if(!L.Util.isArray(path)||path.length<3||!attr.ctx){return;}var trFlag=false,ctx=attr.ctx,rad=attr.radian;if(attr.px||attr.py){ctx.translate(attr.px||0,attr.py||0);trFlag=true;}if(!rad&&attr.rotateRes){rad=Math.PI+gmxAPIutils.degRad(attr.rotateRes);}if(rad){ctx.rotate(rad);trFlag=true;}ctx.moveTo(path[0],path[1]);for(var i=2,len=path.length;i<len;i+=2){ctx.lineTo(path[i],path[i+1]);}if(trFlag){ctx.setTransform(1,0,0,1,0,0);}},pointToCanvas:function pointToCanvas(attr){// Ð¢Ð¾ÑÐºÑ Ð² canvas
var gmx=attr.gmx,pointAttr=attr.pointAttr,style=attr.style||{},item=attr.item,currentStyle=item.currentStyle||item.parsedStyleKeys,iconScale=currentStyle.iconScale||1,image=currentStyle.image,sx=pointAttr.sx,sy=pointAttr.sy,px1=pointAttr.px1,py1=pointAttr.py1,px1sx=px1,py1sy=py1,ctx=attr.ctx;if(currentStyle.type==='image'){sx=style.sx;sy=style.sy;image=style.image;}if(currentStyle.iconCenter){px1sx-=sx/2;py1sy-=sy/2;}else if(style.type==='circle'){px1+=sx/2;py1+=sy/2;}if(currentStyle.iconPath){attr.px=px1;attr.py=py1;attr.rotateRes=currentStyle.rotate||0;}if(image){if('iconColor'in currentStyle&&!L.gmxUtil.isIE11){image=this.replaceColor(image,currentStyle.iconColor,attr.imageData);}style.rotateRes=currentStyle.rotate||0;if('opacity'in style){ctx.globalAlpha=currentStyle.opacity||style.opacity;}if(gmx.transformFlag){// TODO:
var topLeft=attr.topLeft,ww=gmxAPIutils.worldWidthMerc,mInPixel=topLeft.mInPixel,// mInPixel2 = 2 * mInPixel,
tx=(topLeft.wm.x-ww)*mInPixel+sx/2,ty=(ww-topLeft.wm.y)*mInPixel-sy/2;// px1sx = (attr.coords[0] - topLeft.wm.x) * mInPixel - sx / 2;
// py1sy = (topLeft.wm.y - attr.coords[1]) * mInPixel - sy / 2;
ctx.setTransform(1,0,0,1,-tx,ty);// ctx.drawImage(image, attr.coords[0], attr.coords[1], sx, sy);
ctx.drawImage(image,(attr.coords[0]-ww)*mInPixel,(ww-attr.coords[1])*mInPixel,sx,sy);ctx.setTransform(1,0,0,1,0,0);// ctx.setTransform(1, 0, 0, 1, -attr.tpx, attr.tpy);
}else {if(iconScale!==1){sx*=iconScale;sy*=iconScale;px1=pointAttr.px1;py1=pointAttr.py1;px1sx=px1;py1sy=py1;if(currentStyle.iconCenter){px1sx-=sx/2;py1sy-=sy/2;}}if(style.rotateRes){ctx.translate(px1,py1);ctx.rotate(gmxAPIutils.degRad(style.rotateRes));ctx.translate(-px1,-py1);ctx.drawImage(image,px1sx,py1sy,sx,sy);ctx.setTransform(1,0,0,1,0,0);}else {ctx.drawImage(image,px1sx,py1sy,sx,sy);}}if('opacity'in style){ctx.globalAlpha=1;}}else if(style.fillColor||currentStyle.fillRadialGradient){ctx.beginPath();if(currentStyle.iconPath){gmxAPIutils.drawIconPath(currentStyle.iconPath,attr);}else if(style.type==='circle'||currentStyle.fillRadialGradient){var circle=style.iconSize/2;if(currentStyle.fillRadialGradient){var rgr=currentStyle.fillRadialGradient;circle=rgr.r2*iconScale;var radgrad=ctx.createRadialGradient(px1+rgr.x1,py1+rgr.y1,rgr.r1*iconScale,px1+rgr.x2,py1+rgr.y2,circle);for(var i=0,len=rgr.addColorStop.length;i<len;i++){var arr=rgr.addColorStop[i];radgrad.addColorStop(arr[0],arr[1]);}ctx.fillStyle=radgrad;}ctx.arc(px1,py1,circle,0,2*Math.PI);}else {ctx.fillRect(px1sx,py1sy,sx,sy);}ctx.fill();}if(currentStyle.strokeStyle&&currentStyle.lineWidth){ctx.beginPath();if(currentStyle.iconPath){gmxAPIutils.drawIconPath(currentStyle.iconPath,attr);}else if(style.type==='circle'){ctx.arc(px1,py1,style.iconSize/2,0,2*Math.PI);}else {ctx.strokeRect(px1sx,py1sy,sx,sy);}ctx.stroke();}},lineToCanvasAsIcon:function lineToCanvasAsIcon(pixels,attr){// add line(as icon) to canvas
var len=pixels.length,ctx=attr.ctx,item=attr.item,currentStyle=item.currentStyle||item.parsedStyleKeys,iconPath=currentStyle.iconPath;if(len>0){if('getLineDash'in ctx&&ctx.getLineDash().length>0){ctx.setLineDash([]);}ctx.beginPath();for(var i=0,p;i<len;i++){p=pixels[i];gmxAPIutils.drawIconPath(iconPath,{ctx:ctx,px:p.x,py:p.y,radian:p.radian});}if(currentStyle.strokeStyle){ctx.stroke();}if(currentStyle.fillStyle){ctx.fill();}}},lineToCanvas:function lineToCanvas(attr){// Lines in canvas
var topLeft=attr.topLeft,mInPixel=topLeft.mInPixel,coords=attr.coords,ctx=attr.ctx,item=attr.item,currentStyle=item.currentStyle||item.parsedStyleKeys,pixels=currentStyle.iconPath?[]:null;var lastX=null,lastY=null;ctx.beginPath();for(var i=0,len=coords.length;i<len;i++){var p=gmxAPIutils.toPixels(coords[i],attr.tpx,attr.tpy,mInPixel,attr.topLeft),x=p[0],y=p[1];if(lastX!==x||lastY!==y){if(pixels){pixels.push({x:x,y:y,radian:p[2]});}if(i===0){ctx.moveTo(x,y);}else {ctx.lineTo(x,y);}lastX=x;lastY=y;}}ctx.stroke();return pixels;},getCoordsPixels:function getCoordsPixels(attr){var gmx=attr.gmx,coords=attr.coords,hiddenLines=attr.hiddenLines||[],pixels=[],hidden=[],hiddenFlag=false,hash={gmx:gmx,topLeft:attr.topLeft,tpx:attr.tpx,tpy:attr.tpy,coords:null,hiddenLines:null};for(var j=0,len=coords.length;j<len;j++){var coords1=coords[j],hiddenLines1=hiddenLines[j]||[],pixels1=[],hidden1=[];for(var j1=0,len1=coords1.length;j1<len1;j1++){hash.coords=coords1[j1];hash.hiddenLines=hiddenLines1[j1]||[];var res=gmxAPIutils.getRingPixels(hash);pixels1.push(res.coords);hidden1.push(res.hidden);if(res.hidden){hiddenFlag=true;}}pixels.push(pixels1);hidden.push(hidden1);}return {coords:pixels,hidden:hiddenFlag?hidden:null,z:attr.topLeft.tilePoint.z};},getRingPixels:function getRingPixels(attr){if(attr.coords.length===0){return null;}var topLeft=attr.topLeft,mInPixel=topLeft.mInPixel,coords=attr.coords,hiddenLines=attr.hiddenLines||null,// topLeft = attr.topLeft,
px=attr.tpx,py=attr.tpy,cnt=0,cntHide=0,lastX=null,lastY=null,vectorSize=typeof coords[0]==='number'?2:1,pixels=[],hidden=[];for(var i=0,len=coords.length;i<len;i+=vectorSize){var lineIsOnEdge=false;if(hiddenLines&&i===hiddenLines[cntHide]){lineIsOnEdge=true;cntHide++;}var c=vectorSize===1?coords[i]:[coords[i],coords[i+1]],x1=Math.round(c[0]*mInPixel),y1=Math.round(c[1]*mInPixel),x2=Math.round(x1-px),y2=Math.round(py-y1);if(lastX!==x2||lastY!==y2){lastX=x2;lastY=y2;if(lineIsOnEdge){hidden.push(cnt);}pixels[cnt++]=x1;pixels[cnt++]=y1;}}return {coords:pixels,hidden:hidden.length?hidden:null};},polygonToCanvas:function polygonToCanvas(attr){// Polygons in canvas
if(attr.coords.length===0){return null;}var hiddenLines=attr.hiddenLines||null,coords=attr.coords,ctx=attr.ctx,// topLeft = attr.topLeft,
px=attr.tpx,py=attr.tpy,cnt=0,cntHide=0,vectorSize=typeof coords[0]==='number'?2:1,lastX=null,lastY=null;ctx.beginPath();for(var i=0,len=coords.length;i<len;i+=vectorSize){var c=vectorSize===1?coords[i]:[coords[i],coords[i+1]],x=Math.round(c[0]-px),y=Math.round(py-c[1]),lineIsOnEdge=false,lineCap='round';// console.log('px', x, y, px, py, attr);
if(hiddenLines&&i===hiddenLines[cntHide]){lineIsOnEdge=true;lineCap='butt';cntHide++;}if(ctx.lineCap!==lineCap){ctx.lineCap=lineCap;}if(lastX!==x||lastY!==y){ctx[lineIsOnEdge?'moveTo':'lineTo'](x,y);lastX=x;lastY=y;cnt++;}}if(cnt===1){ctx.lineTo(lastX+1,lastY);}ctx.stroke();},polygonToCanvasFill:function polygonToCanvasFill(attr){// Polygon fill
if(attr.coords.length<3){return;}var coords=attr.coords,// topLeft = attr.topLeft,
px=attr.tpx,py=attr.tpy,vectorSize=1,ctx=attr.ctx;ctx.lineWidth=0;if(typeof coords[0]==='number'){vectorSize=2;ctx.moveTo(Math.round(coords[0]-px),Math.round(py-coords[1]));}else {ctx.moveTo(Math.round(coords[0][0]-px),Math.round(py-coords[0][1]));}for(var i=vectorSize,len=coords.length;i<len;i+=vectorSize){var c=vectorSize===1?coords[i]:[coords[i],coords[i+1]];ctx.lineTo(Math.round(c[0]-px),Math.round(py-c[1]));}},isPatternNode:function isPatternNode(it){return it instanceof HTMLCanvasElement||it instanceof HTMLImageElement;},labelCanvasContext:null,// 2dContext canvas for Label size
getLabelWidth:function getLabelWidth(txt,style){// Get label size Label
if(style){if(!gmxAPIutils.labelCanvasContext){var canvas=document.createElement('canvas');canvas.width=canvas.height=512;gmxAPIutils.labelCanvasContext=canvas.getContext('2d');}var ptx=gmxAPIutils.labelCanvasContext;ptx.clearRect(0,0,512,512);if(ptx.font!==style.font){ptx.font=style.font;}//if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }
if(ptx.fillStyle!==style.fillStyle){ptx.fillStyle=style.fillStyle;}var arr=txt.split('\n');return arr.map(function(it){ptx.fillText(it,0,0);return [it,ptx.measureText(it).width];});}return 0;},setLabel:function setLabel(ctx,txt,coord,style){var x=coord[0],y=coord[1];if(ctx.shadowColor!==style.strokeStyle){ctx.shadowColor=style.strokeStyle;}if(ctx.shadowBlur!==style.shadowBlur){ctx.shadowBlur=style.shadowBlur;}if(ctx.font!==style.font){ctx.font=style.font;}if(L.Browser.gecko){// Bug with perfomance in FireFox
if(ctx.strokeStyle!==style.fillStyle){ctx.strokeStyle=style.fillStyle;}}else {if(ctx.strokeStyle!==style.strokeStyle){ctx.strokeStyle=style.strokeStyle;}if(ctx.fillStyle!==style.fillStyle){ctx.fillStyle=style.fillStyle;}}ctx.strokeText(txt,x,y);if(!L.Browser.gecko){ctx.fillText(txt,x,y);}},worldWidthFull:40075016.685578496,// worldWidthMerc: gmxAPIutils.worldWidthFull / 2,
rMajor:6378137.000,degRad:function degRad(ang){return ang*(Math.PI/180.0);},distVincenty:function distVincenty(lon1,lat1,lon2,lat2){var p1={lon:gmxAPIutils.degRad(lon1),lat:gmxAPIutils.degRad(lat1)},p2={lon:gmxAPIutils.degRad(lon2),lat:gmxAPIutils.degRad(lat2)},a=gmxAPIutils.rMajor,b=6356752.3142,f=1/298.257223563;// WGS-84 ellipsiod
var L1=p2.lon-p1.lon,U1=Math.atan((1-f)*Math.tan(p1.lat)),U2=Math.atan((1-f)*Math.tan(p2.lat)),sinU1=Math.sin(U1),cosU1=Math.cos(U1),sinU2=Math.sin(U2),cosU2=Math.cos(U2),lambda=L1,lambdaP=2*Math.PI,iterLimit=20;while(Math.abs(lambda-lambdaP)>1e-12&&--iterLimit>0){var sinLambda=Math.sin(lambda),cosLambda=Math.cos(lambda),sinSigma=Math.sqrt(cosU2*sinLambda*(cosU2*sinLambda)+(cosU1*sinU2-sinU1*cosU2*cosLambda)*(cosU1*sinU2-sinU1*cosU2*cosLambda));if(sinSigma===0){return 0;}var cosSigma=sinU1*sinU2+cosU1*cosU2*cosLambda,sigma=Math.atan2(sinSigma,cosSigma),sinAlpha=cosU1*cosU2*sinLambda/sinSigma,cosSqAlpha=1-sinAlpha*sinAlpha,cos2SigmaM=cosSigma-2*sinU1*sinU2/cosSqAlpha;if(isNaN(cos2SigmaM)){cos2SigmaM=0;}var C=f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));lambdaP=lambda;lambda=L1+(1-C)*f*sinAlpha*(sigma+C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));}if(iterLimit===0){return NaN;}var uSq=cosSqAlpha*(a*a/(b*b)-1),//var uSq = cosSqAlpha * (a * a - b * b) / (b*b),
A=1+uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq))),B=uSq/1024*(256+uSq*(-128+uSq*(74-47*uSq))),deltaSigma=B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM))),s=b*A*(sigma-deltaSigma);//s = s.toFixed(3);
return s;},_vfi:function _vfi(fi,a,b){return [-Math.cos(fi)*Math.sin(a)+Math.sin(fi)*Math.sin(b)*Math.cos(a),Math.cos(fi)*Math.cos(a)+Math.sin(fi)*Math.sin(b)*Math.sin(a),-Math.sin(fi)*Math.cos(b)];},getCircleLatLngs:function getCircleLatLngs(latlng,r){// Get latlngs for circle
var x=0,y=0;if(latlng instanceof L.LatLng){x=latlng.lng;y=latlng.lat;}else if(L.Util.isArray(latlng)){x=latlng[1];y=latlng[0];}else {return null;}var rad=Math.PI/180,a=x*rad,//Ð´Ð¾Ð»Ð³Ð¾ÑÐ° ÑÐµÐ½ÑÑÐ° Ð¾ÐºÑÑÐ¶Ð½Ð¾ÑÑÐ¸ Ð² ÑÐ°Ð´Ð¸Ð°Ð½Ð°Ñ
b=y*rad,//ÑÐ¸ÑÐ¾ÑÐ° ÑÐµÐ½ÑÑÐ° Ð¾ÐºÑÑÐ¶Ð½Ð¾ÑÑÐ¸ Ð² ÑÐ°Ð´Ð¸Ð°Ð½Ð°Ñ
R=gmxAPIutils.rMajor,d=R*Math.sin(r/R),Rd=R*Math.cos(r/R),VR=[Rd*Math.cos(b)*Math.cos(a),Rd*Math.cos(b)*Math.sin(a),Rd*Math.sin(b)],latlngs=[];for(var fi=0,limit=2*Math.PI+0.000001;fi<limit;fi+=rad){var v=gmxAPIutils._vfi(fi,a,b),circle=[];for(var i=0;i<3;i++){circle[i]=VR[i]+d*v[i];}var t2=Math.acos(circle[0]/Math.sqrt(circle[0]*circle[0]+circle[1]*circle[1]))/rad;if(circle[1]<0){t2=-t2;}if(t2<x-180){t2+=360;}else if(t2>x+180){t2-=360;}latlngs.push([Math.asin(circle[2]/R)/rad,t2]);}return latlngs;},/** Get point coordinates from string
   * @memberof L.gmxUtil
   * @param {String} text - point coordinates in following formats:
       <br/><i>55.74312, 37.61558</i>
       <br/><i>55Â°44'35" N, 37Â°36'56" E</i>
       <br/><i>4187347, 7472103</i>
       <br/><i>4219783, 7407468 (EPSG:3395)</i>
       <br/><i>4219783, 7442673 (EPSG:3857)</i>
   * @return {Array} [lat, lng] or null
  */parseCoordinates:function parseCoordinates(text){var crs=null,regex=/\(EPSG:(\d+)\)/g,t=regex.exec(text);if(t){crs=t[1];text=text.replace(regex,'');}if(text.match(/[Ð¹ÑÑÐºÐµÐ½Ð³ÑÑÐ·ÑÑÑÑÐ²Ð°Ð¿ÑÐ¾Ð»Ð´Ð¶ÑÑÑÑÐ¼Ð¸ÑÑÐ±ÑÐÐ¦Ð£ÐÐÐÐÐ¨Ð©ÐÐ¥ÐªÐ¤Ð«ÐÐÐÐ ÐÐÐÐÐ­Ð¯Ð§Ð¡ÐÐÐ¢Ð¬ÐÐ®qrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)){return null;}//there should be a separator in the string (exclude strings like "11E11")
if(text.indexOf(' ')===-1&&text.indexOf(',')===-1){return null;}if(text.indexOf(' ')!==-1){text=text.replace(/,/g,'.');}var results=[];/*eslint-disable no-useless-escape */regex=/(-?\d+(\.\d+)?)([^\d\-]*)/g;/*eslint-enable */t=regex.exec(text);while(t){results.push(t[1]);t=regex.exec(text);}if(results.length<2){return null;}var ii=Math.floor(results.length/2),y=0,mul=1,i;for(i=0;i<ii;i++){y+=parseFloat(results[i])*mul;mul/=60;}var x=0;mul=1;for(i=ii;i<results.length;i++){x+=parseFloat(results[i])*mul;mul/=60;}if(Math.max(text.indexOf('N'),text.indexOf('S'))>Math.max(text.indexOf('E'),text.indexOf('W'))){t=x;x=y;y=t;}var pos;if(crs==3857){pos=L.Projection.SphericalMercator.unproject(new L.Point(y,x));x=pos.lng;y=pos.lat;}if(Math.abs(x)>180||Math.abs(y)>180){pos=L.Projection.Mercator.unproject(new L.Point(y,x));x=pos.lng;y=pos.lat;}if(text.indexOf('W')!==-1){x=-x;}if(text.indexOf('S')!==-1){y=-y;}return [y,x];},pad2:function pad2(t){return t>=0&&t<10?'0'+t:''+t;},trunc:function trunc(x){return (''+(Math.round(10000000*x)/10000000+0.00000001)).substring(0,9);},formatDegrees:function formatDegrees(angle,format){angle=Math.round(10000000*angle)/10000000+0.00000001;var a1=Math.floor(angle),a2=Math.floor(60*(angle-a1)),a3=gmxAPIutils.toPrecision(3600*(angle-a1-a2/60),2),st=gmxAPIutils.pad2(a1)+'Â°';if(format===undefined){format=2;}if(format>0){st+=gmxAPIutils.pad2(a2)+'\'';}if(format>1){st+=gmxAPIutils.pad2(a3)+'"';}return st;},/** Get point coordinates in string format with degrees
   * @memberof L.gmxUtil
   * @param {Number} lng - point longitude
   * @param {Number} lat - point latitude
   * @return {String} point coordinates in string format with degrees
  */latLonFormatCoordinates:function latLonFormatCoordinates(x,y){x%=360;if(x>180){x-=360;}else if(x<-180){x+=360;}return gmxAPIutils.formatDegrees(Math.abs(y))+(y>0?' N, ':' S, ')+gmxAPIutils.formatDegrees(Math.abs(x))+(x>0?' E':' W');},latLonToString:function latLonToString(x,y,prec){x%=360;if(x>180){x-=360;}else if(x<-180){x+=360;}if(prec){x=gmxAPIutils.toPrecision(x,prec);y=gmxAPIutils.toPrecision(y,prec);}return y+(y>0?' N, ':' S, ')+x+(x>0?' E':' W');},formatCoordinates:function formatCoordinates(x,y){return gmxAPIutils.latLonFormatCoordinates(x,y);},/** Get point coordinates in string format
   * @memberof L.gmxUtil
   * @param {Number} lng - point longitude
   * @param {Number} lat - point latitude
   * @return {String} point coordinates in string format
  */latLonFormatCoordinates2:function latLonFormatCoordinates2(x,y){return gmxAPIutils.trunc(Math.abs(y))+(y>0?' N, ':' S, ')+gmxAPIutils.trunc(Math.abs(x))+(x>0?' E':' W');},formatCoordinates2:function formatCoordinates2(x,y){return gmxAPIutils.latLonFormatCoordinates2(x,y);},getPixelScale:function getPixelScale(zoom){return 256/gmxAPIutils.tileSizes[zoom];},forEachPoint:function forEachPoint(coords,callback){if(!coords||coords.length===0){return [];}var i,len,ret=[];if(!coords[0].length){if(coords.length===2){return callback(coords);}else {for(i=0,len=coords.length/2;i<len;i++){ret.push(callback([coords[i*2],coords[i*2+1]]));}}}else {for(i=0,len=coords.length;i<len;i++){if(typeof coords[i]!=='string'){ret.push(gmxAPIutils.forEachPoint(coords[i],callback));}}}return ret;},/*
  	getQuicklookPoints: function(coord) { // Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ 4 ÑÐ¾ÑÐºÐ¸ Ð¿ÑÐ¸Ð²ÑÐ·ÐºÐ¸ ÑÐ½Ð¸Ð¼ÐºÐ°
  		var d1 = Number.MAX_VALUE;
  		var d2 = Number.MAX_VALUE;
  		var d3 = Number.MAX_VALUE;
  		var d4 = Number.MAX_VALUE;
  		var x1, y1, x2, y2, x3, y3, x4, y4;
  		this.forEachPoint(coord, function(p) {
  			var x = p[0];
  			var y = p[1];
  			if ((x - y) < d1) {
  				d1 = x - y;
  				x1 = p[0];
  				y1 = p[1];
  			}
  			if ((-x - y) < d2) {
  				d2 = -x - y;
  				x2 = p[0];
  				y2 = p[1];
  			}
  			if ((-x + y) < d3) {
  				d3 = -x + y;
  				x3 = p[0];
  				y3 = p[1];
  			}
  			if ((x + y) < d4) {
  				d4 = x + y;
  				x4 = p[0];
  				y4 = p[1];
  			}
  		});
  		return {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};
  	},
  */getItemCenter:function getItemCenter(item,geoItems){var bounds=gmxAPIutils.bounds();geoItems.forEach(function(it){bounds.extendBounds(it.dataOption.bounds);});var min=bounds.min,max=bounds.max,type=item.type,isPoint=type==='POINT'||type==='MULTIPOINT',center=isPoint?[min.x,min.y]:[(min.x+max.x)/2,(min.y+max.y)/2];if(type==='MULTIPOLYGON'){return center;}else if(type==='POLYGON'){for(var i=0,len=geoItems.length;i<len;i++){var it=geoItems[i],geom=it.geo,coords=geom.coordinates,dataOption=it.dataOption,bbox=dataOption.bounds;if(bbox.contains(center)){if(geom.type==='POLYGON'){coords=[coords];}for(var j=0,len1=coords.length;j<len1;j++){for(var j1=0,coords1=coords[j],len2=coords1.length;j1<len2;j1++){var pt=gmxAPIutils.getHSegmentsInPolygon(center[1],coords1[j1]);if(pt){return pt.max.center;}}}}}}else if(type==='POINT'||type==='MULTIPOINT'){return center;}else if(type==='LINESTRING'||type==='MULTILINESTRING'){return center;}return null;},getHSegmentsInPolygon:function getHSegmentsInPolygon(y,poly){var s=[],i,len,out,vectorSize=1,p1=poly[0];if(typeof poly[0]==='number'){vectorSize=2;p1=[poly[0],poly[1]];}var isGt1=y>p1[1];for(i=vectorSize,len=poly.length;i<len;i+=vectorSize){var p2=vectorSize===1?poly[i]:[poly[i],poly[i+1]],isGt2=y>p2[1];if(isGt1!==isGt2){s.push(p1[0]-(p1[0]-p2[0])*(p1[1]-y)/(p1[1]-p2[1]));}p1=p2;isGt1=isGt2;}len=s.length;if(len){s=s.sort();var max=0,index=-1;for(i=1;i<len;i+=2){var j=i-1,d=Math.abs(s[i]-s[j]);if(d>max){max=d;index=j;}}out={y:y,segArr:s,max:{width:max,center:[(s[index]+s[index+1])/2,y]}};}return out;},isPointInPolygonArr:function isPointInPolygonArr(chkPoint,coords){// ÐÑÐ¾Ð²ÐµÑÐºÐ° ÑÐ¾ÑÐºÐ¸ Ð½Ð° Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð½Ð¾ÑÑÑ Ð¿Ð¾Ð»Ð¸Ð³Ð¾Ð½Ñ Ð² Ð²Ð¸Ð´Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ð°
var isIn=false,x=chkPoint[0],y=chkPoint[1],vectorSize=1,p1=coords[0];if(typeof coords[0]==='number'){vectorSize=2;p1=[coords[0],coords[1]];}for(var i=vectorSize,len=coords.length;i<len;i+=vectorSize){var p2=vectorSize===1?coords[i]:[coords[i],coords[i+1]],xmin=Math.min(p1[0],p2[0]),xmax=Math.max(p1[0],p2[0]),ymax=Math.max(p1[1],p2[1]);if(x>xmin&&x<=xmax&&y<=ymax&&p1[0]!==p2[0]){var xinters=(x-p1[0])*(p2[1]-p1[1])/(p2[0]-p1[0])+p1[1];if(p1[1]===p2[1]||y<=xinters){isIn=!isIn;}}p1=p2;}return isIn;},/** Is point in polygon with holes
   * @memberof L.gmxUtil
   * @param {chkPoint} chkPoint - point in [x, y] format
   * @param {coords} coords - polygon from geoJSON coordinates data format
   * @return {Boolean} true if polygon contain chkPoint
  */isPointInPolygonWithHoles:function isPointInPolygonWithHoles(chkPoint,coords){if(!gmxAPIutils.isPointInPolygonArr(chkPoint,coords[0])){return false;}for(var j=1,len=coords.length;j<len;j++){if(gmxAPIutils.isPointInPolygonArr(chkPoint,coords[j])){return false;}}return true;},/** Is polygon clockwise
   * @memberof L.gmxUtil
   * @param {ring} ring - ring from geoJSON coordinates data format
   * @return {Boolean} true if ring is clockwise
  */isClockwise:function isClockwise(ring){var area=0;for(var i=0,j,len=ring.length;i<len;i++){j=(i+1)%len;area+=ring[i][0]*ring[j][1];area-=ring[j][0]*ring[i][1];}return area<0;},isPointInPolyLine:function isPointInPolyLine(chkPoint,lineHeight,coords,hiddenLines){// ÐÑÐ¾Ð²ÐµÑÐºÐ° ÑÐ¾ÑÐºÐ¸(Ñ ÑÑÐµÑÐ¾Ð¼ ÑÐ°Ð·Ð¼ÐµÑÐ¾Ð²) Ð½Ð° Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð½Ð¾ÑÑÑ Ð»Ð¸Ð½Ð¸Ð¸
var dx=chkPoint[0],dy=chkPoint[1],nullPoint={x:dx,y:dy},minx=dx-lineHeight,maxx=dx+lineHeight,miny=dy-lineHeight,maxy=dy+lineHeight,cntHide=0;lineHeight*=lineHeight;for(var i=1,len=coords.length;i<len;i++){if(hiddenLines&&i===hiddenLines[cntHide]){cntHide++;}else {var p1=coords[i-1],p2=coords[i],x1=p1[0],y1=p1[1],x2=p2[0],y2=p2[1];if(!(Math.max(x1,x2)<minx||Math.min(x1,x2)>maxx||Math.max(y1,y2)<miny||Math.min(y1,y2)>maxy)){var sqDist=L.LineUtil._sqClosestPointOnSegment(nullPoint,{x:x1,y:y1},{x:x2,y:y2},true);if(sqDist<lineHeight){return true;}}}}return false;},isPointInLines:function isPointInLines(attr){var arr=attr.coords,point=attr.point,delta=attr.delta,boundsArr=attr.boundsArr,hidden=attr.hidden;for(var j=0,len=arr.length,flag=false;j<len;j++){flag=boundsArr[j]?boundsArr[j].contains(point):true;if(flag&&gmxAPIutils.isPointInPolyLine(point,delta,arr[j],hidden?hidden[j]:null)){return true;}}return false;},/** Get length
   * @memberof L.gmxUtil
   * @param {Array} latlngs array
   * @param {Boolean} isMerc - true if coordinates in Mercator
   * @param {Boolean} isWebMerc - true if coordinates in WebMercator	- TODO
   * @return {Number} length
  */getLength:function getLength(latlngs,isMerc){var length=0;if(latlngs&&latlngs.length){var lng=false,lat=false;isMerc=isMerc===undefined||isMerc;latlngs.forEach(function(latlng){if(L.Util.isArray(latlng)){if(L.Util.isArray(latlng[0])){length+=gmxAPIutils.getLength(latlng,isMerc);return length;}else if(isMerc){// From Mercator array
latlng=L.Projection.Mercator.unproject({x:latlng[0],y:latlng[1]});}}if(lng!==false&&lat!==false){length+=parseFloat(gmxAPIutils.distVincenty(lng,lat,latlng.lng,latlng.lat));}lng=latlng.lng;lat=latlng.lat;});}return length;},getText:function getText(str){str=str||'';if(L.gmxLocale){return L.gmxLocale.getText(str);}return str.split('.').pop();},/** Get prettify length
   * @memberof L.gmxUtil
   * @param {Number} area
   * @param {String} type: ('km', 'm', 'nm')
   * @return {String} prettify length
  */prettifyDistance:function prettifyDistance(length,type){var km=' '+gmxAPIutils.getText('units.km');if(type==='nm'){return Math.round(0.539956803*length/10)/100+' '+gmxAPIutils.getText('units.nm');}else if(type==='km'){return Math.round(length)/1000+km;}else if(length<2000||type==='m'){return Math.round(length)+' '+gmxAPIutils.getText('units.m');}else if(length<200000){return Math.round(length/10)/100+km;}return Math.round(length/1000)+km;},/** Get geoJSON length
   * @memberof L.gmxUtil
   * @param {Object} geoJSON - object in <a href="http://geojson.org/geojson-spec.html">GeoJSON format</a>
   * @return {Number} length
  */geoJSONGetLength:function geoJSONGetLength(geoJSON){var out=0,i,j,len,len1,coords;if(geoJSON.type==='GeometryCollection'){out+=geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);}else if(geoJSON.type==='Feature'){out+=gmxAPIutils.geoJSONGetLength(geoJSON.geometry);}else if(geoJSON.type==='FeatureCollection'){out+=geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);}if(geoJSON.type==='LineString'||geoJSON.type==='MultiLineString'){coords=geoJSON.coordinates;if(geoJSON.type==='LineString'){coords=[coords];}for(i=0,len=coords.length;i<len;i++){out+=gmxAPIutils.getRingLength(coords[i]);}}if(geoJSON.type==='Polygon'||geoJSON.type==='MultiPolygon'){coords=geoJSON.coordinates;if(geoJSON.type==='Polygon'){coords=[coords];}for(i=0,len=coords.length;i<len;i++){for(j=0,len1=coords[i].length;j<len1;j++){out+=gmxAPIutils.getRingLength(coords[i][j]);}}}return out;},getRingLength:function getRingLength(coords){var length=0;if(coords&&coords.length){var lng=false,lat=false;coords.forEach(function(lnglat){if(L.Util.isArray(lnglat)){if(lnglat.length>2){length+=gmxAPIutils.getRingLength(lnglat);return length;}}if(lng!==false&&lat!==false){length+=parseFloat(gmxAPIutils.distVincenty(lng,lat,lnglat[0],lnglat[1]));}lng=lnglat[0];lat=lnglat[1];});}return length;},/** Get geoJSON area
   * @memberof L.gmxUtil
   * @param {Object} geojson - object in <a href="http://geojson.org/geojson-spec.html">GeoJSON format</a>
   * @return {Number} area in square meters
  */geoJSONGetArea:function geoJSONGetArea(geoJSON){var out=0;if(geoJSON.type==='GeometryCollection'){out+=geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);}else if(geoJSON.type==='Feature'){out+=gmxAPIutils.geoJSONGetArea(geoJSON.geometry);}else if(geoJSON.type==='FeatureCollection'){out+=geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);}if(geoJSON.type==='Polygon'||geoJSON.type==='MultiPolygon'){var coords=geoJSON.coordinates;if(geoJSON.type==='Polygon'){coords=[coords];}for(var i=0,len=coords.length;i<len;i++){out+=gmxAPIutils.getRingArea(coords[i][0]);for(var j=1,len1=coords[i].length;j<len1;j++){out-=gmxAPIutils.getRingArea(coords[i][j]);}}}return out;},geoJSONGetLatLng:function geoJSONGetLatLng(geoJSON){if(geoJSON.type==='Feature'){return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);}else if(geoJSON.type==='Point'){return L.latLng(geoJSON.coordinates[1],geoJSON.coordinates[0]);}else {throw new Error('cannot get '+geoJSON.type+' latLng');}},getRingArea:function getRingArea(coords){var area=0;for(var i=0,len=coords.length;i<len;i++){var ipp=i===len-1?0:i+1,p1=coords[i],p2=coords[ipp];area+=p1[0]*Math.sin(gmxAPIutils.degRad(p2[1]))-p2[0]*Math.sin(gmxAPIutils.degRad(p1[1]));}var out=Math.abs(area*gmxAPIutils.lambertCoefX*gmxAPIutils.lambertCoefY/2);return out;},/** Get area
   * @memberof L.gmxUtil
   * @param {Array} L.latLng array
   * @return {Number} area in square meters
  */getArea:function getArea(arr){var area=0;for(var i=0,len=arr.length;i<len;i++){var ipp=i===len-1?0:i+1,p1=arr[i],p2=arr[ipp];area+=p1.lng*Math.sin(gmxAPIutils.degRad(p2.lat))-p2.lng*Math.sin(gmxAPIutils.degRad(p1.lat));}return Math.abs(area*gmxAPIutils.lambertCoefX*gmxAPIutils.lambertCoefY/2);},/** Get prettified size of area
   * @memberof L.gmxUtil
   * @param {Number} area in square meters
   * @param {String} type: ('km2', 'ha', 'm2')
   * @return {String} prettified area
  */prettifyArea:function prettifyArea(area,type){var km2=' '+gmxAPIutils.getText('units.km2');if(type==='km2'){return ''+Math.round(area/100)/10000+km2;}else if(type==='ha'){return ''+Math.round(area/100)/100+' '+gmxAPIutils.getText('units.ha');}else if(area<100000||type==='m2'){return Math.round(area)+' '+gmxAPIutils.getText('units.m2');}else if(area<3000000){return (''+Math.round(area/1000)/1000).replace('.',',')+km2;}else if(area<30000000){return (''+Math.round(area/10000)/100).replace('.',',')+km2;}else if(area<300000000){return (''+Math.round(area/100000)/10).replace('.',',')+km2;}return Math.round(area/1000000)+km2;},geoLength:function geoLength(geom){var ret=0,type=geom.type;if(type==='MULTILINESTRING'||type==='MultiLineString'){for(var i=0,len=geom.coordinates.length;i<len;i++){ret+=gmxAPIutils.geoLength({type:'LINESTRING',coordinates:geom.coordinates[i]});}return ret;}else if(type==='LINESTRING'||type==='LineString'){ret=gmxAPIutils.getLength(geom.coordinates);}return ret;},/** Converts Geomixer geometry to geoJSON geometry
   * @memberof L.gmxUtil
   * @param {Object} geometry - Geomixer geometry
   * @param {Boolean} mercFlag - true if coordinates in Mercator
   * @param {Boolean} webmercFlag - true if coordinates in WebMercator
   * @return {Object} geoJSON geometry
  */geometryToGeoJSON:function geometryToGeoJSON(geom,mercFlag,webmercFlag){if(!geom){return null;}var type=geom.type==='MULTIPOLYGON'?'MultiPolygon':geom.type==='POLYGON'?'Polygon':geom.type==='MULTILINESTRING'?'MultiLineString':geom.type==='LINESTRING'?'LineString':geom.type==='MULTIPOINT'?'MultiPoint':geom.type==='POINT'?'Point':geom.type,coords=geom.coordinates;if(mercFlag){coords=gmxAPIutils.coordsFromMercator(type,coords,webmercFlag);}return {type:type,coordinates:coords};},convertGeometry:function convertGeometry(geom,fromMerc,webmercFlag){var type=geom.type==='MULTIPOLYGON'?'MultiPolygon':geom.type==='POLYGON'?'Polygon':geom.type==='MULTILINESTRING'?'MultiLineString':geom.type==='LINESTRING'?'LineString':geom.type==='MULTIPOINT'?'MultiPoint':geom.type==='POINT'?'Point':geom.type,coords=geom.coordinates;if(fromMerc){coords=gmxAPIutils.coordsFromMercator(type,coords,webmercFlag);}else {coords=gmxAPIutils.coordsToMercator(type,coords,webmercFlag);}return {type:geom.type,coordinates:coords};},/** Converts GeoJSON object into GeoMixer format
   * @memberof L.gmxUtil
   * @param {Object} geometry - GeoJSON object
   * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection
   * @return {Object} Geometry in GeoMixer format
  */geoJSONtoGeometry:function geoJSONtoGeometry(geoJSON,mercFlag,webmercFlag){if(geoJSON.type==='FeatureCollection'){return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0],mercFlag,webmercFlag);}else if(geoJSON.type==='Feature'){return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry,mercFlag,webmercFlag);}else if(geoJSON.type==='FeatureCollection'){return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0],mercFlag,webmercFlag);}var type=geoJSON.type==='MultiPolygon'?'MULTIPOLYGON':geoJSON.type==='Polygon'?'POLYGON':geoJSON.type==='MultiLineString'?'MULTILINESTRING':geoJSON.type==='LineString'?'LINESTRING':geoJSON.type==='MultiPoint'?'MULTIPOINT':geoJSON.type==='Point'?'POINT':geoJSON.type,coords=geoJSON.coordinates;if(mercFlag){coords=gmxAPIutils.coordsToMercator(geoJSON.type,coords,webmercFlag);}return {type:type,coordinates:coords};},_coordsConvert:function _coordsConvert(type,coords,toMerc,webmercFlag){var i,len,p,resCoords=[];if(type==='Point'){if(toMerc){p=(webmercFlag?L.CRS.EPSG3857:L.Projection.Mercator).project({lat:coords[1],lng:coords[0]});resCoords=[p.x,p.y];}else {p=L.Projection.Mercator.unproject({y:coords[1],x:coords[0]});resCoords=[p.lng,p.lat];if(webmercFlag){resCoords[1]=gmxAPIutils.fromWebMercY(coords[1]);}}}else if(type==='LineString'||type==='MultiPoint'){for(i=0,len=coords.length;i<len;i++){resCoords.push(gmxAPIutils._coordsConvert('Point',coords[i],toMerc,webmercFlag));}}else if(type==='Polygon'||type==='MultiLineString'){for(i=0,len=coords.length;i<len;i++){resCoords.push(gmxAPIutils._coordsConvert('MultiPoint',coords[i],toMerc,webmercFlag));}}else if(type==='MultiPolygon'){for(i=0,len=coords.length;i<len;i++){resCoords.push(gmxAPIutils._coordsConvert('Polygon',coords[i],toMerc,webmercFlag));}}return resCoords;},coordsFromMercator:function coordsFromMercator(type,coords,webmercFlag){return gmxAPIutils._coordsConvert(type,coords,false,webmercFlag);},coordsToMercator:function coordsToMercator(type,coords,webmercFlag){return gmxAPIutils._coordsConvert(type,coords,true,webmercFlag);},transformGeometry:function transformGeometry(geom,callback){return !geom?geom:{type:geom.type,coordinates:gmxAPIutils.forEachPoint(geom.coordinates,function(p){return callback(p);})};},/** Get area for geometry
   * @memberof L.gmxUtil
   * @param {Object} geometry
   * @param {Boolean} [isMerc=true] - true if coordinates in Mercator
   * @param {Boolean} isWebMerc - true if coordinates in WebMercator	- TODO
   * @return {Number} area in square meters
  */geoArea:function geoArea(geom,isMerc){var i,len,ret=0,type=geom.type||'';isMerc=isMerc===undefined||isMerc;if(type==='MULTIPOLYGON'||type==='MultiPolygon'){for(i=0,len=geom.coordinates.length;i<len;i++){ret+=gmxAPIutils.geoArea({type:'POLYGON',coordinates:geom.coordinates[i]},isMerc);}return ret;}else if(type==='POLYGON'||type==='Polygon'){ret=gmxAPIutils.geoArea(geom.coordinates[0],isMerc);for(i=1,len=geom.coordinates.length;i<len;i++){ret-=gmxAPIutils.geoArea(geom.coordinates[i],isMerc);}return ret;}else if(geom.length){var latlngs=[],vectorSize=typeof geom[0]==='number'?2:1;for(i=0,len=geom.length;i<len;i+=vectorSize){var p=vectorSize===1?geom[i]:[geom[i],geom[i+1]];latlngs.push(isMerc?L.Projection.Mercator.unproject({y:p[1],x:p[0]}):{lat:p[1],lng:p[0]});}return gmxAPIutils.getArea(latlngs);}return 0;},/** Get summary for geoJSON geometry
   * @memberof L.gmxUtil
   * @param {Object} geoJSON geometry
   * @param {Object} unitOptions {
   *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default
   *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default
   *               }
   * @return {String} Summary string for geometry
  */getGeoJSONSummary:function getGeoJSONSummary(geom,unitOptions){var type=geom.type,units=unitOptions||{},out=0,i,len,coords;if(type==='Point'){coords=geom.coordinates;out=gmxAPIutils.formatCoordinates(coords[0],coords[1]);}else if(type==='Polygon'){out=gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom,false),units.squareUnit);}else if(type==='MultiPolygon'){coords=geom.coordinates;for(i=0,len=coords.length;i<len;i++){out+=gmxAPIutils.geoArea({type:'Polygon',coordinates:coords[i]},false);}out=gmxAPIutils.prettifyArea(out,units.squareUnit);}else if(type==='LineString'){out=gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom),units.distanceUnit);}else if(type==='MultiLineString'){coords=geom.coordinates;for(i=0,len=coords.length;i<len;i++){out+=gmxAPIutils.geoJSONGetLength({type:'LineString',coordinates:coords[i]});}out=gmxAPIutils.prettifyDistance(out,units.distanceUnit);}return out;},/** Get summary for point
   * @memberof L.gmxUtil
   * @param {latlng} point
   * @param {num} format number:
   *         0: 62Â°52'30.68" N, 22Â°48'27.42" E
   *         1: 62.875188 N, 22.807617 E
   *         2: 2538932, 9031643 (EPSG:3395)
   *         3: 2538932, 9069712 (EPSG:3857)
   * @return {String} Summary string for LatLng point
  */getCoordinatesString:function getCoordinatesString(latlng,num){var x=latlng.lng,y=latlng.lat,formats=['','',' (EPSG:3395)',' (EPSG:3857)'],len=formats.length,merc,out='';num=num||0;if(x>180){x-=360;}if(x<-180){x+=360;}if(num%len===0){out=gmxAPIutils.formatCoordinates2(x,y);}else if(num%len===1){out=gmxAPIutils.formatCoordinates(x,y);}else if(num%len===2){merc=L.Projection.Mercator.project(new L.LatLng(y,x));out=''+Math.round(merc.x)+', '+Math.round(merc.y)+formats[2];}else {merc=L.CRS.EPSG3857.project(new L.LatLng(y,x));out=''+Math.round(merc.x)+', '+Math.round(merc.y)+formats[3];}return out;},/** Get summary for geometries array
   * @memberof L.gmxUtil
   * @param {Array} geometries array in Geomixer format
   * @param {Object} units Options for length and area
   * @return {String} Summary string for geometries array
  */getGeometriesSummary:function getGeometriesSummary(arr,unitOptions){var out='',type='',res=0;if(!unitOptions){unitOptions={};}if(arr){arr.forEach(function(geom){if(geom){type=geom.type.toUpperCase();var latLngGeometry=L.gmxUtil.geometryToGeoJSON(geom,true,unitOptions.srs==3857);if(type.indexOf('POINT')!==-1){var latlng=L.latLng(latLngGeometry.coordinates.reverse());out='<b>'+gmxAPIutils.getText('Coordinates')+'</b>: '+gmxAPIutils.getCoordinatesString(latlng,unitOptions.coordinatesFormat);}else if(type.indexOf('LINESTRING')!==-1){res+=gmxAPIutils.geoJSONGetLength(latLngGeometry);}else if(type.indexOf('POLYGON')!==-1){res+=gmxAPIutils.geoJSONGetArea(latLngGeometry);}}});}if(!out){if(type.indexOf('LINESTRING')!==-1){out='<b>'+gmxAPIutils.getText('Length')+'</b>: '+gmxAPIutils.prettifyDistance(res,unitOptions.distanceUnit);}else if(type.indexOf('POLYGON')!==-1){out='<b>'+gmxAPIutils.getText('Area')+'</b>: '+gmxAPIutils.prettifyArea(res,unitOptions.squareUnit);}}return out;},getGeometrySummary:function getGeometrySummary(geom,unitOptions){return gmxAPIutils.getGeometriesSummary([geom],unitOptions||{});},chkOnEdge:function chkOnEdge(p1,p2,ext){// Ð¾ÑÑÐµÐ·Ð¾Ðº Ð½Ð° Ð³ÑÐ°Ð½Ð¸ÑÐµ
if(p1[0]<ext.min.x&&p2[0]<ext.min.x||p1[0]>ext.max.x&&p2[0]>ext.max.x){return true;}if(p1[1]<ext.min.y&&p2[1]<ext.min.y||p1[1]>ext.max.y&&p2[1]>ext.max.y){return true;}return false;},getHidden:function getHidden(coords,tb){// Ð¼Ð°ÑÑÐ¸Ð² ÑÐ¾ÑÐµÐº Ð½Ð° Ð³ÑÐ°Ð½Ð¸ÑÐ°Ñ ÑÐ°Ð¹Ð»Ð¾Ð²
var hiddenLines=[],vectorSize=typeof coords[0]==='number'?2:1,prev=null;for(var i=0,len=coords.length;i<len;i+=vectorSize){var p=vectorSize===1?coords[i]:[coords[i],coords[i+1]];if(prev&&gmxAPIutils.chkOnEdge(p,prev,tb)){hiddenLines.push(i);}prev=p;}return hiddenLines;},getNormalizeBounds:function getNormalizeBounds(screenBounds,mercDeltaY){// get bounds array from -180 180 lng
var northWest=screenBounds.getNorthWest(),southEast=screenBounds.getSouthEast(),minX=northWest.lng,maxX=southEast.lng,w=(maxX-minX)/2,minX1=null,maxX1=null,out=[];if(w>=180){minX=-180;maxX=180;}else if(maxX>180||minX<-180){var center=(maxX+minX)/2%360;if(center>180){center-=360;}else if(center<-180){center+=360;}minX=center-w;maxX=center+w;if(minX<-180){minX1=minX+360;maxX1=180;minX=-180;}else if(maxX>180){minX1=-180;maxX1=maxX-360;maxX=180;}}var m1={x:minX,y:southEast.lat},m2={x:maxX,y:northWest.lat};if(mercDeltaY!==undefined){m1=L.Projection.Mercator.project(new L.LatLng([southEast.lat,minX]));m2=L.Projection.Mercator.project(new L.LatLng([northWest.lat,maxX]));m1.y-=mercDeltaY;m2.y-=mercDeltaY;}out.push(gmxAPIutils.bounds([[m1.x,m1.y],[m2.x,m2.y]]));if(minX1){var m11={x:minX1,y:southEast.lat},m12={x:maxX1,y:northWest.lat};if(mercDeltaY!==undefined){m11=L.Projection.Mercator.project(new L.LatLng([southEast.lat,minX1]));m12=L.Projection.Mercator.project(new L.LatLng([northWest.lat,maxX1]));m11.y-=mercDeltaY;m12.y-=mercDeltaY;}out.push(gmxAPIutils.bounds([[m11.x,m11.y],[m12.x,m12.y]]));}return out;},toPrecision:function toPrecision(x,prec){var zn=Math.pow(10,prec?prec:4);return Math.round(zn*x)/zn;},getBoundsByTilePoint:function getBoundsByTilePoint(tPoint){//tPoint - OSM tile point
var gmt=gmxAPIutils.getTileNumFromLeaflet(tPoint);return gmxAPIutils.getTileBounds(gmt.x,gmt.y,gmt.z);},getTileBounds:function getTileBounds(x,y,z){//x, y, z - GeoMixer tile coordinates
var tileSize=gmxAPIutils.tileSizes[z],minx=x*tileSize,miny=y*tileSize;return gmxAPIutils.bounds([[minx,miny],[minx+tileSize,miny+tileSize]]);},parseTemplate:function parseTemplate(str,properties){var matches=str.match(/\[([^\]]+)\]/ig);if(matches){for(var i=0,len=matches.length;i<len;i++){var key1=matches[i],key=key1.substr(1,key1.length-2),res=key in properties?properties[key]:'';str=str.replace(key1,res);}}return str;},getDefaultBalloonTemplate:function getDefaultBalloonTemplate(properties,tileAttributeTypes){var str='';for(var key in properties){if(!tileAttributeTypes||key in tileAttributeTypes){str+='<b>'+key+':</b> ['+key+']<br />';}}str+='<br />[SUMMARY]<br />';return str;},parseBalloonTemplate:function parseBalloonTemplate(str,options){var properties=options.properties;if(!str){str=gmxAPIutils.getDefaultBalloonTemplate(properties,options.tileAttributeTypes);}var matches=str.match(/\[([^\]]+)\]/ig);if(matches){var tileAttributeTypes=options.tileAttributeTypes||{},unitOptions=options.unitOptions,geometries=options.geometries;for(var i=0,len=matches.length;i<len;i++){var key1=matches[i],key=key1.substr(1,key1.length-2),keyLC=key.toLowerCase(),val=properties[key]||properties[keyLC],type=tileAttributeTypes[key]||tileAttributeTypes[keyLC],res='';//if (key in properties) {
if(val!=undefined){res=L.gmxUtil.attrToString(type,val);}else if(key==='SUMMARY'){res=options.summary||L.gmxUtil.getGeometriesSummary(geometries,unitOptions);}str=str.replace(key1,res);}}return str;},styleKeys:{marker:{server:['image','angle','scale','minScale','maxScale','size','circle','center','color'],client:['iconUrl','iconAngle','iconScale','iconMinScale','iconMaxScale','iconSize','iconCircle','iconCenter','iconColor']},outline:{server:['color','opacity','thickness','dashes'],client:['color','opacity','weight','dashArray']},fill:{server:['color','opacity','image','pattern','radialGradient','linearGradient'],client:['fillColor','fillOpacity','fillIconUrl','fillPattern','fillRadialGradient','fillLinearGradient']},label:{server:['text','field','template','color','haloColor','size','spacing','align'],client:['labelText','labelField','labelTemplate','labelColor','labelHaloColor','labelFontSize','labelSpacing','labelAlign']}},styleFuncKeys:{// iconUrl: 'iconUrlFunction',
iconSize:'iconSizeFunction',iconAngle:'rotateFunction',iconScale:'scaleFunction',iconColor:'iconColorFunction',opacity:'opacityFunction',fillOpacity:'fillOpacityFunction',color:'colorFunction',fillColor:'fillColorFunction'},// styleFunc: {
// iconUrl: function() {
// console.log('styleFunc', arguments)
// return '';
// },
// },
styleFuncError:{// iconUrl: function() { return ''; },
iconSize:function iconSize(){return 8;},iconAngle:function iconAngle(){return 0;},iconScale:function iconScale(){return 1;},iconColor:function iconColor(){return 0xFF;},opacity:function opacity(){return 1;},fillOpacity:function fillOpacity(){return 0.5;},color:function color(){return 0xFF;},fillColor:function fillColor(){return 0xFF;}},defaultStyles:{MinZoom:1,MaxZoom:21,Filter:'',Balloon:'',DisableBalloonOnMouseMove:true,DisableBalloonOnClick:false,RenderStyle:{point:{// old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},
color:0xFF,weight:1,iconSize:8},linestring:{// old = {outline: {color: 255, thickness: 1}},
color:0xFF,weight:1},polygon:{// old = {outline: {color: 255, thickness: 1}},
color:0xFF,weight:1}}},getDefaultStyle:function getDefaultStyle(type){var from=gmxAPIutils.defaultStyles,out=L.extend({},from);out.RenderStyle=from.RenderStyle[type];return out;},toServerStyle:function toServerStyle(style){// Style leaflet->Scanex
var out={};for(var key in gmxAPIutils.styleKeys){var keys=gmxAPIutils.styleKeys[key];for(var i=0,len=keys.client.length;i<len;i++){var key1=keys.client[i];if(key1 in style){if(!out[key]){out[key]={};}var zn=style[key1];if(key1==='opacity'||key1==='fillOpacity'){zn*=100;}out[key][keys.server[i]]=zn;}}}if('iconAnchor'in style){if(!out.marker){out.marker={};}out.marker.dx=-style.iconAnchor[0];out.marker.dy=-style.iconAnchor[1];}return out;},fromServerStyle:function fromServerStyle(style){// Style Scanex->leaflet
var st,i,len,key,key1,out={type:''// 'polygon', 'line', 'circle', 'square', 'image'
};for(key in gmxAPIutils.styleKeys){var keys=gmxAPIutils.styleKeys[key];for(i=0,len=keys.client.length;i<len;i++){key1=keys.client[i];if(key1 in style){out[key1]=style[key1];}}st=style[key];if(st&&_typeof$1(st)==='object'){for(i=0,len=keys.server.length;i<len;i++){key1=keys.server[i];if(key1 in st){var newKey=keys.client[i],zn=st[key1];if(typeof zn==='string'){// var func = gmxAPIutils.styleFunc[newKey];
// if (func) {
// styleOut[gmxAPIutils.styleFuncKeys[newKey]] = func;
// } else if (gmxAPIutils.styleFuncKeys[newKey]) {
if(gmxAPIutils.styleFuncKeys[newKey]){/*eslint-disable no-useless-escape */if(zn.match(/[^\d\.]/)===null){/*eslint-enable */zn=Number(zn);}else {var func=L.gmx.Parsers.parseExpression(zn);if(func===null){zn=gmxAPIutils.styleFuncError[newKey]();}else {out[gmxAPIutils.styleFuncKeys[newKey]]=func;}}}}else if(key1==='opacity'){zn/=100;}out[newKey]=zn;}}}}if(style.marker){st=style.marker;if('dx'in st||'dy'in st){var dx=st.dx||0,dy=st.dy||0;out.iconAnchor=[-dx,-dy];// For leaflet type iconAnchor
}}for(key in style){if(!gmxAPIutils.styleKeys[key]){out[key]=style[key];}}return out;},getUnixTimeFromStr:function getUnixTimeFromStr(st){var arr1=L.Util.trim(st).split(' '),arr=arr1[0].split('.'),tm=arr1[1]?arr1[1].split(':'):[0,0,0];if(arr[2].length===4){arr=arr.reverse();}return Date.UTC(arr[0],arr[1]-1,arr[2],tm[0]||0,tm[1]||0,tm[2]||0)/1000;},getDateFromStr:function getDateFromStr(st){var arr=L.Util.trim(st).split(' ');arr=arr[0].split('.');if(arr[2].length===4){arr=arr.reverse();}var dt=new Date(arr[0],arr[1]-1,arr[2]);return dt;},getUTCdate:function getUTCdate(utime){var dt=new Date(utime*1000);return [dt.getUTCFullYear(),gmxAPIutils.pad2(dt.getUTCMonth()+1),gmxAPIutils.pad2(dt.getUTCDate())].join('.');},getUTCtime:function getUTCtime(utime){var h=Math.floor(utime/3600),m=Math.floor((utime-h*3600)/60),s=Math.floor(utime-h*3600-m*60);return [//gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),
gmxAPIutils.pad2(h),gmxAPIutils.pad2(m),gmxAPIutils.pad2(s)].join(':');},getUTCdateTime:function getUTCdateTime(utime){var time=utime%(3600*24);if(time){return [gmxAPIutils.getUTCdate(utime),gmxAPIutils.getUTCtime(utime%(3600*24))].join(' ');}else {return gmxAPIutils.getUTCdate(utime);}},attrToString:function attrToString(type,value){if(type==='date'){return value?L.gmxUtil.getUTCdate(value):value;}else if(type==='time'){return value?L.gmxUtil.getUTCtime(value):value;}else if(type==='datetime'){return value?L.gmxUtil.getUTCdateTime(value):value;}else {return value;}},getTileAttributes:function getTileAttributes(prop){var tileAttributeIndexes={},tileAttributeTypes={};if(prop.attributes){var attrs=prop.attributes,attrTypes=prop.attrTypes||null;if(prop.identityField){tileAttributeIndexes[prop.identityField]=0;}for(var a=0;a<attrs.length;a++){var key=attrs[a];tileAttributeIndexes[key]=a+1;tileAttributeTypes[key]=attrTypes?attrTypes[a]:'string';}}return {tileAttributeTypes:tileAttributeTypes,tileAttributeIndexes:tileAttributeIndexes};}};gmxAPIutils.lambertCoefX=100*gmxAPIutils.distVincenty(0,0,0.01,0);// 111319.5;
gmxAPIutils.lambertCoefY=100*gmxAPIutils.distVincenty(0,0,0,0.01)*180/Math.PI;// 6335440.712613423;
(function(){//pre-calculate tile sizes
for(var z=0;z<30;z++){gmxAPIutils.tileSizes[z]=gmxAPIutils.worldWidthFull/Math.pow(2,z);}})();gmxAPIutils.worldWidthMerc=gmxAPIutils.worldWidthFull/2;gmxAPIutils.Bounds=function(arr){this.min={x:Number.MAX_VALUE,y:Number.MAX_VALUE};this.max={x:-Number.MAX_VALUE,y:-Number.MAX_VALUE};this.extendArray(arr);};gmxAPIutils.Bounds.prototype={extend:function extend(x,y){if(x<this.min.x){this.min.x=x;}if(x>this.max.x){this.max.x=x;}if(y<this.min.y){this.min.y=y;}if(y>this.max.y){this.max.y=y;}return this;},extendBounds:function extendBounds(bounds){return this.extendArray([[bounds.min.x,bounds.min.y],[bounds.max.x,bounds.max.y]]);},extendArray:function extendArray(arr){if(!arr||!arr.length){return this;}var i,len;if(typeof arr[0]==='number'){for(i=0,len=arr.length;i<len;i+=2){this.extend(arr[i],arr[i+1]);}}else {for(i=0,len=arr.length;i<len;i++){this.extend(arr[i][0],arr[i][1]);}}return this;},addBuffer:function addBuffer(dxmin,dymin,dxmax,dymax){this.min.x-=dxmin;this.min.y-=dymin||dxmin;this.max.x+=dxmax||dxmin;this.max.y+=dymax||dymin||dxmin;return this;},contains:function contains(point){// ([x, y]) -> Boolean
var min=this.min,max=this.max,x=point[0],y=point[1];return x>=min.x&&x<=max.x&&y>=min.y&&y<=max.y;},getCenter:function getCenter(){var min=this.min,max=this.max;return [(min.x+max.x)/2,(min.y+max.y)/2];},addOffset:function addOffset(offset){this.min.x+=offset[0];this.max.x+=offset[0];this.min.y+=offset[1];this.max.y+=offset[1];return this;},intersects:function intersects(bounds){// (Bounds) -> Boolean
var min=this.min,max=this.max,min2=bounds.min,max2=bounds.max;return max2.x>min.x&&min2.x<max.x&&max2.y>min.y&&min2.y<max.y;},intersectsWithDelta:function intersectsWithDelta(bounds,dx,dy){// (Bounds, dx, dy) -> Boolean
var min=this.min,max=this.max,x=dx||0,y=dy||0,min2=bounds.min,max2=bounds.max;return max2.x+x>min.x&&min2.x-x<max.x&&max2.y+y>min.y&&min2.y-y<max.y;},isEqual:function isEqual(bounds){// (Bounds) -> Boolean
var min=this.min,max=this.max,min2=bounds.min,max2=bounds.max;return max2.x===max.x&&min2.x===min.x&&max2.y===max.y&&min2.y===min.y;},isNodeIntersect:function isNodeIntersect(coords){for(var i=0,len=coords.length;i<len;i++){if(this.contains(coords[i])){return {num:i,point:coords[i]};}}return null;},clipPolygon:function clipPolygon(points,round){if(points.length){var clippedPoints,edges=[1,4,2,8],i,j,k,a,b,len,edge,p;if(L.LineUtil.isFlat(points)){var coords=points;points=coords.map(function(it){return new L.Point(it[0],it[1],round);});}for(i=0,len=points.length;i<len;i++){points[i]._code=this._getBitCode(points[i]);}// for each edge (left, bottom, right, top)
for(k=0;k<4;k++){edge=edges[k];clippedPoints=[];for(i=0,len=points.length,j=len-1;i<len;j=i++){a=points[i];b=points[j];// if a is inside the clip window
if(!(a._code&edge)){// if b is outside the clip window (a->b goes out of screen)
if(b._code&edge){p=this._getEdgeIntersection(b,a,edge,round);p._code=this._getBitCode(p);clippedPoints.push(p);}clippedPoints.push(a);// else if b is inside the clip window (a->b enters the screen)
}else if(!(b._code&edge)){p=this._getEdgeIntersection(b,a,edge,round);p._code=this._getBitCode(p);clippedPoints.push(p);}}points=clippedPoints;}}return points.map(function(it){return [it.x,it.y];});},_getBitCode:function _getBitCode(p){var code=0;if(p.x<this.min.x){// left
code|=1;}else if(p.x>this.max.x){// right
code|=2;}if(p.y<this.min.y){// bottom
code|=4;}else if(p.y>this.max.y){// top
code|=8;}return code;},_getEdgeIntersection:function _getEdgeIntersection(a,b,code,round){var dx=b.x-a.x,dy=b.y-a.y,min=this.min,max=this.max,x,y;if(code&8){// top
x=a.x+dx*(max.y-a.y)/dy;y=max.y;}else if(code&4){// bottom
x=a.x+dx*(min.y-a.y)/dy;y=min.y;}else if(code&2){// right
x=max.x;y=a.y+dy*(max.x-a.x)/dx;}else if(code&1){// left
x=min.x;y=a.y+dy*(min.x-a.x)/dx;}return new L.Point(x,y,round);},clipPolyLine:function clipPolyLine(coords,angleFlag,delta){// (coords) -> clip coords
delta=delta||0;var min=this.min,max=this.max,bbox=[min.x-delta,min.y-delta,max.x+delta,max.y+delta],bitCode=function bitCode(p){var code=0;if(p[0]<bbox[0])code|=1;// left
else if(p[0]>bbox[2])code|=2;// right
if(p[1]<bbox[1])code|=4;// bottom
else if(p[1]>bbox[3])code|=8;// top
return code;},getAngle=function getAngle(a,b){return Math.PI/2+Math.atan2(b[1]-a[1],a[0]-b[0]);},intersect=function intersect(a,b,edge){return edge&8?[a[0]+(b[0]-a[0])*(bbox[3]-a[1])/(b[1]-a[1]),bbox[3]]:// top
edge&4?[a[0]+(b[0]-a[0])*(bbox[1]-a[1])/(b[1]-a[1]),bbox[1]]:// bottom
edge&2?[bbox[2],a[1]+(b[1]-a[1])*(bbox[2]-a[0])/(b[0]-a[0])]:// right
edge&1?[bbox[0],a[1]+(b[1]-a[1])*(bbox[0]-a[0])/(b[0]-a[0])]:// left
null;},result=[],len=coords.length,codeA=bitCode(coords[0]),part=[],i,a,b,c,codeB,lastCode;for(i=1;i<len;i++){a=coords[i-1];b=coords[i];if(a[0]===b[0]&&a[1]===b[1]){continue;}codeB=lastCode=bitCode(b);while(true){if(!(codeA|codeB)){// accept
if(angleFlag){a[2]=getAngle(a,b);c=coords[i+1];b[2]=c?getAngle(b,c):a[2];}part.push(a);if(codeB!==lastCode){// segment went outside
part.push(b);if(i<len-1){// start a new line
result.push(part);part=[];}}else if(i===len-1){part.push(b);}break;}else if(codeA&codeB){// trivial reject
break;}else if(codeA){// a outside, intersect with clip edge
a=intersect(a,b,codeA);codeA=bitCode(a);}else {// b outside
b=intersect(a,b,codeB);codeB=bitCode(b);}}codeA=lastCode;}if(part.length)result.push(part);return result;},toLatLngBounds:function toLatLngBounds(isWebMerc){var proj=L.Projection.Mercator,min=proj.unproject(this.min),max=proj.unproject(this.max),arr=[[min.lat,min.lng],[max.lat,max.lng]];if(isWebMerc){arr[0][0]=gmxAPIutils.fromWebMercY(this.min.y);arr[1][0]=gmxAPIutils.fromWebMercY(this.max.y);}return L.latLngBounds(arr);}};gmxAPIutils.bounds=function(arr){return new gmxAPIutils.Bounds(arr);};//ÑÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð° Ð¸Ð· API Ð´Ð»Ñ Ð¾Ð±ÐµÑÐ¿ÐµÑÐµÐ½Ð¸Ñ Ð½ÐµÐ·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐ¸ Ð¾Ñ Ð½ÐµÐ³Ð¾
gmxAPIutils.parseUri=function(str){var o=gmxAPIutils.parseUri.options,m=o.parser[o.strictMode?'strict':'loose'].exec(str),uri={},i=14;while(i--){uri[o.key[i]]=m[i]||'';}uri[o.q.name]={};uri[o.key[12]].replace(o.q.parser,function($0,$1,$2){if($1){uri[o.q.name][$1]=$2;}});uri.hostOnly=uri.host;uri.host=uri.authority;// HACK
return uri;};gmxAPIutils.parseUri.options={strictMode:false,key:['source','protocol','authority','userInfo','user','password','host','port','relative','path','directory','file','query','anchor'],q:{name:'queryKey',parser:/(?:^|&)([^&=]*)=?([^&]*)/g},/*eslint-disable no-useless-escape */parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}/*eslint-enable */};gmxAPIutils.layerHelper={/**
   *  ÐÐ¾Ð´Ð¸ÑÐ¸ÑÐ¸ÑÑÐµÑ Ð¾Ð±ÑÐµÐºÑÑ Ð²Ð½ÑÑÑÐ¸ Ð²ÐµÐºÑÐ¾ÑÐ½Ð¾Ð³Ð¾ ÑÐ»Ð¾Ñ, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑ Ð¸ Ð¸Ð½ÑÐ¾ÑÐ¼Ð¸ÑÑÑ Ð¾Ð± ÑÑÐ¾Ð¼ API
   *
   * @memberOf _mapHelper
   * @name modifyObjectLayer
   * @function
   * @param {String} layerName ÐÐ¼Ñ ÑÐ»Ð¾Ñ
   * @param {Object[]} objs ÐÐ°ÑÑÐ¸Ð² Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð². ÐÐ°Ð¶Ð´Ð¾Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÐµÑ Ð¸Ð· ÑÐµÐ±Ñ Ð¾Ð±ÑÐµÐºÑ:
   *
   *  * id {String} ID Ð¾Ð±ÑÐµÐºÑÐ° ÑÐ»Ð¾Ñ, Ð½Ð°Ð´ ÐºÐ¾ÑÐ¾ÑÑÐ¼ Ð¿ÑÐ¾Ð¸Ð·Ð²Ð¾Ð´ÑÑÑÑ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ (ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ Ð¼Ð¾Ð´Ð¸ÑÐ¸ÐºÐ°ÑÐ¸Ð¸ Ð¸ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ)
   *  * geometry ÐÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð³ÐµÐ¾Ð¼ÐµÑÑÐ¸Ð¸ (Ð²ÑÑÐ°Ð²ÐºÐ° Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ). GeoJSON
   *  * source: {rc: <name ÐÐ -Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ°>, rcobj: <id Ð¾Ð±ÑÐµÐºÑÐ° Ð²Ð½ÑÑÑÐ¸ ÐÐ >}
   *  * properties Ð¡Ð²Ð¾Ð¹ÑÑÐ²Ð° Ð¾Ð±ÑÐµÐºÑÐ° (Ð²ÑÑÐ°Ð²ÐºÐ° Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ)
   *  * action {'delete'|'insert'|'update'} ÐÑÐ¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ð¼Ð¾Ðµ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ðµ. ÐÑÐ»Ð¸ Ð½Ðµ ÑÐºÐ°Ð·Ð°Ð½Ð¾, ÑÐ¾ Ð²ÑÑÐ¸ÑÐ»ÑÐµÑÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:
   *    * ÐÑÐ»Ð¸ Ð½Ðµ ÑÐºÐ°Ð·Ð°Ð½ id, ÑÐ¾ Ð²ÑÑÐ°Ð²ÐºÐ°
   *    * ÐÑÐ»Ð¸ ÑÐºÐ°Ð·Ð°Ð½ id, ÑÐ¾ Ð¼Ð¾Ð´Ð¸ÑÐ¸ÑÐ¸ÑÑÐµÐ¼
   *    * ÐÐ»Ñ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ð¾Ð±ÑÐµÐºÑÐ° Ð½ÑÐ¶Ð½Ð¾ ÑÐ²Ð½Ð¾ Ð¿ÑÐ¾Ð¿Ð¸ÑÐ°ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ
   * @param {String} [crs='EPSG:3395'] ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ ÑÐ¸ÑÑÐµÐ¼Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ Ð³ÐµÐ¾Ð¼ÐµÑÑÐ¸Ð¸ Ð¾Ð±ÑÐµÐºÑÐ¾Ð². ÐÐ¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÑÑÑÑ 3395, 4326, 3857
   * @return {jQuery.Deferred} Ð ÐµÑÐ¾Ð»Ð²Ð¸ÑÑÑ Ð² ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¸Ð¸ Ñ Ð¾ÑÐ²ÐµÑÐ¾Ð¼ ÑÐµÑÐ²ÐµÑÐ°
  */modifyObject:function modifyObject(url,layerName,objs,crs){return new Promise(function(resolve,reject){objs.forEach(function(obj){obj.action=obj.action||(obj.id?'update':'insert');});var params={WrapStyle:'None',LayerName:layerName,objects:JSON.stringify(objs)};params['geometry_cs']=crs?crs:'EPSG:4326';L.gmxUtil.sendCrossDomainPostRequest(url,params,function(res){if(res&&res.Status==='ok'){L.gmx.layersVersion.chkVersion(layerName);resolve(res.Result);}else {reject();}});}).catch(console.log);}};if(!L.gmxUtil){L.gmxUtil={};}//public interface
var pNavigation=self.performance&&self.performance.getEntriesByType('navigation')[0];L.extend(L.gmxUtil,{isHTTP2:pNavigation&&pNavigation.nextHopProtocol==='h2',debug:gmxAPIutils.debug,createWorker:gmxAPIutils.createWorker,apiLoadedFrom:gmxAPIutils.apiLoadedFrom,searchScriptPars:gmxAPIutils.searchScriptPars,urlKeys:gmxAPIutils.urlKeys,newId:gmxAPIutils.newId,isPageHidden:gmxAPIutils.isPageHidden,protocol:location.protocol!=='https:'?'http:':location.protocol,prefixURL:location.href.substr(0,location.href.lastIndexOf('/')+1),loaderStatus:function loaderStatus(){},isIE9:gmxAPIutils.isIE(9),isIE10:gmxAPIutils.isIE(10),isIE11:gmxAPIutils.isIE(11),gtIE11:gmxAPIutils.gtIE(11),getText:gmxAPIutils.getText,getFormData:gmxAPIutils.getFormData,requestJSONP:gmxAPIutils.requestJSONP,requestLink:gmxAPIutils.requestLink,getCadastreFeatures:gmxAPIutils.getCadastreFeatures,request:gmxAPIutils.request,getLayerItemFromServer:gmxAPIutils.getLayerItemFromServer,fromServerStyle:gmxAPIutils.fromServerStyle,toServerStyle:gmxAPIutils.toServerStyle,getDefaultStyle:gmxAPIutils.getDefaultStyle,bounds:gmxAPIutils.bounds,getNormalizeBounds:gmxAPIutils.getNormalizeBounds,getGeometryBounds:gmxAPIutils.getGeometryBounds,tileSizes:gmxAPIutils.tileSizes,getDateFromStr:gmxAPIutils.getDateFromStr,getUnixTimeFromStr:gmxAPIutils.getUnixTimeFromStr,getUTCdate:gmxAPIutils.getUTCdate,getUTCtime:gmxAPIutils.getUTCtime,getUTCdateTime:gmxAPIutils.getUTCdateTime,attrToString:gmxAPIutils.attrToString,getTileAttributes:gmxAPIutils.getTileAttributes,formatCoordinates:function formatCoordinates(latlng,type){return gmxAPIutils['formatCoordinates'+(type?'2':'')](latlng.lng,latlng.lat);},formatDegrees:gmxAPIutils.formatDegrees,pad2:gmxAPIutils.pad2,dec2hex:gmxAPIutils.dec2hex,dec2rgba:gmxAPIutils.dec2rgba,trunc:gmxAPIutils.trunc,latLonFormatCoordinates:gmxAPIutils.latLonFormatCoordinates,latLonFormatCoordinates2:gmxAPIutils.latLonFormatCoordinates2,latLonToString:gmxAPIutils.latLonToString,toPrecision:gmxAPIutils.toPrecision,getLength:gmxAPIutils.getLength,geoLength:gmxAPIutils.geoLength,prettifyDistance:gmxAPIutils.prettifyDistance,getArea:gmxAPIutils.getArea,prettifyArea:gmxAPIutils.prettifyArea,geoArea:gmxAPIutils.geoArea,parseBalloonTemplate:gmxAPIutils.parseBalloonTemplate,setSVGIcon:gmxAPIutils.setSVGIcon,getSVGIcon:gmxAPIutils.getSVGIcon,getCoordinatesString:gmxAPIutils.getCoordinatesString,getGeometriesSummary:gmxAPIutils.getGeometriesSummary,getGeometrySummary:gmxAPIutils.getGeometrySummary,getGeoJSONSummary:gmxAPIutils.getGeoJSONSummary,getPropertiesHash:gmxAPIutils.getPropertiesHash,distVincenty:gmxAPIutils.distVincenty,parseCoordinates:gmxAPIutils.parseCoordinates,geometryToGeoJSON:gmxAPIutils.geometryToGeoJSON,coordsFromMercator:gmxAPIutils.coordsFromMercator,convertGeometry:gmxAPIutils.convertGeometry,transformGeometry:gmxAPIutils.transformGeometry,geoJSONtoGeometry:gmxAPIutils.geoJSONtoGeometry,geoJSONGetArea:gmxAPIutils.geoJSONGetArea,geoJSONGetLength:gmxAPIutils.geoJSONGetLength,geoJSONGetLatLng:gmxAPIutils.geoJSONGetLatLng,fromWebMercY:gmxAPIutils.fromWebMercY,parseUri:gmxAPIutils.parseUri,isRectangle:gmxAPIutils.isRectangle,isClockwise:gmxAPIutils.isClockwise,isPointInPolygonWithHoles:gmxAPIutils.isPointInPolygonWithHoles,getPatternIcon:gmxAPIutils.getPatternIcon,getCircleLatLngs:gmxAPIutils.getCircleLatLngs,normalizeHostname:gmxAPIutils.normalizeHostname,getTileBounds:gmxAPIutils.getTileBounds,getBoundsByTilePoint:gmxAPIutils.getBoundsByTilePoint,parseTemplate:gmxAPIutils.parseTemplate});L.gmxUtil.layerHelper=gmxAPIutils.layerHelper;L.gmxUtil.isOldVersion=L.version.substr(0,3)==='0.7';L.gmxUtil.isIEOrEdge=L.gmxUtil.gtIE11||L.gmxUtil.isIE11||L.gmxUtil.isIE10||L.gmxUtil.isIE9;if(!('requestIdleCallback'in window)){window.requestIdleCallback=function(func,opt){var timeout=opt?opt.timeout:0;return window.setTimeout(func,timeout);};window.cancelIdleCallback=window.clearTimeout;}if(!String.prototype.eval){// ES6-like template strings in ES5 - example: 'Hello, ${nested["greeting"]}!'.eval(data);
/*eslint-disable */String.prototype.eval=function(data){return this.replace(/\${(.*?)}/g,function(_,code){var scoped=code.replace(/(["'\.\w\$]+)/g,function(match){return /["']/.test(match[0])?match:'scope.'+match;});try{return new Function('scope','return '+scoped)(data);}catch(e){return '';}});};/*eslint-enable */}L.gmx=L.gmx||{};L.gmx.gmxProxy=window.serverBase&&window.serverBase+'proxy'||'//maps.kosmosnimki.ru/proxy';(function(){var requests={};var lastRequestId=0;var processMessage=function processMessage(e){if(!(e.origin in requests)){return;}var dataStr=decodeURIComponent(e.data.replace(/\n/g,'\n\\'));try{var dataObj=JSON.parse(dataStr);}catch(ev){console.log({Status:'error',ErrorInfo:{ErrorMessage:'JSON.parse exeption',ExceptionType:'JSON.parse',StackTrace:dataStr}});}var request=requests[e.origin][dataObj.CallbackName];if(!request){return;// message Ð¾Ñ Ð´ÑÑÐ³Ð¸Ñ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð²
}delete requests[e.origin][dataObj.CallbackName];delete dataObj.CallbackName;if(request.iframe.parentNode){request.iframe.parentNode.removeChild(request.iframe);}if('callback'in request){request.callback(dataObj);}};L.DomEvent.on(window,'message',processMessage);function createPostIframe2(id,callback,url){var uniqueId='gmxAPIutils_id'+lastRequestId++,iframe=L.DomUtil.create('iframe');iframe.style.display='none';iframe.setAttribute('id',id);iframe.setAttribute('name',id);/*eslint-disable no-script-url */iframe.src='javascript:true';/*eslint-enable */iframe.callbackName=uniqueId;var parsedURL=gmxAPIutils.parseUri(url);var origin=(parsedURL.protocol?parsedURL.protocol+':':L.gmxUtil.protocol)+'//'+(parsedURL.host||window.location.host);requests[origin]=requests[origin]||{};requests[origin][uniqueId]={callback:callback,iframe:iframe};return iframe;}//ÑÐ°ÑÑÐ¸ÑÑÐµÐ¼ namespace
gmxAPIutils.createPostIframe2=createPostIframe2;})();// ÐºÑÐ¾ÑÑÐ´Ð¾Ð¼ÐµÐ½Ð½ÑÐ¹ POST Ð·Ð°Ð¿ÑÐ¾Ñ
(function(){/** ÐÐ¾ÑÑÐ»Ð°ÐµÑ ÐºÑÐ¾ÑÑÐ´Ð¾Ð¼ÐµÐ½Ð½ÑÐ¹ POST Ð·Ð°Ð¿ÑÐ¾Ñ
  * @namespace L.gmxUtil
     * @ignore
  * @function
  *
  * @param url {string} - URL Ð·Ð°Ð¿ÑÐ¾ÑÐ°
  * @param params {object} - ÑÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð²-Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð²
  * @param callback {function} - callback, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð²ÑÐ·ÑÐ²Ð°ÐµÑÑÑ Ð¿ÑÐ¸ Ð¿ÑÐ¸ÑÐ¾Ð´Ðµ Ð¾ÑÐ²ÐµÑÐ° Ñ ÑÐµÑÐ²ÐµÑÐ°. ÐÐ´Ð¸Ð½ÑÑÐ²ÐµÐ½Ð½ÑÐ¹ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑ Ñ-ÑÐ¸Ð¸ - ÑÐ¾Ð±ÑÑÐ²ÐµÐ½Ð½Ð¾ Ð´Ð°Ð½Ð½ÑÐµ
  * @param baseForm {DOMElement} - Ð±Ð°Ð·Ð¾Ð²Ð°Ñ ÑÐ¾ÑÐ¼Ð° Ð·Ð°Ð¿ÑÐ¾ÑÐ°. ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ, ÐºÐ¾Ð³Ð´Ð° Ð½ÑÐ¶Ð½Ð¾ Ð¾ÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð½Ð° ÑÐµÑÐ²ÐµÑ ÑÐ°Ð¹Ð».
  *                                Ð ÑÑÐ½ÐºÑÐ¸Ð¸ ÑÑÐ° ÑÐ¾ÑÐ¼Ð° Ð±ÑÐ´ÐµÑ Ð¼Ð¾Ð´Ð¸ÑÐ¸ÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ, Ð½Ð¾ Ð¿Ð¾ÑÐ»Ðµ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ñ Ð·Ð°Ð¿ÑÐ¾ÑÐ° Ð±ÑÐ´ÐµÑ Ð¿ÑÐ¸Ð²ÐµÐ´ÐµÐ½Ð° Ðº Ð¸ÑÑÐ¾Ð´Ð½Ð¾Ð¼Ñ Ð²Ð¸Ð´Ñ.
  */function sendCrossDomainPostRequest(url,params,callback,baseForm){var form,id='$$iframe_'+gmxAPIutils.newId();var iframe=gmxAPIutils.createPostIframe2(id,callback,url),originalFormAction;if(baseForm){form=baseForm;originalFormAction=form.getAttribute('action');form.setAttribute('action',url);form.target=id;}else if(L.Browser.ielt9){var str='<form id='+id+'" enctype="multipart/form-data" style="display:none" target="'+id+'" action="'+url+'" method="post"></form>';form=document.createElement(str);}else {form=document.createElement('form');form.style.display='none';form.setAttribute('enctype','multipart/form-data');form.target=id;form.setAttribute('method','POST');form.setAttribute('action',url);form.id=id;}var hiddenParamsDiv=document.createElement('div');hiddenParamsDiv.style.display='none';if(params.WrapStyle==='window'){params.WrapStyle='message';}if(params.WrapStyle==='message'){params.CallbackName=iframe.callbackName;}for(var paramName in params){var input=document.createElement('input');var value=typeof params[paramName]!=='undefined'?params[paramName]:'';input.setAttribute('type','hidden');input.setAttribute('name',paramName);input.setAttribute('value',value);hiddenParamsDiv.appendChild(input);}form.appendChild(hiddenParamsDiv);if(!baseForm){document.body.appendChild(form);}document.body.appendChild(iframe);form.submit();if(baseForm){form.removeChild(hiddenParamsDiv);if(originalFormAction!==null){form.setAttribute('action',originalFormAction);}else {form.removeAttribute('action');}}else {form.parentNode.removeChild(form);}}//ÑÐ°ÑÑÐ¸ÑÑÐµÐ¼ namespace
L.gmxUtil.sendCrossDomainPostRequest=gmxAPIutils.sendCrossDomainPostRequest=sendCrossDomainPostRequest;})();/*
   Single-pass recursive descent PEG parser library:
      http://en.wikipedia.org/wiki/Parsing_expression_grammar
   Inspired by Chris Double's parser combinator library in JavaScript:
      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html
	+ ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ ÑÑÐ½ÐºÑÐ¸Ð¸: Math.floor
*/(function(){var regexExpression=/\[(.+?)\]/g,regexMath=/(floor\()/g;var Parsers={// ÐÐ°ÑÑÐµÑÑ
functionFromExpression:function functionFromExpression(s){/*eslint-disable no-new-func*/return new Function(/*eslint-enable */'props','indexes','return '+s.replace(regexExpression,'props[indexes["$1"]]').replace(regexMath,'Math.$1')+';');}};var makePair=function makePair(t1,t2){return {head:t1,tail:t2};};// C-style linked list via recursive typedef.
//   Used purely functionally to get shareable sublists.
//typedef LinkedList = Pair<Dynamic, LinkedList>;
var LinkedList=function LinkedList(t1,t2){return makePair(t1,t2);};// Parser state contains position in string and some accumulated data.
//typedef ParserState = Pair<Int, LinkedList>;
var ParserState=function ParserState(t1,t2){return makePair(t1,t2);};// Parser accepts string and state, returns another state.
//typedef Parser = String->ParserState->ParserState;
// A parser state that indicates failure.
var fail=new ParserState(-1,null);// Check for failure.
var failed=function failed(state){return state.head===-1;};// Advance a parser state by n characters.
var advance=function advance(state,n){return new ParserState(state.head+n,state.tail);};// Match a specified string.
var token=function token(tok){var len=tok.length;return function(s,state){return s.substr(state.head,len)===tok?advance(state,len):fail;};};// Match a string without regard to case.
var caseInsensitiveToken=function caseInsensitiveToken(tok){var len=tok.length;tok=tok.toLowerCase();return function(s,state){return s.substr(state.head,len).toLowerCase()===tok?advance(state,len):fail;};};// Match a single character in a specified range.
var range=function range(startChar,endChar){var startCode=startChar.charCodeAt(0);var endCode=endChar.charCodeAt(0);return function(s,state){var code=s.charCodeAt(state.head);return code>=startCode&&code<=endCode?advance(state,1):fail;};};// Match any character outside a certain set.
//   This combinator is intended only for single character parsers.
var anythingExcept=function anythingExcept(parser){return function(s,state){return s.length>state.head&&failed(parser(s,state))?advance(state,1):fail;};};// Match thing1, then thing2, ..., then thingN.
var sequence=function sequence(parsers){return function(s,state){for(var i=0;i<parsers.length;i++){state=parsers[i](s,state);if(failed(state)){return fail;}}return state;};};// Match thing1, or thing2, ..., or thingN.
var choice=function choice(parsers){return function(s,state){for(var i=0;i<parsers.length;i++){var newState=parsers[i](s,state);if(!failed(newState)){return newState;}}return fail;};};// Match immediately, without regard to what's in the string.
var nothing=function nothing(s,state){return state;};// Match this thing or nothing.
var maybe=function maybe(parser){return choice([parser,nothing]);};// Match minCount or more repetitions of this thing.
var repeat=function repeat(minCount,parser){return function(s,state){var count=0;while(true){var newState=parser(s,state);if(failed(newState)){return count>=minCount?state:fail;}else {count+=1;state=newState;}}// return fail;
};};// Match a list of minCount or more instances of thing1, separated by thing2.
var separatedList=function separatedList(minCount,parser,separator){var parser1=sequence([parser,repeat(minCount-1,sequence([separator,parser]))]);return minCount>0?parser1:choice([parser1,nothing]);};var whitespace=repeat(0,choice([token(' '),token('\t'),token('\n')]));// Same as separatedList, but can have whitespace between items and separators.
var whitespaceSeparatedList=function whitespaceSeparatedList(minCount,parser,separator){return separatedList(minCount,parser,sequence([whitespace,separator,whitespace]));};// Same as sequence, but can have whitespace between items.
var whitespaceSeparatedSequence=function whitespaceSeparatedSequence(parsers){var newParsers=[];for(var i=0;i<parsers.length;i++){if(newParsers.length>0){newParsers.push(whitespace);}newParsers.push(parsers[i]);}return sequence(newParsers);};// This combinator captures the string that the parser matched
//   and adds it to the current parser state, consing a new state.
var capture=function capture(parser){return function(s,state){var newState=parser(s,state);return failed(newState)?fail:new ParserState(newState.head,new LinkedList(s.substr(state.head,newState.head-state.head),newState.tail));};};// This combinator passes the accumulated parser state to a given
//  function for processing. The result goes into the new state.
var action=function action(parser,func){return function(s,state){var oldState=state;var newState=parser(s,new ParserState(oldState.head,null));return failed(newState)?fail:new ParserState(newState.head,new LinkedList(func(newState.tail),oldState.tail));};};// Define a syntactic subset of SQL WHERE clauses.
var fieldName=capture(repeat(1,choice([range('a','z'),range('A','Z'),range('Ð°','Ñ'),range('Ð','Ð¯'),range('0','9'),token('_')])));var fieldNameWithSpaces=capture(repeat(1,choice([range('a','z'),range('A','Z'),range('Ð°','Ñ'),range('Ð','Ð¯'),range('0','9'),token('_'),token(' ')])));var quotedFieldName=choice([fieldName,sequence([token('"'),fieldNameWithSpaces,token('"')]),sequence([token('`'),fieldNameWithSpaces,token('`')])]);var stringLiteral=sequence([token('\''),capture(repeat(0,anythingExcept(token('\'')))),token('\'')]);var digits=repeat(1,range('0','9'));var numberLiteral=capture(sequence([maybe(token('-')),digits,maybe(sequence([token('.'),digits]))]));var literal=choice([numberLiteral,stringLiteral]);var applyParser=function applyParser(s,parser){return parser(s,new ParserState(0,null));};// Order is important here: longer ops should be tried first.
var opTerm=action(whitespaceSeparatedSequence([quotedFieldName,capture(choice([token('=='),token('!='),token('<>'),token('<='),token('>='),token('='),token('<'),token('>'),caseInsensitiveToken('LIKE')])),choice([literal,quotedFieldName])]),function(state){// Linked list contains fieldname, operation, value
// (in reverse order).
var fieldName=state.tail.tail.head;var op=state.tail.head;var referenceValue=state.head;var matchPattern=null;if(op.toUpperCase()==='LIKE'){matchPattern=function matchPattern(fieldValue){var _matchFrom=null;_matchFrom=function matchFrom(referenceIdx,fieldIdx){var referenceChar=referenceValue.charAt(referenceIdx);var fieldChar=fieldValue.charAt(fieldIdx);if(referenceChar===''){return fieldChar==='';}else if(referenceChar==='%'){return _matchFrom(referenceIdx+1,fieldIdx)||fieldChar!==''&&_matchFrom(referenceIdx,fieldIdx+1);}else {return referenceChar===fieldChar&&_matchFrom(referenceIdx+1,fieldIdx+1);}};return _matchFrom(0,0);};}return function(props,indexes,types){var fieldValue=props[indexes[fieldName]],rValue=referenceValue;if(referenceValue in indexes){rValue=props[indexes[rValue]];}if((types[fieldName]==='date'||types[fieldName]==='datetime')&&typeof rValue==='string'){rValue=L.gmxUtil.getUnixTimeFromStr(rValue);}if(typeof fieldValue==='boolean'&&typeof rValue==='string'){fieldValue=fieldValue?'True':'False';}if(fieldValue===null){return false;}if(matchPattern!==null){return matchPattern(fieldValue);/*eslint-disable eqeqeq */}else if(op==='='||op==='=='){return fieldValue==rValue;}else if(op==='!='||op==='<>'){return fieldValue!=rValue;/*eslint-enable */}else {var f1,f2;if(!(referenceValue in indexes)&&typeof rValue==='string'&&applyParser(rValue,numberLiteral).head===rValue.length){f1=parseFloat(fieldValue);f2=parseFloat(rValue);if(op==='<'){return f1<f2;}else if(op==='>'){return f1>f2;}else if(op==='<='){return f1<=f2;}else if(op==='>='){return f1>=f2;}else {return false;}}else {f1=fieldValue;f2=rValue;if(op==='<'){return f1<f2;}else if(op==='>'){return f1>f2;}else if(op==='<='){return f1<=f2;}else if(op==='>='){return f1>=f2;}else {return false;}}}};});var inTerm=action(whitespaceSeparatedSequence([quotedFieldName,caseInsensitiveToken('IN'),token('('),whitespaceSeparatedList(0,literal,token(',')),token(')')]),function(state){// Linked list contains fieldname and multiple values
//   (in reverse order).
var node=state;while(node.tail!=null){node=node.tail;}var fieldName=node.head;return function(props,indexes){var value=props[indexes[fieldName]];if(value==null){return false;}var node=state;while(node.tail!==null){if(node.head===value){return true;}node=node.tail;}return false;};});// Forward declarations to allow mutually recursive grammar definitions.
var _term=function term(s,state){return _term(s,state);};var _expression=function expression(s,state){return _expression(s,state);};var notTerm=action(whitespaceSeparatedSequence([caseInsensitiveToken('NOT'),_term]),function(state){// Linked list contains only processed inner term.
var innerTerm=state.head;return function(props,indexes,types){return !innerTerm(props,indexes,types);};});_term=choice([notTerm,opTerm,inTerm,whitespaceSeparatedSequence([token('('),_expression,token(')')])]);// AND and OR expressions must have at least 2 terms,
//   to disambiguate them from a single term.
var andExpression=action(whitespaceSeparatedList(2,_term,caseInsensitiveToken('AND')),function(state){// Linked list contains multiple processed inner terms
//   (in reverse order).
return function(props,indexes,types){var flag=true;var node=state;while(node!=null){flag=flag&&node.head(props,indexes,types);node=node.tail;}return flag;};});var orExpression=action(whitespaceSeparatedList(2,_term,caseInsensitiveToken('OR')),function(state){// Linked list contains multiple processed inner terms
//   (in reverse order).
return function(props,indexes,types){var flag=false;var node=state;while(node!=null){flag=flag||node.head(props,indexes,types);node=node.tail;}return flag;};});// Order is important here: term should be tried last,
//   because andExpression and orExpression start with it.
_expression=choice([andExpression,orExpression,_term]);var whereClause=sequence([whitespace,_expression,whitespace]);Parsers.parseSQL=function(str){var result=applyParser(str,whereClause);return result.head===str.length?result.tail.head:applyParser(str,whitespace).head===str.length?function()/*props*/{return true;}:null;};var _additiveExpression=function additiveExpression(s,state){return _additiveExpression(s,state);};var _multiplicativeExpression=function multiplicativeExpression(s,state){return _multiplicativeExpression(s,state);};_additiveExpression=action(whitespaceSeparatedList(1,_multiplicativeExpression,capture(choice([token('+'),token('-')]))),function(state){return function(props,indexes,types){var pos=state;var term=0.0;while(pos!==null){term+=pos.head(props,indexes,types);if(pos.tail===null){return term;}else {if(pos.tail.head==='-'){term=-term;}pos=pos.tail.tail;}}return term;};});var multiplicativeTerm=choice([action(numberLiteral,function(state){return function()/*props, indexes, types*/{return parseFloat(state.head);};}),action(sequence([token('floor('),_additiveExpression,token(')')]),function(state){return function(props,indexes,types){var res=state.head(props,indexes,types);return Math.floor(res);};}),action(sequence([token('['),fieldName,token(']')]),function(state){return function(props,indexes){return parseFloat(props[indexes[state.head]]);};}),whitespaceSeparatedSequence([token('('),_additiveExpression,token(')')])]);multiplicativeTerm=choice([multiplicativeTerm,action(whitespaceSeparatedSequence([token('-'),multiplicativeTerm]),function(state){return function(props,indexes,types){return -state.head(props,indexes,types);};})]);_multiplicativeExpression=action(whitespaceSeparatedList(1,multiplicativeTerm,capture(choice([token('*'),token('/')]))),function(state){return function(props,indexes,types){var pos=state;var term=1.0;while(pos!==null){term*=pos.head(props,indexes,types);if(pos.tail===null){return term;}else {if(pos.tail.head==='/'){term=1.0/term;}pos=pos.tail.tail;}}return term;};});multiplicativeTerm=choice([multiplicativeTerm,action(whitespaceSeparatedSequence([token('-'),multiplicativeTerm]),function(state){return function(props,indexes,types){return -state.head(props,indexes,types);};})]);var arithmeticExpression=sequence([whitespace,_additiveExpression,whitespace]);Parsers.parseExpression=function(s){var result=applyParser(s,arithmeticExpression);return result.head===s.length?result.tail.head:null;// return result.head === s.length ? Parsers.functionFromExpression(s) : null;
};var svgPath=action(repeat(0,choice([numberLiteral,token(','),token('M'),token('C'),repeat(1,choice([token(' '),token('\t'),token('\r'),token('\n')]))])),function(state){var coords=[];while(state!==null){coords.push(parseFloat(state.head));state=state.tail;}coords.reverse();return coords;});Parsers.parseSVGPath=function(s){var result=applyParser(s,svgPath);if(result.head===s.length){return result.tail.head;}else {return [];}};//extend L.gmx namespace
L.gmx=L.gmx||{};L.gmx.Parsers=Parsers;})();//all the methods can be called without instance itself
//For example:
//
// var def = new Deferred();
// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))
var Deferred=function Deferred(cancelFunc){var resolveCallbacks=[],rejectCallbacks=[],isFulfilled=false,isResolved=false,fulfilledData,onceAdded=false,isCancelled=false;var fulfill=this._fulfill=function(resolved/*, data*/){if(isFulfilled){return;}var callbacks=resolved?resolveCallbacks:rejectCallbacks;fulfilledData=[].slice.call(arguments,1);isFulfilled=true;isResolved=resolved;callbacks.forEach(function(callback){callback.apply(null,fulfilledData);});resolveCallbacks=rejectCallbacks=[];};this.resolve=function()/*data*/{isCancelled||fulfill.apply(null,[true].concat([].slice.call(arguments)));};this.reject=function()/*data*/{isCancelled||fulfill.apply(null,[false].concat([].slice.call(arguments)));};var cancel=this.cancel=function(){if(!isCancelled&&!isFulfilled){isCancelled=true;cancelFunc&&cancelFunc();}};var then=this.then=function(resolveCallback,rejectCallback){if(isCancelled){return null;}var userFuncDef=null;var def=new Deferred(function(){cancel();userFuncDef&&userFuncDef.cancel();});var fulfillFunc=function fulfillFunc(func,resolved){return function()/*data*/{if(!func){def._fulfill.apply(null,[resolved].concat([].slice.call(arguments)));}else {var res=func.apply(null,arguments);if(res instanceof Deferred){userFuncDef=res;res.then(def.resolve,def.reject);}else {def.resolve(res);}}};};if(isFulfilled){fulfillFunc(isResolved?resolveCallback:rejectCallback,isResolved).apply(null,fulfilledData);}else {resolveCallbacks.push(fulfillFunc(resolveCallback,true));rejectCallbacks.push(fulfillFunc(rejectCallback,false));}return def;};this.once=function(onceResolveCallback){if(!onceAdded){onceAdded=true;then(onceResolveCallback);}};this.always=function(callback){then(callback,callback);};this.getFulfilledData=function(){return fulfilledData;};};Deferred.all=function(){var defArray=[].slice.apply(arguments);var resdef=new Deferred();var left=defArray.length;var results=new Array(defArray.length);if(left){defArray.forEach(function(def,i){def.then(function(res){results[i]=res;left--;if(left===0){resdef.resolve.apply(resdef,results);}},function(){resdef.reject();});});}else {resdef.resolve();}return resdef;};L.gmx=L.gmx||{};L.gmx.Deferred=Deferred;(function(){L.gmx=L.gmx||{};L.gmx.workerPromise=L.gmxUtil.createWorker(L.gmxUtil.apiLoadedFrom()+'/ImageBitmapLoader-worker.js').then(function(worker){var ImageBitmapLoader=function ImageBitmapLoader(){this.jobs={};this.worker=worker;this.worker.onmessage=this.chkMessage.bind(this);};ImageBitmapLoader.prototype={chkMessage:function chkMessage(evt){var message=evt.data,url=message.url;// console.log('ImageBitmapLoader ', message, evt);
for(var i=0,it,arr=this.jobs[url]||[],len=arr.length;i<len;i++){it=arr[i];if(message.load){it.resolve(message);}else {it.reject(message);}}delete this.jobs[url];L.gmxUtil.loaderStatus(url,true);},push:function push(url,options){// Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð² worker
if(url&&url[0]==='.'&&url.indexOf(L.gmxUtil.prefixURL)!==0){url=L.gmxUtil.prefixURL+url;}var attr={options:options},src=url||L.gmxUtil.newId();// Ensure the URL is absolute.
if(typeof this.jobs[src]==='undefined'){this.jobs[src]=[];}this.jobs[src].push(attr);this.worker.postMessage({src:src,options:options});L.gmxUtil.loaderStatus(src);return new Promise(function(resolve,reject){attr.resolve=resolve;attr.reject=reject;}).catch(L.Util.falseFn);}};var imageBitmapLoader=new ImageBitmapLoader();L.gmx.getBitmap=imageBitmapLoader.push.bind(imageBitmapLoader);L.gmx.getJSON=imageBitmapLoader.push.bind(imageBitmapLoader);if(L.gmxUtil.debug===2){L.gmx.sendCmd=function(cmd,options){options.cmd=cmd;options.syncParams=L.gmx.gmxMapManager.syncParams;return imageBitmapLoader.push(null,options);};}worker.onerror=function(ev){console.warn('Error: Worker init: ImageBitmapLoader-worker.js',ev);ev.target.terminate();delete L.gmx.getBitmap;delete L.gmx.getJSON;delete L.gmx.sendCmd;};});})();var HAS_SPECIES_SUPPORT$2$1=arrayMethodHasSpeciesSupport$1('splice');var USES_TO_LENGTH$5$1=arrayMethodUsesToLength$1('splice',{ACCESSORS:true,0:0,1:2});var max$3$1=Math.max;var min$6$1=Math.min;var MAX_SAFE_INTEGER$1$1=0x1FFFFFFFFFFFFF;var MAXIMUM_ALLOWED_LENGTH_EXCEEDED$1='Maximum allowed length exceeded';// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
_export$1({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT$2$1||!USES_TO_LENGTH$5$1},{splice:function splice(start,deleteCount/* , ...items */){var O=toObject$1(this);var len=toLength$1(O.length);var actualStart=toAbsoluteIndex$1(start,len);var argumentsLength=arguments.length;var insertCount,actualDeleteCount,A,k,from,to;if(argumentsLength===0){insertCount=actualDeleteCount=0;}else if(argumentsLength===1){insertCount=0;actualDeleteCount=len-actualStart;}else {insertCount=argumentsLength-2;actualDeleteCount=min$6$1(max$3$1(toInteger$1(deleteCount),0),len-actualStart);}if(len+insertCount-actualDeleteCount>MAX_SAFE_INTEGER$1$1){throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED$1);}A=arraySpeciesCreate$1(O,actualDeleteCount);for(k=0;k<actualDeleteCount;k++){from=actualStart+k;if(from in O)createProperty$1(A,k,O[from]);}A.length=actualDeleteCount;if(insertCount<actualDeleteCount){for(k=actualStart;k<len-actualDeleteCount;k++){from=k+actualDeleteCount;to=k+insertCount;if(from in O)O[to]=O[from];else delete O[to];}for(k=len;k>len-actualDeleteCount+insertCount;k--){delete O[k-1];}}else if(insertCount>actualDeleteCount){for(k=len-actualDeleteCount;k>actualStart;k--){from=k+actualDeleteCount-1;to=k+insertCount-1;if(from in O)O[to]=O[from];else delete O[to];}}for(k=0;k<insertCount;k++){O[k+actualStart]=arguments[k+2];}O.length=len-actualDeleteCount+insertCount;return A;}});var FAILS_ON_PRIMITIVES$4=fails$1(function(){objectKeys$1(1);});// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
_export$1({target:'Object',stat:true,forced:FAILS_ON_PRIMITIVES$4},{keys:function keys(it){return objectKeys$1(toObject$1(it));}});(function(){var ImageRequest=function ImageRequest(id,url,options){this._id=id;this.def=new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader,this));this.remove=L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader,this);this.url=url;this.options=options||{};};var GmxImageLoader=L.Class.extend({includes:L.Evented?L.Evented.prototype:L.Mixin.Events,statics:{MAX_COUNT:20// max number of parallel requests
},initialize:function initialize(){this.curCount=0;// number of currently processing requests (number of items in "inProgress")
this.requests=[];// not yet processed image requests
this.inProgress={};// hash of in progress image loadings
this.requestsCache={};// for requests cache by uniqueID
this.uniqueID=0;},_checkIE11bugFix:function _checkIE11bugFix(def,image){if(!this.divIE11bugFix){var div=document.createElement('div');this.divIE11bugFix=div;div.style.visibility='hidden';div.style.position='absolute';document.body.insertBefore(div,document.body.childNodes[0]);}var ieResolve=function ieResolve(){def.resolve(image);// if (image.parentNode) {
// image.parentNode.removeChild(image);
// }
};this.divIE11bugFix.appendChild(image);setTimeout(ieResolve,0);},_resolveRequest:function _resolveRequest(request,image,canceled){var def=request.def;if(image){if(!canceled&&request.options.cache){var url=request.url,cacheItem=this.requestsCache[url],cacheKey=request._id;if(!cacheItem){cacheItem=this.requestsCache[url]={image:image,requests:{}};}if(!cacheItem.requests[cacheKey]){cacheItem.requests[cacheKey]=request;}}if(L.gmxUtil.isIE11&&/\.svg/.test(request.url)){// skip bug in IE11
this._checkIE11bugFix(def,image);}else {def.resolve(image);}}else if(!canceled){def.reject();}this.fire('requestdone',{request:request});},_imageLoaded:function _imageLoaded(url,image,canceled){if(url in this.inProgress){var resolveRequest=function resolveRequest(it){this._resolveRequest(it,image,canceled);};this.inProgress[url].requests.forEach(resolveRequest.bind(this));--this.curCount;delete this.inProgress[url];}L.gmxUtil.loaderStatus(url,true);this.fire('imageloaded',{url:url});this._nextLoad();},_nextLoad:function _nextLoad(){// Ð·Ð°Ð³ÑÑÐ·ÐºÐ° ÑÐ»ÐµÐ´ÑÑÑÐµÐ³Ð¾
if(this.curCount>=GmxImageLoader.MAX_COUNT||!this.requests.length){return;}var request=this.requests.shift(),url=request.url;if(url in this.inProgress){this.inProgress[url].requests.push(request);}else {var requests=[request];this.inProgress[url]={requests:requests};++this.curCount;for(var k=this.requests.length-1;k>=0;k--){if(this.requests[k].url===url){requests.push(this.requests[k]);this.requests.splice(k,1);}}var image=this._loadImage(request);if(!image.width){L.gmxUtil.loaderStatus(url);}//theoretically image loading can be synchronous operation
if(this.inProgress[url]){this.inProgress[url].image=image;}}},_loadImage:function _loadImage(request){var imageObj=new Image(),url=request.url,_this=this;if(request.options.crossOrigin){imageObj.crossOrigin=request.options.crossOrigin;}imageObj.onload=this._imageLoaded.bind(this,url,imageObj,false);imageObj.onerror=function(){_this._imageLoaded(url);};if(L.gmxUtil.isIEOrEdge){setTimeout(function(){imageObj.src=url;},0);}else {imageObj.src=url;}this.fire('imageloadstart',{url:url});return imageObj;},_cancelRequest:function _cancelRequest(request){var id=request._id,url=request.url,i=0,len;if(url in this.inProgress){var loadingImg=this.inProgress[url],requests=loadingImg.requests;len=requests.length;if(len===1&&requests[0]._id===id){loadingImg.image.onload=L.Util.falseFn;loadingImg.image.onerror=L.Util.falseFn;loadingImg.image.src=L.Util.emptyImageUrl;this._imageLoaded(url,null,true);}else {for(i=0;i<len;i++){if(requests[i]._id===id){requests.splice(i,1);break;}}}}else {for(i=0,len=this.requests.length;i<len;i++){if(this.requests[i]._id===id){this.requests.splice(i,1);break;}}}this.fire('requestdone',{request:request});},_removeRequestFromCache:function _removeRequestFromCache(request){// remove request from cache
this._cancelRequest(request);this._clearCacheItem(request.url,request._id);},_clearCacheItem:function _clearCacheItem(url,cacheKey){// remove cache item
if(this.requestsCache[url]){var cacheItem=this.requestsCache[url];delete cacheItem.requests[cacheKey];if(Object.keys(cacheItem.requests).length===0){delete this.requestsCache[url];}}},_add:function _add(atBegin,url,options){url=url.replace(/^http:/,L.gmxUtil.protocol);var id='id'+ ++this.uniqueID,request=new ImageRequest(id,url,options);if(url in this.inProgress){this.inProgress[url].requests.push(request);}else {atBegin?this.requests.unshift(request):this.requests.push(request);this._nextLoad();}this.fire('request',{request:request});return request;},push:function push(url,options){// Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð² ÐºÐ¾Ð½ÐµÑ Ð¾ÑÐµÑÐµÐ´Ð¸
return this._add(false,url,options);},unshift:function unshift(url,options){// Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð² Ð½Ð°ÑÐ°Ð»Ð¾ Ð¾ÑÐµÑÐµÐ´Ð¸
return this._add(true,url,options);}});L.gmx.imageLoader=new GmxImageLoader();})();var styleCanvasKeys=['strokeStyle','fillStyle','lineWidth'],styleCanvasKeysLen=styleCanvasKeys.length,utils=gmxAPIutils;var setCanvasStyle=function setCanvasStyle(prop,indexes,ctx,style){for(var i=0;i<styleCanvasKeysLen;i++){var key=styleCanvasKeys[i],valKey=style[key];if(valKey!==ctx[key]){ctx[key]=valKey;}}if(style.dashArray){var dashes=style.dashArray,dashOffset=style.dashOffset||0;if('setLineDash'in ctx){ctx.setLineDash(dashes);if(ctx.lineDashOffset!==dashOffset){ctx.lineDashOffset=dashOffset;}}}else if('getLineDash'in ctx&&ctx.getLineDash().length>0){ctx.setLineDash([]);}if(ctx.lineCap!=='round'){ctx.lineCap='round';}if(ctx.lineJoin!=='round'){ctx.lineJoin='round';}if(style.canvasPattern){ctx.fillStyle=ctx.createPattern(style.canvasPattern.canvas,'repeat');}else if(style.fillLinearGradient){var rgr=style.fillLinearGradient,x1=rgr.x1Function?rgr.x1Function(prop,indexes):rgr.x1,y1=rgr.y1Function?rgr.y1Function(prop,indexes):rgr.y1,x2=rgr.x2Function?rgr.x2Function(prop,indexes):rgr.x2,y2=rgr.y2Function?rgr.y2Function(prop,indexes):rgr.y2,lineargrad=ctx.createLinearGradient(x1,y1,x2,y2);for(var j=0,len=rgr.addColorStop.length;j<len;j++){var arr1=rgr.addColorStop[j],arrFunc=rgr.addColorStopFunctions[j],p0=arrFunc[0]?arrFunc[0](prop,indexes):arr1[0],p2=arr1.length<3?100:arrFunc[2]?arrFunc[2](prop,indexes):arr1[2],p1=utils.dec2color(arrFunc[1]?arrFunc[1](prop,indexes):arr1[1],p2>1?p2/100:p2);lineargrad.addColorStop(p0,p1);}ctx.fillStyle=style.fillStyle=lineargrad;}};/*
geoItem
     properties: Ð¾Ð±ÑÐµÐºÑ (Ð² ÑÐ¾ÑÐ¼Ð°ÑÐµ Ð²ÐµÐºÑÐ¾ÑÐ½Ð¾Ð³Ð¾ ÑÐ°Ð¹Ð»Ð°)
     dataOption: Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐµ ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° Ð¾Ð±ÑÐµÐºÑÐ°
item
     skipRasters: ÑÐºÑÑÑÑ ÑÐ°ÑÑÑ
     currentStyle: ÑÐµÐºÑÑÐ¸Ð¹ canvas ÑÑÐ¸Ð»Ñ Ð¾Ð±ÑÐµÐºÑÐ°
     parsedStyleKeys: ÑÑÐ¸Ð»Ñ Ð¿ÑÐ¾ÑÐµÐ´ÑÐ¸Ð¹ Ð¿Ð°ÑÑÐ¸Ð½Ð³
options
     ctx: canvas context
     tbounds: tile bounds
     tpx: X ÑÐ¼ÐµÑÐµÐ½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð°
     tpy: Y ÑÐ¼ÐµÑÐµÐ½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð°
     gmx: ÑÑÑÐ»ÐºÐ° Ð½Ð° layer._gmx
        //gmx.currentZoom
        gmx.lastHover
        gmx.tileAttributeIndexes
     bgImage: ÑÐ°ÑÑÑ Ð´Ð»Ñ background
     rasters: ÑÐ°ÑÑÑÑ Ð¿Ð¾ Ð¾Ð±ÑÐµÐºÑÐ°Ð¼ Ð´Ð»Ñ background
currentStyle
    ÑÐµÐºÑÑÐ¸Ð¹ ÑÑÐ¸Ð»Ñ
style
    ÑÑÐ¸Ð»Ñ Ð² Ð½Ð¾Ð²Ð¾Ð¼ ÑÐ¾ÑÐ¼Ð°ÑÐµ
    style.image - Ð´Ð»Ñ type='image' (`<HTMLCanvasElement || HTMLImageElement>`)
*/L.gmxUtil.drawGeoItem=function(geoItem,item,options,currentStyle,style){var propsArr=geoItem.properties,idr=propsArr[0],i,len,j,len1,gmx=options.gmx,ctx=options.ctx,geom=propsArr[propsArr.length-1],coords=null,dataOption=geoItem.dataOption,rasters=options.rasters||{},tbounds=options.tbounds;item.currentStyle=L.extend({},currentStyle);if(style){if(gmx.styleHook){if(!geoItem.styleExtend){item.ctx=ctx;geoItem.styleExtend=gmx.styleHook(item,gmx.lastHover&&idr===gmx.lastHover.id);}if(geoItem.styleExtend){if(typeof geoItem.styleExtend.strokeStyle==='number'){geoItem.styleExtend.strokeStyle=gmxAPIutils.dec2color(geoItem.styleExtend.strokeStyle,1);}if(typeof geoItem.styleExtend.fillStyle==='number'){geoItem.styleExtend.fillStyle=gmxAPIutils.dec2color(geoItem.styleExtend.fillStyle,1);}item.currentStyle=L.extend(item.currentStyle,geoItem.styleExtend);}else {return false;}}setCanvasStyle(propsArr,gmx.tileAttributeIndexes,ctx,item.currentStyle);}else {style={};}var geoType=geom.type.toUpperCase(),dattr={gmx:gmx,item:item,style:style,styleExtend:geoItem.styleExtend||{},ctx:ctx,topLeft:options.topLeft,tpx:options.tpx,tpy:options.tpy};if(geoType==='POINT'){dattr.pointAttr=utils.getPixelPoint(dattr,geom.coordinates);if(!dattr.pointAttr){return false;}// point not in canvas tile
}if(geoType==='POINT'||geoType==='MULTIPOINT'){// ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð³ÐµÐ¾Ð¼ÐµÑÑÐ¸Ð¸ ÑÐ¾ÑÐµÐº
coords=geom.coordinates;if('iconColor'in style&&style.image&&!L.gmxUtil.isIE11){if(style.lastImage!==style.image){style.lastImage=style.image;style.lastImageData=utils.getImageData(style.image);}dattr.imageData=style.lastImageData;}if(geoType==='MULTIPOINT'){for(i=0,len=coords.length;i<len;i++){dattr.coords=coords[i];utils.pointToCanvas(dattr);}}else {dattr.coords=coords;utils.pointToCanvas(dattr);}}else if(geoType==='POLYGON'||geoType==='MULTIPOLYGON'){if(style.image){// set MULTIPOLYGON as marker
dattr.coords=[(dataOption.bounds.min.x+dataOption.bounds.max.x)/2,(dataOption.bounds.min.y+dataOption.bounds.max.y)/2];dattr.pointAttr=utils.getPixelPoint(dattr,dattr.coords);if(dattr.pointAttr){utils.pointToCanvas(dattr);}}else {coords=geom.coordinates;if(geoType==='POLYGON'){coords=[coords];}var hiddenLines=dataOption.hiddenLines||[],pixelsMap=dataOption.pixels,flagPixels=true;// console.log('pixelsMap', gmx.currentZoom, pixelsMap);
if(!pixelsMap||pixelsMap.z!==options.topLeft.tilePoint.z){pixelsMap=dataOption.pixels=utils.getCoordsPixels({gmx:gmx,coords:coords,topLeft:options.topLeft,tpx:options.tpx,tpy:options.tpy,hiddenLines:hiddenLines});}var coordsToCanvas=function coordsToCanvas(func,flagFill){coords=pixelsMap.coords;hiddenLines=pixelsMap.hidden||[];dattr.flagPixels=flagPixels;for(i=0,len=coords.length;i<len;i++){var coords1=coords[i];var hiddenLines1=hiddenLines[i]||[];ctx.beginPath();for(j=0,len1=coords1.length;j<len1;j++){dattr.coords=coords1[j];dattr.hiddenLines=hiddenLines1[j]||[];func(dattr);}ctx.closePath();if(flagFill){ctx.fill();}}};var strokeStyle=item.currentStyle.strokeStyle||style.strokeStyle,lineWidth=item.currentStyle.lineWidth||style.lineWidth;if(strokeStyle&&lineWidth){coordsToCanvas(utils.polygonToCanvas);}if(options.bgImage){dattr.bgImage=options.bgImage;}else if(rasters[idr]){dattr.bgImage=rasters[idr];}if(dattr.styleExtend.skipRasters||item.skipRasters){delete dattr.bgImage;}if(style.imagePattern){item.currentStyle.fillStyle=ctx.createPattern(style.imagePattern,'repeat');}else if(dattr.bgImage&&tbounds.intersectsWithDelta(dataOption.bounds,-1,-1)){if(utils.isPatternNode(dattr.bgImage)){if('rasterOpacity'in gmx){ctx.globalAlpha=gmx.rasterOpacity;}ctx.fillStyle=ctx.createPattern(dattr.bgImage,'no-repeat');style.bgImage=true;}coordsToCanvas(utils.polygonToCanvasFill,true);ctx.globalAlpha=1;}if(item.currentStyle.fillStyle||item.currentStyle.canvasPattern){ctx.fillStyle=item.currentStyle.canvasPattern||item.currentStyle.fillStyle;coordsToCanvas(utils.polygonToCanvasFill,true);}}}else if(geoType==='LINESTRING'||geoType==='MULTILINESTRING'){coords=geom.coordinates;if(geoType==='LINESTRING'){coords=[coords];}var st=item.currentStyle||item.parsedStyleKeys;var isIconPath=st.iconPath||st.iconPath;var size=(item.currentStyle.maxSize||item.currentStyle.lineWidth)/options.topLeft.mInPixel;for(i=0,len=coords.length;i<len;i++){if(isIconPath){var arr=tbounds.clipPolyLine(coords[i],true,size);for(j=0,len1=arr.length;j<len1;j++){dattr.coords=arr[j];var pixels=utils.lineToCanvas(dattr);if(pixels){ctx.save();utils.lineToCanvasAsIcon(pixels,dattr);ctx.restore();}}}else {dattr.coords=coords[i];utils.lineToCanvas(dattr);}}}return true;};/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)
*/var gmxSessionManager={APIKEY_PARAM:'key',SCRIPT_REGEXP:[/\bleaflet-geomixer(-\w*)?\.js\b/,/\bgeomixer(-\w*)?\.js\b/],_scriptSearched:false,_scriptAPIKey:null,_searchScriptAPIKey:function _searchScriptAPIKey(){var _this=this;if(this._scriptSearched){return this._scriptAPIKey;}var scripts=document.getElementsByTagName('script');for(var i=0;i<scripts.length;i++){var src=scripts[i].getAttribute('src'),arr=this.SCRIPT_REGEXP;for(var j=0,len=arr.length;j<len;j++){if(arr[j].exec(src)){var query=src.split('?')[1];if(query){var params=query.split('&');for(var p=0;p<params.length;p++){var parsedParam=params[p].split('=');if(parsedParam[0]===_this.APIKEY_PARAM){_this._scriptAPIKey=parsedParam[1];break;}}}break;}}if(_this._scriptAPIKey){break;}}this._scriptSearched=true;return this._scriptAPIKey;},//we will search apiKey in script tags iff apiKey parameter is undefined.
//if it is defined as falsy (null, '', etc), we won't send any requests to server
requestSessionKey:function requestSessionKey(serverHost,apiKey,apiKeyEndPoint){var keys=this._sessionKeys;if(!(serverHost in keys)){apiKey=typeof apiKey==='undefined'?this._searchScriptAPIKey():apiKey;if(!apiKey){return new Promise(function(resolve){resolve();});}keys[serverHost]=new Promise(function(resolve,reject){if(apiKey){apiKeyEndPoint=apiKeyEndPoint||'/ApiKey.ashx';var url=L.gmxUtil.protocol+'//'+serverHost+apiKeyEndPoint+'?WrapStyle=None&Key='+apiKey,storeKey=function storeKey(json){if(json&&json.Status==='ok'){var key=gmxSessionManager._sessionKeysRes[serverHost]=json.Result.Key;resolve(key);}else {reject();}};fetch(url,{mode:'cors'}).then(function(resp){return resp.json();}).then(storeKey);}else {resolve('');}});}return keys[serverHost];},//get already received session key
getSessionKey:function getSessionKey(serverHost){return this._sessionKeys[serverHost];},getSessionKeyRes:function getSessionKeyRes(serverHost){return this._sessionKeysRes[serverHost];},_sessionKeysRes:{},//key for each host
_sessionKeys:{}//promise for each host
};L.gmx=L.gmx||{};L.gmx.gmxSessionManager=gmxSessionManager;/** Asynchronously request information about map given server host and map name
*/var gmxMapManager={//serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes
getMap:function getMap(serverHost,apiKey,mapName,skipTiles,srs){return gmxMapManager.loadMapProperties({srs:srs,hostName:serverHost,apiKey:apiKey,mapName:mapName,skipTiles:skipTiles});},_addMapProperties:function _addMapProperties(res,serverHost,mapName){L.gmx._maps[serverHost]=L.gmx._maps[serverHost]||{};L.gmx._maps[serverHost][mapName]={_rawTree:res,_nodes:{}};gmxMapManager.iterateNode(res,function(it){// TODO: ÑÐ´Ð°Ð»Ð¸ÑÑ Ð¿Ð¾ÑÐ»Ðµ Ð¿ÐµÑÐµÐ´ÐµÐ»ÐºÐ¸ ÑÑÐ¸Ð»ÐµÐ¹ Ð½Ð° ÑÐµÑÐ²ÐµÑÐµ
if(it.type==='layer'){var props=it.content.properties;if(props.styles&&!props.gmxStyles){it.content.properties.gmxStyles=L.gmx.StyleManager.decodeOldStyles(props);}}});if(L.gmx.mapPropertiesHook){L.gmx.mapPropertiesHook(res);}},getMapFolder:function getMapFolder(options){var serverHost=options.hostName||options.serverHost||'maps.kosmosnimki.ru',mapId=options.mapId,folderId=options.folderId;var opt={folderId:folderId||'',mapId:mapId,skipTiles:options.skipTiles||'All',// All, NotVisible, None
srs:options.srs||3857};return new Promise(function(resolve,reject){if(L.gmx.sendCmd){console.log('TODO: L.gmx.sendCmd');}else {L.gmx.gmxSessionManager.requestSessionKey(serverHost,options.apiKey).then(function(sessionKey){opt.key=sessionKey;gmxAPIutils.requestJSONP(L.gmxUtil.protocol+'//'+serverHost+'/Map/GetMapFolder',opt).then(function(json){if(json&&json.Status==='ok'&&json.Result){var mapInfo=L.gmx._maps[serverHost][mapId],gmxMap=mapInfo.loaded,res=json.Result.content,outInfo={children:res.children,properties:gmxMap.properties};gmxMapManager.iterateNode(mapInfo._rawTree,function(it){if(folderId===it.content.properties.GroupID){L.extend(it,json.Result);}},true);gmxMap.layersCreated.then(function(){gmxMap.layersCreatePromise(outInfo).then(function(){resolve(json.Result);});});}else {reject(json);}},reject);},reject);}});},loadMapProperties:function loadMapProperties(options){options=options||{};var maps=this._maps,serverHost=options.hostName||options.serverHost||'maps.kosmosnimki.ru',mapPropsEndPoint=options.gmxEndPoints&&options.gmxEndPoints.mapProps?options.gmxEndPoints.mapProps:'/TileSender.ashx',apiKeyEndPoint=options.gmxEndPoints&&options.gmxEndPoints.apiKey?options.gmxEndPoints.apiKey:'/ApiKey.ashx',mapName=options.mapName;if(!maps[serverHost]||!maps[serverHost][mapName]){var opt={WrapStyle:'func',skipTiles:options.skipTiles||'All',// All, NotVisible, None
MapName:mapName,srs:options.srs||3857,ftc:options.ftc||'osm',ModeKey:'map'};if(options.visibleItemOnly){opt.visibleItemOnly=true;}var promise=new Promise(function(resolve,reject){if(L.gmx.sendCmd){L.gmx.sendCmd('mapProperties',{serverHost:serverHost,apiKeyEndPoint:apiKeyEndPoint,mapPropsEndPoint:mapPropsEndPoint,apiKey:options.apiKey,WrapStyle:'func',skipTiles:options.skipTiles||'All',// All, NotVisible, None
MapName:mapName,visibleItemOnly:opt.visibleItemOnly||false,srs:options.srs||3857,ftc:options.ftc||'osm',ModeKey:'map'}).then(function(json){if(json&&json.load&&json.res){gmxMapManager._addMapProperties(json.res,serverHost,mapName);resolve(json.res);}else {reject(json);}}).catch(reject);}else {L.gmx.gmxSessionManager.requestSessionKey(serverHost,options.apiKey).then(function(sessionKey){opt.key=sessionKey;gmxAPIutils.requestJSONP(L.gmxUtil.protocol+'//'+serverHost+mapPropsEndPoint,opt).then(function(json){if(json&&json.Status==='ok'&&json.Result){json.Result.properties.hostName=serverHost;json.Result.properties.sessionKey=sessionKey;gmxMapManager._addMapProperties(json.Result,serverHost,mapName);resolve(json.Result);}else {reject(json);}},reject);},reject);}});maps[serverHost]=maps[serverHost]||{};maps[serverHost][mapName]={promise:promise};}return maps[serverHost][mapName].promise;},syncParams:{},// ÑÑÑÐ°Ð½Ð¾Ð²ÐºÐ° Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² Ð´Ð»Ñ ÑÐµÑÐ²ÐµÑÐ½ÑÑ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð²
setSyncParams:function setSyncParams(hash){this.syncParams=hash;},getSyncParams:function getSyncParams(stringFlag){var res=this.syncParams;if(stringFlag){var arr=[];for(var key in res){arr.push(key+'='+res[key]);}res=arr.join('&');}return res;},//we will (lazy) create index by layer name to speed up multiple function calls
findLayerInfo:function findLayerInfo(serverHost,mapID,layerID){var hostMaps=L.gmx._maps[serverHost],layerInfo=null;if(hostMaps&&hostMaps[mapID]){var mapInfo=hostMaps[mapID];if(!mapInfo._nodes[layerID]){gmxMapManager.iterateNode(mapInfo._rawTree,function(it){mapInfo._nodes[it.content.properties.name]=it;});}layerInfo=mapInfo._nodes[layerID];}return layerInfo?layerInfo.content:null;},iterateLayers:function iterateLayers(treeInfo,callback){var iterate=function iterate(arr){for(var i=0,len=arr.length;i<len;i++){var layer=arr[i];if(layer.type==='layer'){callback(layer.content);}else if(layer.type==='group'){iterate(layer.content.children||[]);}}};treeInfo&&iterate(treeInfo.children);},iterateNode:function iterateNode(treeInfo,callback,onceFlag){var iterate=function iterate(node){var arr=node.children||[];for(var i=0,len=arr.length;i<len;i++){var layer=arr[i];if(callback(layer,node)&&onceFlag){break;}if(layer.type==='group'){iterate(layer.content);}}};treeInfo&&iterate(treeInfo);},_maps:{}//Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}
};L.gmx=L.gmx||{};L.gmx._maps={};// ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° ÑÐ»Ð¾ÐµÐ² Ð¿Ð¾ ÐºÐ°ÑÑÐ°Ð¼
L.gmx._clientLayers={};// ÑÐ²Ð¾Ð¹ÑÑÐ²Ð° ÑÐ»Ð¾ÐµÐ² Ð±ÐµÐ· ÐºÐ°ÑÑ (ÐºÐ»Ð¸ÐµÐ½ÑÑÐºÐ¸Ðµ ÑÐ»Ð¾Ð¸)
if(location.protocol==='https:'){L.gmx._sw='1';// Ð¿ÑÐ¸Ð·Ð½Ð°Ðº Ð·Ð°Ð³ÑÑÐ·ÐºÐ¸ Ð´Ð°Ð½Ð½ÑÑ ÑÐµÑÐµÐ· Service Worker
if('serviceWorker'in navigator){navigator.serviceWorker.register('./gmx-sw'+L.gmx._sw+'.js').then(function(registration){if(registration.active){L.gmx.serviceWorker=registration.active;}console.log('ServiceWorker registration successful with scope: ',registration.scope);}).catch(function(err){console.log('ServiceWorker registration failed: ',err);});}else {console.error('Your browser does not support Service Workers.');}}L.gmx.gmxMapManager=gmxMapManager;//Helper class, that represents layers of single Geomixer's map
//Creates layers from given map description
var gmxMap=L.Class.extend({includes:L.Evented?L.Evented.prototype:L.Mixin.Events,initialize:function initialize(mapInfo,commonLayerOptions){this.layers=[];this.layersByTitle={};this.layersByID={};this.dataManagers={};this.options=commonLayerOptions;this.properties=L.extend({},mapInfo.properties);this.properties.BaseLayers=this.properties.BaseLayers?JSON.parse(this.properties.BaseLayers):[];this.rawTree=mapInfo;this.layersCreated=this.layersCreatePromise(mapInfo);},layersCreatePromise:function layersCreatePromise(mapInfo){return new Promise(function(resolve){var mapID=mapInfo.properties.name,_this=this,commonOptions=this.options,_skipTiles=this.options.skipTiles||'All',_ftc=this.options.ftc||'osm',_srs=this.options.srs||3857,missingLayerTypes={},dataSources={};L.gmx.gmxMapManager.iterateLayers(mapInfo,function(layerInfo){var props=layerInfo.properties,options={mapID:mapID,sessionKey:mapInfo.properties.sessionKey,layerID:props.name};props.hostName=mapInfo.properties.hostName;if(mapInfo.srs){props.srs=mapInfo.srs;}var type=props.ContentID||props.type,meta=props.MetaProperties||{},layerOptions=L.extend(options,commonOptions);if(props.styles&&!props.gmxStyles){props.gmxStyles=L.gmx.StyleManager.decodeOldStyles(props);}if(props.dataSource||'parentLayer'in meta){// Set dataSource layer
layerOptions.parentLayer=props.dataSource||'';if('parentLayer'in meta){// todo ÑÐ´Ð°Ð»Ð¸ÑÑ Ð¿Ð¾ÑÐ»Ðµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹ Ð²Ð¾Ð² Ð²ÑÑÐ²ÐµÑÐµ
layerOptions.parentLayer=meta.parentLayer.Value||'';}if('hostName'in meta){layerOptions.hostName=meta.hostName.Value||'';}if('apiKey'in meta){layerOptions.apiKey=meta.apiKey.Value||'';}dataSources[options.layerID]={info:layerInfo,options:layerOptions};}else if(type in L.gmx._layerClasses){_this.addLayer(L.gmx.createLayer(layerInfo,layerOptions));}else {missingLayerTypes[type]=missingLayerTypes[type]||[];missingLayerTypes[type].push({info:layerInfo,options:layerOptions});}});//load missing layer types
var loaders=[];for(var type in missingLayerTypes){loaders.push(L.gmx._loadLayerClass(type).then(/*eslint-disable no-loop-func */function(type){/*eslint-enable */var it=missingLayerTypes[type];for(var i=0,len=it.length;i<len;i++){_this.addLayer(L.gmx.createLayer(it[i].info,it[i].options));}}.bind(null,type)));}var hosts={},host,id,it;for(id in dataSources){it=dataSources[id];var opt=it.options,pId=opt.parentLayer,pLayer=this.layersByID[pId];if(pLayer){it.options.parentOptions=pLayer.getGmxProperties();it.options.dataManager=this.dataManagers[pId]||new L.gmx.DataManager(it.options.parentOptions,true);this.dataManagers[pId]=it.options.dataManager;this.addLayer(L.gmx.createLayer(it.info,it.options));}else {host=opt.hostName;if(!hosts[host]){hosts[host]={};}if(!hosts[host][pId]){hosts[host][pId]=[];}hosts[host][pId].push(id);}}for(host in hosts){var arr=[],prefix=L.gmxUtil.protocol+'//'+host;for(id in hosts[host]){arr.push({Layer:id});}if(window.apiKey&&host==='maps.kosmosnimki.ru'){loaders.push(L.gmx.gmxSessionManager.requestSessionKey(host,window.apiKey));}var endPoints=this.options.gmxEndPoints||{};var endPoint=endPoints.layerProps||'/Layer/GetLayerJson.ashx';loaders.push(L.gmxUtil.requestJSONP(prefix+endPoint,{WrapStyle:'func',skipTiles:_skipTiles,srs:_srs,ftc:_ftc,Layers:JSON.stringify(arr)},{host:host,ids:hosts[host]}).then(function(json,opt){if(json&&json.Status==='ok'&&json.Result){json.Result.forEach(function(it){var props=it.properties,pId=props.name;props.tiles=[];props.skipTiles=_skipTiles;props.srs=_srs;props.ftc=_ftc;props.hostName=host;var dataManager=_this.addDataManager(it);if(opt&&opt.ids&&opt.ids[pId]){opt.ids[pId].forEach(function(id){var pt=dataSources[id];pt.options.parentOptions=it.properties;pt.options.dataManager=dataManager;pt.info.properties.tiles=[];// Ð¨ÑÐ¼Ð¸Ð»Ð¾Ð² Ð´Ð¾Ð»Ð¶ÐµÐ½ ÑÐ±ÑÐ°ÑÑ
pt.info.properties.skipTiles=_skipTiles;pt.info.properties.srs=_srs;pt.info.properties.ftc=_ftc;_this.addLayer(L.gmx.createLayer(pt.info,pt.options));});}});}else {console.info('Error: loading ',prefix+endPoint,json.ErrorInfo);if(opt&&opt.ids){for(var pId in opt.ids){opt.ids[pId].forEach(function(id){_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));});}}}}));}Promise.all(loaders).then(resolve);}.bind(this));},addDataManager:function addDataManager(it){var pid=it.properties.name;if(!this.dataManagers[pid]){this.dataManagers[pid]=new L.gmx.DataManager(it.properties);}return this.dataManagers[pid];},getDataManager:function getDataManager(id){return this.dataManagers[id];},addLayer:function addLayer(layer){var props=layer.getGmxProperties();this.layers.push(layer);this.layersByTitle[props.title]=layer;this.layersByID[props.name]=layer;this.fire('layeradd',{layer:layer});return this;},removeLayer:function removeLayer(layer){var props=layer.getGmxProperties();for(var i=0;i<this.layers.length;i++){if(this.layers[i].getGmxProperties().name===props.name){this.layers.splice(i,1);break;}}delete this.layersByTitle[props.title];delete this.layersByID[props.name];this.fire('layerremove',{layer:layer});return this;},addLayersToMap:function addLayersToMap(leafletMap){for(var l=this.layers.length-1;l>=0;l--){var layer=this.layers[l];if(layer instanceof L.Layer&&layer.getGmxProperties().visible){leafletMap.addLayer(layer);}}return this;}});L.gmx=L.gmx||{};L.gmx.gmxMap=gmxMap;/*
 * gmxEventsManager - handlers manager
 */var GmxEventsManager=L.Handler.extend({options:{},initialize:function initialize(map){this._map=map;this._layers={};this._lastLayer=null;this._lastId=null;this._drawstart=null;this._lastCursor='';map.on({zoomend:function zoomend(){L.gmx._animatingZoom=false;if(map._gmxMouseLatLng){this._onmousemove({type:'mousemove',latlng:map._gmxMouseLatLng});// setTimeout(function () {
// eventCheck({type: 'mousemove', latlng: map._gmxMouseLatLng});
// }, 0);
}},zoomanim:function zoomanim(){L.gmx._animatingZoom=true;},click:this._eventCheck,dblclick:this._eventCheck,mousedown:this._eventCheck,mouseup:this._eventCheck,mousemove:this._onmousemove,contextmenu:this._onmousemove,layeradd:function layeradd(ev){var layer=ev.layer;if('gmxEventCheck'in layer&&layer.options.clickable){var i=0;if(layer._container){var container=layer._container,arr=container.parentNode.childNodes,len;for(i=0,len=arr.length;i<len;i++){if(container===arr[i]){break;}}}this._layers[layer._leaflet_id]=i;}},layerremove:function layerremove(ev){var id=ev.layer._leaflet_id;delete this._layers[id];if(this._lastLayer&&this._lastLayer._leaflet_id===id){this._lastLayer=null;this._lastId=0;}}},this);},_onmousemove:function _onmousemove(ev){if(!this._map._animatingZoom){if(this._onmousemoveTimer){clearTimeout(this._onmousemoveTimer);}this._onmousemoveTimer=setTimeout(this._eventCheck.bind(this,ev),50);// if (this._onmousemoveTimer) { cancelIdleCallback(this._onmousemoveTimer); }
// this._onmousemoveTimer = requestIdleCallback(this._eventCheck.bind(this, ev), {timeout: 50});
}},_isDrawing:function _isDrawing(){var map=this._map;if(this._drawstart){return true;}else if(this._drawstart===null){if(map.gmxControlsManager){var drawingControl=map.gmxControlsManager.get('drawing');if(drawingControl){drawingControl.on('activechange',function(ev){this._drawstart=ev.activeIcon;map._container.style.cursor=this._drawstart?'pointer':'';}.bind(this));}}this._drawstart=false;}return false;},_clearLastHover:function _clearLastHover(){if(this._lastLayer){this._lastLayer.gmxEventCheck({type:'mousemove'},true);this._lastLayer=null;}},_eventCheck:function _eventCheck(ev){var type=ev.type,map=this._map;if(ev.originalEvent){var target=ev.originalEvent.target;var tagName=target.tagName.toLowerCase();if(tagName!=='svg'&&target!==map._container){return;}if(tagName==='path'){return;}map.gmxMouseDown=L.Browser.webkit&&!L.gmxUtil.isIEOrEdge?ev.originalEvent.which:ev.originalEvent.buttons;}if(map._animatingZoom||!ev.latlng||this._isDrawing()||type==='click'&&map._skipClick||// from drawing
type==='mousemove'&&map.gmxMouseDown){this._clearLastHover();map._skipClick=false;return;}if(ev.layerPoint){map._gmxMouseLatLng=ev.latlng;map.gmxMousePos=map.getPixelOrigin().add(ev.layerPoint);}var arr=Object.keys(this._layers).sort(function(a,b){var la=map._layers[a],lb=map._layers[b];if(la&&lb){var oa=la.options,ob=lb.options,za=(oa.zIndexOffset||0)+(oa.zIndex||0),zb=(ob.zIndexOffset||0)+(ob.zIndex||0),delta=zb-za;return delta?delta:this._layers[b]-this._layers[a];}return 0;}.bind(this));var layer,foundLayer=null,cursor='';for(var i=0,len=arr.length;i<len;i++){var id=arr[i];layer=map._layers[id];if(layer&&layer._map&&!layer._animating&&layer.options.clickable){if(layer.gmxEventCheck(ev)){if(layer.hasEventListeners('mouseover')){cursor='pointer';}foundLayer=layer;break;}}}if(this._lastCursor!==cursor&&!this._isDrawing()){map._container.style.cursor=cursor;}this._lastCursor=cursor;if(type!=='zoomend'){if(foundLayer){if(this._lastLayer!==foundLayer){this._clearLastHover();}this._lastLayer=foundLayer;}else {this._clearLastHover();}}}});L.Map.addInitHook(function(){// Check to see if handler has already been initialized.
if(!this._gmxEventsManager){this._gmxEventsManager=new GmxEventsManager(this);this.isGmxDrawing=function(){return this._gmxEventsManager._drawstart;}.bind(this);this.on('remove',function(){if(this._gmxEventsManager){this._gmxEventsManager.removeHooks();}},this);}});(function(){var DEFAULT_LANGUAGE='rus',_setKeyText=function _setKeyText(lang,key,item,hash){if(!hash[lang]){hash[lang]={};}hash[lang][key]=item;};L.gmxLocale={setLanguage:function setLanguage(lang){this._language=lang;},getLanguage:function getLanguage(){return window.language||this._language||DEFAULT_LANGUAGE;}};L.gmxLocaleMixin={addText:function addText(){var lang=arguments[0],newHash=arguments[1];if(arguments.length===1){newHash=lang;lang=null;}for(var k in newHash){if(lang===null){for(var k1 in newHash[k]){_setKeyText(k,k1,newHash[k][k1],this);}}else {_setKeyText(lang,k,newHash[k],this);}}return this;},getText:function getText(key){var lang=L.gmxLocale.getLanguage(),locale=this[lang]||{};var keyArr=key?key.split(/\./):[];for(var i=0,len=keyArr.length;i<len;i++){if(!locale){break;}locale=locale[keyArr[i]];}return locale;}};L.extend(L.gmxLocale,L.gmxLocaleMixin);})();L.extend(L.gmxLocale,{rus:{Coordinates:'ÐÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ',Length:'ÐÐ»Ð¸Ð½Ð°',angleLength:'ÐÐ·Ð¸Ð¼ÑÑ, ÑÐ°ÑÑÐ¾ÑÐ½Ð¸Ðµ',nodeLength:'ÐÐ»Ð¸Ð½Ð° Ð¾Ñ Ð½Ð°ÑÐ°Ð»Ð°',edgeLength:'ÐÐ»Ð¸Ð½Ð° ÑÐµÐ³Ð¼ÐµÐ½ÑÐ°','Rotate around Point':'ÐÐ¾Ð²Ð¾ÑÐ¾Ñ Ð²Ð¾ÐºÑÑÐ³ Ð²ÐµÑÑÐ¸Ð½Ñ','Remove point':'Ð£Ð´Ð°Ð»Ð¸ÑÑ ÑÐ¾ÑÐºÑ','Delete feature':'Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð¾Ð±ÑÐµÐºÑ',Rotate:'ÐÐ¾Ð²Ð¾ÑÐ¾Ñ',Move:'Ð¡Ð´Ð²Ð¸Ð³',Save:'ÐÑÐ¸Ð¼ÐµÐ½Ð¸ÑÑ',Cancel:'ÐÑÐ¼ÐµÐ½Ð¸ÑÑ',Angle:'Ð£Ð³Ð¾Ð»',Area:'ÐÐ»Ð¾ÑÐ°Ð´Ñ',Perimeter:'ÐÐµÑÐ¸Ð¼ÐµÑÑ',units:{m:'Ð¼',nm:'Ð¼.Ð¼Ð¸Ð»Ð¸',km:'ÐºÐ¼',m2:'ÐºÐ². Ð¼',km2:'ÐºÐ². ÐºÐ¼',ha:'Ð³Ð°',m2html:'Ð¼<sup>2',km2html:'ÐºÐ¼<sup>2'}}});L.extend(L.gmxLocale,{eng:{Coordinates:'Coordinates',Length:'Length',angleLength:'Angle, length',nodeLength:'From start point',edgeLength:'Segment length','Rotate around Point':'Rotate around Point',Rotate:'Rotate',Move:'Move',Save:'Apply',Cancel:'Cancel',Angle:'Angle',Area:'Area',Perimeter:'Perimeter',units:{m:'m',nm:'nmi',km:'km',m2:'sq. m',km2:'sq. km',ha:'ha',m2html:'m<sup>2',km2html:'km<sup>2'}}});var gmxVectorTileLoader={_loadedTiles:{},_getKey:function _getKey(ti){return [ti.layerID,ti.x,ti.y,ti.z,typeof ti.d==='undefined'?-1:ti.d,typeof ti.s==='undefined'?-1:ti.s,ti.v].join(':');},load:function load(tileSenderPrefix,tileInfo){var key=gmxVectorTileLoader._getKey(tileInfo);if(!this._loadedTiles[key]){var requestParams={ModeKey:'tile',ftc:'osm',r:'j',LayerName:tileInfo.layerID,z:tileInfo.z,x:tileInfo.x,y:tileInfo.y,v:tileInfo.v};if(tileInfo.srs){requestParams.srs=tileInfo.srs;}if(tileInfo.d!==-1){requestParams.Level=tileInfo.d;requestParams.Span=tileInfo.s;}if(L.gmx._sw){requestParams.sw=L.gmx._sw;}var promise=new Promise(function(resolve,reject){var query=tileSenderPrefix+'&'+Object.keys(requestParams).map(function(name){return name+'='+requestParams[name];}).join('&');fetch(query,{mode:'cors',credentials:'include'}).then(function(response){if(response.status===404){reject(response);return '';}return response.text();}).then(function(txt){if(txt){var pref='gmxAPI._vectorTileReceiver(';if(txt.substr(0,pref.length)===pref){txt=txt.replace(pref,'');txt=txt.substr(0,txt.length-1);}resolve(JSON.parse(txt));}else {resolve({srs:'3857',isGeneralized:false,values:[],//bbox: [],
LayerName:tileInfo.layerID,level:tileInfo.d,span:tileInfo.s,v:tileInfo.v,x:tileInfo.x,y:tileInfo.y,z:tileInfo.z});}}).catch(console.log);});this._loadedTiles[key]=promise;}return this._loadedTiles[key];}};window.gmxAPI=window.gmxAPI||{};window.gmxAPI._vectorTileReceiver=window.gmxAPI._vectorTileReceiver||function(data){var key=gmxVectorTileLoader._getKey({layerID:data.LayerName,x:data.x,y:data.y,z:data.z,d:data.level,s:data.span,v:data.v});gmxVectorTileLoader._loadedTiles[key]&&gmxVectorTileLoader._loadedTiles[key].resolve({bbox:data.bbox,srs:data.srs,isGeneralized:data.isGeneralized,values:data.values});};L.gmx.VectorTileLoader=gmxVectorTileLoader;(function(){//Single vector tile, received from GeoMixer server
//  dataProvider: has single method "load": function(x, y, z, v, s, d, callback), which calls "callback" with the following parameters:
//      - {Object[]} data - information about vector objects in tile
//      - {Number[4]} [bbox] - optional bbox of objects in tile
//  options:
//      x, y, z, v, s, d: GeoMixer vector tile point
//      dateZero: zero Date for temporal layers
//      isGeneralized: flag for generalized tile
var VectorTile=function VectorTile(dataProvider,options){this.dataProvider=dataProvider;this.itemsKeys={};this.x=options.x;this.y=options.y;this.z=options.z;this.v=options.v;this.s=options.s||-1;this.d=options.d||-1;// this._itemsArr = options._itemsArr;
this.processing=options.processing;this.attributes=options.attributes;this.isGeneralized=options.isGeneralized;this.isFlatten=options.isFlatten;this.bounds=gmxAPIutils.getBoundsByTilePoint(this.z?options:{z:0,x:0,y:0});this.gmxTilePoint={x:this.x,y:this.y,z:this.z,s:this.s,d:this.d};this.vectorTileKey=VectorTile.makeTileKey(this.x,this.y,this.z,this.v,this.s,this.d);if(this.s>=0&&options.dateZero){this.beginDate=new Date(options.dateZero.valueOf()+this.s*this.d*gmxAPIutils.oneDay*1000);this.endDate=new Date(options.dateZero.valueOf()+(this.s+1)*this.d*gmxAPIutils.oneDay*1000);}this.clear();};VectorTile.prototype={itemsKeys:null,data:null,// attributes: {},
addData:function addData(data,keys){if(keys){this.removeData(keys,true);}var len=data.length,dataOptions=new Array(len),dataBounds=gmxAPIutils.bounds();for(var i=0;i<len;i++){var it=data[i],dataOption=this._parseItem(it);dataOptions[i]=dataOption;dataBounds.extendBounds(dataOption.bounds);this.itemsKeys[it[0]]=i;}if(!this.data){this.data=data;this.dataOptions=dataOptions;}else {this.data=this.data.concat(data);this.dataOptions=this.dataOptions.concat(dataOptions);}this.loaded(data);return dataBounds;},removeData:function removeData(keys){for(var arr=this.data||[],i=arr.length-1;i>=0;i--){if(keys[arr[i][0]]){arr.splice(i,1);if(this.dataOptions){this.dataOptions.splice(i,1);}}}},loaded:function loaded(data){this.state='loaded';this._resolve(data);},load:function load(){if(this.state==='notLoaded'){this.state='loading';var _this=this;this.dataProvider.load(_this.x,_this.y,_this.z,_this.v,_this.s,_this.d,function(data){_this.bbox=data.bbox;_this.srs=data.srs;_this.isGeneralized=data.isGeneralized;_this.addData(data.values);});}return this.loadDef;},clear:function clear(){this.state='notLoaded';//notLoaded, loading, loaded
this.data=null;this.dataOptions=null;this.itemsKeys={};this.loadDef=new Promise(function(resolve,reject){this._resolve=resolve;this._reject=reject;}.bind(this));},// TODO: ÐÐ»Ñ ÑÐ¿Ð°ÐºÐ¾Ð²ÐºÐ¸ Ð°ÑÑÐ¸Ð±ÑÑÐ¾Ð²
// _getLinkProp: function(nm, val) {
// var attr = this.attributes,
// name = attr[nm - 1],
// arr = this._itemsArr[name],
// len = arr.length,
// i = 0;
// for (; i < len; i++) {
// if (val === arr[i]) { return i; }
// }
// arr[i] = val;
// return i;
// },
_parseItem:function _parseItem(it){var len=it.length-1,// props = new Uint32Array(len),
i;// props[0] = it[0];
// TODO: old properties null = ''
for(i=1;i<len;i++){if(it[i]===null){it[i]='';}// props[i] = this._getLinkProp(i, it[i]);
}var geo=it[len],needFlatten=this.isFlatten,type=geo.type,isLikePolygon=type.indexOf('POLYGON')!==-1||type.indexOf('Polygon')!==-1,isPolygon=type==='POLYGON'||type==='Polygon',coords=geo.coordinates,hiddenLines=[],bounds=null,boundsArr=[];if(isLikePolygon){if(isPolygon){coords=[coords];}bounds=gmxAPIutils.bounds();var edgeBounds=gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),hiddenFlag=false;for(i=0,len=coords.length;i<len;i++){var arr=[],hiddenLines1=[];for(var j=0,len1=coords[i].length;j<len1;j++){if(needFlatten&&typeof coords[i][j][0]!=='number'){coords[i][j]=gmxAPIutils.flattenRing(coords[i][j]);}var b=gmxAPIutils.bounds(coords[i][j]);arr.push(b);if(j===0){bounds.extendBounds(b);}// EdgeLines calc
var edgeArr=gmxAPIutils.getHidden(coords[i][j],edgeBounds);hiddenLines1.push(edgeArr);if(edgeArr.length){hiddenFlag=true;}}boundsArr.push(arr);hiddenLines.push(hiddenLines1);}if(!hiddenFlag){hiddenLines=null;}if(isPolygon){boundsArr=boundsArr[0];}}else if(type==='POINT'||type==='Point'){bounds=gmxAPIutils.bounds([coords]);}else if(type==='MULTIPOINT'||type==='MultiPoint'){bounds=gmxAPIutils.bounds();for(i=0,len=coords.length;i<len;i++){bounds.extendBounds(gmxAPIutils.bounds([coords[i]]));}}else if(type==='LINESTRING'||type==='LineString'){bounds=gmxAPIutils.bounds(coords);}else if(type==='MULTILINESTRING'||type==='MultiLineString'){bounds=gmxAPIutils.bounds();for(i=0,len=coords.length;i<len;i++){bounds.extendBounds(gmxAPIutils.bounds(coords[i]));}}var dataOption={id:it[0],type:type,processing:this.processing,currentFilter:null,properties:it,options:{fromTiles:{},isGeneralized:this.isGeneralized},// options: {
// fromTiles: {5_23_6_52334_14179_1: 1},
// unixTimeStamp: 1540599811000
// },
// props: props,
bounds:bounds,boundsArr:boundsArr};if(hiddenLines){dataOption.hiddenLines=hiddenLines;}return dataOption;}};//class methods
VectorTile.makeTileKey=function(x,y,z,v,s,d){return z+'_'+x+'_'+y+'_'+v+'_'+s+'_'+d;};VectorTile.createTileKey=function(opt){return [opt.z,opt.x,opt.y,opt.v,opt.s,opt.d].join('_');};VectorTile.parseTileKey=function(gmxTileKey){var p=gmxTileKey.split('_').map(function(it){return Number(it);});return {z:p[0],x:p[1],y:p[2],v:p[3],s:p[4],d:p[5]};};VectorTile.boundsFromTileKey=function(gmxTileKey){var p=VectorTile.parseTileKey(gmxTileKey);return gmxAPIutils.getTileBounds(p.x,p.y,p.z);};if(!L.gmx){L.gmx={};}L.gmx.VectorTile=VectorTile;})();var Observer=L.Class.extend({includes:L.Evented?L.Evented.prototype:L.Mixin.Events,/* options : {
          type: 'resend | update',    // `resend` - send all data (like screen tile observer)
                                      // `update` - send only changed data
          callback: Func,             // will be called when layer's data for this observer is changed
          dateInterval: [dateBegin,dateEnd], // temporal interval
          bbox: bbox,                 // bbox to observe on Mercator
          filters: [String]           // filter keys array
          active: [Boolean=true]      // is this observer active
          layerID: String           	// ID ÑÐ»Ð¾Ñ view
  target: String				// ÐºÐ»ÑÑ Ð½Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð¾Ð±ÑÐµÑÐ²ÐµÑÐ°
  z: zoom						// zoom Ð´Ð»Ñ 'screen' Ð¾Ð±ÑÐµÑÐ²ÐµÑÐ°
          targetZoom: [Number]        // for zoom generalized type default(null)
  topLeft: {}					// Ð´Ð»Ñ screen
          needBbox: [Boolean=false]   // ÑÐµÐ¶Ð¸Ð¼ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð² ÑÐ¿Ð¸ÑÐºÐ° ÑÐ°Ð¹Ð»Ð¾Ð² Ð¿Ð¾ BBOX
      }
  */initialize:function initialize(options){this.type=options.type||'update';this._callback=options.callback;this.layerID=options.layerID;this.target=options.target;this.z=options.z;this.itemHook=options.itemHook;// set hook for item (set empty data for callback function)
this._items=null;this.bbox=options.bbox;// set bbox by Mercator bounds
this.needBbox=options.needBbox;// ÑÐµÐ¶Ð¸Ð¼ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð² ÑÐ¿Ð¸ÑÐºÐ° ÑÐ°Ð¹Ð»Ð¾Ð² Ð¿Ð¾ BBOX
this.filters=options.filters||[];this.targetZoom=options.targetZoom||null;this.active='active'in options?options.active:true;this.srs=options.srs||3857;// 3857, 3395
if(options.bounds){// set bbox by LatLngBounds
this.setBounds(options.bounds);}var w=gmxAPIutils.worldWidthMerc,dx;if(!this.bbox){this.bbox=gmxAPIutils.bounds([[-w,-w],[w,w]]);this.world=true;}else if(this.bbox.max.x>w){dx=this.bbox.max.x-w;this.bbox1=gmxAPIutils.bounds([[dx-w,this.bbox.max.y],[-(dx+w),this.bbox.min.y]]);}else if(this.bbox.min.x<-w){dx=this.bbox.min.x+w;this.bbox1=gmxAPIutils.bounds([[dx+w,this.bbox.max.y],[w-dx,this.bbox.min.y]]);}if(options.dateInterval){this._setDateInterval(options.dateInterval[0],options.dateInterval[1]);}},hasFilter:function hasFilter(filterName){for(var i=0,len=this.filters.length;i<len;i++){if(this.filters[i]===filterName){return true;}}return false;},activate:function activate(withoutActivate){if(!this.active){this.active=true;if(!withoutActivate){this.fire('activate');}}return this;},deactivate:function deactivate(withoutActivate){if(this.active){this.active=false;if(!withoutActivate){this.fire('activate');}}return this;},toggleActive:function toggleActive(isActive){return isActive?this.activate():this.deactivate();},isActive:function isActive(){return this.active;},updateData:function updateData(data){var len=data.length,out={count:len};if(this.type==='update'){//calculate difference with previous data
if(!this._items){this._items={};}var prevItems=this._items,newItems={},added=[],removed=[],key;for(var i=0;i<len;i++){var it=data[i];key=it.id+'_'+it.tileKey;newItems[key]=it;if(!prevItems[key]){added.push(it);}}for(key in prevItems){if(!newItems[key]){removed.push(prevItems[key]);}}if(added.length){out.added=added;}if(removed.length){out.removed=removed;}this._items=newItems;}else {out.added=data;}this.fire('data',{data:this._callback(out)});out=null;data=null;return this;},removeData:function removeData(keys){if(this.type!=='update'||!this._items){return this;}var items=this._items,removed=[];for(var id in keys){if(items[id]){removed.push(items[id]);delete items[id];}}if(removed.length){this._callback({removed:removed});}return this;},/*setFilter: function (func) {
      this._filters.userFilter = func;
      this.fire('update');
      return this;
  },
   removeFilter: function () {
      delete this._filters.userFilter;
      this.fire('update');
      return this;
  },*/setBounds:function setBounds(bounds,buffer){var w;if(!bounds){if(!this.world){w=gmxAPIutils.worldWidthMerc;this.bbox=gmxAPIutils.bounds([[-w,-w],[w,w]]);this.bbox1=null;this.world=true;this.fire('update');}return this;}var min=bounds.min,max=bounds.max;if(!min||!max){var latLngBounds=L.latLngBounds(bounds),sw=latLngBounds.getSouthWest(),ne=latLngBounds.getNorthEast();min={x:sw.lng,y:sw.lat};max={x:ne.lng,y:ne.lat};}var minX=min.x,maxX=max.x,minY=min.y,maxY=max.y,minX1=null,maxX1=null;this.world=false;w=(maxX-minX)/2;if(w>=180){minX=-180;maxX=180;this.world=true;}else if(maxX>180||minX<-180){var center=(maxX+minX)/2%360;if(center>180){center-=360;}else if(center<-180){center+=360;}minX=center-w;maxX=center+w;if(minX<-180){minX1=minX+360;maxX1=180;minX=-180;}else if(maxX>180){minX1=-180;maxX1=maxX-360;maxX=180;}}var crs=this.srs==3857?L.CRS.EPSG3857:L.Projection.Mercator,m1=crs.project(L.latLng(minY,minX)),m2=crs.project(L.latLng(maxY,maxX));this.bbox=gmxAPIutils.bounds([[m1.x,m1.y],[m2.x,m2.y]]);if(buffer){this.bbox.addBuffer(buffer);}this.bbox1=null;if(minX1){m1=crs.project(L.latLng(minY,minX1));m2=crs.project(L.latLng(maxY,maxX1));this.bbox1=gmxAPIutils.bounds([[m1.x,m1.y],[m2.x,m2.y]]);if(buffer){this.bbox1.addBuffer(buffer);}}this.fire('update');return this;},intersects:function intersects(bounds){return this.world||this.bbox.intersects(bounds)||!!(this.bbox1&&this.bbox1.intersects(bounds));},intersectsWithTile:function intersectsWithTile(tile){if(this.targetZoom&&!this.needBbox){var z=this.targetZoom+(this.targetZoom%2?1:0);if(tile.isGeneralized&&tile.z!==z||tile.z>z){return false;}}var di=this.dateInterval;return this.intersects(tile.bounds)&&(!tile.beginDate||di&&di.endDate>=tile.beginDate&&di.beginDate<=tile.endDate);},intersectsWithGeometry:function intersectsWithGeometry(geometry){var type=geometry.type.toUpperCase(),coords=geometry.coordinates;if(type==='POINT'){return this.world||this.bbox.contains(coords)||!!(this.bbox1&&this.bbox1.contains(coords));}else if(type==='POLYGON'){coords=[coords[0]];}else if(type==='MULTIPOLYGON'){coords=coords.map(function(arr){return arr[0];});}else if(type==='LINESTRING'){coords=[coords];// } else if (type === 'MULTILINESTRING') {
}for(var i=0,len=coords.length;i<len;i++){if(this.bbox.clipPolygon(coords[i]).length||this.bbox1&&this.bbox1.clipPolygon(coords[i]).length){return true;}}return false;},_setDateInterval:function _setDateInterval(beginDate,endDate){if(beginDate&&endDate){// var beginValue = beginDate.valueOf(),
// endValue = endDate.valueOf();
this.dateInterval={beginDate:beginDate,endDate:endDate};}else {this.dateInterval=null;}},setDateInterval:function setDateInterval(beginDate,endDate){var isValid=beginDate&&endDate;if(!this.dateInterval!==!isValid||isValid&&(this.dateInterval.beginDate.valueOf()!==beginDate.valueOf()||this.dateInterval.endDate.valueOf()!==endDate.valueOf())){this._setDateInterval(beginDate,endDate);this.fire('update',{temporalFilter:true});}return this;}});L.gmx.observer=function(options){return new Observer(options);};(function(){//tree for fast tiles selection inside temporal interval
//  options:
//      TemporalTiles: tilePoints array
//      TemporalVers: tiles version array
//      TemporalPeriods: periods
//      ZeroDate: start Date
var TilesTree=function TilesTree(options){var _rootNodes=[],tiles=options.TemporalTiles||[],vers=options.TemporalVers||[],periods=options.TemporalPeriods||[],maxPeriod=periods[periods.length-1],smin=Number.MAX_VALUE,arr=options.ZeroDate.split('.'),zn=new Date(arr.length>2?arr[2]:2008,arr.length>1?arr[1]-1:0,arr.length>0?arr[0]:1),dateZero=new Date(zn.getTime()-zn.getTimezoneOffset()*60000),zeroUT=dateZero.getTime()/1000;this.dateZero=dateZero;var addTile=function addTile(node,tile,key){var d=node.d;if(tile.d===periods[d]){node.count++;node.tiles.push(key);return;}var pd=periods[d-1],childrenCount=periods[d]/pd;if(!('children'in node)){node.children=new Array(childrenCount);}var sChild=Math.floor(tile.s*tile.d/pd),ds=sChild-node.s*childrenCount;if(!node.children[ds]){var pdOneDay=pd*gmxAPIutils.oneDay,t1=sChild*pdOneDay+zeroUT;node.children[ds]={d:d-1,s:sChild,t1:t1,t2:t1+pdOneDay,count:0,children:[],tiles:[]};}addTile(node.children[ds],tile,key);};var dmax=periods.length-1,dmaxOneDay=periods[dmax]*gmxAPIutils.oneDay,i,len;for(i=0,len=tiles.length;i<len;i++){arr=tiles[i];var s=Number(arr[1]),d=Number(arr[0]);if(d===maxPeriod){smin=Math.min(smin,s);}}for(i=0,len=tiles.length;i<len;i++){arr=tiles[i];var t={x:Number(arr[2]),y:Number(arr[3]),z:Number(arr[4]),v:Number(vers[i]),s:Number(arr[1]),d:Number(arr[0])};if(t.d<0){continue;}var ds=Math.floor(t.s*t.d/periods[dmax])-smin,cs=ds+smin;_rootNodes[ds]=_rootNodes[ds]||{d:dmax,s:cs,t1:cs*dmaxOneDay+zeroUT,t2:(cs+1)*dmaxOneDay+zeroUT,count:0,tiles:[]};var key=L.gmx.VectorTile.createTileKey(t);addTile(_rootNodes[ds],t,key);}tiles=vers=null;//options: bounds (in mercator projection)
this.selectTiles=function(t1,t2,options){options=options||{};var t1Val=t1.valueOf()/1000,t2Val=t2.valueOf()/1000;// We will restrict tile levels by the nearest two levels to target date interval length
// For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles
var minLevel=0,dateIntervalLength=(t2Val-t1Val)/3600/24;for(var i=0;i<periods.length;i++){if(periods[i]>dateIntervalLength){minLevel=Math.max(0,i-1);break;}}if(periods[periods.length-1]<=dateIntervalLength){minLevel=periods.length-1;}var maxLevel=Math.min(periods.length-1,minLevel+Number(dateIntervalLength>periods[minLevel]));var getCountOfIntersected=function getCountOfIntersected(tileBounds,bounds){var count=0;for(var t=0;t<tileBounds.length;t++){if(tileBounds[t].intersects(bounds)){count++;}}return count;};// --------------------
var selectTilesForNode=function selectTilesForNode(node,t1,t2){if(t1>=node.t2||t2<=node.t1){return {count:0,tiles:[],nodes:[]};}if(options.bounds&&!node.tileBounds){node.tileBounds=node.tiles.map(function(it){return L.gmx.VectorTile.boundsFromTileKey(it);});}if(node.d===minLevel){var count=options.bounds?getCountOfIntersected(node.tileBounds,options.bounds):node.count;return {tiles:node.tiles,count:count,nodes:[node]};}var childrenCount=0,//number of tiles if we use shorter intervals
childrenRes=[],len=node.children?node.children.length:0,ds;for(ds=0;ds<len;ds++){if(node.children[ds]){childrenRes[ds]=selectTilesForNode(node.children[ds],Math.max(t1,node.t1),Math.min(t2,node.t2));}else {childrenRes[ds]={count:0,tiles:[],nodes:[]};}childrenCount+=childrenRes[ds].count;}var intersectCount=options.bounds?getCountOfIntersected(node.tileBounds,options.bounds):node.count;if(node.d>maxLevel||childrenCount<intersectCount){var resTilesArr=[],resNodesArr=[];for(ds=0;ds<childrenRes.length;ds++){resNodesArr.push(childrenRes[ds].nodes);resTilesArr.push(childrenRes[ds].tiles);}return {tiles:[].concat.apply([],resTilesArr),count:childrenCount,nodes:[].concat.apply([],resNodesArr)};}else {return {tiles:node.tiles,count:intersectCount,nodes:[node]};}};var resTiles=[];for(var ds=0;ds<_rootNodes.length;ds++){if(_rootNodes[ds]){var nodeSelection=selectTilesForNode(_rootNodes[ds],t1Val,t2Val);if(nodeSelection.tiles.length){resTiles=resTiles.concat(nodeSelection.tiles);}}}var resTilesHash={};for(var t=0;t<resTiles.length;t++){resTilesHash[resTiles[t]]=true;}return {tiles:resTilesHash};};this.getNode=function(d,s){if(d<0||s<0){return null;}var findNode=function findNode(node,d,s){if(!node){return null;}if(periods[node.d]===d){return node.s===s?node:null;}var childrenCount=periods[node.d]/periods[node.d-1];var sChild=Math.floor(s*d/periods[node.d-1]);var ds=sChild-node.s*childrenCount;return node.children[ds]?findNode(node.children[ds],d,s):null;};for(var ds=0;ds<_rootNodes.length;ds++){var node=findNode(_rootNodes[ds],d,s);if(node){return node;}}return null;};};L.gmx.tilesTree=function(options){return new TilesTree(options);};})();var $filter$1$1=arrayIteration$1.filter;var HAS_SPECIES_SUPPORT$3$1=arrayMethodHasSpeciesSupport$1('filter');// Edge 14- issue
var USES_TO_LENGTH$6$1=arrayMethodUsesToLength$1('filter');// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
_export$1({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT$3$1||!USES_TO_LENGTH$6$1},{filter:function filter(callbackfn/* , thisArg */){return $filter$1$1(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});var $reduce$1$1=arrayReduce$1.left;var STRICT_METHOD$5$1=arrayMethodIsStrict$1('reduce');var USES_TO_LENGTH$7$1=arrayMethodUsesToLength$1('reduce',{1:0});// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
_export$1({target:'Array',proto:true,forced:!STRICT_METHOD$5$1||!USES_TO_LENGTH$7$1},{reduce:function reduce(callbackfn/* , initialValue */){return $reduce$1$1(this,callbackfn,arguments.length,arguments.length>1?arguments[1]:undefined);}});var ObserverTileLoader=L.Class.extend({includes:L.Evented?L.Evented.prototype:L.Mixin.Events,initialize:function initialize(dataManager){this._dataManager=dataManager;this._observerData={};this._tileData={};},addObserver:function addObserver(observer){this._observerData[observer.id]={observer:observer,tiles:{},leftToLoad:0,loadingState:false//are we loading any tiles for this observer?
};observer.on('update',this._updateObserver.bind(this,observer));this._updateObserver(observer);return this;},removeObserver:function removeObserver(id){var obsTiles=this._observerData[id].tiles;for(var tileId in obsTiles){delete this._tileData[tileId].observers[id];}delete this._observerData[id];return this;},addTile:function addTile(tile){var leftToLoadDelta=tile.state==='loaded'?0:1;var tileObservers={};for(var key in this._observerData){var obsInfo=this._observerData[key];if(obsInfo.observer.intersectsWithTile(tile)){obsInfo.tiles[tile.vectorTileKey]=true;obsInfo.leftToLoad+=leftToLoadDelta;tileObservers[key]=true;}}this._tileData[tile.vectorTileKey]={observers:tileObservers,tile:tile};tile.loadDef.then(this._tileLoadedCallback.bind(this,tile));return this;},removeTile:function removeTile(tileId){var tileData=this._tileData[tileId],leftToLoadDelta=tileData.tile.state==='loaded'?0:1;for(var id in tileData.observers){var observerData=this._observerData[id];observerData.leftToLoad-=leftToLoadDelta;delete observerData.tiles[tileId];}delete this._tileData[tileId];return this;},_isLeftToLoad:function _isLeftToLoad(obsData){var cnt=0,processingTile=this._dataManager.processingTile;for(var tileId in obsData.tiles){var vtile=this._tileData[tileId].tile;if(vtile!==processingTile&&vtile.state!=='loaded'){cnt++;}}return cnt;},startLoadTiles:function startLoadTiles(observer){//force active tile list update
this._dataManager._getActiveTileKeys();var obsData=this._observerData[observer.id];if(obsData){obsData.leftToLoad=this._isLeftToLoad(obsData);if(obsData.leftToLoad<1){this.fire('observertileload',{observer:observer});return this;}if(!obsData.loadingState){obsData.loadingState=true;observer.fire('startLoadingTiles');}for(var tileId in obsData.tiles){this._tileData[tileId].tile.load();}}return this;},getTileObservers:function getTileObservers(tileId){return this._tileData[tileId].observers;},getObserverLoadingState:function getObserverLoadingState(observer){return this._observerData[observer.id].loadingState;},getObserverLeftToLoad:function getObserverLeftToLoad(observer){return this._observerData[observer.id].leftToLoad;},_updateObserver:function _updateObserver(observer){if(this._observerData[observer.id]){var obsData=this._observerData[observer.id],newObserverTiles={},leftToLoad=0,key;for(key in this._tileData){var tile=this._tileData[key].tile;if(observer.intersectsWithTile(tile)){newObserverTiles[key]=true;if(tile.state!=='loaded'){leftToLoad++;}this._tileData[key].observers[observer.id]=true;}}for(key in obsData.tiles){if(!(key in newObserverTiles)){delete this._tileData[key].observers[observer.id];}}obsData.tiles=newObserverTiles;obsData.leftToLoad=leftToLoad;}},_tileLoadedCallback:function _tileLoadedCallback(tile){this.fire('tileload',{tile:tile});var vtk=tile.vectorTileKey;if(!(vtk in this._tileData)){// TODO: Ð¿ÑÐ¾Ð²ÐµÑÐºÐ° Ð·Ð°Ð³ÑÑÐ¶Ð°ÐµÐ¼Ð¾Ð³Ð¾ ÑÐ°Ð¹Ð»Ð°
//console.log('tileload', tile, this._tileData)
return;}var tileObservers=this._tileData[vtk].observers;for(var id in tileObservers){var obsData=this._observerData[id],leftToLoad=obsData.leftToLoad;obsData.leftToLoad=this._isLeftToLoad(obsData);if(obsData.leftToLoad<1){if(obsData.loadingState){obsData.loadingState=false;}if(leftToLoad){this.fire('observertileload',{observer:obsData.observer});}}}}});var DataManager=L.Class.extend({includes:L.Evented?L.Evented.prototype:L.Mixin.Events,options:{name:null,// layer ID
srs:'',// geometry projection (3395 or 3857)
identityField:'',// attribute name for identity items
attributes:[],// attributes names
attrTypes:[],// attributes types
tiles:null,// tiles array for nontemporal data
tilesVers:null,// tiles version array for nontemporal data
LayerVersion:-1,// layer version
GeoProcessing:null,// processing data
Temporal:false,// only for temporal data
TemporalColumnName:'',// temporal attribute name
ZeroDate:'01.01.2008',// 0 date string
TemporalPeriods:[],// temporal periods
TemporalTiles:[],// temporal tiles array
TemporalVers:[],// temporal version array
hostName:'maps.kosmosnimki.ru',// default hostName
sessionKey:'',// session key
isGeneralized:false,// flag for use generalized tiles
needBbox:false,// flag for get tiles list by BBOX
isFlatten:false// flag for flatten geometry
},setOptions:function setOptions(options){if(options.GeoProcessing){if(this.options.LayerVersion===options.LayerVersion){return;// Ð½Ðµ Ð±ÑÐ»Ð¾ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð²ÐµÑÑÐ¸Ð¸ ÑÐ»Ð¾Ñ - Ð½Ð¾ ÑÐµÑÐ²ÐµÑ Ð¿Ð¾ÑÐµÐ¼Ñ ÑÐ¾ Ð¿ÑÐ¸ÑÑÐ»Ð°ÐµÑ Ð½Ð¾Ð²Ð¾Ðµ properties ÑÐ»Ð¾Ñ
}this._chkProcessing(options.GeoProcessing);}else {this._clearProcessing();}L.setOptions(this,options);this.optionsLink=options;this._isTemporalLayer=this.options.Temporal;var tileAttributes=L.gmxUtil.getTileAttributes(this.options);this.tileAttributeIndexes=tileAttributes.tileAttributeIndexes;this.temporalColumnType=tileAttributes.tileAttributeTypes[this.options.TemporalColumnName];var hostName=this.options.hostName,gmxEndPoints=this.options.gmxEndPoints||{},endPoint=gmxEndPoints.tileProps||'/TileSender.ashx',sessionKey=gmxEndPoints.sessionKey||'';// if (!sessionKey) {
// sessionKey = L.gmx.gmxSessionManager.getSessionKeyRes(hostName);
// }
this.tileSenderPrefix=L.gmxUtil.protocol+'//'+hostName+endPoint+'?WrapStyle=None'+'&key='+encodeURIComponent(sessionKey);this._needCheckActiveTiles=true;},_vectorTileDataProviderLoad:function _vectorTileDataProviderLoad(x,y,z,v,s,d,callback){var _this=this;L.gmx.VectorTileLoader.load(_this.tileSenderPrefix,{x:x,y:y,z:z,v:v,s:s,d:d,srs:this.options.srs,layerID:_this.options.name}).then(callback,function(res){console.log('Error loading vector tile:',res);callback({values:[]});_this.fire('chkLayerUpdate',{dataProvider:_this});//TODO: do we really need event here?
});},initialize:function initialize(options,clearVersion){this._tilesTree=null;this._activeTileKeys={};this._endDate=null;this._beginDate=null;this._tiles={};this._filters={};this._filtersView={};this._freeSubscrID=0;this._observers={};this._needCheckDateInterval=false;this._needCheckActiveTiles=true;var _this=this;this._vectorTileDataProvider={load:this._vectorTileDataProviderLoad.bind(this)};this._observerTileLoader=new ObserverTileLoader(this);this._observerTileLoader.on('observertileload',function(event){var observer=event.observer;if(observer.isActive()){observer.needRefresh=false;// if (L.gmx._animatingZoom) {
// console.log('____ observer.updateData', observer.id);
// return;
// }
observer.updateData(_this.getItems(observer.id));// observer._animId = L.Util.requestAnimFrame(function() {
// observer.updateData(_this.getItems(observer.id));
// }, _this);
}});this.setOptions(options);if(clearVersion){this.options.LayerVersion=-1;}if(this._isTemporalLayer){this.addFilter('TemporalFilter',function(item,tile,observer){var unixTimeStamp=this._getUnixTimeStamp(item),// var unixTimeStamp = item.options.unixTimeStamp,
dates=observer.dateInterval;return dates&&unixTimeStamp>=dates.beginDate.valueOf()&&unixTimeStamp<dates.endDate.valueOf();}.bind(this));}},_getActiveTileKeys:function _getActiveTileKeys(){// if (L.gmx._animatingZoom) {
// console.log('___bg', L.gmx._animatingZoom);
// return this._activeTileKeys;
// }
this._chkMaxDateInterval();if(this.options.needBbox||!this._needCheckActiveTiles){return this._activeTileKeys;}// ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ ÑÐµÐ¶Ð¸Ð¼Ð° Ñ Ð¿Ð¾Ð»Ð½ÑÐ¼Ð¸ ÑÐ¿Ð¸ÑÐºÐ°Ð¼Ð¸ ÑÐ°Ð¹Ð»Ð¾Ð²
this._needCheckActiveTiles=false;if(this._isTemporalLayer);else {this.initTilesList();}return this._activeTileKeys;},getViewFilters:function getViewFilters(name,layerID){var out=[];name=name||'screen';for(var key in this._filtersView[layerID]){if(key.indexOf(name)===0){out.push(key);}}return out;},_getObserversByFilterName:function _getObserversByFilterName(filterName,target){var oKeys={};for(var id in this._observers){var observer=this._observers[id];if(observer.hasFilter(filterName)){oKeys[id]=true;}else if(target&&target===observer.target){observer.filters.push(filterName);oKeys[id]=true;}}return oKeys;},addLayerFilter:function addLayerFilter(filterFunc,options){if(options&&options.layerID){var layerID=options.layerID,target=options.target||'screen',name=target;if(!this._filtersView[layerID]){this._filtersView[layerID]={};}if(options.id){name+='_'+options.id;}this._filtersView[layerID][name]=filterFunc;this._triggerObservers(this._getObserversByFilterName(name,target));}return this;},removeLayerFilter:function removeLayerFilter(options){if(this._filtersView[options.layerID]){var layerID=options.layerID,target=options.target||'screen',name=target;if(options.id){name+='_'+options.id;}if(this._filtersView[layerID][name]){var oKeys=this._getObserversByFilterName(name,target);delete this._filtersView[layerID][name];this._triggerObservers(oKeys);}}return this;},addFilter:function addFilter(filterName,filterFunc){this._filters[filterName]=filterFunc;this._triggerObservers(this._getObserversByFilterName(filterName));return this;},removeFilter:function removeFilter(filterName){if(this._filters[filterName]){var oKeys=this._getObserversByFilterName(filterName);delete this._filters[filterName];this._triggerObservers(oKeys);}return this;},getItems:function getItems(oId){var resArr=[],observer=this._observers[oId];// console.log('getItems', oId, this.options.name);
// if (!observer || !observer.isActive()) {
if(!observer){return [];}if(!observer.isActive()&&observer.id!=='hover'){return [];}//add internal filters
var layerID=observer.layerID,_filtersView=this._filtersView[layerID]||{},filters=observer.filters.concat('processingFilter');this._isTemporalLayer&&filters.push('TemporalFilter');filters=filters.filter(function(filter){return filter in this._filters||filter in _filtersView;}.bind(this));var _this=this,putData=function putData(tile){var data=tile.data,lastIndex=resArr.length,len=data.length;resArr.length=lastIndex+len;for(var i=0;i<len;i++){var dataOption=tile.dataOptions[i];if(!observer.intersects(dataOption.bounds)){continue;}var it=data[i],geom=it[it.length-1];if(!observer.intersectsWithGeometry(geom)){continue;}var id=it[0],// item = _this.getItem(id),
isFiltered=false;for(var f=0;f<filters.length;f++){var name=filters[f],filterFunc=_this._filters[name]||_filtersView[name];if(filterFunc&&!filterFunc(dataOption,tile,observer,geom,dataOption)){// if (filterFunc && !filterFunc(item, tile, observer, geom, dataOption)) {
isFiltered=true;break;}}if(!isFiltered){var rItem={id:id,properties:it,item:dataOption,dataOption:dataOption,v:tile.v,tileKey:tile.vectorTileKey};if(observer.itemHook){observer.itemHook(rItem);}else {resArr[lastIndex++]=rItem;}}}resArr.length=lastIndex;};var activeTileKeys=this._getActiveTileKeys();for(var tkey in activeTileKeys){var tile=_this._tiles[tkey].tile;if(tile.data&&tile.data.length>0&&(tile.z===0||observer.intersectsWithTile(tile))){putData(tile);}}return resArr;},_getUnixTimeStamp:function _getUnixTimeStamp(item){if(!item.options.unixTimeStamp){item.options.unixTimeStamp=1000*Number(item.properties[this.tileAttributeIndexes[this.options.TemporalColumnName]]);}return item.options.unixTimeStamp;},getMaxDateInterval:function getMaxDateInterval(){this._chkMaxDateInterval();return {beginDate:this._beginDate,endDate:this._endDate};},_chkMaxDateInterval:function _chkMaxDateInterval(){if(this._isTemporalLayer&&this._needCheckDateInterval){this._needCheckDateInterval=false;var observers=this._observers,newBeginDate=null,newEndDate=null;for(var oId in observers){var observer=observers[oId],dateInterval=observer.dateInterval;if(!dateInterval){continue;}if(!newBeginDate||dateInterval.beginDate<newBeginDate){newBeginDate=dateInterval.beginDate;}if(!newEndDate||dateInterval.endDate>newEndDate){newEndDate=dateInterval.endDate;}}if(newBeginDate&&newEndDate&&(this._beginDate!==newBeginDate||this._endDate!==newEndDate)){this._beginDate=newBeginDate;this._endDate=newEndDate;this._needCheckActiveTiles=true;}}},addObserver:function addObserver(options,id){id=id||'s'+ ++this._freeSubscrID;var _this=this,observer=L.gmx.observer(options);observer.id=id;observer.needRefresh=true;this._observerTileLoader.addObserver(observer);observer.on('update',function(ev){observer.needRefresh=true;if(ev.temporalFilter){_this._needCheckDateInterval=true;}L.gmx.layersVersion.now();_this._waitCheckObservers();}).on('activate',function(){_this.fire('observeractivate');_this.checkObserver(observer);});_this._needCheckDateInterval=true;this._observers[id]=observer;this._waitCheckObservers();if(observer.isActive()){this.fire('observeractivate');}return observer;},getActiveObserversCount:function getActiveObserversCount(){var count=0;for(var k in this._observers){if(this._observers[k].isActive()){count++;}}return count;},getObserver:function getObserver(id){return this._observers[id];},// removeScreenObservers: function(z) {
// for (var k in this._observers) {
// var observer = this._observers[k];
// if (observer.target === 'screen') {
// if (z && observer.z === z) {
// continue;
// }
// observer.deactivate(true);
// this.removeObserver(k);
// }
// }
// },
// toggleScreenObservers: function(flag, z) {
// for (var k in this._observers) {
// var observer = this._observers[k];
// if (observer.target === 'screen' && observer.z === z) {
// if (flag) {
// observer.activate();
// } else {
// observer.deactivate();
// }
// }
// }
// },
removeObserver:function removeObserver(id){if(this._observers[id]){this._observerTileLoader.removeObserver(id);var isActive=this._observers[id].isActive();delete this._observers[id];if(isActive){this.fire('observeractivate');}}},getObserverLoadingState:function getObserverLoadingState(observer){return this._observerTileLoader.getObserverLoadingState(observer);},getObserverLeftToLoad:function getObserverLeftToLoad(observer){return this._observerTileLoader.getObserverLeftToLoad(observer);},// getTileKeysToLoad: function(beginDate, endDate) {
// var newTileKeys = this._tilesTree.selectTiles(beginDate, endDate).tiles;
// return newTileKeys;
// },
getItemsBounds:function getItemsBounds(){// get all objects bounds
var bounds=gmxAPIutils.bounds(),tile,key;for(key in this._activeTileKeys){tile=this._tiles[key].tile;tile.dataOptions.map(function(it){bounds.extendBounds(it.bounds);});}return bounds;},getItemBounds:function getItemBounds(id){// Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ bbox Ð¿Ð¾ Ð¾ÑÐ´ÐµÐ»ÑÐ½ÑÐ¼ ÐºÑÑÐºÐ°Ð¼ item
var bounds=gmxAPIutils.bounds(),arr=this._getItemArrByActiveTileKeys(id);arr.map(function(it){bounds.extendBounds(it.bounds);});return bounds;},_getItemArrByActiveTileKeys:function _getItemArrByActiveTileKeys(id,firstOnly){var arr=[];for(var key in this._activeTileKeys){// get full object bounds
var tile=this._tiles[key].tile;if(this.processingTile===tile){arr=tile.dataOptions.filter(function(it){return id===it.id;});break;}if(tile.data&&id in tile.itemsKeys){arr.push(tile.dataOptions[tile.itemsKeys[id]]);if(firstOnly){break;}}}return arr;},// ??? combine and return all parts of geometry
getItem:function getItem(id){return this._getItemArrByActiveTileKeys(id)[0];},getItemMembers:function getItemMembers(id){var members=this._getItemArrByActiveTileKeys(id).map(function(it){var props=it.properties,bbox=it.bounds;return {geo:props[props.length-1],width:bbox.max.x-bbox.min.x,dataOption:it};});return members.sort(function(a,b){return b.width-a.width;});},getItemGeometries:function getItemGeometries(id){return this._getItemArrByActiveTileKeys(id).map(function(it){var props=it.properties;return gmxAPIutils.getUnFlattenGeo(props[props.length-1]);});},addTile:function addTile(tile){this._tiles[tile.vectorTileKey]={tile:tile};this._getActiveTileKeys()[tile.vectorTileKey]=true;this._observerTileLoader.addTile(tile);this.checkObservers();},checkObserver:function checkObserver(observer){if(observer.needRefresh&&observer.isActive()){this._observerTileLoader.startLoadTiles(observer);}},checkObservers:function checkObservers(){// if (L.gmx._animatingZoom) {
// console.log('___ checkObservers', L.gmx._animatingZoom);
// return;
// }
var observers=this._observers;for(var id in this._observers){this.checkObserver(observers[id]);}},_waitCheckObservers:function _waitCheckObservers(){//TODO: refactor
if(this._checkObserversTimer){clearTimeout(this._checkObserversTimer);}this._checkObserversTimer=setTimeout(L.bind(this.checkObservers,this),25);// if (this._checkObserversTimer) { cancelIdleCallback(this._checkObserversTimer); }
// this._checkObserversTimer = requestIdleCallback(L.bind(this.checkObservers, this), {timeout: 25});
},_triggerObservers:function _triggerObservers(oKeys){var keys=oKeys||this._observers;// console.log('_triggerObservers:', Object.keys(keys).length);	// TODO: Ð¼Ð½Ð¾Ð³Ð¾ Ð²ÑÐ·Ð¾Ð²Ð¾Ð² Ð¿ÑÐ¸ Ð½Ð°ÑÐ°Ð»ÑÐ½Ð¾Ð¹ Ð·Ð°Ð³ÑÑÐ·ÐºÐµ ÐºÐ°ÑÑÑ
for(var id in keys){if(this._observers[id]){this._observers[id].needRefresh=true;}}// if (L.gmx._animatingZoom) {
// return;
// console.log('____triggerObservers', nsGmx.leafletMap._animatingZoom);
// }
this._waitCheckObservers();},_removeDataFromObservers:function _removeDataFromObservers(data){var keys=this._observers;for(var id in keys){this._observers[id].removeData(data);}this._waitCheckObservers();},/*
      preloadTiles: function(dateBegin, dateEnd, bounds) {
          var tileKeys = {};
          if (this._isTemporalLayer) {
              if (!this._tilesTree) {
                  this.initTilesTree();
              }
              tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;
          } else {
              this._needCheckActiveTiles = true;
              tileKeys = this._getActiveTileKeys();
          }
  
          var loadingDefs = [];
          for (var key in tileKeys) {
              var tile = this._getVectorTile(key, true).tile;
  
              if (tile.state !== 'notLoaded') {
                  continue;
              }
  
              if (bounds && !bounds.intersects(tile.bounds)) {
                  continue;
              }
  
              var loadDef = tile.load();
              loadingDefs.push(loadDef);
          }
  
          return Deferred.all.apply(null, loadingDefs);
      },
  */_updateActiveTilesList:function _updateActiveTilesList(newTilesList){if(this._tileFilteringHook){var filteredTilesList={};for(var tk in newTilesList){if(this._tileFilteringHook(this._getVectorTile(tk,true).tile)){filteredTilesList[tk]=true;}}newTilesList=filteredTilesList;}var oldTilesList=this._activeTileKeys||{};var observersToUpdate={},key;if(this.processingTile){newTilesList[this.processingTile.vectorTileKey]=true;}if(this._rasterVectorTile){key=this._rasterVectorTile.vectorTileKey;newTilesList[key]=true;this._tiles[key]={tile:this._rasterVectorTile};}for(key in newTilesList){if(!oldTilesList[key]){this._observerTileLoader.addTile(this._getVectorTile(key,true).tile);this._checkSubscription(key,observersToUpdate);}}for(key in oldTilesList){if(!newTilesList[key]){this._checkSubscription(key,observersToUpdate);this._observerTileLoader.removeTile(key);}}this._activeTileKeys=newTilesList;this._triggerObservers(observersToUpdate);},_checkSubscription:function _checkSubscription(vKey,observersToUpdate){var observerIds=this._observerTileLoader.getTileObservers(vKey);for(var sid in observerIds){observersToUpdate[sid]=true;}},_propertiesToArray:function _propertiesToArray(it){var prop=it.properties,indexes=this.tileAttributeIndexes,arr=[];for(var key in indexes){arr[indexes[key]]=prop[key];}arr[arr.length]=it.geometry;arr[0]=it.id;return arr;},_clearProcessing:function _clearProcessing(){if(this.processingTile){this.processingTile.clear();}},_chkProcessing:function _chkProcessing(processing){this.processingTile=this.processingTile||this.addData([]);this.processingTile.clear();var needProcessingFilter=false,skip={},id,i,len,it;if(processing){if(processing.Deleted){for(i=0,len=processing.Deleted.length;i<len;i++){id=processing.Deleted[i];skip[id]=true;}if(len>0){needProcessingFilter=true;}}var out={};if(processing.Inserted){for(i=0,len=processing.Inserted.length;i<len;i++){it=processing.Inserted[i];id=it[0];if(!skip[id]){out[id]=it;}}}if(processing.Updated){for(i=0,len=processing.Updated.length;i<len;i++){it=processing.Updated[i];id=it[0];if(!skip[id]){out[id]=it;}if(!needProcessingFilter){needProcessingFilter=true;}}}var data=[];for(id in out){data.push(out[id]);}if(data.length>0){this.processingTile=this.addData(data);}}if(needProcessingFilter){var processingTile=this.processingTile;this.addFilter('processingFilter',function(item,tile){return tile.z===0||!(item.id in processingTile.itemsKeys||skip[item.id]);});}else if(this._filters['processingFilter']){this.removeFilter('processingFilter');}},_isUpdateded:function _isUpdateded(a,b){if(a.length===b.length){for(var i=0,len=a.length;i<len;i++){if(_typeof$1(a[i])==='object'&&JSON.stringify(a[i])!==JSON.stringify(b[i])&&a[i]!==b[i]){return i;}}return false;}else {return true;}},enableGeneralization:function enableGeneralization(){if(!this.options.isGeneralized){this.options.isGeneralized=true;this._resetTilesTree();}},disableGeneralization:function disableGeneralization(){if(this.options.isGeneralized){this.options.isGeneralized=false;this._resetTilesTree();}},_resetTilesTree:function _resetTilesTree(){this._tilesTree=null;this._reCheckActiveTileKeys();// this._needCheckActiveTiles = true;
// this._getActiveTileKeys(); //force list update
},updateVersion:function updateVersion(options,tiles){if(!L.gmx.skipLoadTiles){if(options){this.setOptions(options);}if(tiles){// ÐµÑÑÑ ÑÐ¿Ð¸ÑÐºÐ¸ ÑÐ°Ð¹Ð»Ð¾Ð² Ð¿Ð¾ BBOX
this._needCheckActiveTiles=false;var tKey,newTiles={},newActiveTileKeys={};for(var i=0,cnt=0,len=tiles.length;i<len;i+=6,cnt++){tKey=L.gmx.VectorTile.createTileKey({z:Number(tiles[i]),x:Number(tiles[i+1]),y:Number(tiles[i+2]),v:Number(tiles[i+3]),d:Number(tiles[i+4]),s:Number(tiles[i+5])});newTiles[tKey]=this._getVectorTile(tKey,true);newActiveTileKeys[tKey]=true;}this._tiles=newTiles;if(this.processingTile){this._tiles[this.processingTile.vectorTileKey]={tile:this.processingTile};}this._updateActiveTilesList(newActiveTileKeys);}else {this._resetTilesTree();}}},getNotLoadedVectorTiles:function getNotLoadedVectorTiles(options){var count=0;if(options.tiles){// options.tilesOrder = ["Z", "X", "Y", "V", "Level", "Span"]
var arr=options.tiles||[];for(var i=0,cnt=0,len=arr.length;i<len;i+=6,cnt++){if(!this._tiles[L.gmx.VectorTile.createTileKey({z:Number(arr[i]),x:Number(arr[i+1]),y:Number(arr[i+2]),v:Number(arr[i+3]),d:Number(arr[i+4]),s:Number(arr[i+5])})]){count++;}}}return count;},_getDataKeys:function _getDataKeys(data){var chkKeys={};for(var i=0,len=data.length;i<len;i++){chkKeys[data[i][0]]=true;}return chkKeys;},_getProcessingTile:function _getProcessingTile(){if(!this.processingTile){var x=-0.5,y=-0.5,z=0,v=0,s=-1,d=-1,isFlatten=this.options.isFlatten;this.processingTile=new L.gmx.VectorTile({load:function load(x,y,z,v,s,d,callback){callback({values:[]});}},{x:x,y:y,z:z,v:v,s:s,d:d,isFlatten:isFlatten,processing:true});this.addTile(this.processingTile);}return this.processingTile;},addData:function addData(data){if(!data){data=[];}var vTile=this._getProcessingTile(),chkKeys=this._getDataKeys(data);vTile.addData(data,chkKeys);this._triggerObservers();return vTile;},removeData:function removeData(data){var vTile=this.processingTile;if(vTile){var chkKeys=(data||vTile.data).reduce(function(a,item){var id=typeof item==='string'?item:item[0];a[id]=true;return a;}.bind(this),{});this._removeDataFromObservers(chkKeys);vTile.removeData(chkKeys,true);this._triggerObservers();}return vTile;},/*
      initTilesTree: function() {
  		// console.log('_tilesTree', this._tilesTree);
          this._tilesTree = L.gmx.tilesTree(this.options);
          this.options.TemporalTiles = this.options.TemporalVers = null;
  
          if ('TemporalTiles' in this.optionsLink) {
              this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;
          }
          this.dateZero = this._tilesTree.dateZero;
          if (this.processingTile) {
              this._tiles[this.processingTile.vectorTileKey] = {
                  tile: this.processingTile
              };
          }
      },
  */_getVectorTile:function _getVectorTile(vKey,createFlag){if(!this._tiles[vKey]&&createFlag){var info=L.gmx.VectorTile.parseTileKey(vKey);info.dateZero=this.dateZero;this._addVectorTile(info);}return this._tiles[vKey];},_addVectorTile:function _addVectorTile(info){info.isFlatten=this.options.isFlatten;info.needBbox=this.options.needBbox;info.attributes=this.options.attributes;var tile=new L.gmx.VectorTile(this._vectorTileDataProvider,info),vKey=tile.vectorTileKey;this._tiles[vKey]={tile:tile};return vKey;},_getGeneralizedTileKeys:function _getGeneralizedTileKeys(vTilePoint){var dz=vTilePoint.z%2?1:2,pz=Math.pow(2,dz),z=vTilePoint.z-dz,x=Math.floor(vTilePoint.x/pz),y=Math.floor(vTilePoint.y/pz),temp={v:vTilePoint.v,s:-1,d:-1,isGeneralized:true},keys={};while(z>1){var gKey=[z,x,y].join('_');keys[gKey]=L.extend({},temp,{x:x,y:y,z:z});z-=2;x=Math.floor(x/4);y=Math.floor(y/4);}return keys;},initTilesList:function initTilesList(){// For non temporal layers we create all Vector tiles
var newActiveTileKeys={};if(this.options.tiles){// console.log('initTilesList', this.options.isGeneralized);
var arr=this.options.tiles||[],vers=this.options.tilesVers,generalizedKeys=this.options.isGeneralized?{}:null,newTiles={},gKey,tKey,info,tHash;for(var i=0,cnt=0,len=arr.length;i<len;i+=3,cnt++){info={x:Number(arr[i]),y:Number(arr[i+1]),z:Number(arr[i+2]),v:Number(vers[cnt]),s:-1,d:-1};tHash=this._getVectorTile(L.gmx.VectorTile.createTileKey(info),true);tKey=tHash.tile.vectorTileKey;newTiles[tKey]=tHash;newActiveTileKeys[tKey]=true;if(generalizedKeys){var gKeys=this._getGeneralizedTileKeys(info);for(gKey in gKeys){var gPoint=gKeys[gKey];if(generalizedKeys[gKey]){generalizedKeys[gKey].v=Math.max(gPoint.v,generalizedKeys[gKey].v);}else {generalizedKeys[gKey]=gPoint;}}}}if(generalizedKeys){for(gKey in generalizedKeys){info=generalizedKeys[gKey];tKey=L.gmx.VectorTile.createTileKey(info);if(!newTiles[tKey]){if(!this._tiles[tKey]){this._addVectorTile(info);}newTiles[tKey]=this._tiles[tKey];newActiveTileKeys[tKey]=true;}}}this._tiles=newTiles;if(this.processingTile){this._tiles[this.processingTile.vectorTileKey]={tile:this.processingTile};}}this._updateActiveTilesList(newActiveTileKeys);},//Tile filtering hook filters out active vector tiles.
//Can be used to prevent loading data from some spatial-temporal region
setTileFilteringHook:function setTileFilteringHook(filteringHook){this._tileFilteringHook=filteringHook;this._reCheckActiveTileKeys();// this._needCheckActiveTiles = true;
// this._getActiveTileKeys(); //force list update
},removeTileFilteringHook:function removeTileFilteringHook(){this._tileFilteringHook=null;this._reCheckActiveTileKeys();// this._needCheckActiveTiles = true;
// this._getActiveTileKeys(); //force list update
},_reCheckActiveTileKeys:function _reCheckActiveTileKeys(){this._needCheckActiveTiles=true;this._getActiveTileKeys();//force list update
}});L.gmx=L.gmx||{};L.gmx.DataManager=DataManager;var fetchOptions={//mode: 'cors',
credentials:'include'};function ScreenVectorTile(layer,tileElem){this.layer=layer;this.ts=layer.options.tileSize;this.tileElem=tileElem;this.tile=tileElem.el;var tilePoint=tileElem.coords,zoom=tilePoint.z,pz=Math.pow(2,zoom),x=tilePoint.x%pz,y=tilePoint.y%pz,utils=gmxAPIutils;if(x<0){x+=pz;}if(y<0){y+=pz;}this.ntp={z:zoom,x:x,y:y};this.tilePoint=tilePoint;this.zoom=zoom;this.gmx=layer._gmx;this.zKey=this.layer._tileCoordsToKey(tilePoint,zoom);this.worldWidthMerc=utils.worldWidthMerc;var gmxTilePoint=utils.getTileNumFromLeaflet(tilePoint,zoom);this.tpx=this.ts*gmxTilePoint.x;this.tpy=this.ts*(1+gmxTilePoint.y);var tileSize=utils.tileSizes[tilePoint.z]*this.ts/256;this.tbounds=utils.getBoundsByTilePoint(this.ntp,tileSize);this.topLeft={tilePoint:tilePoint,tileSize:tileSize,mInPixel:this.ts/tileSize,pix:{px:this.ts*tilePoint.x,py:this.ts*tilePoint.y},wm:{x:tileSize*tilePoint.x-this.worldWidthMerc,y:this.worldWidthMerc-tileSize*tilePoint.y},bounds:utils.getBoundsByTilePoint(tilePoint,tileSize)};this.gmxTilePoint=gmxTilePoint;this.showRaster=zoom>=this.gmx.minZoomRasters&&'rasterBGfunc'in this.gmx||zoom>=this.gmx.minZoomQuicklooks&&'quicklookBGfunc'in this.gmx;this.rasters={};//combined and processed canvases for each vector item in tile
this.rasterRequests={};// all cached raster requests
this.itemsView=[];// items on screen tile + todo: without not visible
this._uniqueID=0;// draw attempt id
this.gmx.badTiles=this.gmx.badTiles||{};}ScreenVectorTile.prototype={_getUrlFunction:function _getUrlFunction(gtp,item){return this.gmx.rasterBGfunc(gtp.x,gtp.y,gtp.z,item);},_chkZoom:function _chkZoom(zoom){return zoom>=this.gmx.minZoomRasters&&'rasterBGfunc'in this.gmx||zoom>=this.gmx.minZoomQuicklooks&&'quicklookBGfunc'in this.gmx;},_loadTileRecursive:function _loadTileRecursive(tilePoint,item){//return promise, which resolves with object {gtp, image}
var gmx=this.gmx,gtp={z:tilePoint.z,x:this.ntp.x,y:this.ntp.y},_this=this;// for (var key in this.rasterRequests) {
// this.rasterRequests[key].reject();
// }
this.rasterRequests={};return new Promise(function(resolve){var tryLoad=function tryLoad(gtp,crossOrigin){var rUrl=_this._getUrlFunction(gtp,item);if(gmx.rastersCache&&gmx.rastersCache[rUrl]){resolve({gtp:gtp,image:gmx.rastersCache[rUrl]});}else {var tryHigherLevelTile=function tryHigherLevelTile(url){if(url){gmx.badTiles[url]=true;}var nextZoom=gtp.z-1;if(nextZoom&&_this._chkZoom(nextZoom)){tryLoad({x:Math.floor(gtp.x/2),y:Math.floor(gtp.y/2),z:nextZoom},'');// 'anonymous' 'use-credentials'
}else {resolve({gtp:gtp});}},skipUrl=function skipUrl(res){_this.layer.fire('bitmap',{id:item.id,loaded:false,url:rUrl,result:res});tryHigherLevelTile(rUrl);};if(gmx.badTiles[rUrl]||gmx.maxNativeZoom&&gmx.maxNativeZoom<gtp.z){tryHigherLevelTile();return;}if(L.gmx.getBitmap){L.gmx.getBitmap(rUrl,fetchOptions).then(function(res){if(res){var imageObj=res.imageBitmap,canvas_=document.createElement('canvas');canvas_.width=imageObj.width;canvas_.height=imageObj.height;canvas_.getContext('2d').drawImage(imageObj,0,0,canvas_.width,canvas_.width);if(gmx.rastersCache){gmx.rastersCache[rUrl]=canvas_;}resolve({gtp:gtp,image:canvas_});_this.layer.fire('bitmap',{id:item.id,loaded:true,url:rUrl,result:res});}else {skipUrl();}},skipUrl// function(res) {
// _this.layer.fire('bitmap', {id: item.id, loaded: false, url: rUrl, result: res});
// tryHigherLevelTile(rUrl);
// }
).catch(L.Util.falseFn);}else {var request=_this.rasterRequests[rUrl];if(!request){if(gmx.rasterProcessingHook){crossOrigin='anonymous';}request=L.gmx.imageLoader.push(rUrl,{tileRastersId:_this._uniqueID,zoom:_this.zoom,cache:true,crossOrigin:gmx.crossOrigin||crossOrigin||''});_this.rasterRequests[rUrl]=request;}else {request.options.tileRastersId=_this._uniqueID;}request.def.then(function(imageObj){if(imageObj){if(gmx.rastersCache){gmx.rastersCache[rUrl]=imageObj;}resolve({gtp:gtp,image:imageObj});}else {tryHigherLevelTile(rUrl);}},function(){// console.log('tryHigherLevelTile111 ', rUrl);
tryHigherLevelTile(rUrl);});}}};tryLoad(gtp);});},_rasterHook:function _rasterHook(attr){var source=attr.sourceTilePoint||attr.destinationTilePoint,info={geoItem:attr.geoItem,zKey:attr.zKey,destination:{z:attr.destinationTilePoint.z,x:attr.destinationTilePoint.x,y:attr.destinationTilePoint.y},source:{z:source.z,x:source.x,y:source.y}};if(attr.url){info.quicklook=attr.url;}return (this.gmx.rasterProcessingHook||this._defaultRasterHook)(attr.res,attr.image,attr.sx||0,attr.sy||0,attr.sw||256,attr.sh||256,attr.dx||0,attr.dy||0,attr.dw||256,attr.dh||256,info);},// default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp
_defaultRasterHook:function _defaultRasterHook(res,image,sx,sy,sw,sh,dx,dy,dw,dh){if(image){var ptx=res.getContext('2d');ptx.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh);}return res;},// get pixels parameters for shifted object
_getShiftPixels:function _getShiftPixels(it){var w=it.dx+(it.dx<0?256:0),h=it.dy+(it.dy<0?256:0),sx=0,sw=256-w,dx=w,dw=sw;if(it.tx>it.x){sx=sw;sw=w;dx=0;dw=sw;}if(sx===256||sw<1){return null;}var sy=h,sh=256-h,dy=0,dh=sh;if(it.ty>it.y){sy=0;dy=sh;sh=h;dh=sh;}if(sy===256||sh<1){return null;}return {sx:sx,sy:sy,sw:sw,sh:sh,dx:dx,dy:dy,dw:dw,dh:dh};},// get tiles parameters for shifted object
_getShiftTilesArray:function _getShiftTilesArray(bounds,shiftX,shiftY){var mInPixel=this.topLeft.mInPixel,gmxTilePoint=this.gmxTilePoint,px=shiftX*mInPixel,py=shiftY*mInPixel,deltaX=Math.floor(0.5+px%this.ts),// shift on tile in pixel
deltaY=Math.floor(0.5+py%this.ts),tileSize=this.ts/mInPixel,tminX=gmxTilePoint.x-shiftX/tileSize,// by screen tile
tminY=gmxTilePoint.y-shiftY/tileSize,rminX=Math.floor(tminX),rmaxX=rminX+(tminX===rminX?0:1),rminY=Math.floor(tminY),rmaxY=rminY+(tminY===rminY?0:1),minX=Math.floor((bounds.min.x-shiftX)/tileSize),// by geometry bounds
maxX=Math.floor((bounds.max.x-shiftX)/tileSize),minY=Math.floor((bounds.min.y-shiftY)/tileSize),maxY=Math.floor((bounds.max.y-shiftY)/tileSize);if(rminX<minX){rminX=minX;}if(rmaxX>maxX){rmaxX=maxX;}if(rminY<minY){rminY=minY;}if(rmaxY>maxY){rmaxY=maxY;}var arr=[];for(var j=rminY;j<=rmaxY;j++){for(var i=rminX;i<=rmaxX;i++){arr.push({z:gmxTilePoint.z,x:i,y:j,dx:deltaX,dy:deltaY,tx:tminX,ty:tminY});}}return arr;},_chkRastersByItemIntersect:function _chkRastersByItemIntersect(arr,item){var geo=item.properties[item.properties.length-1],out=[];arr.forEach(function(it){var bounds=gmxAPIutils.getBoundsByTilePoint(it);if(gmxAPIutils.isItemIntersectBounds(geo,bounds)){out.push(it);}});return out;},getTilePosZoomDelta:function getTilePosZoomDelta(tilePoint,zoomFrom,zoomTo){// Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ ÑÐ¼ÐµÑÐµÐ½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð° Ð½Ð° Ð¼ÐµÐ½ÑÑÐµÐ¼ zoom
var dz=Math.pow(2,zoomFrom-zoomTo),size=this.ts/dz,dx=tilePoint.x%dz,dy=tilePoint.y%dz;return {size:size,zDelta:dz,x:size*dx,y:size*dy};},// Loads missing rasters for single item and combines them in canvas.
// Stores resulting canvas in this.rasters
_getItemRasters:function _getItemRasters(geo){var properties=geo.properties,idr=properties[0],_this=this,gmx=this.gmx,indexes=gmx.tileAttributeIndexes,rasters=this.rasters,shiftX=Number(gmx.shiftXfield?gmxAPIutils.getPropItem(gmx.shiftXfield,properties,indexes):0)%this.worldWidthMerc,shiftY=Number(gmx.shiftYfield?gmxAPIutils.getPropItem(gmx.shiftYfield,properties,indexes):0),isShift=shiftX||shiftY,urlBG=gmxAPIutils.getPropItem('urlBG',properties,indexes),url='',itemImageProcessingHook=null,isTiles=false,// item = gmx.dataManager.getItem(idr),
item=geo,gmxTilePoint=this.gmxTilePoint,tilePoint=this.tilePoint,ntp=this.ntp,resCanvas=null;item.v=geo.v;if(gmx.IsRasterCatalog&&(gmx.rawProperties.type==='Raster'||gmxAPIutils.getPropItem('GMX_RasterCatalogID',properties,indexes))){isTiles=true;// Raster Layer
}else if(gmx.quicklookBGfunc){url=gmx.quicklookBGfunc(item);// Quicklook
itemImageProcessingHook=gmx.imageQuicklookProcessingHook;}else if(urlBG){url=urlBG;// Image urlBG from properties
itemImageProcessingHook=gmx.imageQuicklookProcessingHook;}if(isTiles){return new Promise(function(resolve1){var dataOption=geo.dataOption||{},tileToLoadPoints=this._chkRastersByItemIntersect(isShift?this._getShiftTilesArray(dataOption.bounds,shiftX,shiftY):[ntp],geo);var cnt=tileToLoadPoints.length,chkReadyRasters=function chkReadyRasters(){if(cnt<1){resolve1();}},skipRasterFunc=function skipRasterFunc(){cnt--;chkReadyRasters();},onLoadFunction=function onLoadFunction(gtp,p,img){item.skipRasters=false;var isImage=true;if(itemImageProcessingHook){img=itemImageProcessingHook(img,{gmx:gmx,geoItem:geo,item:item,gmxTilePoint:gtp});isImage=false;}var info={geoItem:geo,image:img,zKey:_this.zKey,destinationTilePoint:tilePoint,sourceTilePoint:gtp,sx:0,sy:0,sw:_this.ts,sh:_this.ts,dx:0,dy:0,dw:_this.ts,dh:_this.ts};if(isShift){var pos=_this._getShiftPixels(p);if(pos===null){skipRasterFunc();return;}L.extend(info,pos);isImage=false;}if(gtp.z!==ntp.z){var posInfo=_this.getTilePosZoomDelta(ntp,ntp.z,gtp.z);if(posInfo.size<1/256){// Ð¼ÐµÐ½ÑÑÐµ 1px
chkReadyRasters();return;}isImage=false;info.sx=Math.floor(posInfo.x);info.sy=Math.floor(posInfo.y);info.sw=info.sh=posInfo.size;if(isShift){var sw=Math.floor(info.dw/posInfo.zDelta);info.sx=(info.dx===0?info.sw:_this.ts)-sw;info.sw=sw;var sh=Math.floor(info.dh/posInfo.zDelta);info.sy=(info.dy===0?info.sh:_this.ts)-sh;info.sh=sh;}}if(isImage&&!gmx.rasterProcessingHook){cnt--;resCanvas=img;rasters[idr]=resCanvas;chkReadyRasters();}else {if(!resCanvas){resCanvas=document.createElement('canvas');resCanvas.width=resCanvas.height=_this.ts;}info.res=resCanvas;var hookResult=_this._rasterHook(info),then=function then(){cnt--;//p.resImage = resCanvas;
rasters[idr]=resCanvas;chkReadyRasters();};if(hookResult){if(hookResult.then){hookResult.then(then);}else {resCanvas=hookResult;then();}}else if(hookResult===null){item.skipRasters=true;skipRasterFunc();}else {resCanvas=img;then();}}};if(cnt){tileToLoadPoints.map(function(it){var loader=_this._loadTileRecursive(it,item);loader.then(function(loadResult){onLoadFunction(loadResult.gtp,it,loadResult.image);},skipRasterFunc);return loader;});}else {item.skipRasters=true;skipRasterFunc();}}.bind(this));}if(gmx.sessionKey){url+=(url.indexOf('?')===-1?'?':'&')+'key='+encodeURIComponent(gmx.sessionKey);}return new Promise(function(resolve1){var skipRaster=function skipRaster(res){_this.layer.fire('bitmap',{id:idr,loaded:false,url:url,result:res});item.skipRasters=true;resolve1();};// console.log('____3_____', this.zKey, url)
if(!url){skipRaster();return;}var done=function(resCanvas){gmx.quicklooksCache[url]=resCanvas;var res=resCanvas;if(this.gmx.rasterProcessingHook);if(itemImageProcessingHook){// ÑÑÐµÐ±ÑÐµÑÑÑ transform
var imgAttr={gmx:gmx,topLeft:this.topLeft,geoItem:geo,item:item,gmxTilePoint:gmxTilePoint};res=itemImageProcessingHook(resCanvas,imgAttr);}if(res){resolve1(res);item.skipRasters=false;rasters[idr]=res;}else {skipRaster();}}.bind(this);if(gmx.quicklooksCache&&gmx.quicklooksCache[url]){done(gmx.quicklooksCache[url]);}else if(L.gmx.getBitmap){var urlProxy=url;if(gmx.gmxProxy){urlProxy=gmx.gmxProxy+'?WrapStyle=none&get='+encodeURIComponent(url);}L.gmx.getBitmap(urlProxy,fetchOptions).then(function(res){var imageObj=res.imageBitmap,canvas_=document.createElement('canvas');canvas_.width=imageObj.width;canvas_.height=imageObj.height;canvas_.getContext('2d').drawImage(imageObj,0,0,canvas_.width,canvas_.height);done(canvas_);_this.layer.fire('bitmap',{id:idr,loaded:true,url:url,result:res});},skipRaster).catch(skipRaster);}else {var request=this.rasterRequests[url];if(!request){request=L.gmx.imageLoader.push(url,{tileRastersId:_this._uniqueID,crossOrigin:gmx.crossOrigin||'anonymous'});this.rasterRequests[url]=request;}else {request.options.tileRastersId=this._uniqueID;}// in fact, we want to return request.def, but need to do additional action during cancellation.
// so, we consctruct new promise and add pipe it with request.def
request.def.then(done,skipRaster);}}.bind(this));},_getVisibleItems:function _getVisibleItems(geoItems){if(geoItems.length<2){this.itemsView=geoItems;return geoItems;}if(!gmxAPIutils._tileCanvas){gmxAPIutils._tileCanvas=document.createElement('canvas');gmxAPIutils._tileCanvas.width=gmxAPIutils._tileCanvas.height=this.ts;}var i,len,gmx=this.gmx,dm=gmx.dataManager,canvas=gmxAPIutils._tileCanvas,ctx=canvas.getContext('2d'),dattr={tbounds:this.tbounds,gmx:gmx,topLeft:this.topLeft,tpx:this.tpx,tpy:this.tpy,ctx:ctx};ctx.clearRect(0,0,this.ts,this.ts);ctx.imageSmoothingEnabled=false;for(i=0,len=geoItems.length;i<len;i++){ctx.fillStyle=gmxAPIutils.dec2rgba(i+1,1);var geoItem=geoItems[i];L.gmxUtil.drawGeoItem(geoItem,dm.getItem(geoItem.properties[0]),dattr,{fillStyle:ctx.fillStyle});}var items={},data=ctx.getImageData(0,0,this.ts,this.ts).data;for(i=0,len=data.length;i<len;i+=4){if(data[i+3]===255){var color=data[i+2];if(data[i+1]){color+=data[i+1]<<8;}if(data[i]){color+=data[i]<<16;}if(color){items[color]=true;}}}var out=[];for(var num in items){var it=geoItems[Number(num)-1];if(it){out.push(it);}}this.itemsView=out;return out;},_getNeedRasterItems:function _getNeedRasterItems(geoItems){var gmx=this.gmx,indexes=gmx.tileAttributeIndexes,tbounds=this.tbounds,out=[];for(var i=0,len=geoItems.length;i<len;i++){var geo=geoItems[i],properties=geo.properties,idr=properties[0],dataOption=geo.dataOption||{},skipRasters=false;if(gmx.quicklookBGfunc&&!gmxAPIutils.getPropItem('GMX_RasterCatalogID',properties,indexes)){if(gmx.minZoomQuicklooks&&this.zoom<gmx.minZoomQuicklooks){continue;}var platform=gmxAPIutils.getPropItem(gmx.quicklookPlatform,properties,indexes)||gmx.quicklookPlatform||'';if((!platform||platform==='imageMercator')&&!gmxAPIutils.getQuicklookPointsFromProperties(properties,gmx)){continue;}}if(gmx.styleHook){geo.styleExtend=gmx.styleHook(gmx.dataManager.getItem(idr),gmx.lastHover&&idr===gmx.lastHover.id);skipRasters=geo.styleExtend&&geo.styleExtend.skipRasters;}if(!skipRasters&&tbounds.intersectsWithDelta(dataOption.bounds,-1,-1)){out.push(geo);}}return this._getVisibleItems(out);},_getTileRasters:function _getTileRasters(geoItems){//load all missing rasters for items we are going to render
return new Promise(function(resolve){var arr=this._getNeedRasterItems(geoItems).map(this._getItemRasters.bind(this));// console.log('_getTileRasters___', arr)
Promise.all(arr).then(resolve,function(){// console.log('_getTileRasters', ev)
});}.bind(this));},_chkItems:function _chkItems(data){var layer=this.layer;if(!layer._map){return null;}var items=data&&data.added&&data.added.length?data.added:null;if(!items){var tLink=layer._tiles[this.zKey];if(tLink&&tLink.el){tLink.el.getContext('2d').clearRect(0,0,this.ts,this.ts);}return null;}return this.gmx.sortItems?layer.getSortedItems(items):items;},destructor:function destructor(){// if (this.drawReject) {
// this.drawReject('Ð¾ÑÐ¼ÐµÐ½Ð°');
// this.drawReject = null;
// }
if(this._preRenderPromise){this._preRenderPromise.reject();// cancel preRenderHooks chain if exists
}if(this._renderPromise){this._renderPromise.reject();// cancel renderHooks chain if exists
}this._cancelRastersPromise();this._clearCache();},_cancelRastersPromise:function _cancelRastersPromise(){if(this.rastersPromise){if(this.rastersPromise.reject){this.rastersPromise.reject();}this.rastersPromise=null;}},_clearCache:function _clearCache(){for(var url in this.rasterRequests){this.rasterRequests[url].remove();}this.rasterRequests={};},drawTile:function drawTile(data){// if (L.gmx._animatingZoom) {
// if (this._animId) { L.Util.cancelAnimFrame(this._animId); }
// console.log('____ drawTile', L.gmx._animatingZoom);
// return new Promise(function(resolve, reject) {
// resolve();
// });
// }
this.destructor();return new Promise(function(resolve,reject){// if (L.gmx._animatingZoom) {
// resolve();
// return;
// }
if(L.gmx._zoomStart&&L.gmx._zoomStart!==this.zoom){resolve();return;}// this.drawReject = reject;
var geoItems=this._chkItems(data);var result=function(){resolve({count:geoItems.length});}.bind(this);this._uniqueID++;// count draw attempt
if(geoItems){if(this.layer._gridClusters&&this.layer._gridClusters.checkData({geoItems:geoItems,tileElem:this.tileElem,layer:this.layer})){result();return;}if(this.showRaster){this.rastersPromise=this._getTileRasters(geoItems);this.rastersPromise.then(function(){this._doDraw(geoItems,resolve,reject);}.bind(this),reject);//first load all raster images, then render all of them at once
}else {this._doDraw(geoItems,resolve,reject);}}else {resolve();}}.bind(this)).catch(console.warn);},_doDraw:function _doDraw(geoItems,resolve,reject){// if (L.gmx._animatingZoom) {
// console.log('____ _doDraw', L.gmx._animatingZoom);
// return [];
// }
var _this=this,tile=_this.tile,ctx=tile.getContext('2d'),gmx=_this.gmx,ts=_this.layer.options.tileSize||256,dattr={//tileLink: tileLink,
tbounds:_this.tbounds,rasters:_this.rasters,gmx:gmx,topLeft:_this.topLeft,tpx:_this.tpx,tpy:_this.tpy,ctx:ctx},tinfo='zKey:'+_this.zKey+' count: '+geoItems.length;L.DomUtil.addClass(_this.tile,tinfo);_this.tile.width=_this.tile.height=ts;if(!_this.layer._gridClusters){ctx.clearRect(0,0,ts,ts);if(gmx.showScreenTiles){ctx.strokeRect(0,0,ts-1,ts-1);ctx.strokeText(_this.zKey+' '+geoItems.length,50,50);}}var hookInfo={zKey:_this.zKey,topLeft:_this.topLeft,tpx:_this.tpx,tpy:_this.tpy,x:_this.tilePoint.x,y:_this.tilePoint.y,z:_this.zoom},bgImage;var fArr=[];gmx.preRenderHooks.forEach(function(f){if(!bgImage){bgImage=document.createElement('canvas');bgImage.width=bgImage.height=ts;}var res=f(bgImage,hookInfo);if(res&&res.then){fArr.push(res);}});Promise.all(fArr).then(function(){if(bgImage){dattr.bgImage=bgImage;}// if (L.gmx._animatingZoom) {
// console.log('geoItems', geoItems.length, L.gmx._animatingZoom, gmx.preRenderHooks);
// resolve({count: 0});
// return;
// }
// window.tStamp = Date.now();
//ctx.save();
// var drawCount = 0;
for(var i=0,len=geoItems.length;i<len;i++){var geoItem=geoItems[i],id=geoItem.id,item=geoItem;// item = gmx.dataManager.getItem(id);
if(item){// skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)
var style=gmx.styleManager.getObjStyle(item,_this.zoom),hover=gmx.lastHover&&gmx.lastHover.id===geoItem.id&&style;if(gmx.multiFilters){for(var j=0,len1=item.multiFilters.length;j<len1;j++){var it=item.multiFilters[j];L.gmxUtil.drawGeoItem(geoItem,item,dattr,hover?it.parsedStyleHover:it.parsedStyle,it.style);}}else {// if(!dattr.rasters[item.id]) {
// console.log('___bg', _this.ntp, item.skipRasters, item.id, dattr.rasters[item.id]);
// }
// geoItem._animId = L.Util.requestAnimFrame(function() {
// if (L.gmx._animatingZoom) {
// console.log('__________L.gmxUtil.drawGeoItem_', i, geoItem._animId, geoItems.length);
// break;
// }
// L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);
// }, this);
L.gmxUtil.drawGeoItem(geoItem,item,dattr,hover?item.parsedStyleHover:item.parsedStyleKeys,style);//drawCount += L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style) ? 1 : 0;
}if(id in gmx._needPopups&&!gmx._needPopups[id]){gmx._needPopups[id]=true;}}}// console.log('doDraw:', _this.zKey, drawCount, geoItems.length, (Date.now() - window.tStamp) / 1000, ' sec.');
//ctx.restore();
//_this.rasters = {}; // clear rasters		TODO: ÑÐ°ÑÑÑÑ Ð¿ÑÐ¾Ð¿Ð°Ð´Ð°ÑÑ Ð¸Ð·-Ð·Ð° Ð±ÑÑÑÑÑÑ Ð¿ÐµÑÐµÑÐ¸ÑÐ¾Ð²Ð¾Ðº permalink=C2YMI
Promise.all(_this._getHooksPromises(gmx.renderHooks,tile,hookInfo)).then(function(){resolve({count:geoItems.length});},reject);},reject);// _this.layer.appendTileToContainer(_this.tileElem);
},_getHooksPromises:function _getHooksPromises(hooks,obj,options){var arr=[];hooks.forEach(function(f){var res=f(obj,options);if(res&&res.then){arr.push(res);}});return arr;}};var VectorGridLayer=L.GridLayer.extend({_animateZoom:function _animateZoom(e){this.options.updateWhenZooming=false;this._setView(e.center,e.zoom,true,true);},_setZoomTransform:function _setZoomTransform(level,center,zoom){// Add by Geomixer (for cache levels transform)
var key=level.zoom+'_'+zoom+'_'+level.origin.x+'_'+level.origin.y,cache=L.gmx._zoomLevelsCache[key]||{},translate=cache.translate,scale=cache.scale;if(!translate){scale=this._map.getZoomScale(zoom,level.zoom);translate=level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center,zoom))._round();L.gmx._zoomLevelsCache[key]={translate:translate,scale:scale};}if(L.Browser.any3d){L.DomUtil.setTransform(level.el,translate,scale);}else {L.DomUtil.setPosition(level.el,translate);}},_clearOldLevels:function _clearOldLevels(z){if(this._map){z=z||this._map.getZoom();for(var key in this._levels){var el=this._levels[key].el,zz=Number(key);if(zz!==z){L.DomUtil.remove(el);this._removeTilesAtZoom(zz);this._onRemoveLevel(zz);delete this._levels[key];}}}},_noTilesToLoad:function _noTilesToLoad(){var zoom=this._tileZoom||this._map.getZoom();for(var key in this._tiles){if(this._tiles[key].coords.z===zoom&&!this._tiles[key].loaded){return false;}}return true;},_tileReady:function _tileReady(coords,err,tile){if(!this._map){return;}// Add by Geomixer (Ð½ÐµÑ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÐ¸ Ð¾ÑÐºÐ»ÑÑÐµÐ½Ð¸Ñ fade-anim)
if(err){// @event tileerror: TileErrorEvent
// Fired when there is an error loading a tile.
this.fire('tileerror',{error:err,tile:tile,coords:coords});}var key=this._tileCoordsToKey(coords);tile=this._tiles[key];if(!tile){return;}tile.loaded=+new Date();if(!err){L.DomUtil.addClass(tile.el,'leaflet-tile-loaded');this.fire('tileload',{// @event tileload: TileEvent // Fired when a tile loads.
tile:tile.el,coords:coords});}if(this._noTilesToLoad()){this._loading=false;this._clearOldLevels(this._tileZoom);this.fire('load');// @event load: Event // Fired when the grid layer loaded all visible tiles.
}},//////////////////
_updateLevels:function _updateLevels(){// Add by Geomixer (coords.z is Number however _levels keys is String)
var zoom=this._tileZoom,map=this._map;// ,
// maxZoom = this.options.maxZoom;
if(zoom===undefined){return undefined;}for(var z in this._levels){var delta=zoom-z;if(delta===0){this._levels[z].origin=map.project(map.unproject(map.getPixelOrigin()),zoom).round();this._onUpdateLevel(zoom);}}var level=this._levels[zoom];if(!level){level=this._levels[zoom]={};level.el=L.DomUtil.create('div','leaflet-tile-container leaflet-zoom-animated',this._container);level.origin=map.project(map.unproject(map.getPixelOrigin()),zoom).round();level.zoom=zoom;this._setZoomTransform(level,map.getCenter(),map.getZoom());// force the browser to consider the newly added element for transition
// L.Util.falseFn(level.el.offsetWidth);
this._onCreateLevel(level);}this._level=level;return level;},_update:function _update(center){// Add by Geomixer (Ð´Ð»Ñ ÑÐ¾Ð±ÑÑÐ¸Ñ update _tiles + Ð½Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑÑ Ð¿ÑÑÑÑÐµ ÑÐ°Ð¹Ð»Ñ)
var map=this._map;if(!map){return;}var zoom=this._clampZoom(map.getZoom());if(center===undefined){center=map.getCenter();}if(this._tileZoom===undefined){return;}// if out of minzoom/maxzoom
var pixelBounds=this._getTiledPixelBounds(center),tileRange=this._pxBoundsToTileRange(pixelBounds),tileCenter=tileRange.getCenter(),queue=[],margin=this.options.keepBuffer,noPruneRange=new L.Bounds(tileRange.getBottomLeft().subtract([margin,-margin]),tileRange.getTopRight().add([margin,-margin]));// Sanity check: panic if the tile range contains Infinity somewhere.
if(!(isFinite(tileRange.min.x)&&isFinite(tileRange.min.y)&&isFinite(tileRange.max.x)&&isFinite(tileRange.max.y))){throw new Error('Attempted to load an infinite number of tiles');}for(var key in this._tiles){var c=this._tiles[key].coords;if(c.z!==this._tileZoom||!noPruneRange.contains(new L.Point(c.x,c.y))){this._tiles[key].current=false;}}// _update just loads more tiles. If the tile zoom level differs too much
// from the map's, let _setView reset levels and prune old tiles.
if(Math.abs(zoom-this._tileZoom)>1){this._setView(center,zoom);return;}// create a queue of coordinates to load tiles from
for(var j=tileRange.min.y;j<=tileRange.max.y;j++){for(var i=tileRange.min.x;i<=tileRange.max.x;i++){var coords=new L.Point(i,j);coords.z=this._tileZoom;if(!this._isValidTile(coords)){continue;}var tile=this._tiles[this._tileCoordsToKey(coords)];if(tile){tile.current=true;// if (tile.el.parentNode !== this._level.el) {
// this._level.el.appendChild(tile.el);
// }
}else {queue.push(coords);}}}// sort tile queue to load tiles in order of their distance to center
queue.sort(function(a,b){return a.distanceTo(tileCenter)-b.distanceTo(tileCenter);});if(queue.length!==0){// if it's the first batch of tiles to load
if(!this._loading){this._loading=true;// @event loading: Event
// Fired when the grid layer starts loading tiles.
this.fire('loading');}// create DOM fragment to append tiles in one batch
var fragment=document.createDocumentFragment();for(i=0;i<queue.length;i++){this._addTile(queue[i],fragment);}// if (!(this instanceof L.gmx.VectorLayer)) {
// this._level.el.appendChild(fragment);
// }
}this.fire('update');}});L.gmx.VectorLayer=VectorGridLayer.extend({options:{tilesCRS:L.CRS.EPSG3395,openPopups:[],className:'vector-tiles',minZoom:1,zIndexOffset:0,isGeneralized:true,isFlatten:false,useWebGL:false,skipTiles:'All',// All, NotVisible, None
iconsUrlReplace:[],cacheRasters:true,cacheQuicklooks:true,clearCacheOnLoad:true,showScreenTiles:false,updateWhenZooming:false,// bubblingMouseEvents: false,
keepBuffer:0,clickable:true},// extended from L.GridLayer
initialize:function initialize(options){// options = L.setOptions(this, L.extend(this.options, options));
options=L.setOptions(this,options);this._initPromise=new Promise(function(resolve,reject){this._resolve=resolve;this._reject=reject;}.bind(this));this.repaintObservers={};// external observers like screen
this._gmx={hostName:gmxAPIutils.normalizeHostname(options.hostName||'maps.kosmosnimki.ru'),mapName:options.mapID,gmxEndPoints:options.gmxEndPoints,sessionKey:this.options.sessionKey,iconsUrlReplace:this.options.iconsUrlReplace,showScreenTiles:this.options.showScreenTiles,skipTiles:options.skipTiles,needBbox:options.skipTiles==='All',useWebGL:options.useWebGL,srs:options.srs||'',layerID:options.layerID,beginDate:options.beginDate,endDate:options.endDate,sortItems:options.sortItems||null,styles:options.styles||[],shiftXlayer:0,shiftYlayer:0,renderHooks:[],preRenderHooks:[],_needPopups:{}};if(/\buseWebGL=1\b/.test(location.search)){this._gmx.useWebGL=true;}if(options.cacheQuicklooks){// cache quicklooks for CR
this._gmx.quicklooksCache={};}if(options.cacheRasters){// cache rasters for CR
this._gmx.rastersCache={};}if(options.crossOrigin){this._gmx.crossOrigin=options.crossOrigin;}},_onCreateLevel:function _onCreateLevel(level){this._updateShiftY(level.zoom);//console.log('_onCreateLevel ', level);
},_initContainer:function _initContainer(){if(this._container){return;}var classNames=['leaflet-layer'];if(this.options.className){classNames.push(this.options.className);}this._container=L.DomUtil.create('div',classNames.join(' '));if(this.options.clickable===false){this._container.style.pointerEvents='none';}this._updateZIndex();this.getPane(this.options.pane).appendChild(this._container);},_onVersionChange:function _onVersionChange(){this._updateProperties(this._gmx.rawProperties);this._chkTiles(true);},_waitCheckOldLevels:function _waitCheckOldLevels(){if(this._oldLevelsTimer){clearTimeout(this._oldLevelsTimer);}this._oldLevelsTimer=setTimeout(this._chkOldLevels.bind(this),250);},_chkOldLevels:function _chkOldLevels(){if(!this._map){return;}var zoom=this._map._zoom,key,tile;for(key in this._tiles){tile=this._tiles[key];if(tile.coords.z===zoom&&!tile.loaded){return;}}this._loading=false;this._clearOldLevels(zoom);this.fire('load');// @event load: Event // Fired when the grid layer loaded all visible tiles.
},_waitOnMoveEnd:function _waitOnMoveEnd(){if(this._onmoveendTimer){clearTimeout(this._onmoveendTimer);}this._onmoveendTimer=setTimeout(this._chkTiles.bind(this),250);},_chkCurrentTiles:function _chkCurrentTiles(){if(!this._map){return;}// console.log('_onmoveend ', this._tileZoom, this._loading, this._noTilesToLoad(), this._tileZoom, Date.now());
var zoom=this._tileZoom||this._map._zoom,key,tile;for(key in this._tiles){tile=this._tiles[key];if(tile.coords.z===zoom){L.DomUtil.setPosition(tile.el,this._getTilePos(tile.coords));// Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸ ÑÐ°Ð¹Ð»Ð¾Ð²
if(!tile.promise){// Ð´Ð°Ð½Ð½ÑÐ¹ ÑÐ°Ð¹Ð» ÐµÑÐµ Ð½Ðµ ÑÐ¸ÑÐ¾Ð²Ð°Ð»ÑÑ
this.__drawTile(tile);}}}},_chkTiles:function _chkTiles(flag){this._chkCurrentTiles();if(flag){this.repaint();}this._waitCheckOldLevels();},// _removeScreenObservers: function (z, flag) {
// if (this._gmx && this._gmx.dataManager) {
// var dm = this._gmx.dataManager;
// dm.removeScreenObservers(z);
// if (flag) {
// dm.fire('moveend');
// }
// }
// },
// _onMoveEnd: function () {
// if (!this._map || this._map._animatingZoom) { return; }
//console.log('_onMoveEnd', arguments)
// requestIdleCallback(function () {
// this._update();
// }.bind(this), {timeout: 0});
//this._update();
// },
_getEvents:function _getEvents(){var events=L.GridLayer.prototype.getEvents.call(this);L.extend(events,{// zoomanim: function(ev) {
//this._setZoomTransforms(ev.center, ev.zoom);
// }
// beforezoomanim: function(ev) {
// this._setZoomTransforms(ev.center, ev.zoom);
// }
// zoomstart: function() {
// console.log('zoomstart', this._map._zoom, this._gmx.layerID, arguments);
// this._gmx.zoomstart = true;
// this._removeScreenObservers();
// }
//,
// zoomanim: function(ev) {
// this._setZoomTransforms(ev.center, ev.zoom);
// this._gmx.zoomstart = true;
// },
// zoomend: function() {
//this._gmx.zoomstart = false;
// this._drawDoneObjectsCount = this._drawnObjectsCount;
// this._drawnObjectsCount = 0;
// }
});var gmx=this._gmx;var owner={dateIntervalChanged:function dateIntervalChanged(){this._chkTiles(true);if(L.gmx.sendCmd){var interval=gmx.dataManager.getMaxDateInterval();L.gmx.sendCmd('dateIntervalChanged',{layerID:gmx.layerID,mapID:gmx.mapName,hostName:gmx.hostName,dInterval:[Math.floor(interval.beginDate.getTime()/1000),Math.floor(interval.endDate.getTime()/1000)]});}},// load: function() {				// Fired when the grid layer starts loading tiles.
// console.log('load layer ', this._tileZoom, this._map._zoom, Date.now() - window.startTest)
// this._clearOldLevels(this._tileZoom);
// if (this._onloadTimer) { clearTimeout(this._onloadTimer); }
// this._onloadTimer = setTimeout(L.bind(this.repaint, this), 150);
// },
tileloadstart:function tileloadstart(ev){// ÑÐ°Ð¹Ð» (ev.coords) Ð·Ð°Ð³ÑÑÐ¶Ð°ÐµÑÑÑ
var key=ev.key||this._tileCoordsToKey(ev.coords),tLink=this._tiles[key];tLink.loaded=0;},stylechange:function stylechange(){// var gmx = this._gmx;
if(!gmx.balloonEnable&&this._popup){this.unbindPopup();}else if(gmx.balloonEnable&&!this._popup){this.bindPopup('');}if(this._map){if(this.options.minZoom!==gmx.styleManager.minZoom||this.options.maxZoom!==gmx.styleManager.maxZoom){this.options.minZoom=gmx.styleManager.minZoom;this.options.maxZoom=gmx.styleManager.maxZoom;this._resetView();// this._map._updateZoomLevels();
}if(gmx.labelsLayer){this._map._labelsLayer.add(this);}else if(!gmx.labelsLayer){this._map._labelsLayer.remove(this);}// this.repaint();
this._chkTiles(true);}},versionchange:this._onVersionChange};events.moveend=this._waitOnMoveEnd.bind(this);events.zoomend=function(){this._chkTiles(true);};return {map:events,owner:owner};},beforeAdd:function beforeAdd(map){this._updateShiftY(map.getZoom());L.GridLayer.prototype.beforeAdd.call(this,map);this._map=map;this._drawnObjectsCount=0;},onAdd:function onAdd(map){map=map||this._map;if(map.options.crs!==L.CRS.EPSG3857&&map.options.crs!==L.CRS.EPSG3395){throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';}this.beforeAdd(map);var gmx=this._gmx;this.options.tilesCRS=gmx.srs==3857?L.CRS.EPSG3857:L.CRS.EPSG3395;gmx.shiftY=0;gmx.applyShift=map.options.crs===L.CRS.EPSG3857&&gmx.srs!=3857;gmx.currentZoom=map.getZoom();this._levels={};// need init before styles promise resolved
this._tiles={};this._initContainer();gmx.styleManager.initStyles().then(function(){if(gmx.balloonEnable&&!this._popup){this.bindPopup('');}if(this._map){var events=this._getEvents();map.on(events.map,this);this.on(events.owner,this);this.once('remove',function(){map.off(events.map,this);this.off(events.owner,this);},this);L.gmx._zoomLevelsCache={};this._invalidateAll();this._resetView();gmx.dataManager.fire('moveend');this._chkTiles(true);L.gmx.layersVersion.add(this);}// this._addLayerVersion();
this.fire('add');}.bind(this));},onRemove:function onRemove(map){var gmx=this._gmx,dm=gmx.dataManager;// if (gmx.labelsLayer) {	// ÑÐ´Ð°Ð»Ð¸ÑÑ Ð¸Ð· labelsLayer
// map._labelsLayer.remove(this);
// }
this._invalidateAll();//gmx.badTiles = {};
gmx.quicklooksCache={};gmx.rastersCache={};delete gmx.map;if(dm&&!dm.getActiveObserversCount()){L.gmx.layersVersion.remove(this);}if(this._map){L.GridLayer.prototype.onRemove.call(this,map);}this._map=null;this.fire('remove');},_removeTile:function _removeTile(key){if(!this._map||this._map._animatingZoom){return;}if(this._gmx&&this._gmx.dataManager){this._gmx.dataManager.removeObserver(key);// TODO: Ð¿ÑÐ¾ active
}L.GridLayer.prototype._removeTile.call(this,key);},_updateZIndex:function _updateZIndex(){if(this._container){var options=this.options,zIndex=options.zIndex||0,zIndexOffset=options.zIndexOffset||0;this._container.style.zIndex=zIndexOffset+zIndex;}this.fire('zindexupdated');},/*eslint-disable no-unused-vars */createTile:function createTile(coords,done){//this._test = [coords, done];
var tile=L.DomUtil.create('canvas','leaflet-tile');var size=this.getTileSize();tile.width=tile.height=0;tile.style.width=size.x+'px';tile.style.height=size.y+'px';tile.onselectstart=L.Util.falseFn;tile.onmousemove=L.Util.falseFn;// without this hack, tiles disappear after zoom on Chrome for Android
// https://github.com/Leaflet/Leaflet/issues/2078
if(L.Browser.android&&!L.Browser.android23){tile.style.WebkitBackfaceVisibility='hidden';}// tile.setAttribute('role', 'presentation');
// tile.style.opacity = this.options.opacity;
return tile;},/*eslint-enable */ //block: public interface
initFromDescription:function initFromDescription(ph){var gmx=this._gmx;gmx.properties=ph.properties;gmx.geometry=ph.geometry;if(gmx.properties._initDone){// need delete tiles key
delete gmx.properties[gmx.properties.Temporal?'TemporalTiles':'tiles'];}gmx.properties._initDone=true;if(!gmx.geometry){var worldSize=gmxAPIutils.tileSizes[1];gmx.geometry={type:'POLYGON',coordinates:[[[-worldSize,-worldSize],[-worldSize,worldSize],[worldSize,worldSize],[worldSize,-worldSize],[-worldSize,-worldSize]]]};}// Original properties from the server.
// Descendant classes can override this property
// Not so good solution, but it works
gmx.rawProperties=ph.rawProperties||ph.properties;this._updateProperties(ph.properties);if(gmx.rawProperties.type==='Vector'){ph.properties.srs=gmx.srs=3857;gmx.RasterSRS=Number(gmx.rawProperties.RasterSRS)||3857;// } else if (gmx.rawProperties.RasterSRS) {
// ph.properties.srs = gmx.srs = Number(gmx.rawProperties.RasterSRS);
}ph.properties.sessionKey=ph.properties.sessionKey||gmx.sessionKey||'';ph.properties.needBbox=gmx.needBbox;ph.properties.isGeneralized=this.options.isGeneralized;ph.properties.isFlatten=this.options.isFlatten;ph.properties.gmxEndPoints=this.options.gmxEndPoints;gmx.dataManager=this.options.dataManager||new L.gmx.DataManager(ph.properties);if(this.options.parentOptions){if(!ph.properties.styles){ph.properties.styles=this.options.parentOptions.styles;}gmx.dataManager.on('versionchange',this._onVersionChange,this);}gmx.styleManager=new L.gmx.StyleManager(gmx);this.options.minZoom=gmx.styleManager.minZoom;this.options.maxZoom=gmx.styleManager.maxZoom;gmx.dataManager.on('observeractivate',this._chkNeedLayerVersion,this);if(gmx.properties.type==='Vector'&&!('chkUpdate'in this.options)){this.options.chkUpdate=true;//Check updates for vector layers by default
}if(gmx.rawProperties.type!=='Raster'&&this._objectsReorderInit){this._objectsReorderInit(this);}if(gmx.clusters){this.bindClusters(JSON.parse(gmx.clusters));}if(gmx.filter){/*eslint-disable no-useless-escape */var func=L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\[\]]/g,'"'));/*eslint-enable */if(func){gmx.dataManager.addFilter('userFilter_'+gmx.layerID,function(item){return gmx.layerID!==this._gmx.layerID||!func||func(item.properties,gmx.tileAttributeIndexes,gmx.tileAttributeTypes)?item.properties:null;}.bind(this));}}if(gmx.dateBegin&&gmx.dateEnd){this.setDateInterval(gmx.dateBegin,gmx.dateEnd);}this._resolve();return this;},getStyleIcon:function getStyleIcon(nm,txt){return this._gmx.styleManager.getStyleIcon(nm,txt);},_chkNeedLayerVersion:function _chkNeedLayerVersion(){if(this._chkNeedLayerVersionTimer){clearTimeout(this._chkNeedLayerVersionTimer);}this._chkNeedLayerVersionTimer=setTimeout(function(){if(this._gmx.dataManager.getActiveObserversCount()){L.gmx.layersVersion.add(this);}else {L.gmx.layersVersion.remove(this);}}.bind(this),100);},/*
      _addLayerVersion: function () {
  		// if (this._onVersionTimer) { cancelIdleCallback(this._onVersionTimer); }
  		// this._onVersionTimer = requestIdleCallback(L.gmx.layersVersion.add.bind(L.gmx.layersVersion, this), {timeout: 0});
  		if (this._onVersionTimer) { clearTimeout(this._onVersionTimer); }
  		this._onVersionTimer = setTimeout(L.gmx.layersVersion.add.bind(L.gmx.layersVersion, this), 0);
      },
  */getDataManager:function getDataManager(){return this._gmx.dataManager;},enableGeneralization:function enableGeneralization(){if(!this.options.isGeneralized){this.options.isGeneralized=true;if(this._gmx.dataManager){// this._clearAllSubscriptions();
this._gmx.dataManager.enableGeneralization();this.redraw();this._chkTiles(true);}}},disableGeneralization:function disableGeneralization(){if(this.options.isGeneralized){this.options.isGeneralized=false;if(this._gmx.dataManager){// this._clearAllSubscriptions();
this._gmx.dataManager.disableGeneralization();this.redraw();this._chkTiles(true);}}},setRasterOpacity:function setRasterOpacity(opacity){if(this._gmx.rasterOpacity!==opacity){this._gmx.rasterOpacity=opacity;this._initPromise.then(this.repaint.bind(this));}return this;},getStyles:function getStyles(){return this._gmx.styleManager.getStyles();},getIcons:function getIcons(callback){this._gmx.styleManager.getIcons(callback);return this;},setStyles:function setStyles(styles){this._initPromise.then(function(){this._gmx.styleManager.clearStyles();if(styles){styles.forEach(function(it,i){this.setStyle(it,i,true);}.bind(this));}else {this.fire('stylechange');}}.bind(this));return this;},getStyle:function getStyle(num){return this.getStyles()[num];},setStyle:function setStyle(style,num,createFlag){this._initPromise.then(function(){this._gmx.styleManager.setStyle(style,num,createFlag).then(function(){this.fire('stylechange',{num:num||0});}.bind(this));}.bind(this));return this;},setStyleHook:function setStyleHook(func){this._gmx.styleHook=func;this.repaint();return this;},removeStyleHook:function removeStyleHook(){this._gmx.styleHook=null;return this;},setRasterHook:function setRasterHook(func){this._gmx.rasterProcessingHook=func;this.repaint();return this;},removeRasterHook:function removeRasterHook(){this._gmx.rasterProcessingHook=null;this.repaint();return this;},setFilter:function setFilter(func){var gmx=this._gmx;gmx.dataManager.addFilter('userFilter',function(item){return gmx.layerID!==this._gmx.layerID||!func||func(item)?item.properties:null;}.bind(this));return this;},removeFilter:function removeFilter(){this._gmx.dataManager.removeFilter('userFilter');return this;},addLayerFilter:function addLayerFilter(func,options){var gmx=this._gmx;options=options||{};options.layerID=gmx.layerID;gmx.dataManager.addLayerFilter(function(item){return !func||func(item)?item.properties:null;}.bind(this),options);return this;},removeLayerFilter:function removeLayerFilter(options){options=options||{};options.layerID=this._gmx.layerID;this._gmx.dataManager.removeLayerFilter(options);return this;},setDateInterval:function setDateInterval(beginDate,endDate){var gmx=this._gmx;if(gmx.dateBegin&&gmx.dateEnd){beginDate=gmx.dateBegin;endDate=gmx.dateEnd;}//check that something changed
if(!gmx.beginDate!==!beginDate||!gmx.endDate!==!endDate||beginDate&&gmx.beginDate.valueOf()!==beginDate.valueOf()||endDate&&gmx.endDate.valueOf()!==endDate.valueOf()){if(gmx.rawProperties.maxShownPeriod&&beginDate){var msecPeriod=gmx.rawProperties.maxShownPeriod*24*3600*1000;beginDate=new Date(Math.max(beginDate.valueOf(),endDate.valueOf()-msecPeriod));}gmx.beginDate=beginDate;gmx.endDate=endDate;var observer=null,dataManager=gmx.dataManager;for(var key in this._tiles){this._tiles[key].loaded=0;observer=this._tiles[key].observer;if(observer){observer.setDateInterval(beginDate,endDate);}}observer=dataManager.getObserver('_Labels');if(observer){observer.setDateInterval(beginDate,endDate);}if(gmx.skipTiles==='NotVisible'||gmx.needBbox||gmx.properties.UseTiles===false){if(!gmx.needBbox){gmx.properties.LayerVersion=-1;dataManager.setOptions({LayerVersion:-1});}if(this._map){L.gmx.layersVersion.now();}}this.fire('dateIntervalChanged');}return this;},getDateInterval:function getDateInterval(){return {beginDate:this._gmx.beginDate,endDate:this._gmx.endDate};},addObserver:function addObserver(options){return this._gmx.dataManager.addObserver(options);},removeObserver:function removeObserver(observer){return this._gmx.dataManager.removeObserver(observer.id);},setPositionOffset:function setPositionOffset(dx,dy){var gmx=this._gmx;gmx.shiftXlayer=dx;gmx.shiftYlayer=dy;this._update();return this;},getPositionOffset:function getPositionOffset(){var gmx=this._gmx;return {shiftX:gmx.shiftXlayer,shiftY:gmx.shiftYlayer};},setZIndexOffset:function setZIndexOffset(offset){if(arguments.length){this.options.zIndexOffset=offset;}this._updateZIndex();return this;},_clearLoaded:function _clearLoaded(zKey){if(this._tiles[zKey]){this._tiles[zKey].loaded=0;}},repaint:function repaint(zKeys){if(this._map){this._chkCurrentTiles();if(!zKeys){var zoom=L.gmx._zoomStart||this._tileZoom||this._map._zoom,key,tile;// console.log('_____',  L.gmx._zoomStart, this._tileZoom, this._map._zoom)
zKeys={};for(key in this._tiles){tile=this._tiles[key];if(tile.coords.z===zoom){zKeys[key]=true;this._clearLoaded(key);if(tile.observer){tile.observer.activate(true);}}else if(tile.observer){tile.observer.deactivate(true);}}L.extend(zKeys,this.repaintObservers);}else if(L.Util.isArray(zKeys)){var arr=zKeys;zKeys={};arr.forEach(function(it){zKeys[it]=true;this._clearLoaded(it);}.bind(this));}else if(typeof zKeys==='string'){var it=zKeys;this._clearLoaded(it);zKeys={};zKeys[it]=true;}this._gmx.dataManager._triggerObservers(zKeys);//this._onmoveend();
}},redrawItem:function redrawItem(item){if(this._map){if(_typeof$1(item)!=='object'){item=this._gmx.dataManager.getItem(item);}if(item){var gmxTiles=this._getTilesByBounds(item.bounds);this.repaint(gmxTiles);}}},appendTileToContainer:function appendTileToContainer(tileLink){// call from screenTile
//createTi
if(this._level&&this._level.zoom===tileLink.coords.z&&this._level.el!==tileLink.el.parentNode){this._level.el.appendChild(tileLink.el);}},addData:function addData(data,options){if(!this._gmx.mapName){// client side layer
this._gmx.dataManager.addData(data,options);this.repaint();}return this;},removeData:function removeData(data,options){if(!this._gmx.mapName){// client side layer
this._gmx.dataManager.removeData(data,options);this.repaint();}return this;},getStylesByProperties:function getStylesByProperties(propArray,zoom){return this._gmx.styleManager.getCurrentFilters(propArray,zoom);},getItemStyle:function getItemStyle(id){var gmx=this._gmx,item=gmx.dataManager.getItem(id);return gmx.styleManager.getObjStyle(item);},getTileAttributeTypes:function getTileAttributeTypes(){return this._gmx.tileAttributeTypes;},getTileAttributeIndexes:function getTileAttributeIndexes(){return this._gmx.tileAttributeIndexes;},getItemBalloon:function getItemBalloon(id){var gmx=this._gmx,item=gmx.dataManager.getItem(id),styles=this.getStyles(),out='';if(item&&styles[item.currentFilter]){var propsArr=item.properties;out=L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon,{properties:this.getItemProperties(propsArr),geometries:[propsArr[propsArr.length-1]],tileAttributeTypes:gmx.tileAttributeTypes,unitOptions:this._map?this._map.options:{}});}return out;},getItemProperties:function getItemProperties(propArray){var properties={},indexes=this._gmx.tileAttributeIndexes;for(var key in indexes){properties[key]=propArray[indexes[key]];}return properties;},addPreRenderHook:function addPreRenderHook(renderHook){this._gmx.preRenderHooks.push(renderHook);this.repaint();},removePreRenderHook:function removePreRenderHook(hook){var arr=this._gmx.preRenderHooks;for(var i=0,len=arr.length;i<len;i++){if(arr[i]===hook){arr.splice(i,1);this.repaint();break;}}},addRenderHook:function addRenderHook(renderHook){this._gmx.renderHooks.push(renderHook);this.repaint();},removeRenderHook:function removeRenderHook(hook){var arr=this._gmx.renderHooks;for(var i=0,len=arr.length;i<len;i++){if(arr[i]===hook){arr.splice(i,1);this.repaint();break;}}},getGmxProperties:function getGmxProperties(){return this._gmx.rawProperties;},//returns L.LatLngBounds
getBounds:function getBounds(){var gmxBounds=this._gmx.layerID?gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds:this._gmx.dataManager.getItemsBounds();if(gmxBounds){return gmxBounds.toLatLngBounds(this._gmx.srs==3857);}else {return new L.LatLngBounds();}},getGeometry:function getGeometry(){if(!this._gmx.latLngGeometry){this._gmx.latLngGeometry=L.gmxUtil.geometryToGeoJSON(this._gmx.geometry,true,this._gmx.srs==3857);}return this._gmx.latLngGeometry;},getPropItem:function getPropItem(key,propArr){return gmxAPIutils.getPropItem(key,propArr,this._gmx.tileAttributeIndexes);},//block: internal
_getTilesByBounds:function _getTilesByBounds(bounds){// ÐÐ¾Ð»ÑÑÐ¸ÑÑ ÑÐ¿Ð¸ÑÐ¾Ðº gmxTiles Ð¿Ð¾ bounds
var gmx=this._gmx,zoom=this._tileZoom||this._map._zoom,shiftX=gmx.shiftX||0,// Ð¡Ð´Ð²Ð¸Ð³ ÑÐ»Ð¾Ñ
shiftY=gmx.shiftY||0,// Ð¡Ð´Ð²Ð¸Ð³ ÑÐ»Ð¾Ñ + OSM
latLngBounds=bounds.toLatLngBounds(gmx.srs==3857),minLatLng=latLngBounds.getSouthWest(),maxLatLng=latLngBounds.getNorthEast(),screenBounds=this._map.getBounds(),sw=screenBounds.getSouthWest(),ne=screenBounds.getNorthEast(),dx=0;if(ne.lng-sw.lng<360){if(maxLatLng.lng<sw.lng){dx=360*(1+Math.floor((sw.lng-maxLatLng.lng)/360));}else if(minLatLng.lng>ne.lng){dx=360*Math.floor((ne.lng-minLatLng.lng)/360);}}minLatLng.lng+=dx;maxLatLng.lng+=dx;var pixelBounds=this._map.getPixelBounds(),minPoint=this._map.project(minLatLng),maxPoint=this._map.project(maxLatLng),ts=this.options.tileSize;var minY,maxY,minX,maxX;if(pixelBounds){minY=Math.floor((Math.max(maxPoint.y,pixelBounds.min.y)+shiftY)/ts);maxY=Math.floor((Math.min(minPoint.y,pixelBounds.max.y)+shiftY)/ts);minX=minLatLng.lng<=-180?pixelBounds.min.x:Math.max(minPoint.x,pixelBounds.min.x);minX=Math.floor((minX+shiftX)/ts);maxX=maxLatLng.lng>=180?pixelBounds.max.x:Math.min(maxPoint.x,pixelBounds.max.x);maxX=Math.floor((maxX+shiftX)/ts);}else {minY=Math.floor((maxPoint.y+shiftY)/ts);maxY=Math.floor((minPoint.y+shiftY)/ts);minX=Math.floor((minPoint.x+shiftX)/ts);maxX=Math.floor((maxPoint.x+shiftX)/ts);}var gmxTiles={};for(var x=minX;x<=maxX;x++){for(var y=minY;y<=maxY;y++){var zKey=this._tileCoordsToKey({x:x,y:y,z:zoom});gmxTiles[zKey]=true;}}return gmxTiles;},_updateProperties:function _updateProperties(prop){var gmx=this._gmx;if(!gmx.sessionKey){gmx.sessionKey=prop.sessionKey=this.options.sessionKey||'';//should be already received
}if(this.options.parentOptions){prop=this.options.parentOptions;}gmx.identityField=prop.identityField;// ogc_fid
gmx.GeometryType=(prop.GeometryType||'').toLowerCase();// ÑÐ¸Ð¿ Ð³ÐµÐ¾Ð¼ÐµÑÑÐ¸Ð¹ Ð¾Ð±ÑÐµÐºÑÐ¾Ð² Ð² ÑÐ»Ð¾Ðµ
gmx.minZoomRasters=prop.RCMinZoomForRasters||1;// Ð¼Ð¸Ð½. zoom Ð´Ð»Ñ ÑÐ°ÑÑÑÐ¾Ð²
gmx.minZoomQuicklooks=gmx.minZoomRasters;// Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ minZoom Ð´Ð»Ñ ÐºÐ²Ð¸ÐºÐ»ÑÐºÐ¾Ð² Ð¸ ÐÐ  ÑÐ°Ð²Ð½Ñ
var type=prop.type||'Vector';if(prop.Temporal){type+='Temporal';}gmx.layerType=type;// VectorTemporal Vector
gmx.items={};L.extend(gmx,L.gmxUtil.getTileAttributes(prop));if(gmx.dataManager){gmx.dataManager.setOptions(prop);}if('ZIndexField'in prop){if(prop.ZIndexField in gmx.tileAttributeIndexes){gmx.zIndexField=gmx.tileAttributeIndexes[prop.ZIndexField];// sort field index
}}if(this._objectsReorder){this._objectsReorder.initialize();}// if ('clusters' in prop) {
// gmx.clusters = prop.clusters;
// }
gmx.filter=prop.filter;// for dataSource attr
gmx.dateBegin=prop.dateBegin;gmx.dateEnd=prop.dateEnd;gmx.dataSource=prop.dataSource;if('MetaProperties'in gmx.rawProperties){var meta=gmx.rawProperties.MetaProperties;if('srs'in meta){// Ð¿ÑÐ¾ÐµÐºÑÐ¸Ñ ÑÐ»Ð¾Ñ
gmx.srs=meta.srs.Value||'';}if('parentLayer'in meta){// ÑÐ¸Ð»ÑÑÑ ÑÐ»Ð¾Ñ		// todo ÑÐ´Ð°Ð»Ð¸ÑÑ Ð¿Ð¾ÑÐ»Ðµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹ Ð²Ð¾Ð² Ð²ÑÑÐ²ÐµÑÐµ
gmx.dataSource=meta.parentLayer.Value||'';}if('filter'in meta){// ÑÐ¸Ð»ÑÑÑ ÑÐ»Ð¾Ñ
gmx.filter=meta.filter.Value||'';}if('dateBegin'in meta){// ÑÐ¸Ð»ÑÑÑ Ð´Ð»Ñ Ð¼ÑÐ»ÑÑÐ¸Ð²ÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ»Ð¾Ñ
gmx.dateBegin=L.gmxUtil.getDateFromStr(meta.dateBegin.Value||'01.01.1980');}if('dateEnd'in meta){// ÑÐ¸Ð»ÑÑÑ Ð´Ð»Ñ Ð¼ÑÐ»ÑÑÐ¸Ð²ÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ»Ð¾Ñ
gmx.dateEnd=L.gmxUtil.getDateFromStr(meta.dateEnd.Value||'01.01.1980');}if('showScreenTiles'in meta){// Ð¿Ð¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ Ð³ÑÐ°Ð½Ð¸ÑÑ ÑÐºÑÐ°Ð½Ð½ÑÑ ÑÐ°Ð¹Ð»Ð¾Ð²
gmx.showScreenTiles=meta.showScreenTiles.Value==='1'?true:false;}if('shiftX'in meta||'shiftY'in meta){// ÑÐ´Ð²Ð¸Ð³ Ð²ÑÐµÐ³Ð¾ ÑÐ»Ð¾Ñ
gmx.shiftXlayer=meta.shiftX?Number(meta.shiftX.Value):0;gmx.shiftYlayer=meta.shiftY?Number(meta.shiftY.Value):0;}if('shiftXfield'in meta||'shiftYfield'in meta){// Ð¿Ð¾Ð»Ñ ÑÐ´Ð²Ð¸Ð³Ð° ÑÐ°ÑÑÑÐ¾Ð² Ð¾Ð±ÑÐµÐºÑÐ¾Ð² ÑÐ»Ð¾Ñ
if(meta.shiftXfield){gmx.shiftXfield=meta.shiftXfield.Value;}if(meta.shiftYfield){gmx.shiftYfield=meta.shiftYfield.Value;}}if('quicklookPlatform'in meta){// ÑÐ¸Ð¿ ÑÐ¿ÑÑÐ½Ð¸ÐºÐ°
gmx.quicklookPlatform=meta.quicklookPlatform.Value;if(gmx.quicklookPlatform==='image'){delete gmx.quicklookPlatform;}}if('quicklookX1'in meta){gmx.quicklookX1=meta.quicklookX1.Value;}if('quicklookY1'in meta){gmx.quicklookY1=meta.quicklookY1.Value;}if('quicklookX2'in meta){gmx.quicklookX2=meta.quicklookX2.Value;}if('quicklookY2'in meta){gmx.quicklookY2=meta.quicklookY2.Value;}if('quicklookX3'in meta){gmx.quicklookX3=meta.quicklookX3.Value;}if('quicklookY3'in meta){gmx.quicklookY3=meta.quicklookY3.Value;}if('quicklookX4'in meta){gmx.quicklookX4=meta.quicklookX4.Value;}if('quicklookY4'in meta){gmx.quicklookY4=meta.quicklookY4.Value;}if('gmxProxy'in meta){// Ð£ÑÑÐ°Ð½Ð¾Ð²ÐºÐ° Ð¿ÑÐ¾ÐºÐ°ÑÐ¸Ð²Ð°Ð»ÐºÐ¸
gmx.gmxProxy=meta.gmxProxy.Value.toLowerCase()==='true'?L.gmx.gmxProxy:meta.gmxProxy.Value;}if('multiFilters'in meta){// Ð¿ÑÐ¾Ð²ÐµÑÐºÐ° Ð²ÑÐµÑ ÑÐ¸Ð»ÑÑÑÐ¾Ð² Ð´Ð»Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð² ÑÐ»Ð¾Ñ
gmx.multiFilters=meta.multiFilters.Value==='1'?true:false;}if('isGeneralized'in meta){// Set generalization
this.options.isGeneralized=meta.isGeneralized.Value!=='false';}if('isFlatten'in meta){// Set flatten geometry
this.options.isFlatten=meta.isFlatten.Value!=='false';}}if(prop.Temporal){// Clear generalization flag for Temporal layers
this.options.isGeneralized=false;}if(prop.IsRasterCatalog){gmx.IsRasterCatalog=prop.IsRasterCatalog;var layerLink=gmx.tileAttributeIndexes.GMX_RasterCatalogID;if(layerLink){var endPoint=this.options.gmxEndPoints?this.options.gmxEndPoints.tileProps:'/TileSender.ashx';gmx.rasterBGfunc=function(x,y,z,item,srs){var properties=item.properties,url=L.gmxUtil.protocol+'//'+gmx.hostName+endPoint+'?ModeKey=tile&ftc=osm'+'&x='+x+'&y='+y+'&z='+z;if(srs||gmx.srs){url+='&srs='+(srs||gmx.srs);}if(gmx.crossOrigin){url+='&cross='+gmx.crossOrigin;}url+='&LayerName='+properties[layerLink];if(gmx.sessionKey){url+='&key='+encodeURIComponent(gmx.sessionKey);}if(L.gmx._sw&&item.v){url+='&sw='+L.gmx._sw+'&v='+item.v;}return url;};}}if(prop.Quicklook){var quicklookParams;//ÑÐ°Ð½ÑÑÐµ ÑÑÐ¾ Ð±ÑÐ»Ð° Ð¿ÑÐ¾ÑÑÐ¾ ÑÑÑÐ¾ÐºÐ° Ñ ÑÐ°Ð±Ð»Ð¾Ð½Ð¾Ð¼ ÐºÐ²Ð¸ÐºÐ»ÑÐºÐ°, Ð° ÑÐµÐ¿ÐµÑÑ ÑÑÐ°Ð»Ð¾ JSON'Ð¾Ð¼
if(prop.Quicklook[0]==='{'){quicklookParams=JSON.parse(prop.Quicklook);}else {quicklookParams={minZoom:gmx.minZoomRasters,template:prop.Quicklook};}if('X1'in quicklookParams){gmx.quicklookX1=quicklookParams.X1;}if('Y1'in quicklookParams){gmx.quicklookY1=quicklookParams.Y1;}if('X2'in quicklookParams){gmx.quicklookX2=quicklookParams.X2;}if('Y2'in quicklookParams){gmx.quicklookY2=quicklookParams.Y2;}if('X3'in quicklookParams){gmx.quicklookX3=quicklookParams.X3;}if('Y3'in quicklookParams){gmx.quicklookY3=quicklookParams.Y3;}if('X4'in quicklookParams){gmx.quicklookX4=quicklookParams.X4;}if('Y4'in quicklookParams){gmx.quicklookY4=quicklookParams.Y4;}var template=gmx.Quicklook=quicklookParams.template;if('minZoom'in quicklookParams){gmx.minZoomQuicklooks=quicklookParams.minZoom;}gmx.quicklookBGfunc=function(item){var url=template,reg=/\[([^\]]+)\]/,matches=reg.exec(url);while(matches&&matches.length>1){url=url.replace(matches[0],item.properties[gmx.tileAttributeIndexes[matches[1]]]);matches=reg.exec(url);}//if (gmx.srs) { url += (url.indexOf('?') === -1 ? '?' : '&') + 'srs=' + gmx.srs; }
return url;};gmx.imageQuicklookProcessingHook=L.gmx.gmxImageTransform;}this.options.attribution=prop.Copyright||'';},_updateShiftY:function _updateShiftY(zoom){var gmx=this._gmx;gmx.currentZoom=zoom;gmx.tileSize=gmxAPIutils.tileSizes[zoom];gmx.mInPixel=this.options.tileSize/gmx.tileSize;},__drawTile:function __drawTile(ev){var coords=ev.coords,zKey=this._tileCoordsToKey(coords),tileElem=this._tiles[zKey];if(!tileElem){return;}var myLayer=this,zoom=this._tileZoom,gmx=this._gmx;// if (tileElem.observer) {
// gmx.dataManager.removeObserver(tileElem.observer.id);
// tileElem.reject();
//this._tileReady(coords, null, tileElem.el);
// }
if(!tileElem.promise){tileElem.loaded=0;tileElem.key=zKey;tileElem.screenTile=new ScreenVectorTile(myLayer,tileElem);tileElem.promise=new Promise(function(resolve,reject){tileElem.resolve=resolve;tileElem.reject=reject;var filters=gmx.dataManager.getViewFilters('screen',gmx.layerID);var done=function done(){if(tileElem.count){myLayer._drawnObjectsCount+=tileElem.count;myLayer.appendTileToContainer(tileElem);}myLayer._tileReady(coords,null,tileElem.el);};tileElem.observer=gmx.dataManager.addObserver({type:'resend',layerID:gmx.layerID,needBbox:gmx.needBbox,//topLeft: tileElem.screenTile.topLeft,
srs:gmx.srs,target:'screen',z:zoom,targetZoom:myLayer.options.isGeneralized?zoom:null,dateInterval:gmx.layerType==='VectorTemporal'?[gmx.beginDate,gmx.endDate]:null,active:true,bbox:gmx.styleManager.getStyleBounds(coords),filters:['clipFilter','userFilter_'+gmx.layerID,'styleFilter','userFilter'].concat(filters),callback:function callback(data){// if (L.gmx._animatingZoom) {
// console.log('____ tileElem.promise', data);
// }
// if (myLayer._tiles[zKey] && !myLayer._map._animatingZoom) {
if(myLayer._tiles[zKey]){myLayer._tiles[zKey].loaded=0;tileElem.screenTile.drawTile(data).then(function(res){if(res){tileElem.count=res.count;}done();},function(err){done();}).catch(console.log);}else {done();}}},zKey);}).catch(function(e){console.warn('catch:',e);});}else {tileElem.resolve();}// },
// _abortLoading: function () {	// stops loading all tiles in the background layer
// this._removeScreenObservers();
}});L.Map.addInitHook(function(){if(L.Mixin.ContextMenu){L.gmx.VectorLayer.include(L.Mixin.ContextMenu);}this.options.ftc=this.options.ftc||'osm';this.options.srs=this.options.srs||3857;this.options.skipTiles=this.options.skipTiles||'All';L.gmx.leafletMap=this;L.gmx._zoomLevelsCache={};// L.gmx._zoomAnimCache = {};
// this.on('zoomend', function(ev) {
// console.log('zoomend ', ev);
// }, this);
this.on('zoomstart',function(ev){// console.log('zoomstart ', ev);
L.gmx._zoomStart=ev.zoom;L.gmx._zoomLevelsCache={};L.gmx._zoomLevelsCount=0;var cnt=0,maxZoomAnimGmxLayers=this.options.maxZoomAnimGmxLayers||5;for(var key in this._layers){var it=this._layers[key];if(it._map&&it instanceof L.gmx.VectorLayer){var func=L.DomUtil.removeClass;if(ev.zoom>this._zoom&&(it._drawnObjectsCount===0||cnt>maxZoomAnimGmxLayers)){func=L.DomUtil.addClass;}else {cnt++;}func(it._container,'leaflet-zoom-hide');it._drawnObjectsCount=0;}}},this);});/*
 * ObjectsReorder  - Reorder objects in Gemixer layer
 */(function(){var MAX=1000000,ObjectsReorder=function ObjectsReorder(layer){this.all={};this.userSetSortFunc=false;// user sort func flag
this.sortFunc=null;this.count=0;this.disabled=false;this.layer=layer;layer.on('add',this.onAdd,this);layer.on('remove',this.onRemove,this);};ObjectsReorder.prototype={addToReorder:function addToReorder(id,bottomFlag){++this.count;this.all[id]=bottomFlag?-this.count:this.count;},clickFunc:function clickFunc(ev){if(!this.disabled){var id=ev.gmx.id;this.addToReorder(id,ev.originalEvent.ctrlKey);this.layer.redrawItem(id);}},sortItems:function sortItems(a,b){// layer context
var reorder=this._objectsReorder;if(reorder.count>0){var ap=reorder.all[a.id],bp=reorder.all[b.id];if(ap||bp){ap=ap?ap+(ap>0?MAX:-MAX):0;bp=bp?bp+(bp>0?MAX:-MAX):0;return ap-bp;}}return reorder.sortFunc?reorder.sortFunc.call(this,a,b):0;},resetSortFunc:function resetSortFunc(){var layer=this.layer,gmx=layer._gmx,zIndexField=gmx.zIndexField;gmx.sortItems=this.sortItems;this.sortFunc=zIndexField&&!this.userSetSortFunc?function(a,b){// layer context
var res=Number(a.properties[zIndexField])-Number(b.properties[zIndexField]);return res?res:a.id-b.id;}:function(a,b){return a.id-b.id;};},initialize:function initialize(){var gmx=this.layer._gmx;if(!this.userSetSortFunc&&(gmx.GeometryType==='polygon'||gmx.GeometryType==='linestring')){this.resetSortFunc();}},onAdd:function onAdd(){this.initialize();this.layer.on('click',this.clickFunc,this);},onRemove:function onRemove(){this.layer.off('click',this.clickFunc,this);}};L.gmx.VectorLayer.include({_objectsReorder:null,_objectsReorderInit:function _objectsReorderInit(){if(!this._objectsReorder){this._objectsReorder=new ObjectsReorder(this);}},getReorderArrays:function getReorderArrays(){var out={top:[],bottom:[]};if(this._objectsReorder){var reorder=this._objectsReorder,arr=Object.keys(reorder.all).sort(function(a,b){return reorder.all[a]-reorder.all[b];});for(var i=0,len=arr.length;i<len;i++){var id=arr[i];if(reorder.all[id]>0){out.top.push(id);}else {out.bottom.push(id);}}}return out;},bringToTopItem:function bringToTopItem(id){this._objectsReorderInit();this._objectsReorder.addToReorder(id);this.redrawItem(id);return this;},bringToBottomItem:function bringToBottomItem(id){this._objectsReorderInit();this._objectsReorder.addToReorder(id,true);this.redrawItem(id);return this;},clearReorderArrays:function clearReorderArrays(){if(this._objectsReorder){var reorder=this._objectsReorder;reorder.all={};reorder.count=0;this.repaint();}return this;},setReorderArrays:function setReorderArrays(top,bottom){this._objectsReorderInit();var reorder=this._objectsReorder;reorder.all={};reorder.count=0;if(bottom){bottom.forEach(function(id){reorder.addToReorder(id,true);});}if(top){top.forEach(function(id){reorder.addToReorder(id);});}this.repaint();return this;},getSortedItems:function getSortedItems(arr){this._objectsReorderInit();return arr.sort(L.bind(this._objectsReorder.count>0?this._gmx.sortItems:this._objectsReorder.sortFunc,this));},setSortFunc:function setSortFunc(func){this._objectsReorderInit();var reorder=this._objectsReorder;reorder.sortFunc=func;reorder.userSetSortFunc=func?true:false;this._gmx.sortItems=reorder.sortItems;this.repaint();return this;},disableFlip:function disableFlip(){this._objectsReorderInit();this._objectsReorder.disabled=true;return this;},enableFlip:function enableFlip(){this._objectsReorderInit();this._objectsReorder.disabled=false;return this;}});})();// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
var thisNumberValue$1=function thisNumberValue(value){if(typeof value!='number'&&classofRaw$1(value)!='Number'){throw TypeError('Incorrect invocation');}return +value;};// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
var stringRepeat$1=''.repeat||function repeat(count){var str=String(requireObjectCoercible$1(this));var result='';var n=toInteger$1(count);if(n<0||n==Infinity)throw RangeError('Wrong number of repetitions');for(;n>0;(n>>>=1)&&(str+=str)){if(n&1)result+=str;}return result;};var nativeToFixed$1=1.0.toFixed;var floor$6$1=Math.floor;var pow$2$1=function pow$2(x,n,acc){return n===0?acc:n%2===1?pow$2(x,n-1,acc*x):pow$2(x*x,n/2,acc);};var log$1$1=function log$1(x){var n=0;var x2=x;while(x2>=4096){n+=12;x2/=4096;}while(x2>=2){n+=1;x2/=2;}return n;};var FORCED$8$1=nativeToFixed$1&&(0.00008.toFixed(3)!=='0.000'||0.9.toFixed(0)!=='1'||1.255.toFixed(2)!=='1.25'||1000000000000000128.0.toFixed(0)!=='1000000000000000128')||!fails$1(function(){// V8 ~ Android 4.3-
nativeToFixed$1.call({});});// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
_export$1({target:'Number',proto:true,forced:FORCED$8$1},{// eslint-disable-next-line max-statements
toFixed:function toFixed(fractionDigits){var number=thisNumberValue$1(this);var fractDigits=toInteger$1(fractionDigits);var data=[0,0,0,0,0,0];var sign='';var result='0';var e,z,j,k;var multiply=function multiply(n,c){var index=-1;var c2=c;while(++index<6){c2+=n*data[index];data[index]=c2%1e7;c2=floor$6$1(c2/1e7);}};var divide=function divide(n){var index=6;var c=0;while(--index>=0){c+=data[index];data[index]=floor$6$1(c/n);c=c%n*1e7;}};var dataToString=function dataToString(){var index=6;var s='';while(--index>=0){if(s!==''||index===0||data[index]!==0){var t=String(data[index]);s=s===''?t:s+stringRepeat$1.call('0',7-t.length)+t;}}return s;};if(fractDigits<0||fractDigits>20)throw RangeError('Incorrect fraction digits');// eslint-disable-next-line no-self-compare
if(number!=number)return 'NaN';if(number<=-1e21||number>=1e21)return String(number);if(number<0){sign='-';number=-number;}if(number>1e-21){e=log$1$1(number*pow$2$1(2,69,1))-69;z=e<0?number*pow$2$1(2,-e,1):number/pow$2$1(2,e,1);z*=0x10000000000000;e=52-e;if(e>0){multiply(0,z);j=fractDigits;while(j>=7){multiply(1e7,0);j-=7;}multiply(pow$2$1(10,j,1),0);j=e-1;while(j>=23){divide(1<<23);j-=23;}divide(1<<j);multiply(1,1);divide(2);result=dataToString();}else {multiply(0,z);multiply(1<<-e,0);result=dataToString()+stringRepeat$1.call('0',fractDigits);}}if(fractDigits>0){k=result.length;result=sign+(k<=fractDigits?'0.'+stringRepeat$1.call('0',fractDigits-k)+result:result.slice(0,k-fractDigits)+'.'+result.slice(k-fractDigits));}else {result=sign+result;}return result;}});var StyleManager=function StyleManager(gmx){this.gmx=gmx;this.promise=new Promise(function(resolve,reject){this.resolve=resolve;this.reject=reject;}.bind(this));this._maxVersion=0;this._maxStyleSize=0;this._styles=[];this._deferredIcons=[];this._parserFunctions={};this._serverStylesParsed=false;var minZoom=Infinity,maxZoom=-Infinity,arr=gmx.properties.styles||[];for(var i=0,len=arr.length;i<len;i++){var st=arr[i];minZoom=Math.min(minZoom,st.MinZoom);maxZoom=Math.max(maxZoom,st.MaxZoom);}this.minZoom=minZoom===Infinity?0:minZoom;this.maxZoom=maxZoom===-Infinity?18:maxZoom;};StyleManager.prototype={getStyleIcon:function getStyleIcon(nm,txt){// ÑÑÑÐ¾ÐºÐ° Ð»ÐµÐ³ÐµÐ½Ð´Ñ ÑÑÐ¸Ð»ÐµÐ¹
var st=this._styles[nm];if(!st){return null;}txt=txt||'';var geometryType=this.gmx.GeometryType||'polygon',renderStyle=st.RenderStyle,out='<div class="gmx-style-legend"><span class="prefixWrapper"><span class="prefix'+(renderStyle.iconUrl?'':' style')+'">'+txt+'</span></span>';out+='<span class="legend-block">';if(renderStyle.iconUrl){out+='<span class="legendIconStyleImage"><img crossorigin="" src="'+renderStyle.iconUrl+'" /></span>';}else {var style='';if(renderStyle.fillColor){style='background-color: '+L.gmxUtil.dec2rgba(renderStyle.fillColor,renderStyle.fillOpacity||1);}if(renderStyle.color){style+=' border-color: '+L.gmxUtil.dec2rgba(renderStyle.color,renderStyle.opacity||1);}out+='<span class="legendIconStyle '+geometryType+'"'+(style?' style="'+style+'"':'')+'"></span>';}var title=st.Name||st.Filter||'Ð»ÐµÐ³ÐµÐ½Ð´Ð°';out+='<span class="legendIconCell"><span class="styleName"> '+title+'</span>';out+='</span></div>';return out;},_getMaxStyleSize:function _getMaxStyleSize(zoom){// estimete style size for arbitrary object
var maxSize=0;for(var i=0,len=this._styles.length;i<len;i++){var style=this._styles[i];if(zoom>style.MaxZoom||zoom<style.MinZoom){continue;}var RenderStyle=style.RenderStyle;// if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {
if(this._needLoadIcons||!RenderStyle||!('maxSize'in RenderStyle)){maxSize=StyleManager.MAX_STYLE_SIZE;break;}var maxShift=0;if('iconAnchor'in RenderStyle&&!RenderStyle.iconCenter){maxShift=Math.max(Math.abs(RenderStyle.iconAnchor[0]),Math.abs(RenderStyle.iconAnchor[1]));}maxSize=Math.max(RenderStyle.maxSize+maxShift,maxSize);}return maxSize;},getStyleBounds:function getStyleBounds(ntp){if(!ntp){return gmxAPIutils.bounds();}this._maxStyleSize=this._getMaxStyleSize(ntp.z);var mercSize=2*this._maxStyleSize*gmxAPIutils.tileSizes[ntp.z]/256;//TODO: check formula
return gmxAPIutils.getBoundsByTilePoint(ntp).addBuffer(mercSize);},//is any style is visible at given zoom?
isVisibleAtZoom:function isVisibleAtZoom(zoom){for(var i=0,len=this._styles.length;i<len;i++){var style=this._styles[i];if(zoom>=style.MinZoom&&zoom<=style.MaxZoom){return true;}}return false;},getIcons:function getIcons(callback){var _this=this;this.promise.then(function(){var out=[];for(var i=0,len=_this._styles.length;i<len;i++){var style=_this._styles[i],pt={};if(style.RenderStyle){pt.RenderStyle={image:style.RenderStyle.image};}if(style.HoverStyle){pt.HoverStyle={image:style.HoverStyle.image};}out.push(pt);}if(callback){callback(out);}});this.initStyles();},_chkReady:function _chkReady(){if(this._needLoadIcons<1){if(this.gmx.dataManager){this.gmx.dataManager.addFilter('styleFilter',this._chkStyleFilter.bind(this));this.gmx.dataManager.addFilter('labelFilter',this._chkStyleFilterLabels.bind(this));}this.resolve();}},initStyles:function initStyles(){if(!this._serverStylesParsed){this._parseServerStyles();}for(var i=0,len=this._deferredIcons.length;i<len;i++){this._getImageSize(this._deferredIcons[i]);}this._deferredIcons=[];this._chkReady();return this.promise;},getStyles:function getStyles(){if(!this._serverStylesParsed){this._parseServerStyles();}var out=[];for(var i=0,len=this._styles.length;i<len;i++){var style=L.extend({},this._styles[i]);style.RenderStyle=StyleManager.getStyleKeys(style.RenderStyle);if(style.HoverStyle){style.HoverStyle=StyleManager.getStyleKeys(style.HoverStyle);}delete style.filterFunction;delete style.version;delete style.common;delete style.type;out.push(style);}return out;},clearStyles:function clearStyles(){this._styles=[];this.gmx.balloonEnable=false;this.gmx.labelsLayer=false;},_changeStylesVersion:function _changeStylesVersion(){var _this=this;this._styles.map(function(it){it.version=++_this._maxVersion;});},setStyle:function setStyle(st,num,createFlag){num=num||0;if(num<this._styles.length||createFlag){var style=this._styles[num];if(!style){style=this._prepareItem({});this._styles[num]=style;}style.version=++this._maxVersion;if('Filter'in st){style.Filter=st.Filter;var type=_typeof$1(st.Filter);/*eslint-disable no-useless-escape */style.filterFunction=type==='string'?L.gmx.Parsers.parseSQL(style.Filter.replace(/[\[\]]/g,'"')):type==='function'?style.Filter:null;/*eslint-enable */this._changeStylesVersion();}for(var i=0,len=StyleManager.DEFAULT_KEYS.length;i<len;i++){var key=StyleManager.DEFAULT_KEYS[i];if(key in st){style[key]=st[key];}}if(st.RenderStyle){style.RenderStyle=this._parseStyle(st.RenderStyle);}if(st.HoverStyle){style.HoverStyle=this._parseStyle(st.HoverStyle,style.RenderStyle);}this._checkStyles();}return this.initStyles();},getItemBalloon:function getItemBalloon(item){if(typeof item==='number'){item=this.gmx.dataManager.getItem(item);}var currentFilter=item?item.currentFilter:0,style=this._styles[currentFilter];return style?{DisableBalloonOnMouseMove:style.DisableBalloonOnMouseMove||false,DisableBalloonOnClick:style.DisableBalloonOnClick||false,templateBalloon:style.Balloon||null,isSummary:/\[SUMMARY\]/.test(style.Balloon)}:null;},// apply styleHook func
// applyStyleHook: function(item, hoverFlag) {
// return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));
// },
getObjStyle:function getObjStyle(item,zoom){this._chkStyleFilter(item,zoom);var style=this._styles[item.currentFilter],version;if(!style){return null;}if(style.hoverDiff&&this.gmx.lastHover&&item.id===this.gmx.lastHover.id){if(style.HoverStyle){version=style.HoverStyle.version||-1;if(version!==item.styleVersion){item.parsedStyleHover=this._itemStyleParser(item,style.HoverStyle);}return style.HoverStyle;}else {delete item.parsedStyleHover;}return null;}version=style.version||-1;if(version!==item.styleVersion){item.parsedStyleKeys=this._itemStyleParser(item,style.RenderStyle);}return style.RenderStyle;},_needLoadIcons:0,_getImageSize:function _getImageSize(pt){// check image size
var url=pt.iconUrl||pt.fillIconUrl||'',opt={crossOrigin:'anonymous'},isIE11=L.gmxUtil.isIE11&&/\.svg/.test(url),_this=this;if(self.location.protocol!=='file:'){url=url.replace(/http(s*):/,'');// remove protocol from icon URL
}if(isIE11){url+=(url.indexOf('?')===-1?'?':'&')+'crossOrigin='+opt.crossOrigin;}opt.layerID=this.gmx.layerID;++this._needLoadIcons;L.gmx.imageLoader.unshift(url,opt).def.then(function(it){pt.version=++_this._maxVersion;if(pt.fillIconUrl){pt.imagePattern=it;}else {pt.sx=it.width||it.offsetWidth;pt.sy=it.height||it.offsetHeight;pt.image=it;var maxSize=pt.iconAngle?Math.sqrt(pt.sx*pt.sx+pt.sy*pt.sy):Math.max(pt.sx,pt.sy);if(!pt.scaleFunction&&!pt.rotateFunction){if(pt.iconScale||pt.iconScale===1){maxSize*=pt.iconScale;}pt.common=true;}pt.maxSize=Number(maxSize.toFixed());}_this._needLoadIcons--;_this._chkReady();},function(){pt.version=++_this._maxVersion;pt.sx=1;pt.sy=0;pt.image=null;_this._needLoadIcons--;_this._chkReady();console.log({url:url,func:'_getImageSize',Error:'image not found'});});},getCurrentFilters:function getCurrentFilters(propArray,zoom){var gmx=this.gmx,indexes=gmx.tileAttributeIndexes,types=gmx.tileAttributeTypes,z=zoom||1,out=[];if(!this._serverStylesParsed){this._parseServerStyles();}for(var i=0,len=this._styles.length;i<len;i++){var st=this._styles[i];if(st.disabled||z>st.MaxZoom||z<st.MinZoom||st.filterFunction&&!st.filterFunction(propArray,indexes,types)){continue;}out.push(i);if(!gmx.multiFilters){break;}}return out;},_chkStyleFilterLabels:function _chkStyleFilterLabels(item){var st=this._styles[item.currentFilter];if(st){var z=this.gmx.currentZoom,minZoom=st.labelMinZoom||st.MinZoom,maxZoom=st.labelMaxZoom||st.MaxZoom;if(!st.disabled&&z<=maxZoom&&z>=minZoom){return true;}}return false;},_chkStyleFilter:function _chkStyleFilter(item){var gmx=this.gmx,fnum=gmx.multiFilters?-1:item.currentFilter,curr=this._styles[fnum],needParse=!curr||curr.version!==item.styleVersion,zoom=gmx.currentZoom;// zoom = zoom || gmx.currentZoom;
if(needParse||item._lastZoom!==zoom){item.currentFilter=-1;item.multiFilters=[];var filters=this.getCurrentFilters(item.properties,zoom);for(var i=0,len=filters.length;i<len;i++){var num=filters[i],st=this._styles[num];item.hoverDiff=st.hoverDiff;item.currentFilter=num;if(needParse||fnum!==num){var parsed=st.common&&st.common.RenderStyle||this._itemStyleParser(item,st.RenderStyle),parsedHover=null;item.parsedStyleKeys=parsed;if(st.HoverStyle){parsedHover=st.common&&st.common.HoverStyle||this._itemStyleParser(item,st.HoverStyle);item.parsedStyleHover=parsedHover;}if(gmx.multiFilters){item.multiFilters.push({style:st.RenderStyle,styleHover:st.HoverStyle,parsedStyle:parsed,parsedStyleHover:parsedHover});}}item.styleVersion=st.version;if(!gmx.multiFilters){break;}}item._lastZoom=zoom;}if(this._styles[item.currentFilter]){return true;}else {item.currentFilter=-1;return false;}},_parseServerStyles:function _parseServerStyles(){var gmx=this.gmx,props=gmx.properties,gmxStyles=props.gmxStyles?props.gmxStyles.styles:null,arr=gmxStyles||props.styles||[{MinZoom:1,MaxZoom:21,RenderStyle:StyleManager.DEFAULT_STYLE}],len=Math.max(arr.length,gmx.styles.length),i,gmxStyle;if(gmxStyles){for(i=0;i<len;i++){if(!this._styles[i]){gmxStyle=gmx.styles[i]||arr[i];gmxStyle.RenderStyle=this._parseStyle(gmxStyle.RenderStyle);gmxStyle.HoverStyle=this._parseStyle(gmxStyle.HoverStyle);this._styles.push(gmxStyle);if(this._isLabel(gmxStyle.RenderStyle)){gmx.labelsLayer=true;}}}}else {for(i=0;i<len;i++){if(!this._styles[i]){gmxStyle=gmx.styles[i]||arr[i];if(!gmxStyle.RenderStyle){gmxStyle.RenderStyle=StyleManager.DEFAULT_STYLE;}if(gmxStyle.HoverStyle===undefined){var hoveredStyle=JSON.parse(JSON.stringify(gmxStyle.RenderStyle));if(hoveredStyle.outline){hoveredStyle.outline.thickness+=1;}gmxStyle.HoverStyle=hoveredStyle;}else if(gmxStyle.HoverStyle===null){delete gmxStyle.HoverStyle;}var pt=this._prepareItem(gmxStyle);this._styles.push(pt);if(this._isLabel(pt.RenderStyle)){gmx.labelsLayer=true;}}}}this._checkStyles();this._serverStylesParsed=true;},_iconsUrlReplace:function _iconsUrlReplace(iconUrl){var str=iconUrl||'';if(iconUrl&&this.gmx.iconsUrlReplace){this.gmx.iconsUrlReplace.forEach(function(it){str=str.replace(it.from,it.to);});}return str;},_checkStyles:function _checkStyles(){var minZoom=Infinity,maxZoom=-Infinity,balloonEnable=false,labelsLayer=false;for(var i=0,len=this._styles.length;i<len;i++){var st=this._styles[i];st.DisableBalloonOnMouseMove=st.DisableBalloonOnMouseMove===false?false:true;st.DisableBalloonOnClick=st.DisableBalloonOnClick||false;if(st.DisableBalloonOnMouseMove===false||st.DisableBalloonOnClick===false){balloonEnable=true;st.BalloonEnable=true;}st.hoverDiff=null;st.common={};if(st.RenderStyle){if(st.RenderStyle.iconUrl){st.RenderStyle.iconUrl=this._iconsUrlReplace(st.RenderStyle.iconUrl);}if(st.HoverStyle&&st.HoverStyle.iconUrl){st.HoverStyle.iconUrl=this._iconsUrlReplace(st.HoverStyle.iconUrl);}if(!labelsLayer){if(this._isLabel(st.RenderStyle)){labelsLayer=true;}}if(st.RenderStyle.common){st.common.RenderStyle=this._itemStyleParser({},st.RenderStyle);}if(st.HoverStyle){st.hoverDiff=StyleManager.checkDiff(st.RenderStyle,st.HoverStyle);}}if(st.HoverStyle&&st.HoverStyle.common){st.common.HoverStyle=this._itemStyleParser({},st.HoverStyle);}minZoom=Math.min(minZoom,st.MinZoom);maxZoom=Math.max(maxZoom,st.MaxZoom);}if(this.minZoom!==Infinity){this.minZoom=minZoom;}if(this.maxZoom!==-Infinity){this.maxZoom=maxZoom;}this.gmx.balloonEnable=balloonEnable;this.gmx.labelsLayer=labelsLayer;},_parseStyle:function _parseStyle(st,renderStyle){if(st){st.common=true;for(var key in st){if(gmxAPIutils.styleFuncKeys[key]){var fkey=gmxAPIutils.styleFuncKeys[key],val=st[key];if(typeof val==='string'){st.common=false;if(renderStyle&&renderStyle[key]===val){st[fkey]=renderStyle[fkey];}else {if(!this._parserFunctions[val]){// this._parserFunctions[val] = gmxAPIutils.styleFunc[key] || L.gmx.Parsers.parseExpression(val);
this._parserFunctions[val]=L.gmx.Parsers.parseExpression(val);}st[fkey]=this._parserFunctions[val];}}else if(typeof val==='function'){st.common=false;st[fkey]=val;}}}var type='';if('iconUrl'in st){type='image';if(st.iconUrl){st.maxSize=256;this._deferredIcons.push(st);}}else if(st.fillIconUrl){type='square';this._deferredIcons.push(st);}else if(st.fillPattern){type='square';st.common=StyleManager.parsePattern(st.fillPattern);st.canvasPattern=gmxAPIutils.getPatternIcon(null,st);}else if(st.iconCircle){type='circle';if(!('iconSize'in st)){st.iconSize=4;}}else if(st.iconPath){type='iconPath';var iconSize=0,arr=L.Util.isArray(st.iconPath)?st.iconPath:StyleManager.DEFAULT_ICONPATH;st.iconPath=StyleManager.DEFAULT_ICONPATH.map(function(it,i){var z=arr[i]||it;iconSize=Math.max(iconSize,z);return z;});st.iconSize=2*iconSize;}else if(st.fillRadialGradient){type='circle';if(!('iconCenter'in st)){st.iconCenter=true;}var size=StyleManager.parseRadialGradient(st.fillRadialGradient);if(size===null){st.common=false;}else {st.iconSize=size;}}else if(st.fillLinearGradient){type='square';st.common=StyleManager.parseLinearGradient(st.fillLinearGradient);}else if(st.iconSize){type='square';if(!('iconCenter'in st)){st.iconCenter=true;}}st.type=type;if(st.common&&!st.maxSize){st.maxSize=st.iconSize||0;st.maxSize+=st.weight?st.weight:0;if('iconScale'in st){st.maxSize*=st.iconScale;}}}return st;},_prepareItem:function _prepareItem(style){// Style Scanex->leaflet
var pt={MinZoom:style.MinZoom||0,MaxZoom:style.MaxZoom||18,Filter:style.Filter||null,Balloon:style.Balloon||'',RenderStyle:style.RenderStyle?this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)):{},version:++this._maxVersion};pt.labelMinZoom=style.labelMinZoom||pt.MinZoom;pt.labelMaxZoom=style.labelMaxZoom||pt.MaxZoom;pt.DisableBalloonOnMouseMove=style.DisableBalloonOnMouseMove===false?false:true;pt.DisableBalloonOnClick=style.DisableBalloonOnClick||false;if(style.HoverStyle){pt.HoverStyle=this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle),pt.RenderStyle);}if('Filter'in style){/*eslint-disable no-useless-escape */var ph=L.gmx.Parsers.parseSQL(style.Filter.replace(/[\[\]]/g,'"'));/*eslint-enable */if(ph){pt.filterFunction=ph;}}return pt;},_isLabel:function _isLabel(st){var indexes=this.gmx.tileAttributeIndexes;return st&&(st.labelTemplate||st.labelField&&st.labelField in indexes);},_itemStyleParser:function _itemStyleParser(item,pt){pt=pt||{};var out={},arr,i,len,indexes=this.gmx.tileAttributeIndexes,prop=item.properties||{},itemType=item.type,type=pt.type,color='color'in pt?pt.color:255,opacity='opacity'in pt?pt.opacity:1;out.sx=pt.sx;out.sy=pt.sy;if(pt.maxSize){out.maxSize=pt.maxSize;}if(pt.iconAngle){var rotateRes=pt.iconAngle||0;if(rotateRes&&typeof rotateRes==='string'){rotateRes=pt.rotateFunction?pt.rotateFunction(prop,indexes):0;}out.rotate=rotateRes||0;}if('iconColor'in pt){out.iconColor=pt.iconColorFunction?pt.iconColorFunction(prop,indexes):pt.iconColor;}if('iconScale'in pt){out.iconScale=pt.scaleFunction?pt.scaleFunction(prop,indexes):pt.iconScale||1;}if(type==='image'){out.type=type;if(pt.iconUrl){// out.iconUrl = pt.iconUrlFunction ? pt.iconUrlFunction(pt.iconUrl, prop, indexes) : pt.iconUrl;
out.iconUrl=pt.iconUrl;}if(pt.image){out.image=pt.image;}}else if(pt.fillRadialGradient){var rgr=pt.fillRadialGradient,r1=rgr.r1Function?rgr.r1Function(prop,indexes):rgr.r1,r2=rgr.r2Function?rgr.r2Function(prop,indexes):rgr.r2,x1=rgr.x1Function?rgr.x1Function(prop,indexes):rgr.x1,y1=rgr.y1Function?rgr.y1Function(prop,indexes):rgr.y1,x2=rgr.x2Function?rgr.x2Function(prop,indexes):rgr.x2,y2=rgr.y2Function?rgr.y2Function(prop,indexes):rgr.y2;if(rgr.r2max){r2=Math.min(r2,rgr.r2max);}var colorStop=[];len=rgr.addColorStop.length;if(!rgr.addColorStopFunctions){rgr.addColorStopFunctions=new Array(len);}for(i=0;i<len;i++){arr=rgr.addColorStop[i];var arrFunc=rgr.addColorStopFunctions[i]||[],p0=arrFunc[0]?arrFunc[0](prop,indexes):arr[0],p3=arr[3];if(arr.length<4){var op=arr.length<3?1:arrFunc[2]?arrFunc[2](prop,indexes):arr[2];p3=gmxAPIutils.dec2color(arrFunc[1]?arrFunc[1](prop,indexes):arr[1],op);}colorStop.push([p0,p3]);}out.maxSize=out.sx=out.sy=out.iconSize=r2;out.fillRadialGradient={x1:x1,y1:y1,r1:r1,x2:x2,y2:y2,r2:r2,addColorStop:colorStop};out._radialGradientParsed={create:[x1,y1,r1,x2,y2,r2],colorStop:colorStop};}else if(pt.fillLinearGradient){out.fillLinearGradient=pt.fillLinearGradient;}else {if(pt.fillPattern){out.canvasPattern=pt.canvasPattern?pt.canvasPattern:gmxAPIutils.getPatternIcon(item,pt,indexes);}if(type==='iconPath'){out.type=type;out.iconPath=pt.iconPath;}if(itemType==='POLYGON'||itemType==='MULTIPOLYGON'||this.gmx.GeometryType==='polygon'){type='polygon';}if(pt.iconSize){var iconSize=pt.sizeFunction?pt.sizeFunction(prop,indexes):pt.iconSize;out.sx=out.sy=iconSize;// iconSize += pt.weight ? pt.weight : 0;
out.iconSize=iconSize;if('iconScale'in pt){out.iconSize*=pt.iconScale;}out.maxSize=iconSize;}out.stroke=true;color=pt.colorFunction?pt.colorFunction(prop,indexes):color;opacity=pt.opacityFunction?pt.opacityFunction(prop,indexes):opacity;out.strokeStyle=gmxAPIutils.dec2color(color,opacity);out.lineWidth='weight'in pt?pt.weight:1;}if('iconScale'in pt){out.iconScale=pt.scaleFunction?pt.scaleFunction(prop,indexes)||1:pt.iconScale;}if('iconAnchor'in pt){out.iconAnchor=pt.iconAnchor;}out.iconCenter='iconCenter'in pt?pt.iconCenter:true;if(type==='square'||type==='polygon'||type==='circle'||type==='iconPath'){out.type=type;var fop=pt.fillOpacity,fc=pt.fillColor,fcDec=typeof fc==='string'?parseInt(fc.replace(/#/,''),16):fc;if('fillColor'in pt){out.fillStyle=gmxAPIutils.dec2color(fcDec,1);}if('fillColorFunction'in pt||'fillOpacityFunction'in pt){color=pt.fillColorFunction?pt.fillColorFunction(prop,indexes):fc||255;opacity=pt.fillOpacityFunction?pt.fillOpacityFunction(prop,indexes):fop||1;out.fillStyle=gmxAPIutils.dec2color(color,opacity);}else if('fillOpacity'in pt&&'fillColor'in pt){out.fillStyle=gmxAPIutils.dec2color(fcDec,fop);}}if('dashArray'in pt){out.dashArray=pt.dashArray;}if('dashOffset'in pt){out.dashOffset=pt.dashOffset;}if(this.gmx.labelsLayer){arr=gmxAPIutils.styleKeys.label.client;for(i=0,len=arr.length;i<len;i++){var it=arr[i];if(it in pt){if(it==='labelField'){if(!indexes[pt[it]]){continue;}}else if(it==='labelTemplate'){var properties=gmxAPIutils.getPropertiesHash(prop,indexes);out.labelText=gmxAPIutils.parseTemplate(pt[it],properties);}out[it]=pt[it];}}if('labelAnchor'in pt){out.labelAnchor=pt.labelAnchor;}}return out;}};StyleManager.MAX_STYLE_SIZE=256;//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};
StyleManager.DEFAULT_STYLE={outline:{color:255,thickness:1},marker:{size:8}};StyleManager.DEFAULT_KEYS=['Name','MinZoom','labelMinZoom','MaxZoom','labelMaxZoom','Balloon','BalloonEnable','DisableBalloonOnMouseMove','DisableBalloonOnClick','disabled'];StyleManager.DEFAULT_ICONPATH=[0,10,5,-10,-5,-10,0,10];// [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]
StyleManager.DEFAULT_STYLE_KEYS=['iconUrl','iconAngle','iconSize','iconScale','iconMinScale','iconMaxScale','iconCircle','iconCenter','iconAnchor','iconColor',// Ð´Ð»Ñ Ð¸ÐºÐ¾Ð½Ð¾Ðº
'stroke','color','weight','opacity','dashArray',// Ð´Ð»Ñ Ð»Ð¸Ð½Ð¸Ð¸
'fillColor','fillOpacity','fillIconUrl','fillPattern','fillRadialGradient','fillLinearGradient',// Ð´Ð»Ñ Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ
'labelTemplate','labelField','labelColor','labelHaloColor','labelFontSize','labelSpacing','labelAlign','labelAnchor','labelText'// Ð´Ð»Ñ Ð½Ð°Ð´Ð¿Ð¸ÑÐµÐ¹
];StyleManager.HASH_KEYS=StyleManager.DEFAULT_KEYS.reduce(function(a,key){a[key]=true;return a;},{});StyleManager.HASH_KEYS.RenderStyle=StyleManager.DEFAULT_STYLE_KEYS.reduce(function(a,key){a[key]=true;return a;},{});StyleManager.parsePattern=function(pattern){var common=true,parsers=L.gmx.Parsers;if('step'in pattern&&typeof pattern.step==='string'){pattern.patternStepFunction=parsers.parseExpression(pattern.step);common=false;}if('width'in pattern&&typeof pattern.width==='string'){pattern.patternWidthFunction=parsers.parseExpression(pattern.width);common=false;}if('colors'in pattern){var arr=[];for(var i=0,len=pattern.colors.length;i<len;i++){var rt=pattern.colors[i];if(typeof rt==='string'){arr.push(parsers.parseExpression(rt));common=false;}else {arr.push(null);}}pattern.patternColorsFunction=arr;}return common;};StyleManager.getStyleKeys=function(style){var out={};for(var key in gmxAPIutils.styleKeys){var keys=gmxAPIutils.styleKeys[key];for(var i=0,len=keys.client.length;i<len;i++){var key1=keys.client[i];if(key1 in style){if(style[key1]!==undefined){out[key1]=JSON.parse(JSON.stringify(style[key1]));}if(key1==='fillPattern'){delete out[key1].patternColorsFunction;}else if(key1==='fillLinearGradient'){delete out[key1].addColorStopFunctions;}}}}if('iconAnchor'in style){out.iconAnchor=style.iconAnchor;}if('labelAnchor'in style){out.labelAnchor=style.labelAnchor;}return out;};StyleManager.checkDiff=function(st,st1){for(var key in st){if(st[key]!==st1[key]){return key;}}return null;};StyleManager.parseRadialGradient=function(rg){//	x1,y1,r1 â ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ ÑÐµÐ½ÑÑÐ° Ð¸ ÑÐ°Ð´Ð¸ÑÑ Ð¿ÐµÑÐ²Ð¾Ð¹ Ð¾ÐºÑÑÐ¶Ð½Ð¾ÑÑÐ¸;
//	x2,y2,r2 â ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ ÑÐµÐ½ÑÑÐ° Ð¸ ÑÐ°Ð´Ð¸ÑÑ Ð²ÑÐ¾ÑÐ¾Ð¹ Ð¾ÐºÑÑÐ¶Ð½Ð¾ÑÑÐ¸.
//	addColorStop - ÑÑÐ¾Ð¿ ÑÐ²ÐµÑÐ° Ð¾Ð±ÑÐµÐºÑÐ° Ð³ÑÐ°Ð´Ð¸ÐµÐ½ÑÐ° [[position, color]...]
//		position â Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑÐ° Ð² Ð³ÑÐ°Ð´Ð¸ÐµÐ½ÑÐµ. ÐÐ½Ð°ÑÐµÐ½Ð¸Ðµ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð² Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ðµ 0.0 (Ð½Ð°ÑÐ°Ð»Ð¾) Ð´Ð¾ 1.0 (ÐºÐ¾Ð½ÐµÑ);
//		color â ÐºÐ¾Ð´ ÑÐ²ÐµÑÐ° Ð¸Ð»Ð¸ ÑÐ¾ÑÐ¼ÑÐ»Ð°.
//		opacity â Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ
//		canvasStyleColor â ÑÐµÐ·ÑÐ»ÑÑÑÑÑÑÐ¸Ð¹ ÑÐ²ÐµÑ Ð² ÑÐ¾ÑÐ¼Ð°ÑÐµ canvas
var common=true,parsers=L.gmx.Parsers,i=0,arr=['r1','x1','y1','r2','x2','y2'],len=arr.length;for(i=0;i<len;i++){var it=arr[i];if(!rg[it]){rg[it]=0;}if(typeof rg[it]==='string'){rg[it+'Function']=parsers.parseExpression(rg[it]);common=false;}}rg.addColorStop=rg.addColorStop||[[0,0xFF0000,0.5],[1,0xFFFFFF,0.5]];rg.addColorStopFunctions=[];for(i=0,len=rg.addColorStop.length;i<len;i++){arr=rg.addColorStop[i];var resFunc=[typeof arr[0]==='string'?parsers.parseExpression(arr[0]):null,typeof arr[1]==='string'?parsers.parseExpression(arr[1]):null,typeof arr[2]==='string'?parsers.parseExpression(arr[2]):null];rg.addColorStopFunctions.push(resFunc);if(resFunc[1]===null&&resFunc[2]===null){arr[3]=gmxAPIutils.dec2color(arr[1],arr[2]>1?arr[2]/100:arr[2]);}else {common=false;}}if('r2Function'in rg){common=false;}return common?Math.max(rg.r1,rg.r2):null;};StyleManager.parseLinearGradient=function(lg){var common=true;//	x1,y1 â ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð½Ð°ÑÐ°Ð»ÑÐ½Ð¾Ð¹ ÑÐ¾ÑÐºÐ¸
//	x2,y2 â ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ ÐºÐ¾Ð½ÐµÑÐ½Ð¾Ð¹ ÑÐ¾ÑÐºÐ¸
//	addColorStop - ÑÑÐ¾Ð¿ ÑÐ²ÐµÑÐ° Ð¾Ð±ÑÐµÐºÑÐ° Ð³ÑÐ°Ð´Ð¸ÐµÐ½ÑÐ° [[position, color]...]
//		position â Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑÐ° Ð² Ð³ÑÐ°Ð´Ð¸ÐµÐ½ÑÐµ. ÐÐ½Ð°ÑÐµÐ½Ð¸Ðµ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð² Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ðµ 0.0 (Ð½Ð°ÑÐ°Ð»Ð¾) Ð´Ð¾ 1.0 (ÐºÐ¾Ð½ÐµÑ);
//		color â ÐºÐ¾Ð´ ÑÐ²ÐµÑÐ° Ð¸Ð»Ð¸ ÑÐ¾ÑÐ¼ÑÐ»Ð°.
//		opacity â Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ
var i=0,parsers=L.gmx.Parsers,arr=['x1','y1','x2','y2'],def=[0,0,0,256],len=arr.length;for(i=0;i<len;i++){var it=arr[i];if(it in lg){if(typeof lg[it]==='string'){lg[it+'Function']=parsers.parseExpression(lg[it]);common=false;}}else {lg[it]=def[i];}}lg.addColorStop=lg.addColorStop||[[0,0xFF0000],[1,0xFFFFFF]];lg.addColorStopFunctions=[];for(i=0,len=lg.addColorStop.length;i<len;i++){arr=lg.addColorStop[i];lg.addColorStopFunctions.push([typeof arr[0]==='string'?parsers.parseExpression(arr[0]):null,typeof arr[1]==='string'?parsers.parseExpression(arr[1]):null,typeof arr[2]==='string'?parsers.parseExpression(arr[2]):null]);}return common;};StyleManager.parReg=/\[([^\]]+)\]/g;StyleManager.getKeysHash=function(str,type){var out={},arr=str.match(StyleManager.parReg);if(arr){arr.forEach(function(it){var key=it.replace(/[[\]""]/g,'');if(!out[key]){out[key]=type||true;}});}return out;};StyleManager.decodeOldStyle=function(style){// Style Scanex->leaflet
var st,i,len,key,key1,styleOut={},attrKeys={},type='';for(key in gmxAPIutils.styleKeys){var keys=gmxAPIutils.styleKeys[key];for(i=0,len=keys.client.length;i<len;i++){key1=keys.client[i];if(key1 in style){styleOut[key1]=style[key1];}}st=style[key];if(st&&_typeof$1(st)==='object'){for(i=0,len=keys.server.length;i<len;i++){key1=keys.server[i];if(key1 in st){var newKey=keys.client[i],zn=st[key1];if(typeof zn==='string'){var hash=StyleManager.getKeysHash(zn,newKey);if(Object.keys(hash).length){styleOut.common=false;L.extend(attrKeys,hash);}// var func = gmxAPIutils.styleFunc[newKey];
// if (func) {
// styleOut[gmxAPIutils.styleFuncKeys[newKey]] = func;
// } else
if(gmxAPIutils.styleFuncKeys[newKey]){/*eslint-disable no-useless-escape */if(zn.match(/[^\d\.]/)===null){/*eslint-enable */zn=Number(zn);}else {var func=L.gmx.Parsers.parseExpression(zn);if(func===null){zn=gmxAPIutils.styleFuncError[newKey]();}else {styleOut[gmxAPIutils.styleFuncKeys[newKey]]=func;}}}}else if(key1==='opacity'){zn/=100;}styleOut[newKey]=zn;}}}}if(style.marker){st=style.marker;if('dx'in st||'dy'in st){var dx=st.dx||0,dy=st.dy||0;styleOut.iconAnchor=[-dx,-dy];// For leaflet type iconAnchor
}}for(key in style){if(!gmxAPIutils.styleKeys[key]){styleOut[key]=style[key];}}return {style:styleOut,// ÑÑÐ¸Ð»Ñ
attrKeys:attrKeys,// Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÐ¼ÑÐµ Ð¿Ð¾Ð»Ñ Ð°ÑÑÐ¸Ð±ÑÑÐ¾Ð²
type:type// 'polygon', 'line', 'circle', 'square', 'image'
};};StyleManager.decodeOldStyles=function(props){var styles=props.styles,arr=styles||[{MinZoom:1,MaxZoom:21,RenderStyle:StyleManager.DEFAULT_STYLE}],type=props.type.toLocaleLowerCase(),gmxStyles={attrKeys:{},iconsUrl:{}};gmxStyles.styles=arr.map(function(it){var pt={Name:it.Name||'',type:type||'',//legend: false,
MinZoom:it.MinZoom||0,MaxZoom:it.MaxZoom||18};pt.labelMinZoom=it.labelMinZoom||pt.MinZoom;pt.labelMaxZoom=it.labelMaxZoom||pt.MaxZoom;if('Balloon'in it){pt.Balloon=it.Balloon;var hash=StyleManager.getKeysHash(it.Balloon,'Balloon');if(Object.keys(hash).length){L.extend(gmxStyles.attrKeys,hash);}}if(it.RenderStyle){var rt=StyleManager.decodeOldStyle(it.RenderStyle);L.extend(gmxStyles.attrKeys,rt.attrKeys);if(rt.style.iconUrl){gmxStyles.iconsUrl[rt.style.iconUrl]=true;}pt.RenderStyle=rt.style;if(it.HoverStyle===undefined){var hoveredStyle=JSON.parse(JSON.stringify(pt.RenderStyle));if(hoveredStyle.outline){hoveredStyle.outline.thickness+=1;}pt.HoverStyle=hoveredStyle;}else if(it.HoverStyle===null){delete pt.HoverStyle;}else {var ht=StyleManager.decodeOldStyle(it.HoverStyle);pt.HoverStyle=ht.style;}}else if(type==='vector '){pt.RenderStyle=StyleManager.DEFAULT_STYLE;}if('DisableBalloonOnMouseMove'in it){pt.DisableBalloonOnMouseMove=it.DisableBalloonOnMouseMove===false?false:true;}if('DisableBalloonOnClick'in it){pt.DisableBalloonOnClick=it.DisableBalloonOnClick||false;}if('Filter'in it){// TODO: Ð¿ÐµÑÐµÐ´ÐµÐ»Ð°ÑÑ Ð½Ð° new Function = function(props, indexes, types)
/*eslint-disable no-useless-escape */pt.Filter=it.Filter;var ph=L.gmx.Parsers.parseSQL(it.Filter.replace(/[\[\]]/g,'"'));/*eslint-enable */ // TODO: need body for function Æ (props, indexes, types)
if(ph){pt.filterFunction=ph;}}return pt;});return gmxStyles;};L.gmx=L.gmx||{};L.gmx.StyleManager=StyleManager;L.gmx.VectorLayer.include({bindPopup:function bindPopup(content,options){var popupOptions=L.extend({maxWidth:10000,className:'gmxPopup',layerId:this._gmx.layerID},options);if(this._popup){this.unbindPopup();}if(content instanceof L.Popup){this._popup=content;}else {if(!this._popup||options){this._popup=new L.Popup(popupOptions);}this._popup.setContent(content);}this._popup._initContent=content;this._popup._state='';if(!this._popupHandlersAdded){this.on('click',this._openClickPopup,this).on('mousemove',this._movePopup,this).on('mouseover',this._overPopup,this).on('mouseout',this._outPopup,this).on('doneDraw',this._chkNeedOpenPopup,this);this._popupHandlersAdded=true;}if(popupOptions&&popupOptions.popupopen){this._popupopen=popupOptions.popupopen;}this._popup.updateLayout=this._popup._updateLayout;return this;},unbindPopup:function unbindPopup(){if(this._popup){this._popup=null;this.off('click',this._openClickPopup,this).off('mousemove',this._movePopup,this).off('mouseover',this._overPopup,this).off('mouseout',this._outPopup,this).off('doneDraw',this._chkNeedOpenPopup,this);this._popupopen=null;this._popupHandlersAdded=false;}this._gmx.balloonEnable=false;return this;},_chkNeedOpenPopup:function _chkNeedOpenPopup(){for(var id in this._gmx._needPopups){if(this._gmx._needPopups[id]){this.addPopup(id);delete this._gmx._needPopups[id];}}},disablePopup:function disablePopup(flagHover){this._popupDisabled=true;if(flagHover){this._cacheClickable=this.options.clickable;this.options.clickable=false;}return this;},enablePopup:function enablePopup(flagHover){this._popupDisabled=false;if(flagHover){this.options.clickable=this._cacheClickable;}return this;},openPopup:function openPopup(latlng,options){if(this._popup){// open the popup from one of the path's points if not specified
latlng=latlng||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)];options=options||{};options.latlng=latlng;this._openPopup(options);}return this;},closePopup:function closePopup(type){if(this._popup){this._popup._close();if(type!=='mouseout'){this.getPopups().forEach(this._clearPopup.bind(this));}this.fire('popupclose',{popup:this._popup});}return this;},_movePopup:function _movePopup(options){if(this._popup._state==='mouseover'){var id=this._popup.options._gmxID||-1;if(id!==options.gmx.id){this._setPopupContent(options);}this._popup.setLatLng(options.latlng);}},_overPopup:function _overPopup(options){var _popup=this._popup;if(!_popup._map){this._openPopup(options);}else {this.fire('popupopen',{popup:_popup,gmx:this._setPopupContent(options,_popup)});}if(_popup._state==='mouseover'){_popup.setLatLng(options.latlng);}},_outPopup:function _outPopup(ev){if(this._popup._state==='mouseover'&&!ev.gmx.prevId){this.closePopup(ev.type);}},_callBalloonHook:function _callBalloonHook(props,div){var spans=div.getElementsByTagName('span'),hooksCount={},key,i,len;for(key in this._balloonHook){// collect hook counts
var hookID=this._balloonHook[key].hookID;hooksCount[key]=0;for(i=0,len=spans.length;i<len;i++){if(spans[i].id===hookID){hooksCount[key]++;}}}for(key in this._balloonHook){var hook=this._balloonHook[key],fid=hook.hookID,notFound=true;for(i=0,len=spans.length;i<len;i++){var node=spans[i];if(node.id===fid){notFound=false;node.id+='_'+i;hook.callback(props,div,node,hooksCount);}}if(notFound){hook.callback(props,div,null,hooksCount);}}},_setPopupContent:function _setPopupContent(options,_popup){if(!_popup){_popup=this._popup;}var gmx=options.gmx||{},balloonData=gmx.balloonData||{},properties=L.extend({},gmx.properties),target=gmx.target||{},geometry=target.geometry||{},offset=target.offset,templateBalloon=_popup._initContent||balloonData.templateBalloon||'',type=options.type,skipSummary=this.options.isGeneralized&&(type==='mouseover'||type==='mousemove'),outItem={id:gmx.id,type:type,nodePoint:gmx.nodePoint,latlng:options.latlng,properties:properties,templateBalloon:templateBalloon};if(geometry.type==='POINT'){var geoJson=L.gmxUtil.geometryToGeoJSON(geometry,true,gmx.srs==3857);outItem.latlng=L.latLng(geoJson.coordinates.reverse());}if(offset){var protoOffset=L.Popup.prototype.options.offset;_popup.options.offset=[-protoOffset[0]-offset[0],protoOffset[1]-offset[1]];}else {_popup.options.offset[1]=type==='mouseover'?-7:7;}if(this._popupopen){this._popupopen({popup:_popup,latlng:outItem.latlng,layerPoint:options.layerPoint,contentNode:_popup._contentNode,containerPoint:options.containerPoint,originalEvent:options.originalEvent,gmx:outItem});}else if(!(templateBalloon instanceof L.Popup)){if(!(templateBalloon instanceof HTMLElement)){var geometries,summary='',unitOptions=this._map?this._map.options:{};if(!skipSummary){geometries=target.geometry?[target.geometry]:gmx.geometries||this._gmx.dataManager.getItemGeometries(gmx.id)||[];outItem.summary=summary=L.gmxUtil.getGeometriesSummary(geometries,unitOptions);}if(this._balloonHook){if(!templateBalloon){templateBalloon=gmxAPIutils.getDefaultBalloonTemplate(properties);}for(var key in this._balloonHook){properties[key]=gmxAPIutils.parseTemplate(this._balloonHook[key].resStr,properties);}}templateBalloon=L.gmxUtil.parseBalloonTemplate(templateBalloon,{properties:properties,tileAttributeTypes:this._gmx.tileAttributeTypes,unitOptions:unitOptions,summary:summary,geometries:geometries});}var contentDiv=L.DomUtil.create('div','');contentDiv.innerHTML=templateBalloon;_popup.setContent(contentDiv);if(this._balloonHook){this._callBalloonHook(gmx.properties,_popup.getContent());}//outItem.templateBalloon = templateBalloon;
}_popup.options._gmxID=gmx.id;return outItem;},_openClickPopup:function _openClickPopup(options){var originalEvent=options.originalEvent||{},skip=!options.gmx||this._popupDisabled||originalEvent.ctrlKey||originalEvent.altKey||originalEvent.shiftKey;if(!skip){var type=options.type,gmx=options.gmx,balloonData=gmx.balloonData,flag=type==='click'&&balloonData.isSummary&&!balloonData.DisableBalloonOnClick,item=gmx.target.item;if(flag&&item.options.isGeneralized&&!item.geometry){var layerProp=gmx.layer.getGmxProperties();var endPoints=this.options.gmxEndPoints||{};gmxAPIutils.getLayerItemFromServer({options:options,url:endPoints.searchLayerItem?L.gmxUtil.protocol+'//'+this.options.hostName+endPoints.searchLayerItem:null,layerID:layerProp.name,value:item.id,field:layerProp.identityField}).then(function(json,params){if(json&&json.Status==='ok'&&json.Result){var pArr=json.Result.values[0];params.options.gmx.target.fromServerProps=pArr;params.options.gmx.target.geometry=pArr[pArr.length-1];this._openPopup(params.options);}}.bind(this));}else {if(item.type.indexOf('POINT')!==-1){options.latlng=L.latLng(L.gmxUtil.geometryToGeoJSON(item.properties[item.properties.length-1],true,this._gmx.srs==3857).coordinates.reverse());}this._openPopup(options);}}},_openPopup:function _openPopup(options,notSkip){var map=this._map,originalEvent=options.originalEvent||{},skip=notSkip?!notSkip:this._popupDisabled||originalEvent.ctrlKey||originalEvent.altKey||originalEvent.shiftKey;if(!skip){var type=options.type,_popup=this._popup,gmx=options.gmx||{},balloonData=gmx.balloonData||{};if(type==='click'){if(!notSkip&&balloonData.DisableBalloonOnClick&&!this.hasEventListeners('popupopen')){return;}if(!('_gmxPopups'in map)){map._gmxPopups=[];}if(!('maxPopupCount'in map.options)){map.options.maxPopupCount=1;}if(!this._gmx._gmxPopupsInit){this._gmx._gmxPopupsInit=true;map.on({layerremove:function layerremove(ev){if(ev.layer instanceof L.Popup){this._clearPopup(ev.layer);}else if(ev.layer===this){if(map._gmxPopups){var layerId=this._gmx.layerID;map._gmxPopups=map._gmxPopups.reduce(function(p,c){if(c._map){if(c.options.layerId===layerId){c._map.removeLayer(c);}else {p.push(c);}}return p;},[]);}this.closePopup();}}},this);}this._clearPopup(gmx.id);var opt=this._popup?this._popup.options:{maxWidth:10000,className:'gmxPopup',layerId:this._gmx.layerID};_popup=new L.Popup(L.extend({},opt,{closeOnClick:map.options.maxPopupCount===1,autoPan:true}));}else if(type==='mouseover'){if(balloonData.DisableBalloonOnMouseMove){_popup._state='';return;}_popup.options.autoPan=false;}else {return;}_popup.options.objectId=gmx.id;_popup._state=type;var outItem=this._setPopupContent(options,_popup);_popup.setLatLng(outItem.latlng);this.fire('popupopen',{popup:_popup,gmx:outItem});if(type==='click'){if(map._gmxPopups.length>=map.options.maxPopupCount){map.removeLayer(map._gmxPopups.shift());}map._gmxPopups.push(_popup);}_popup.addTo(map);// this._map.openPopup(_popup);
if(_popup._closeButton){var closeStyle=_popup._closeButton.style;if(type==='mouseover'&&closeStyle!=='hidden'){closeStyle.visibility='hidden';_popup._container.style.marginBottom='7px';_popup._container.style.pointerEvents='none';}else if(type==='click'&&closeStyle!=='inherit'){closeStyle.visibility='inherit';_popup._container.style.marginBottom='';_popup._container.style.pointerEvents='';}}}},_clearPopup:function _clearPopup(item/* <L.Popup> or objectId */){var map=this._map;if(map&&map._gmxPopups){var layerId=this._gmx.layerID,flagPopup=item instanceof L.Popup;map._gmxPopups=map._gmxPopups.reduce(function(p,c){if(c._map){if(flagPopup&&c===item){c._map.removeLayer(c);}else if(c.options.layerId===layerId&&c.options.objectId===item){c._map.removeLayer(c);}else {p.push(c);}}return p;},[]);}},getPopups:function getPopups(flag){var map=this._map,out=[];if(map&&map._gmxPopups){var layerId=this._gmx.layerID;map._gmxPopups.reduce(function(p,c){if(c.options.layerId===layerId){p.push(flag?c:c.options.objectId);}return p;},out);}return out;},addPopup:function addPopup(id){var gmx=this._gmx,item=gmx.dataManager.getItem(id);if(!item||!this._map){gmx._needPopups[id]=false;}else {var center=item.bounds.getCenter(),latlng=L.latLng(L.gmxUtil.coordsFromMercator('Point',center,gmx.srs==3857).reverse());this._openPopup({type:'click',latlng:latlng,gmx:this.getHoverOption(item)},true);delete gmx._needPopups[id];}return this;},addPopupHook:function addPopupHook(key,callback){if(!this._balloonHook){this._balloonHook={};}if(!this._balloonHook[key]){var hookID='_'+L.stamp({});this._balloonHook[key]={key:key,hookID:hookID,resStr:'<span id="'+hookID+'"></span>',callback:callback};}return this;},removePopupHook:function removePopupHook(key){if(this._balloonHook){delete this._balloonHook[key];}return this;}});L.gmx.VectorLayer.include({_gmxFirstObjectsByPoint:function _gmxFirstObjectsByPoint(geoItems,mercPoint,bounds){// ÐÐ¾Ð»ÑÑÐ¸ÑÑ Ð²ÐµÑÑÐ½Ð¸Ð¹ Ð¾Ð±ÑÐµÐºÑ Ð¿Ð¾ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼ mouseClick
var gmx=this._gmx,mInPixel=gmx.mInPixel,j,len;for(var i=geoItems.length-1;i>=0;i--){var geoItem=geoItems[i].properties,idr=geoItem[0],dataOption=geoItems[i].dataOption||{},item=geoItems[i],parsedStyleKeys=item.parsedStyleKeys||{},dpStyleKeys=dataOption.parsedStyleKeys||{},// item = gmx.dataManager.getItem(idr),
currentStyle=item.currentStyle||parsedStyleKeys||{},iconScale=currentStyle.iconScale||1,iconCenter=currentStyle.iconCenter,iconAnchor=!iconCenter&&currentStyle.iconAnchor?currentStyle.iconAnchor:null,parsedStyle=gmx.styleManager.getObjStyle(item)||{},lineWidth=currentStyle.lineWidth||parsedStyle.lineWidth||parsedStyle.weight||0,sx=lineWidth+(parsedStyle.sx||currentStyle.sx||parsedStyle.iconSize||dpStyleKeys.sx||0),sy=lineWidth+(parsedStyle.sy||currentStyle.sy||parsedStyle.iconSize||dpStyleKeys.sy||0),offset=[iconScale*sx/2,iconScale*sy/2],point=mercPoint,geom=geoItem[geoItem.length-1],type=geom.type;if(type==='POINT'&&parsedStyle.type==='circle'){offset[0]*=2;offset[1]*=2;}var radius=offset[0],objBounds=gmxAPIutils.bounds().extendBounds(dataOption.bounds).addBuffer(offset[0]/mInPixel,offset[1]/mInPixel);if(iconAnchor){offset=[iconAnchor[0]-offset[0],iconAnchor[1]-offset[1]];point=[mercPoint[0]+offset[0]/mInPixel,mercPoint[1]-offset[1]/mInPixel];}if(!objBounds.contains(point)){continue;}var fill=currentStyle.fillStyle||currentStyle.canvasPattern||parsedStyle.bgImage||'fillColor'in parsedStyle||parsedStyle.fillPattern,marker=parsedStyle&&parsedStyle.image?parsedStyle.image:null,chktype=type,hiddenLines=dataOption.hiddenLines||[],boundsArr=dataOption.boundsArr,coords=geom.coordinates,nodePoint=null,ph={point:mercPoint,bounds:bounds,coords:coords,boundsArr:boundsArr};if(type==='MULTIPOLYGON'||type==='POLYGON'){if(marker){chktype='POINT';}else if(!fill){if(type==='POLYGON'){chktype='MULTILINESTRING';hiddenLines=hiddenLines[0];}else {chktype='LIKEMULTILINESTRING';}ph.hidden=hiddenLines;}}if(chktype==='LINESTRING'){if(!gmxAPIutils.isPointInPolyLine(mercPoint,lineWidth/mInPixel,coords)){nodePoint=gmxAPIutils.bounds([point]).addBuffer(offset[0]/mInPixel,offset[1]/mInPixel).isNodeIntersect(coords);if(nodePoint===null){continue;}}}else if(chktype==='LIKEMULTILINESTRING'){ph.delta=lineWidth/mInPixel;var flag=false;for(j=0,len=coords.length;j<len;j++){ph.coords=coords[j];ph.hidden=hiddenLines?hiddenLines[j]:null;ph.boundsArr=boundsArr[j];if(gmxAPIutils.isPointInLines(ph)){flag=true;break;}}if(!flag){continue;}}else if(chktype==='MULTILINESTRING'){ph.delta=lineWidth/mInPixel;ph.hidden=hiddenLines;if(!gmxAPIutils.isPointInLines(ph)){var pBounds=gmxAPIutils.bounds([point]).addBuffer(offset[0]/mInPixel,offset[1]/mInPixel);for(j=0,len=coords.length;j<len;j++){nodePoint=pBounds.isNodeIntersect(coords[j]);if(nodePoint!==null){nodePoint.ring=j;break;}}if(nodePoint===null){continue;}}}else if(chktype==='MULTIPOLYGON'||chktype==='POLYGON'){var chkPoint=mercPoint;flag=false;if(chktype==='POLYGON'){coords=[geom.coordinates];boundsArr=[dataOption.boundsArr];}for(j=0,len=coords.length;j<len;j++){var arr=coords[j],bbox=boundsArr[j];for(var j1=0,len1=arr.length;j1<len1;j1++){var b=bbox[j1];if(b.intersects(bounds)){if(gmxAPIutils.isPointInPolygonWithHoles(chkPoint,arr)){flag=j1===0?true:false;break;}}}}if(!flag){continue;}}else if(chktype==='POINT'){if(parsedStyle.type==='circle'){var x=(coords[0]-point[0])*mInPixel,y=(coords[1]-point[1])*mInPixel;if(x*x+y*y>radius*radius){continue;}}}if(!this.isPointInClipPolygons(mercPoint)){continue;}return {id:idr,item:item,properties:item.properties,geometry:geom,bounds:item.bounds,nodePoint:nodePoint,offset:iconAnchor?offset:null,parsedStyle:parsedStyle};}return null;},gmxEventCheck:function gmxEventCheck(ev,skipOver){if(!this._map){return 0;}var layer=this,gmx=layer._gmx,type=ev.type,lastHover=gmx.lastHover,chkHover=function chkHover(evType){if(lastHover&&type==='mousemove'){if(evType&&layer.hasEventListeners(evType)){ev.gmx=lastHover;layer.fire(evType,ev);}if(lastHover.hoverDiff){layer.redrawItem(lastHover.id);}}};var zoom=this._map.getZoom();if(zoom>this.options.maxZoom||zoom<this.options.minZoom){skipOver=true;}if(skipOver){if(lastHover){lastHover.prevId=null;}chkHover('mouseout');gmx.lastHover=null;}else if(this.hasEventListeners('mouseover')||this.hasEventListeners('mouseout')||this.hasEventListeners(type)||type==='mousemove'&&gmx.properties.fromType!=='Raster'){var lng=ev.latlng.lng%360,latlng=new L.LatLng(ev.latlng.lat,lng+(lng<-180?360:lng>180?-360:0)),crs=gmx.srs==3857?L.CRS.EPSG3857:L.Projection.Mercator,point=crs.project(latlng)._subtract({x:gmx.shiftXlayer||0,y:gmx.shiftYlayer||0}),delta=Math.max(5,gmx.styleManager._getMaxStyleSize(zoom))/gmx.mInPixel,mercatorPoint=[point.x,point.y],filters=gmx.dataManager.getViewFilters('screen',gmx.layerID);//ÑÐ¾Ð·Ð´Ð°ÑÐ¼ observer ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ ÑÐ¾Ð³Ð¾, ÑÑÐ¾Ð±Ñ ÑÐ´ÐµÐ»Ð°ÑÑ Ð²ÑÐ±Ð¾ÑÐºÑ Ð´Ð°Ð½Ð½ÑÑ Ð²Ð¾ÐºÑÑÐ³ ÐºÑÑÑÐ¾ÑÐ°
var observerOptions={type:'resend',layerID:gmx.layerID,needBbox:gmx.needBbox,bbox:gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),dateInterval:gmx.layerType==='VectorTemporal'?[gmx.beginDate,gmx.endDate]:null,filters:['clipFilter','userFilter_'+gmx.layerID,'styleFilter','userFilter'].concat(filters),active:false//Ð´ÐµÐ»Ð°ÐµÐ¼ ÐµÐ³Ð¾ Ð½ÐµÐ°ÐºÑÐ¸Ð²Ð½ÑÐ¼, ÑÐ°Ðº ÐºÐ°Ðº Ð¿Ð¾ÑÐ¾Ð¼ Ð±ÑÐ´ÐµÐ¼ ÑÐ²Ð½Ð¾ Ð²ÑÐ±Ð¸ÑÐ°ÑÑ Ð´Ð°Ð½Ð½ÑÐµ
};if(this.options.isGeneralized){observerOptions.targetZoom=zoom;}gmx.dataManager.addObserver(observerOptions,'hover');var geoItems=gmx.dataManager.getItems('hover');gmx.dataManager.removeObserver('hover');if(geoItems&&geoItems.length){if(geoItems.length>1&&gmx.sortItems){geoItems=this.getSortedItems(geoItems);}var target=this._gmxFirstObjectsByPoint(geoItems,mercatorPoint,observerOptions.bbox);if(target){var idr=target.id,item=target.item,// item = gmx.dataManager.getItem(idr),
prevId=lastHover?lastHover.id:null,changed=!lastHover||lastHover.id!==idr;if(type==='mousemove'&&lastHover){if(!changed){ev.gmx=lastHover;this.fire(type,ev);return idr;}else {ev.gmx=lastHover;this.fire('mouseout',ev);}chkHover(item.currentFilter!==lastHover.currentFilter?'mouseout':'');gmx.lastHover=null;}ev.gmx=L.extend(this.getHoverOption(item),{targets:geoItems,nodePoint:target.nodePoint,prevId:prevId,hoverDiff:item.hoverDiff});if(this.hasEventListeners(type)){this.fire(type,ev);}if(type==='mousemove'&&changed){lastHover=gmx.lastHover=ev.gmx;chkHover('mouseover');gmx.lastMouseover=gmx.lastHover;}this._map.doubleClickZoom.disable();return idr;}}}if(!this._map.doubleClickZoom.enabled()){this._map.doubleClickZoom.enable();}return 0;},getHoverOption:function getHoverOption(item){return {layer:this,target:item,balloonData:this._gmx.styleManager.getItemBalloon(item),properties:this.getItemProperties(item.properties),currentFilter:item.currentFilter||0,id:item.id};}});(function(){var delay=20000,layers={},dataManagersLinks={},script='/Layer/CheckVersion.ashx',intervalID=null,timeoutID=null,hostBusy={},needReq={},w=gmxAPIutils.worldWidthMerc,WORLDBBOX=JSON.stringify([[-w,-w,w,w]]);var isExistsTiles=function isExistsTiles(prop){var tilesKey=prop.Temporal?'TemporalTiles':'tiles';return tilesKey in prop||prop.currentTiles;};var getBboxes=function getBboxes(mbbox){var minY=mbbox.min.y,maxY=mbbox.max.y,minX=mbbox.min.x,maxX=mbbox.max.x,minX1=null,maxX1=null,ww=gmxAPIutils.worldWidthFull,size=mbbox.getSize(),out=[];if(size.x>ww){return WORLDBBOX;}if(maxX>w||minX<-w){var hs=size.x/2,center=(maxX+minX)/2%ww;center=center+(center>w?-ww:center<-w?ww:0);minX=center-hs;maxX=center+hs;if(minX<-w){minX1=minX+ww;maxX1=w;minX=-w;}else if(maxX>w){minX1=-w;maxX1=maxX-ww;maxX=w;}}out.push([minX,minY,maxX,maxY]);if(minX1){out.push([minX1,minY,maxX1,maxY]);}return JSON.stringify(out);};var getParams=function getParams(prop,dm,gmx){var gmxEndPoints=gmx.gmxEndPoints||{};var pt={endPoint:gmxEndPoints.checkVersion||'/Layer/CheckVersion.ashx',Name:prop.name,Version:isExistsTiles(prop)?prop.LayerVersion:-1};if(dm&&(prop.UseTiles===false||gmx.skipTiles==='NotVisible'||gmx.needBbox||gmx.options.needBbox)){var maxDateInterval=dm.getMaxDateInterval(),beginDate=maxDateInterval.beginDate||gmx.beginDate,endDate=maxDateInterval.endDate||gmx.endDate;if(beginDate){pt.dateBegin=Math.floor(beginDate.getTime()/1000);}if(endDate){pt.dateEnd=Math.floor(endDate.getTime()/1000);}}return pt;};var getRequestParams=function getRequestParams(layer){var hosts={},prop,hostName,dm,gmx;if(layer&&layer._gmx){if(layer.target instanceof L.gmx.DataManager){layer=layer.target;}if(layer instanceof L.gmx.DataManager){dm=layer;prop=dm.options;}else {// if (!layer._gmx) {return hosts;}
prop=layer._gmx.properties;dm=layer._gmx.dataManager;gmx=layer._gmx;}hostName=prop.hostName||layer._gmx.hostName;hosts[hostName]=[getParams(prop,dm,gmx)];}else {var skipItems={};for(var id in layers){var obj=layers[id],isDataManager=obj instanceof L.gmx.DataManager;if(obj.options.chkUpdate||isDataManager){dm=isDataManager?obj:obj._gmx.dataManager;prop=isDataManager?obj.options:obj._gmx.properties;gmx=isDataManager?obj:obj._gmx;hostName=prop.hostName||obj._gmx.hostName;var pt=getParams(prop,dm,gmx),key=pt.Name+pt.Version,valid=!skipItems[key]&&(!prop.Temporal||pt.dateBegin);if(valid){if(hosts[hostName]){hosts[hostName].push(pt);}else {hosts[hostName]=[pt];}}skipItems[key]=true;}}}return hosts;};var chkVersion=function chkVersion(layer,callback){if(typeof layer==='string'){layer=layers[layer];}var map=layersVersion._map;var processResponse=function processResponse(res){if(res&&res.Status==='ok'&&res.Result){var arr=res.Result,len=arr.length,count=0,i,key,curLayer,id,item;if(layersVersion.needBbox){for(i=0;i<len;i++){item=arr[i];id=item.name||item.properties.name;curLayer=null;if(layer&&layer._gmx.properties.name===id){curLayer=layer;}else {for(key in layers){curLayer=layers[key];if(layer&&layer===curLayer&&'updateVersion'in layer){continue;}if(curLayer._gmx&&curLayer._gmx.properties.name===id&&'updateVersion'in curLayer){// ÑÐ»Ð¾Ð¸
break;}else if(curLayer instanceof L.gmx.DataManager&&curLayer.options.name===id){// Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ¸ Ð´Ð°Ð½Ð½ÑÑ
break;}}}if(curLayer){count+=(curLayer.getDataManager?curLayer.getDataManager():curLayer).getNotLoadedVectorTiles(item);}}map.fire('needLoadTiles',{count:count});if(L.gmx.skipLoadTiles){console.log('Skiped tiles: ',L.gmx.needLoadTiles);return;}}for(i=0;i<len;i++){item=arr[i];id=item.name||item.properties.name;if(layer&&layer._gmx.properties.name===id&&'updateVersion'in layer){layer.updateVersion(item);}for(key in layers){curLayer=layers[key];if(layer&&layer===curLayer){continue;}if(curLayer._gmx&&curLayer._gmx.properties.name===id&&'updateVersion'in curLayer){// ÑÐ»Ð¾Ð¸
curLayer.updateVersion(item);}else if(curLayer instanceof L.gmx.DataManager&&curLayer.options.name===id){// Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ¸ Ð´Ð°Ð½Ð½ÑÑ
curLayer.updateVersion(item.properties,item.tiles);}}}}// lastLayersStr = '';
if(callback){callback(res);}};if(document.body&&!L.gmxUtil.isPageHidden()){var hosts=getRequestParams(layer),workerParams=[],bboxStr=WORLDBBOX,chkHost=function chkHost(hostName,busyFlag){var layersData=hosts[hostName];if(!layersData){return;}var endPoint=layersData[0].endPoint||script,url=L.gmxUtil.protocol+'//'+hostName+endPoint,layersStr=JSON.stringify(layersData);var ph={WrapStyle:'None',ftc:'osm'};var params='WrapStyle=func&ftc=osm';// var params = 'WrapStyle=None&ftc=osm';
if(layersVersion.needBbox){var bbox=map.getBounds(),ne=bbox.getNorthEast(),sw=bbox.getSouthWest(),zoom=map.getZoom(),crs=L.Projection.Mercator;params+='&zoom='+zoom;ph.zoom=zoom;if(map.options.srs==3857){params+='&srs=3857';ph.srs=3857;crs=L.CRS.EPSG3857;}if(map.options.generalized===false){params+='&generalizedTiles=false';ph.generalizedTiles=false;}if(!map.options.allWorld&&ne.lng-sw.lng<180){var ts=L.gmxUtil.tileSizes[zoom],pb={x:ts,y:ts};bboxStr=getBboxes(L.bounds(crs.project(sw)._subtract(pb),crs.project(ne)._add(pb)));}params+='&bboxes='+bboxStr;ph.bboxes=bboxStr;}ph.layers=layersStr;params+='&layers='+encodeURIComponent(layersStr);if(L.gmx.sendCmd){workerParams.push({hostName:hostName,pars:ph});return;}if('FormData'in window){var onError=function onError(response){console.log('Error: LayerVersion ',response);delete hostBusy[hostName];if(needReq[hostName]&&!busyFlag){delete needReq[hostName];chkHost(hostName,true);}};L.gmxUtil.requestJSONP(url+'?'+params,{}).then(function(json){delete hostBusy[hostName];if(needReq[hostName]&&!busyFlag){delete needReq[hostName];hosts=getRequestParams();chkHost(hostName,true);}else {processResponse(json);}},onError);hostBusy[hostName]=true;var timeStamp=Date.now();for(var key in layers){var it=layers[key];var options=it._gmx||it.options;if(options.hostName===hostName){options._stampVersionRequest=timeStamp;}}}};for(var hostName in hosts){if(!hostBusy[hostName]){chkHost(hostName);}else {needReq[hostName]=true;}}if(L.gmx.sendCmd&&workerParams.length){L.gmx.sendCmd('getLayersVersion',{pars:workerParams}).then(function(){// console.log('gggg', arguments);
});}}};var layersVersion={needBbox:false,addDataManager:function addDataManager(dataManager){var options=dataManager.options,id=options.name;if(id in layers){return;}if(options.needBbox&&!layersVersion.needBbox){layersVersion.needBbox=options.needBbox;}dataManager.on('chkLayerUpdate',chkVersion.bind(dataManager));layers[id]=dataManager;},removeDataManager:function removeDataManager(dataManager){var id=dataManager.options.name;if(id in layers){dataManager.off('chkLayerUpdate',chkVersion.bind(dataManager));delete layers[id];}},remove:function remove(layer){var layerID=layer.options.layerID;if(L.gmx.sendCmd){L.gmx.sendCmd('toggleDataSource',{active:false,// Ð²ÐºÐ»ÑÑÐ¸ÑÑ/Ð²ÑÐºÐ»ÑÑÐ¸ÑÑ ÐºÐ¾Ð½ÑÑÐ¾Ð»Ñ Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ¾Ð²
hostName:layer.options.hostName,mapID:layer.options.mapID,layerID:layerID});}var _gmx=layer._gmx,pOptions=layer.options.parentOptions;if(pOptions){var pId=pOptions.name;if(dataManagersLinks[pId]){delete dataManagersLinks[pId][_gmx.properties.name];if(!Object.keys(dataManagersLinks[pId]).length){layersVersion.removeDataManager(_gmx.dataManager);delete dataManagersLinks[pId];}}}if(!dataManagersLinks[layerID]){delete layers[layerID];_gmx.dataManager.off('chkLayerUpdate',_gmx._chkVersion);}},add:function add(layer){var id=layer._gmx.layerID;if(L.gmx.sendCmd){var opt={active:true,// Ð²ÐºÐ»ÑÑÐ¸ÑÑ/Ð²ÑÐºÐ»ÑÑÐ¸ÑÑ ÐºÐ¾Ð½ÑÑÐ¾Ð»Ñ Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ¾Ð²
hostName:layer.options.hostName,mapID:layer.options.mapID,layerID:layer.options.layerID};var interval=layer._gmx.dataManager.getMaxDateInterval();if(interval.beginDate&&interval.endDate){opt.dInterval=[Math.floor(interval.beginDate.getTime()/1000),Math.floor(interval.endDate.getTime()/1000)];}L.gmx.sendCmd('toggleDataSource',opt);}if(id in layers){return;}var _gmx=layer._gmx,prop=_gmx.properties;if('LayerVersion'in prop){layers[id]=layer;_gmx._chkVersion=function(){chkVersion(layer);};_gmx.dataManager.on('chkLayerUpdate',_gmx._chkVersion);var pOptions=layer.options.parentOptions;if(pOptions){var pId=pOptions.name;layersVersion.addDataManager(_gmx.dataManager);if(!dataManagersLinks[pId]){dataManagersLinks[pId]={};}dataManagersLinks[pId][prop.name]=layer;}if(_gmx.needBbox&&!layersVersion.needBbox){layersVersion.needBbox=_gmx.needBbox;}layersVersion.start();// if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {
layersVersion.now();// }
}},chkVersion:chkVersion,now:function now(){if(timeoutID){clearTimeout(timeoutID);}timeoutID=setTimeout(chkVersion,0);},stop:function stop(){if(intervalID){clearInterval(intervalID);}intervalID=null;},start:function start(msec){if(msec){delay=msec;}layersVersion.stop();intervalID=setInterval(chkVersion,delay);}};if(!L.gmx){L.gmx={};}L.gmx.layersVersion=layersVersion;L.gmx.VectorLayer.include({updateVersion:function updateVersion(layerDescription){if(layerDescription){var gmx=this._gmx;if(layerDescription.geometry){gmx.geometry=layerDescription.geometry;}if(layerDescription.properties){var out={versionChanged:layerDescription.properties.LayerVersion!==gmx.properties.LayerVersion};L.extend(gmx.properties,layerDescription.properties);gmx.properties.currentTiles=layerDescription.tiles;gmx.properties.GeoProcessing=layerDescription.properties.GeoProcessing;// TODO: Ð¿ÑÐ¾Ð²ÐµÑÐºÐ° Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð²ÐµÑÑÐ¸Ð¸
gmx.rawProperties=gmx.properties;this.fire('versionchange',out);}if(!gmx.dataSource&&gmx.dataManager){gmx.dataManager.updateVersion(gmx.rawProperties,layerDescription.tiles);}}}});L.Map.addInitHook(function(){layersVersion._map=this;var map=this,prev={};this.on('moveend',function(){var z=map.getZoom(),center=map.getPixelBounds().getCenter();if(z!==prev.z||prev.center.distanceTo(center)>128){chkVersion();prev.z=z;prev.center=center;}});});})();L.gmx.RasterLayer=L.gmx.VectorLayer.extend({options:{isGeneralized:false,zIndexOffset:0//clickable: false
},initFromDescription:function initFromDescription(ph){this._gmx.srs=this._gmx.srs||3857;var props=ph.properties,styles=props.styles[0]||{MinZoom:props.MinZoom||0,MaxZoom:props.MaxZoom||21},vectorProperties={type:'Vector',fromType:props.type,identityField:'ogc_fid',GeometryType:'POLYGON',IsRasterCatalog:true,RasterSRS:Number(props.RasterSRS)||3857,Copyright:props.Copyright||'',RCMinZoomForRasters:styles.MinZoom,visible:props.visible,styles:[{DisableBalloonOnClick:true,MinZoom:styles.MinZoom,MaxZoom:styles.MaxZoom,RenderStyle:{outline:{thickness:0},fill:{opacity:100}},HoverStyle:null}]},gmx=this._gmx,worldSize=gmxAPIutils.tileSizes[1];if(props.MaxZoom){gmx.maxNativeZoom=props.MaxZoom;}props.sessionKey=props.sessionKey||L.gmx.gmxSessionManager.getSessionKeyRes(props.hostName);if(props.sessionKey){gmx.sessionKey=props.sessionKey;}if(!ph.geometry){ph.geometry={type:'POLYGON',coordinates:[[[-worldSize,-worldSize],[-worldSize,worldSize],[worldSize,worldSize],[worldSize,-worldSize],[-worldSize,-worldSize]]]};}else if(gmx.srs==3857&&gmx.srs!=vectorProperties.RasterSRS){ph.geometry=gmxAPIutils.convertGeometry(gmxAPIutils.convertGeometry(ph.geometry,true,true),false,true);}L.gmx.VectorLayer.prototype.initFromDescription.call(this,{geometry:ph.geometry,properties:vectorProperties,rawProperties:ph.properties});var endPoint=this.options.gmxEndPoints?this.options.gmxEndPoints.tileProps:'/TileSender.ashx';gmx.rasterBGfunc=function(x,y,z){var url=L.gmxUtil.protocol+'//'+gmx.hostName+endPoint+'?ModeKey=tile&ftc=osm'+'&z='+z+'&x='+x+'&y='+y;if(gmx.srs){url+='&srs='+gmx.srs;}if(L.gmx._sw){url+='&sw='+L.gmx._sw;}if(gmx.crossOrigin){url+='&cross='+gmx.crossOrigin;}url+='&LayerName='+gmx.layerID;if(gmx.sessionKey){url+='&key='+encodeURIComponent(gmx.sessionKey);}return url;};gmx.dataManager._rasterVectorTile=new L.gmx.VectorTile({load:function load(x,y,z,v,s,d,callback){var objects=[[777,ph.geometry]],itemBounds=gmxAPIutils.geoItemBounds(ph.geometry),bounds=itemBounds.bounds;if(bounds.max.x>worldSize){// for old layers geometry
var ww2=2*worldSize,id=777,coords=ph.geometry.coordinates,bboxArr=itemBounds.boundsArr;objects=[];if(ph.geometry.type==='POLYGON'){coords=[coords];bboxArr=[bboxArr];}for(var i=0,len=coords.length;i<len;i++){var it=coords[i],bbox=bboxArr[i][0],arr=it;objects.push([id++,{type:'POLYGON',coordinates:arr}]);if(bbox.max.x>worldSize){arr=[];for(var j=0,len1=it.length;j<len1;j++){var it1=it[j];for(var j1=0,arr1=[],len2=it1.length;j1<len2;j1++){var it2=it1[j1];arr1.push([it2[0]-ww2,it2[1]]);}arr.push(arr1);}objects.push([id++,{type:'POLYGON',coordinates:arr}]);}}}callback({bbox:[bounds.min.x,bounds.min.y,bounds.max.x,bounds.max.y],srs:gmx.srs,isGeneralized:false,changeState:true,values:objects});// gmx.dataManager._updateItemsFromTile(gmx.dataManager._rasterVectorTile);
}},{x:0,y:0,z:0,v:0,s:-2,d:-2});gmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);return this;},setZoomBounds:function setZoomBounds(minZoom,maxZoom){var styles=this.getStyles().slice(0);styles[0]=L.extend({},styles[0]);styles[0].MinZoom=minZoom;styles[0].MaxZoom=maxZoom;this.setStyles(styles);}});L.Map.addInitHook(function(){if(this.options.multiRasterLayers){// All L.gmx.RasterLayer to one CR
var map=this,visibleLayers={},curId=0,multiRasterLayer=L.gmx.createLayer({properties:{type:'Vector',GeometryType:'polygon',identityField:'gmx_id',ZIndexField:'_zIndex',attributes:['gmx_id','_zIndex','MinZoom','MaxZoom','GMX_RasterCatalogID'],attrTypes:['integer','integer','integer','integer','string'],IsRasterCatalog:true,RCMinZoomForRasters:1}},{_vectorType:'multiRasterLayer'}).setFilter(function(it){var zoom=map.getZoom(),pArr=it.properties;return visibleLayers[pArr[5]]&&zoom>=pArr[3]&&zoom<=pArr[4];}).setStyles([{MinZoom:1,MaxZoom:21,DisableBalloonOnClick:true,DisableBalloonOnMouseMove:true,RenderStyle:{weight:0},HoverStyle:{weight:0}}]).once('update',function(){requestIdleCallback(multiRasterLayer.repaint.bind(multiRasterLayer),{timeout:0});}),setVisible=function setVisible(it,flag){var rawProp=it.getGmxProperties(),layerId=rawProp.name,zindexupdated=function zindexupdated(ev){var opt=ev.target.options,arr=visibleLayers[opt.layerID];if(arr){arr[2]=(opt.zIndexOffset?opt.zIndexOffset:0)+(opt.zIndex?opt.zIndex:0);}multiRasterLayer.repaint();};if(flag){curId++;var options=it.options,zIndex=(options.zIndexOffset?options.zIndexOffset:0)+(options.zIndex?options.zIndex:0),gmxId=curId,pArr=[gmxId,gmxId,zIndex,rawProp.styles[0].MinZoom||1,rawProp.styles[0].MaxZoom||21,layerId,it._gmx.geometry];multiRasterLayer.addData([pArr]);visibleLayers[layerId]=pArr;it.onRemove(map);it.on('zindexupdated',zindexupdated);}else {it.off('zindexupdated',zindexupdated);multiRasterLayer.removeData([visibleLayers[layerId]]);visibleLayers[layerId]=null;}multiRasterLayer.repaint();};map.on('layeradd',function(ev){var it=ev.layer;if(it instanceof L.gmx.RasterLayer){setVisible(it,true);}}).on('layerremove',function(ev){var it=ev.layer;if(it instanceof L.gmx.RasterLayer){setVisible(it,false);}}).addLayer(multiRasterLayer);}});/*
 (c) 2014, Sergey Alekseev
 Leaflet.LabelsLayer, plugin for Gemixer layers.
*/L.LabelsLayer=(L.Layer||L.Class).extend({options:{animate:false,labels:'default',pane:'overlayPane'},initialize:function initialize(map,options){L.setOptions(this,L.extend(this.options,options));this.__map=map;this._observers={};this._styleManagers={};this._labels={};this._labelsIndex={};var _this=this;this.bbox=gmxAPIutils.bounds();var chkData=function chkData(data,layer){if(!data.added&&!data.removed){return;}var opt=layer.options,added=map._zoom>=opt.minZoom&&map._zoom<=opt.maxZoom?data.added:[],layerId='_'+layer._leaflet_id,gmx=layer._gmx,labels={};for(var i=0,len=added.length;i<len;i++){var item=added[i].item,isPoint=item.type==='POINT'||item.type==='MULTIPOINT',currentStyle=item.parsedStyleKeys||item.currentStyle||{};if(gmx.styleHook){var styleExtend=gmx.styleHook(item,gmx.lastHover&&item.id===gmx.lastHover.id);if(styleExtend){currentStyle=L.extend({},currentStyle,styleExtend);}else {continue;}}if(item.multiFilters){for(var j=0,len1=item.multiFilters.length;j<len1;j++){var st=item.multiFilters[j].parsedStyle;if('labelField'in st||'labelText'in st){currentStyle=st;break;}}}var style=gmx.styleManager.getObjStyle(item)||{},labelText=currentStyle.labelText||style.labelText,labelField=currentStyle.labelField||style.labelField,fieldType=gmx.tileAttributeTypes[labelField],txt=String(labelText||L.gmxUtil.attrToString(fieldType,layer.getPropItem(labelField,item.properties)));if(style.labelTemplate){var reg=/\[([^\]]*)\]/g,match;txt=style.labelTemplate;while(match=reg.exec(style.labelTemplate)){if(match.length===2){labelField=match[1];fieldType=gmx.tileAttributeTypes[labelField];var val=L.gmxUtil.attrToString(fieldType,layer.getPropItem(labelField,item.properties));txt=txt.replace(match[0],val);}}}if(txt||txt===0){var fontSize=style.labelFontSize||currentStyle.labelFontSize||12,id='_'+item.id,changed=true,width=0,arrTxtWidth,options=item.options,labelStyle={font:fontSize+'px "Arial"',labelHaloColor:'labelHaloColor'in currentStyle?currentStyle.labelHaloColor:'labelHaloColor'in style?style.labelHaloColor:0xffffff,labelColor:currentStyle.labelColor||style.labelColor,labelAlign:currentStyle.labelAlign||style.labelAlign,labelAnchor:currentStyle.labelAnchor||style.labelAnchor,labelFontSize:fontSize};if(options){if(!('center'in options)){var center=gmxAPIutils.getItemCenter(item,gmx.dataManager.getItemMembers(item.id));if(!center){continue;}options.center=center;}if(options.label){width=options.label.width;arrTxtWidth=options.label.arrTxtWidth;var pstyle=options.label.style;changed=options.label.txt!==txt||pstyle.labelHaloColor!==labelStyle.labelHaloColor||pstyle.labelColor!==labelStyle.labelColor||pstyle.labelAlign!==labelStyle.labelAlign||pstyle.labelAnchor!==labelStyle.labelAnchor||pstyle.labelFontSize!==labelStyle.labelFontSize;}}if(changed){width=0;arrTxtWidth=gmxAPIutils.getLabelWidth(txt,labelStyle);if(arrTxtWidth){arrTxtWidth.forEach(function(it){width=Math.max(width,it[1]);});}if(!width){delete labels[id];continue;}width+=4;item.options.labelStyle=null;}options.label={isPoint:isPoint,width:width,sx:style.sx||0,txt:txt,arrTxtWidth:arrTxtWidth,style:labelStyle};labels[id]=item;}}_this._labelsIndex[layerId]=layer.options.zIndex;_this._labels[layerId]=labels;};var addObserver=function addObserver(layer,id){var gmx=layer._gmx,dm=gmx.dataManager,filters=['clipFilter','clipPointsFilter','styleFilter','labelFilter','userFilter'],options={type:'resend',bbox:_this.bbox,filters:filters,callback:function callback(data){chkData(data,layer);_this.redraw();}};if(gmx.beginDate&&gmx.endDate){options.dateInterval=[gmx.beginDate,gmx.endDate];}return dm.addObserver(options,'_Labels_'+id);};this.add=function(layer){var id=layer._leaflet_id,gmx=layer._gmx;if(!_this._observers[id]&&gmx&&gmx.labelsLayer&&id){gmx.styleManager.promise.then(function(){var observer=addObserver(layer,id),_zoom=_this.__map._zoom;if(layer.options.isGeneralized){observer.targetZoom=_zoom;//need update to current zoom
}if(observer.dateInterval){layer.on('dateIntervalChanged',function(ev){var dInterval=ev.target.getDateInterval();this.setDateInterval(dInterval.beginDate,dInterval.endDate);},observer);}if(!gmx.styleManager.isVisibleAtZoom(_zoom)){observer.deactivate();}_this._observers[id]=observer;_this._styleManagers[id]=gmx.styleManager;_this._labels['_'+id]={};_this._labelsIndex['_'+id]={};_this._updateBbox();});}};this.remove=function(layer){if(layer){var id=layer._leaflet_id;if(_this._observers[id]){var gmx=layer._gmx,dataManager=gmx.dataManager;dataManager.removeObserver(_this._observers[id].id);delete _this._observers[id];delete _this._styleManagers[id];delete _this._labels['_'+id];delete _this._labelsIndex['_'+id];_this.redraw();}}};// this._layeradd = function (ev) {
// if (ev.layer._gmx.dataManager) {
// _this.add(ev.layer);
// }
// };
// this._layerremove = function (ev) {
// _this.remove(ev.layer);
// };
},_layeradd:function _layeradd(ev){var clayer=ev.layer,gmx=clayer._gmx;if(gmx&&gmx.dataManager){this.add(clayer);}},_layerremove:function _layerremove(ev){var clayer=ev.layer,id=clayer._leaflet_id,gmx=clayer._gmx;if(gmx&&gmx.dataManager&&this._observers[id]){gmx.dataManager.removeObserver(this._observers[id].id);delete this._observers[id];delete this._styleManagers[id];delete this._labels['_'+id];delete this._labelsIndex['_'+id];this.redraw();}},redraw:function redraw(){if(!this._frame&&this.__map&&!this.__map._animating){this._frame=L.Util.requestAnimFrame(this._redraw,this);}return this;},_addToPane:function _addToPane(){var pane=this.__map.getPanes()[this.options.pane];if(pane){pane.insertBefore(this._canvas,pane.firstChild);}},onAdd:function onAdd(map){// this._map = map;
if(!this._canvas){this._initCanvas();}var arr=window.location.search.match('labels=([^&]+)');if(arr){this.options.labels=arr[1];}// this._addToPane();
map.on({moveend:this._reset,zoomstart:this._hideMe,layeradd:this._layeradd,layerremove:this._layerremove},this);this._reset();},_hideMe:function _hideMe(){this._canvas.style.visibility='hidden';},onRemove:function onRemove(map){if(this._canvas.parentNode){this._canvas.parentNode.removeChild(this._canvas);}map.off({moveend:this._reset,zoomstart:this._hideMe,layeradd:this._layeradd,layerremove:this._layerremove},this);},addTo:function addTo(map){map.addLayer(this);return this;},_initCanvas:function _initCanvas(){var canvas=L.DomUtil.create('canvas','leaflet-labels-layer leaflet-layer leaflet-zoom-hide'),size=this.__map.getSize();canvas.width=size.x;canvas.height=size.y;canvas.style.pointerEvents='none';this._canvas=canvas;},_updateBbox:function _updateBbox(){var _map=this.__map,screenBounds=_map.getBounds(),southWest=screenBounds.getSouthWest(),northEast=screenBounds.getNorthEast(),crs=_map.options.srs==3857?L.CRS.EPSG3857:L.Projection.Mercator,m1=crs.project(southWest),// Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°ÐµÐ¼ ÑÑÐ¾ Ð²ÑÐµ ÑÐ»Ð¾Ð¸ Ð² Ð¾Ð´Ð½Ð¾Ð¹ Ð¿ÑÐ¾ÐµÐºÑÐ¸Ð¸
m2=crs.project(northEast),_zoom=_map.getZoom();this.mInPixel=gmxAPIutils.getPixelScale(_zoom);this._ctxShift=[m1.x*this.mInPixel,m2.y*this.mInPixel];for(var id in this._observers){var observer=this._observers[id];if(observer.targetZoom){observer.targetZoom=_zoom;}observer.setBounds({min:{x:southWest.lng,y:southWest.lat},max:{x:northEast.lng,y:northEast.lat}});}},_reset:function _reset(){this._updateBbox();for(var id in this._observers){var observer=this._observers[id];if(!observer.isActive()&&this._styleManagers[id].isVisibleAtZoom(this.__map.getZoom())){observer.activate();}observer.fire('update');}setTimeout(function(){this._canvas.style.visibility='';}.bind(this),200);},_redraw:function _redraw(){var out=[],_map=this.__map;if(!_map||!_map._mapPane){return;}var mapSize=_map.getSize(),_canvas=this._canvas,chkIntersects=this.options.labels,offset=_map.latLngToContainerPoint(_map.getBounds().getNorthWest()),topLeft=_map.containerPointToLayerPoint(offset);_canvas.width=mapSize.x;_canvas.height=mapSize.y;L.DomUtil.setPosition(_canvas,topLeft);var w2=2*this.mInPixel*gmxAPIutils.worldWidthMerc,start=w2*Math.floor(_map.getPixelBounds().min.x/w2),ctx=_canvas.getContext('2d'),arr=Object.keys(this._labels).sort(function(a,b){return this._labelsIndex[b]-this._labelsIndex[a];}.bind(this)),i,len,it;arr.forEach(function(layerId){var labels=this._labels[layerId];for(var id in labels){it=labels[id];var options=it.options,label=options.label,style=label.style,labelAlign=style.labelAlign||'center',arrTxtWidth=label.arrTxtWidth,count=arrTxtWidth.length||1,width=label.width,width2=width/2,labelFontFamily=style.labelFontFamily||'Arial',size=style.labelFontSize||12,size2=size/2,center=options.center,pos=[center[0]*this.mInPixel,center[1]*this.mInPixel],isFiltered=false;if(label.isPoint){var delta=label.sx;if(labelAlign==='left'){pos[0]+=width2+delta;}else if(labelAlign==='right'){pos[0]-=width+delta;}}pos[0]-=width2+this._ctxShift[0];pos[1]=-size2-pos[1]+this._ctxShift[1];size2*=count;if(style.labelAnchor){pos[0]+=style.labelAnchor[0];pos[1]+=style.labelAnchor[1];}for(var tx=pos[0]+start;tx<mapSize.x;tx+=w2){var coord=[Math.floor(tx),Math.floor(pos[1])],bbox=gmxAPIutils.bounds([[coord[0],coord[1]-size2],[coord[0]+width,coord[1]+size2]]);if(chkIntersects!=='All'){for(i=0,len=out.length;i<len;i++){if(bbox.intersects(out[i].bbox)){isFiltered=true;break;}}if(isFiltered){continue;}}if(!options.labelStyle){options.labelStyle={font:size+'px "'+labelFontFamily+'"',//font: size + 'px "Arial"',
fillStyle:gmxAPIutils.dec2color(style.labelColor||0,1),shadowBlur:4};if(style.labelHaloColor!==-1){options.labelStyle.strokeStyle=options.labelStyle.shadowColor=gmxAPIutils.dec2color(style.labelHaloColor,1);}}out.push({arr:it.properties,bbox:bbox,arrTxtWidth:arrTxtWidth,width2:labelAlign==='center'?width2:0,txt:label.txt,style:options.labelStyle,size:size,coord:coord});}}}.bind(this));if(out.length){ctx.clearRect(0,0,_canvas.width,_canvas.height);for(i=0,len=out.length;i<len;i++){it=out[i];it.arrTxtWidth.forEach(function(pt,nm){var coord=[it.coord[0],it.coord[1]+(nm+1)*it.size];gmxAPIutils.setLabel(ctx,pt[0],coord,it.style);});}if(!_canvas.parentNode){this._addToPane();}}else if(_canvas.parentNode){_canvas.parentNode.removeChild(_canvas);}this._frame=null;},_animateZoom:function _animateZoom(e){var scale=this.__map.getZoomScale(e.zoom),offset=this.__map._latLngBoundsToNewLayerBounds(this.__map.getBounds(),e.zoom,e.center).min;L.DomUtil.setTransform(this._canvas,offset,scale);}});L.labelsLayer=function(map,options){return new L.LabelsLayer(map,options);};L.Map.addInitHook(function(){// Check to see if Labels has already been initialized.
if(!this._labelsLayer){this._labelsLayer=new L.LabelsLayer(this,this.options);this._labelsLayer.addTo(this);}});(function(){var isBoundsIntersects=function isBoundsIntersects(bounds,clipPolygons){for(var key in clipPolygons){var arr=clipPolygons[key];for(var i=0,len=arr.length;i<len;i++){var it=arr[i],type=it.geometry.type,boundsArr=it.boundsArr;for(var j=0,len1=boundsArr.length;j<len1;j++){var bbox=boundsArr[j];if(type==='Polygon'){bbox=[bbox];}for(var j1=0,len2=bbox.length;j1<len2;j1++){if(bbox[j1].intersects(bounds)){return true;}}}}}return false;};var isObserverIntersects=function isObserverIntersects(observer,clipPolygons){for(var key in clipPolygons){var arr=clipPolygons[key];for(var i=0,len=arr.length;i<len;i++){var it=arr[i],type=it.geometry.type,boundsArr=it.boundsArr;for(var j=0,len1=boundsArr.length;j<len1;j++){var bbox=boundsArr[j];if(type==='Polygon'){bbox=[bbox];}for(var j1=0,len2=bbox.length;j1<len2;j1++){if(observer.intersects(bbox[j1])){return true;}}}}}return false;};var _isPointInClipPolygons=function isPointInClipPolygons(chkPoint,clipPolygons){if(!clipPolygons||Object.keys(clipPolygons).length===0){return true;}for(var key in clipPolygons){var arr=clipPolygons[key];for(var i=0,len=arr.length;i<len;i++){var it=arr[i],type=it.geometry.type,boundsArr=it.boundsArr;for(var j=0,len1=boundsArr.length;j<len1;j++){var bbox=boundsArr[j];if(type==='Polygon'){bbox=[bbox];}for(var j1=0,len2=bbox.length;j1<len2;j1++){if(bbox[j1].contains(chkPoint)){var coords=it.geometry.coordinates,isIn=false;if(type==='Polygon'){coords=[coords];}for(var j2=0,len3=coords.length;j2<len3;j2++){if(gmxAPIutils.isPointInPolygonWithHoles(chkPoint,coords[j2])){isIn=true;break;}}if(isIn){return true;}}}}}}return false;};var getClipPolygonItem=function getClipPolygonItem(geo){var geometry=gmxAPIutils.convertGeometry(geo,false,true),// Ð²ÑÐµ Ð² 3857
bboxArr=gmxAPIutils.geoItemBounds(geometry);bboxArr.geometry=geometry;return bboxArr;};var clipTileByPolygon=function clipTileByPolygon(dattr){var canvas=document.createElement('canvas');canvas.width=canvas.height=256;var ctx=canvas.getContext('2d'),clipPolygons=dattr.clipPolygons;dattr.ctx=ctx;ctx.fillStyle=ctx.createPattern(dattr.tile,'no-repeat');for(var key in clipPolygons){var arr=clipPolygons[key];for(var i=0,len=arr.length;i<len;i++){var geo=arr[i].geometry,coords=geo.coordinates;if(geo.type==='Polygon'){coords=[coords];}for(var i1=0,len1=coords.length;i1<len1;i1++){var coords1=coords[i1];ctx.beginPath();for(var j1=0,len2=coords1.length;j1<len2;j1++){dattr.coords=coords1[j1];var pixels=gmxAPIutils.getRingPixels(dattr);dattr.coords=pixels.coords;gmxAPIutils.polygonToCanvasFill(dattr);}ctx.closePath();ctx.fill();}}}ctx=dattr.tile.getContext('2d');ctx.clearRect(0,0,256,256);ctx.drawImage(canvas,0,0);};L.gmx.VectorLayer.include({isPointInClipPolygons:function isPointInClipPolygons(point){// point [x, y] in Mercator
return _isPointInClipPolygons(point,this._gmx._clipPolygons);},addClipPolygon:function addClipPolygon(polygon){// (L.Polygon) or (L.GeoJSON with Polygons)
var item=[],i,len;if('coordinates'in polygon&&'type'in polygon){item.push(getClipPolygonItem(polygon));}else if(polygon instanceof L.Polygon){item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));}else if(polygon instanceof L.GeoJSON){var layers=polygon.getLayers();for(i=0,len=layers.length;i<len;i++){var layer=layers[i];if(layer instanceof L.Polygon&&layer.feature){item.push(getClipPolygonItem(layer.feature.geometry));}else if(layer instanceof L.MultiPolygon&&layer.feature){item.push(getClipPolygonItem(layer.feature.geometry));}}}if(item.length){var gmx=this._gmx,dataManager=gmx.dataManager,_this=this,id=L.stamp(polygon);if(!this._gmx._clipPolygons){this._gmx._clipPolygons={};}this._gmx._clipPolygons[id]=item;dataManager.setTileFilteringHook(function(tile){return isBoundsIntersects(tile.bounds,_this._gmx._clipPolygons);});dataManager.addFilter('clipFilter',function(item,tile,observer){return isObserverIntersects(observer,_this._gmx._clipPolygons);});dataManager.addFilter('clipPointsFilter',function(item){if(item.type==='POINT'){var propArr=item.properties,geom=propArr[propArr.length-1];return _isPointInClipPolygons(geom.coordinates,_this._gmx._clipPolygons);}return true;});if(Object.keys(this._gmx._clipPolygons).length===1){gmx.renderHooks.unshift(function(tile,hookInfo){if(tile&&Object.keys(_this._gmx._clipPolygons).length>0){clipTileByPolygon({tile:tile,topLeft:hookInfo.topLeft,tpx:hookInfo.tpx,tpy:hookInfo.tpy,gmx:{mInPixel:gmx.mInPixel},clipPolygons:_this._gmx._clipPolygons});}});}}return this;},removeClipPolygon:function removeClipPolygon(polygon){var id=L.stamp(polygon);if(this._gmx._clipPolygons){delete this._gmx._clipPolygons[id];if(Object.keys(this._gmx._clipPolygons).length===0){this._gmx.dataManager.removeTileFilteringHook();this._gmx.dataManager.removeFilter('clipFilter');}}return this;}});})();L.gmx.gmxImageTransform=function(img,hash){var gmx=hash.gmx,topLeft=hash.topLeft,mInPixel=topLeft.mInPixel,gmxTilePoint=hash.gmxTilePoint,geoItem=hash.geoItem,properties=geoItem.properties,dataOption=geoItem.dataOption||{},// geom = properties[properties.length - 1],
// coord = geom.coordinates[0],
indexes=gmx.tileAttributeIndexes,quicklookPlatform=properties[indexes[gmx.quicklookPlatform]]||gmx.quicklookPlatform||'',points={};// if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }
if(quicklookPlatform==='LANDSAT8'){points.x1=dataOption.bounds.min.x;points.y1=dataOption.bounds.max.y;points.x2=dataOption.bounds.max.x;points.y2=dataOption.bounds.max.y;points.x3=dataOption.bounds.max.x;points.y3=dataOption.bounds.min.y;points.x4=dataOption.bounds.min.x;points.y4=dataOption.bounds.min.y;}else {points=gmxAPIutils.getQuicklookPointsFromProperties(properties,gmx);}var x1=mInPixel*points.x1,y1=mInPixel*points.y1,x2=mInPixel*points.x2,y2=mInPixel*points.y2,x3=mInPixel*points.x3,y3=mInPixel*points.y3,x4=mInPixel*points.x4,y4=mInPixel*points.y4,boundsP=gmxAPIutils.bounds([[x1,y1],[x2,y2],[x3,y3],[x4,y4]]),ww=Math.round(boundsP.max.x-boundsP.min.x),hh=Math.round(boundsP.max.y-boundsP.min.y),dy=256-boundsP.max.y+256*gmxTilePoint.y,itbounds=geoItem.item.bounds,wMerc=Number(gmxAPIutils.worldWidthMerc.toFixed(2)),tpx=gmxTilePoint.x;if(tpx<0&&itbounds.max.x>=wMerc&&itbounds.min.x<=-wMerc){// For points intersects 180 deg
tpx+=Math.round(wMerc*mInPixel/128);}var dx=boundsP.min.x-256*tpx;x1-=boundsP.min.x;y1=boundsP.max.y-y1;x2-=boundsP.min.x;y2=boundsP.max.y-y2;x3-=boundsP.min.x;y3=boundsP.max.y-y3;x4-=boundsP.min.x;y4=boundsP.max.y-y4;var shiftPoints=[[x1,y1],[x2,y2],[x3,y3],[x4,y4]];if(!gmx.ProjectiveImage){gmx.ProjectiveImage=(gmx.useWebGL?L.gmx.projectiveImageWebGL():null)||L.gmx.projectiveImage();}var pt=gmx.ProjectiveImage.getCanvas({imageObj:img,points:shiftPoints,wView:ww,hView:hh,deltaX:dx,deltaY:dy});return pt.canvas;};// `Float32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor$1('Float32',function(init){return function Float32Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});(function(){var ProjectiveImageWebGL=L.Class.extend({options:{antialias:true,depth:false,preserveDrawingBuffer:true,shaderVS:'attribute vec2 aVertCoord;\
            uniform mat4 uTransformMatrix;\
            varying vec2 vTextureCoord;\
            void main(void) {\
                vTextureCoord = aVertCoord;\
                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\
            }\
        ',shaderFS:'precision mediump float;\
            varying vec2 vTextureCoord;\
            uniform sampler2D uSampler;\
            void main(void) {\
                gl_FragColor = texture2D(uSampler, vTextureCoord);\
            }\
        '},setOptions:function setOptions(options){L.setOptions(this,options);},initialize:function initialize(options){this.setOptions(options);var canvas=document.createElement('canvas'),glOpts={antialias:this.options.antialias,depth:this.options.depth,preserveDrawingBuffer:this.options.preserveDrawingBuffer},gl=canvas.getContext('webgl',glOpts)||canvas.getContext('experimental-webgl',glOpts);if(!gl){return;}var glResources=this._setupGlContext(gl);if(!glResources){return;}canvas.width=canvas.height=256;glResources.canvas=canvas;this.glResources=glResources;this.canvas=canvas;this.gl=gl;},_getShader:function _getShader(type,source,gl){var shader=gl.createShader(type);gl.shaderSource(shader,source);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){gl.deleteShader(shader);return null;}return shader;},_setupGlContext:function _setupGlContext(gl){// Store return values here
var vertexShader=this._getShader(gl.VERTEX_SHADER,this.options.shaderVS,gl),fragmentShader=this._getShader(gl.FRAGMENT_SHADER,this.options.shaderFS,gl);if(vertexShader&&fragmentShader){// Compile the program
var shaderProgram=gl.createProgram();gl.attachShader(shaderProgram,vertexShader);gl.attachShader(shaderProgram,fragmentShader);gl.linkProgram(shaderProgram);if(gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){// Find and set up the uniforms and attributes
gl.useProgram(shaderProgram);this.vertices=new Float32Array([0,0,1,0,0,1,1,1]);var vertexBuffer=gl.createBuffer(),// Create a buffer to hold the vertices
vertAttrib=gl.getAttribLocation(shaderProgram,'aVertCoord');gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(this.vertices),gl.STATIC_DRAW);// draw the triangles
gl.enableVertexAttribArray(vertAttrib);gl.vertexAttribPointer(vertAttrib,2,gl.FLOAT,false,0,0);return {transMatUniform:gl.getUniformLocation(shaderProgram,'uTransformMatrix'),samplerUniform:gl.getUniformLocation(shaderProgram,'uSampler'),screenTexture:gl.createTexture()// Create a texture to use for the screen image
};}}return null;},_bindTexture:function _bindTexture(gl,image,texture){gl.bindTexture(gl.TEXTURE_2D,texture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);// gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);// Prevents s-coordinate wrapping (repeating).
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);// Prevents t-coordinate wrapping (repeating).
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.bindTexture(gl.TEXTURE_2D,null);},getCanvas:function getCanvas(attr){var p=attr.points,deltaX=attr.deltaX,deltaY=attr.deltaY,dstPoints=new Float32Array([(p[0][0]+deltaX)/128-1,1-(p[0][1]+deltaY)/128,(p[1][0]+deltaX)/128-1,1-(p[1][1]+deltaY)/128,(p[3][0]+deltaX)/128-1,1-(p[3][1]+deltaY)/128,(p[2][0]+deltaX)/128-1,1-(p[2][1]+deltaY)/128]);var v=ProjectiveImageWebGL.Utils.general2DProjection(this.vertices,dstPoints),gl=this.gl,glResources=this.glResources;this._bindTexture(gl,attr.imageObj,glResources.screenTexture);gl.viewport(0,0,256,256);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);// set background to full transparency
gl.uniformMatrix4fv(glResources.transMatUniform,false,[v[0],v[3],0,v[6],v[1],v[4],0,v[7],0,0,1,0,v[2],v[5],0,1]);gl.activeTexture(gl.TEXTURE0);gl.bindTexture(gl.TEXTURE_2D,glResources.screenTexture);gl.uniform1i(glResources.samplerUniform,0);gl.drawArrays(gl.TRIANGLE_STRIP,0,4);return this;}});function adj(m){// Compute the adjugate of m
return [m[4]*m[8]-m[5]*m[7],m[2]*m[7]-m[1]*m[8],m[1]*m[5]-m[2]*m[4],m[5]*m[6]-m[3]*m[8],m[0]*m[8]-m[2]*m[6],m[2]*m[3]-m[0]*m[5],m[3]*m[7]-m[4]*m[6],m[1]*m[6]-m[0]*m[7],m[0]*m[4]-m[1]*m[3]];}function multmm(a,b){// multiply two matrices
var c=Array(9);for(var i=0;i!==3;++i){for(var j=0;j!==3;++j){var cij=0;for(var k=0;k!==3;++k){cij+=a[3*i+k]*b[3*k+j];}c[3*i+j]=cij;}}return c;}function multmv(m,v){// multiply matrix and vector
return [m[0]*v[0]+m[1]*v[1]+m[2]*v[2],m[3]*v[0]+m[4]*v[1]+m[5]*v[2],m[6]*v[0]+m[7]*v[1]+m[8]*v[2]];}function basisToPoints(p){var m=[p[0],p[2],p[4],p[1],p[3],p[5],1,1,1];var v=multmv(adj(m),[p[6],p[7],1]);return multmm(m,[v[0],0,0,0,v[1],0,0,0,v[2]]);}ProjectiveImageWebGL.Utils={general2DProjection:function general2DProjection(from,to){var arr=multmm(basisToPoints(to),adj(basisToPoints(from)));if(arr[8]){for(var i=0;i!==9;++i){arr[i]=arr[i]/arr[8];}}return arr;},getWebGlResources:function getWebGlResources(options){var obj=new ProjectiveImageWebGL(options);return obj.gl?obj:null;}};L.gmx.projectiveImageWebGL=function(options){var res=new ProjectiveImageWebGL(options);return res.gl?res:null;};})();(function(){// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.
var ProjectiveImage=function ProjectiveImage(){var cnt=0,limit=4,patchSize=64,transform=null;var allocate=function allocate(w,h){var values=[];for(var i=0;i<h;++i){values[i]=[];for(var j=0;j<w;++j){values[i][j]=0;}}return values;};var Matrix=function Matrix(w,h,values){this.w=w;this.h=h;this.values=values||allocate(h);};var cloneValues=function cloneValues(values){var clone=[];for(var i=0;i<values.length;++i){clone[i]=[].concat(values[i]);}return clone;};Matrix.prototype={add:function add(operand){if(operand.w!==this.w||operand.h!==this.h){throw new Error('Matrix add size mismatch');}var values=allocate(this.w,this.h);for(var y=0;y<this.h;++y){for(var x=0;x<this.w;++x){values[y][x]=this.values[y][x]+operand.values[y][x];}}return new Matrix(this.w,this.h,values);},transformProjectiveVector:function transformProjectiveVector(operand){var out=[],x,y;for(y=0;y<this.h;++y){out[y]=0;for(x=0;x<this.w;++x){out[y]+=this.values[y][x]*operand[x];}}var zn=out[out.length-1];if(zn){var iz=1/out[out.length-1];for(y=0;y<this.h;++y){out[y]*=iz;}}return out;},multiply:function multiply(operand){var values,x,y;if(+operand!==operand){// Matrix mult
if(operand.h!==this.w){throw new Error('Matrix mult size mismatch');}values=allocate(this.w,this.h);for(y=0;y<this.h;++y){for(x=0;x<operand.w;++x){var accum=0;for(var s=0;s<this.w;s++){accum+=this.values[y][s]*operand.values[s][x];}values[y][x]=accum;}}return new Matrix(operand.w,this.h,values);}else {// Scalar mult
values=allocate(this.w,this.h);for(y=0;y<this.h;++y){for(x=0;x<this.w;++x){values[y][x]=this.values[y][x]*operand;}}return new Matrix(this.w,this.h,values);}},rowEchelon:function rowEchelon(){if(this.w<=this.h){throw new Error('Matrix rowEchelon size mismatch');}var temp=cloneValues(this.values);// Do Gauss-Jordan algorithm.
for(var yp=0;yp<this.h;++yp){// Look up pivot value.
var pivot=temp[yp][yp];while(pivot===0){// If pivot is zero, find non-zero pivot below.
for(var ys=yp+1;ys<this.h;++ys){if(temp[ys][yp]!==0){// Swap rows.
var tmpRow=temp[ys];temp[ys]=temp[yp];temp[yp]=tmpRow;break;}}if(ys===this.h){// No suitable pivot found. Abort.
return new Matrix(this.w,this.h,temp);}else {pivot=temp[yp][yp];}}// Normalize this row.
var scale=1/pivot;for(var x=yp;x<this.w;++x){temp[yp][x]*=scale;}// Subtract this row from all other rows (scaled).
for(var y=0;y<this.h;++y){if(y===yp){continue;}var factor=temp[y][yp];temp[y][yp]=0;for(x=yp+1;x<this.w;++x){temp[y][x]-=factor*temp[yp][x];}}}return new Matrix(this.w,this.h,temp);},invert:function invert(){var x,y;if(this.w!==this.h){throw new Error('Matrix invert size mismatch');}var temp=allocate(this.w*2,this.h);// Initialize augmented matrix
for(y=0;y<this.h;++y){for(x=0;x<this.w;++x){temp[y][x]=this.values[y][x];temp[y][x+this.w]=x===y?1:0;}}temp=new Matrix(this.w*2,this.h,temp);temp=temp.rowEchelon();// Extract right block matrix.
var values=allocate(this.w,this.h);for(y=0;y<this.w;++y){// @todo check if "x < this.w;" is mistake
for(x=0;x<this.w;++x){values[y][x]=temp.values[y][x+this.w];}}return new Matrix(this.w,this.h,values);}};var getProjectiveTransform=function getProjectiveTransform(points){var eqMatrix=new Matrix(9,8,[[1,1,1,0,0,0,-points[2][0],-points[2][0],-points[2][0]],[0,1,1,0,0,0,0,-points[3][0],-points[3][0]],[1,0,1,0,0,0,-points[1][0],0,-points[1][0]],[0,0,1,0,0,0,0,0,-points[0][0]],[0,0,0,-1,-1,-1,points[2][1],points[2][1],points[2][1]],[0,0,0,0,-1,-1,0,points[3][1],points[3][1]],[0,0,0,-1,0,-1,points[1][1],0,points[1][1]],[0,0,0,0,0,-1,0,0,points[0][1]]]);var kernel=eqMatrix.rowEchelon().values;var transform=new Matrix(3,3,[[-kernel[0][8],-kernel[1][8],-kernel[2][8]],[-kernel[3][8],-kernel[4][8],-kernel[5][8]],[-kernel[6][8],-kernel[7][8],1]]);return transform;};var divide=function divide(u1,v1,u4,v4,p1,p2,p3,p4,limit,attr){if(limit){// Measure patch non-affinity.
var d1=[p2[0]+p3[0]-2*p1[0],p2[1]+p3[1]-2*p1[1]];var d2=[p2[0]+p3[0]-2*p4[0],p2[1]+p3[1]-2*p4[1]];var d3=[d1[0]+d2[0],d1[1]+d2[1]];var r=Math.abs((d3[0]*d3[0]+d3[1]*d3[1])/(d1[0]*d2[0]+d1[1]*d2[1]));// Measure patch area.
d1=[p2[0]-p1[0]+p4[0]-p3[0],p2[1]-p1[1]+p4[1]-p3[1]];d2=[p3[0]-p1[0]+p4[0]-p2[0],p3[1]-p1[1]+p4[1]-p2[1]];var area=Math.abs(d1[0]*d2[1]-d1[1]*d2[0]);// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)
// The non-affinity measure is used as a correction factor.
if(u1===0&&u4===1||(.25+r*5)*area>patchSize*patchSize){// Calculate subdivision points (middle, top, bottom, left, right).
var umid=(u1+u4)/2;var vmid=(v1+v4)/2;var pmid=transform.transformProjectiveVector([umid,vmid,1]);var pt=transform.transformProjectiveVector([umid,v1,1]);var pb=transform.transformProjectiveVector([umid,v4,1]);var pl=transform.transformProjectiveVector([u1,vmid,1]);var pr=transform.transformProjectiveVector([u4,vmid,1]);// Subdivide.
limit--;divide.call(this,u1,v1,umid,vmid,p1,pt,pl,pmid,limit,attr);divide.call(this,umid,v1,u4,vmid,pt,p2,pmid,pr,limit,attr);divide.call(this,u1,vmid,umid,v4,pl,pmid,p3,pb,limit,attr);divide.call(this,umid,vmid,u4,v4,pmid,pr,pb,p4,limit,attr);return;}}var ctx=attr.ctx;// Get patch edge vectors.
var d12=[p2[0]-p1[0],p2[1]-p1[1]];var d24=[p4[0]-p2[0],p4[1]-p2[1]];var d43=[p3[0]-p4[0],p3[1]-p4[1]];var d31=[p1[0]-p3[0],p1[1]-p3[1]];// Find the corner that encloses the most area
var a1=Math.abs(d12[0]*d31[1]-d12[1]*d31[0]);var a2=Math.abs(d24[0]*d12[1]-d24[1]*d12[0]);var a4=Math.abs(d43[0]*d24[1]-d43[1]*d24[0]);var a3=Math.abs(d31[0]*d43[1]-d31[1]*d43[0]);var amax=Math.max(Math.max(a1,a2),Math.max(a3,a4));var dx=0,dy=0,padx=0,pady=0;// Align the transform along this corner.
// Calculate 1.05 pixel padding on vector basis.
if(amax===a1){ctx.setTransform(d12[0],d12[1],-d31[0],-d31[1],p1[0]+attr.deltaX,p1[1]+attr.deltaY);if(u4!==1){padx=1.05/Math.sqrt(d12[0]*d12[0]+d12[1]*d12[1]);}if(v4!==1){pady=1.05/Math.sqrt(d31[0]*d31[0]+d31[1]*d31[1]);}}else if(amax===a2){ctx.setTransform(d12[0],d12[1],d24[0],d24[1],p2[0]+attr.deltaX,p2[1]+attr.deltaY);if(u4!==1){padx=1.05/Math.sqrt(d12[0]*d12[0]+d12[1]*d12[1]);}if(v4!==1){pady=1.05/Math.sqrt(d24[0]*d24[0]+d24[1]*d24[1]);}dx=-1;}else if(amax===a4){ctx.setTransform(-d43[0],-d43[1],d24[0],d24[1],p4[0]+attr.deltaX,p4[1]+attr.deltaY);if(u4!==1){padx=1.05/Math.sqrt(d43[0]*d43[0]+d43[1]*d43[1]);}if(v4!==1){pady=1.05/Math.sqrt(d24[0]*d24[0]+d24[1]*d24[1]);}dx=-1;dy=-1;}else if(amax===a3){ctx.setTransform(-d43[0],-d43[1],-d31[0],-d31[1],p3[0]+attr.deltaX,p3[1]+attr.deltaY);if(u4!==1){padx=1.05/Math.sqrt(d43[0]*d43[0]+d43[1]*d43[1]);}if(v4!==1){pady=1.05/Math.sqrt(d31[0]*d31[0]+d31[1]*d31[1]);}dy=-1;}// Calculate image padding to match.
var du=u4-u1;var dv=v4-v1;padx++;pady++;var iw=attr.imageObj.width,ih=attr.imageObj.height,sx=Math.floor(u1*iw),sy=Math.floor(v1*ih),sw=Math.floor(Math.min(padx*du,1)*iw),sh=Math.floor(Math.min(pady*dv,1)*ih);cnt++;ctx.drawImage(attr.imageObj,sx,sy,sw,sh,dx,dy,padx,pady);};this.getCanvas=function(attr){cnt=0;transform=getProjectiveTransform(attr.points);// Begin subdivision process.
var ptl=transform.transformProjectiveVector([0,0,1]),ptr=transform.transformProjectiveVector([1,0,1]),pbl=transform.transformProjectiveVector([0,1,1]),pbr=transform.transformProjectiveVector([1,1,1]);var canvas=document.createElement('canvas');canvas.width=canvas.height=256;attr.canvas=canvas;attr.ctx=canvas.getContext('2d');var boundsP=gmxAPIutils.bounds([ptl,ptr,pbr,pbl]),maxSize=Math.max(boundsP.max.x-boundsP.min.x,boundsP.max.y-boundsP.min.y);limit='limit'in attr?attr.limit:maxSize<200?1:4;patchSize='patchSize'in attr?attr.patchSize:maxSize/8;try{divide(0,0,1,1,ptl,ptr,pbl,pbr,limit,attr);}catch(e){console.log('Error: ProjectiveImage event:',e);canvas=null;}return {canvas:canvas,ptl:ptl,ptr:ptr,pbl:pbl,pbr:pbr,cnt:cnt};};};L.gmx.projectiveImage=function(){return new ProjectiveImage();};})();// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js
L.RotatedMarker=L.Marker.extend({options:{angle:0},statics:{TRANSFORM_ORIGIN:L.DomUtil.testProp(['transformOrigin','WebkitTransformOrigin','OTransformOrigin','MozTransformOrigin','msTransformOrigin'])},_initIcon:function _initIcon(){L.Marker.prototype._initIcon.call(this);this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN]=this._getTransformOrigin();},_getTransformOrigin:function _getTransformOrigin(){var iconAnchor=this.options.icon.options.iconAnchor;if(!iconAnchor){return '50% 50%';}return iconAnchor[0]+'px '+iconAnchor[1]+'px';},_setPos:function _setPos(pos){L.Marker.prototype._setPos.call(this,pos);if(L.DomUtil.TRANSFORM){// use the CSS transform rule if available
this._icon.style[L.DomUtil.TRANSFORM]+=' rotate('+this.options.angle+'deg)';}else if(L.Browser.ie){// fallback for IE6, IE7, IE8
var rad=this.options.angle*(Math.PI/180),costheta=Math.cos(rad),sintheta=Math.sin(rad);this._icon.style.filter+=' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\'auto expand\', M11='+costheta+', M12='+-sintheta+', M21='+sintheta+', M22='+costheta+')';}},setAngle:function setAngle(ang){this.options.angle=ang;}});L.rotatedMarker=function(pos,options){return new L.RotatedMarker(pos,options);};L.gmx.ExternalLayer=L.Class.extend({createExternalLayer:function createExternalLayer(){// extend: must return <ILayer> or null = this.externalLayer
return null;},isExternalVisible:function isExternalVisible()/*zoom*/{// extend: return true view this.externalLayer, return false view this.parentLayer
return true;},updateData:function updateData()/*data*/{// extend: for data update in this.externalLayer
},setDateInterval:function setDateInterval(){if(this._observer){var gmx=this.parentLayer._gmx;this._observer.setDateInterval(gmx.beginDate,gmx.endDate);}},options:{useDataManager:true,observerOptions:{delta:0,filters:['clipFilter','userFilter','clipPointsFilter']}},initialize:function initialize(options,layer){L.setOptions(this,options);this.parentLayer=layer;layer.on('add',this._addEvent,this).on('dateIntervalChanged',this.setDateInterval,this);if(this.options.useDataManager){this._addObserver(this.options.observerOptions);}this.externalLayer=this.createExternalLayer();if(layer._map){this._addEvent({target:{_map:layer._map}});this._updateBbox();}},_addObserver:function _addObserver(opt){this._items={};this._observer=this.parentLayer.addObserver(L.extend({bbox:gmxAPIutils.bounds([[Number.MAX_VALUE,Number.MAX_VALUE]]),callback:L.bind(this.updateData,this)},opt)).deactivate();},unbindLayer:function unbindLayer(){this.parentLayer.off('add',this._addEvent,this).off('dateIntervalChanged',this.setDateInterval,this);if(this._observer){delete this.parentLayer.repaintObservers[this._observer.id];}var map=this._map||this.parentLayer._map;this._onRemove(!map);this._removeMapHandlers();},_addMapHandlers:function _addMapHandlers(map){if(map){this._map=map;this._map.on({moveend:this._updateBbox,zoomend:this._chkZoom,layeradd:this._layeradd,layerremove:this._layerremove},this);}},_removeMapHandlers:function _removeMapHandlers(){if(this._map){this._map.off({moveend:this._updateBbox,zoomend:this._chkZoom,layeradd:this._layeradd,layerremove:this._layerremove},this);}this._map=null;},_addEvent:function _addEvent(ev){this._addMapHandlers(ev.target._map);this._updateBbox();this._chkZoom();},_isParentLayer:function _isParentLayer(ev){var layer=ev.layer;return layer._gmx&&layer._gmx.layerID===this.parentLayer.options.layerID;},_layeradd:function _layeradd(ev){if(this._isParentLayer(ev)){this._chkZoom();}},_layerremove:function _layerremove(ev){if(this._isParentLayer(ev)){this._onRemove(true);this._removeMapHandlers();}},_onRemove:function _onRemove(fromMapFlag){// remove external layer from parent layer
if(this._observer){this._observer.deactivate();}var map=this._map;if(map){if(map.hasLayer(this.externalLayer)){this._chkZoom();map.removeLayer(this.externalLayer);}if(!fromMapFlag){this.parentLayer.onAdd(map);}}},_chkZoom:function _chkZoom(){if(!this._map){return;}var layer=this.parentLayer,observer=this._observer,map=this._map,isExtLayerOnMap=map.hasLayer(this.externalLayer);if(layer.setCurrentZoom){layer.setCurrentZoom(map);}if(!this.isExternalVisible(map.getZoom())){if(observer){observer.deactivate();}if(!layer._map){if(isExtLayerOnMap){map.removeLayer(this.externalLayer);}layer.onAdd(map);}layer.enablePopup();}else if(layer._map){layer.onRemove(map);if(!isExtLayerOnMap){map.addLayer(this.externalLayer);}this.setDateInterval();if(observer){layer.getIcons(function(){observer.activate();}.bind(this));}layer.disablePopup();}},_updateBbox:function _updateBbox(){if(!this._map||!this._observer){return;}var map=this._map,screenBounds=map.getBounds(),p1=screenBounds.getNorthWest(),p2=screenBounds.getSouthEast(),bbox=L.gmxUtil.bounds([[p1.lng,p1.lat],[p2.lng,p2.lat]]),delta=this.options.observerOptions.delta,buffer=delta?delta*L.gmxUtil.tileSizes[map.getZoom()]/256:0;this._observer.setBounds(bbox,buffer);}});(function(){var BindWMS=L.gmx.ExternalLayer.extend({options:{minZoom:1,maxZoom:6,useDataManager:false,format:'png',transparent:true},createExternalLayer:function createExternalLayer(){var poptions=this.parentLayer.options,opt={map:poptions.mapID,layers:poptions.layerID,format:this.options.format,transparent:this.options.transparent},rawProperties=this.parentLayer.getGmxProperties();if(rawProperties&&rawProperties.Temporal){this._extendOptionsByDateInterval(opt);}if(this.options.apikey){opt.apikey=this.options.apikey;}return L.tileLayer.wms(L.gmxUtil.protocol+'//'+poptions.hostName+'/TileService.ashx',opt);},_extendOptionsByDateInterval:function _extendOptionsByDateInterval(options){var dateInterval=this.parentLayer.getDateInterval(),beginDate=dateInterval.beginDate,endDate=dateInterval.endDate;L.extend(options,{StartDate:beginDate&&beginDate.toLocaleDateString(),EndDate:endDate&&endDate.toLocaleDateString()});},setDateInterval:function setDateInterval(){this._extendOptionsByDateInterval(this.externalLayer.wmsParams);this.externalLayer.redraw();},isExternalVisible:function isExternalVisible(zoom){return !(zoom<this.options.minZoom||zoom>this.options.maxZoom);}});L.gmx.VectorLayer.include({bindWMS:function bindWMS(options){if(this._layerWMS){this._layerWMS.unbindLayer();}this._layerWMS=new BindWMS(options,this);this.isExternalVisible=this._layerWMS.isExternalVisible;return this;},unbindWMS:function unbindWMS(){if(this._layerWMS){this._layerWMS.unbindLayer();this._layerWMS=null;this.isExternalVisible=null;this.enablePopup();}return this;}});})();(function(){var GmxHeatMap=L.gmx.ExternalLayer.extend({options:{minHeatMapZoom:1,maxHeatMapZoom:6,intensityField:'',intensityScale:1,observerOptions:{type:'resend'}},createExternalLayer:function createExternalLayer(){return L.heatLayer([],L.extend({// minOpacity: 0.05,
// maxZoom: 18,
// radius: 25,
// blur: 15,
// max: 1.0
},this.options));},isExternalVisible:function isExternalVisible(zoom){return !(zoom<this.options.minHeatMapZoom||zoom>this.options.maxHeatMapZoom);},updateData:function updateData(data){if(data.added){var latlngs=[],indexes=this.parentLayer.getTileAttributeIndexes(),altIndex=null,intensityField=this.options.intensityField||'',intensityScale=this.options.intensityScale||1;if(intensityField&&intensityField in indexes){altIndex=indexes[intensityField];}for(var i=0,len=data.added.length;i<len;i++){var it=data.added[i].properties,alt=altIndex!==null?it[altIndex]:1,geo=it[it.length-1],coord=geo.coordinates,point=L.Projection.Mercator.unproject({x:coord[0],y:coord[1]});latlngs.push([point.lat,point.lng,typeof intensityScale==='function'?intensityScale(alt):intensityScale*alt]);}this.externalLayer.setLatLngs(latlngs);}}});L.gmx.VectorLayer.include({bindHeatMap:function bindHeatMap(options){if(L.heatLayer){if(this._heatmap){this._heatmap.unbindLayer();}this._heatmap=new GmxHeatMap(options,this);}return this;},unbindHeatMap:function unbindHeatMap(){if(L.heatLayer){if(this._heatmap){this._heatmap.unbindLayer();this._heatmap=null;this.enablePopup();}}return this;}});})();(function(){var _DEFAULTS={radiusFunc:function radiusFunc(count){var r=Math.floor(count/15);if(r>40){r=40;}else if(r<20){r=20;}return r;},text:{stroke:'black','stroke-width':1,'text-anchor':'middle',fill:'white'}};var GmxMarkerCluster=L.gmx.ExternalLayer.extend({options:{observerOptions:{delta:256,filters:['clipFilter','styleFilter','userFilter','clipPointsFilter']},spiderfyOnMaxZoom:true,animate:false,minZoom:1,maxZoom:6},createExternalLayer:function createExternalLayer(){var mOptions=L.extend({showCoverageOnHover:false,disableClusteringAtZoom:1+Number(this.options.maxZoom)},this.options);if('clusterIconOptions'in this.options){var opt=this.options.clusterIconOptions;if('radialGradient'in opt){var radialGradient=opt.radialGradient,text=opt.text||_DEFAULTS.text;mOptions.iconCreateFunction=function(cluster){var childCount=cluster.getChildCount();text.count=childCount;return L.gmxUtil.getSVGIcon({type:'circle',iconSize:2*(radialGradient.radiusFunc||_DEFAULTS.radiusFunc)(childCount),text:text,fillRadialGradient:radialGradient});};}}if(this.options.clusterclick){mOptions.clusterclick=this.options.clusterclick;if(mOptions.clusterclick===true){mOptions.zoomToBoundsOnClick=false;}}this._popup=new L.Popup({maxWidth:10000,className:'gmxPopup'});var markers=new L.MarkerClusterGroup(mOptions);// ÑÐµÐºÑÑÐ¸Ð¹ ÑÐ°Ð·Ð²ÑÑÐ½ÑÑÑÐ¹ ÐºÐ»Ð°ÑÑÐµÑ
var currentSpiderfiedCluster=null;markers.on('click',function(ev){var propsArr=ev.layer.options.properties,properties=this.parentLayer.getItemProperties(propsArr),geometry=[propsArr[propsArr.length-1]],id=propsArr[0];if(currentSpiderfiedCluster&&!(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer)+1)){currentSpiderfiedCluster.unspiderfy();markers.once('unspiderfied',function(){this._openPopup(propsArr,ev.latlng);},this);}else {this._openPopup(propsArr,ev.latlng);}this.parentLayer.fire('click',L.extend(ev,{eventFrom:'markerClusters',originalEventType:'click',gmx:{id:id,layer:this.parentLayer,properties:properties,target:{id:id,properties:propsArr,geometry:geometry}}}));},this).on('animationend',function(){if(this._popup&&this._popup._map){this._popup._map.removeLayer(this._popup);}},this).on('clusterclick',function(ev){this.parentLayer.fire('clusterclick',L.extend(ev,{eventFrom:'markerClusters',originalEventType:'clusterclick'}));},this).on('spiderfied',function(ev){currentSpiderfiedCluster=ev.cluster;},this).on('unspiderfied',function(){currentSpiderfiedCluster=null;},this);if(mOptions.clusterclick){markers.on('clusterclick',mOptions.clusterclick instanceof Function?mOptions.clusterclick:function(a){a.layer.spiderfy();});}return markers;},isExternalVisible:function isExternalVisible(zoom){return !(zoom<this.options.minZoom||zoom>this.options.maxZoom);},updateData:function updateData(data){var arr=[],i,len,vectorTileItem,id,marker;if(data.removed){for(i=0,len=data.removed.length;i<len;i++){vectorTileItem=data.removed[i];id=vectorTileItem.id;marker=this._items[id];if(marker){arr.push(marker);}delete this._items[id];}this.externalLayer.removeLayers(arr);arr=[];}if(data.added){var tilesCRS=this.parentLayer.options.tilesCRS||L.Projection.Mercator;for(i=0,len=data.added.length;i<len;i++){vectorTileItem=data.added[i];id=vectorTileItem.id;marker=this._items[id];var item=vectorTileItem.properties;if(marker&&item.processing){this.externalLayer.removeLayer(marker);marker=null;}if(!marker){if(!vectorTileItem.item.parsedStyleKeys){vectorTileItem.item.parsedStyleKeys=this.parentLayer.getItemStyle(id);}var geo=item[item.length-1],parsedStyle=vectorTileItem.item.parsedStyleKeys,p=geo.coordinates,latlng=tilesCRS.unproject({x:p[0],y:p[1]}),opt={properties:vectorTileItem.properties,mPoint:p};if(this.options.notClusteredIcon){var icon=this.options.notClusteredIcon;if(icon instanceof L.Icon){opt.icon=icon;}else {opt.icon=L.icon(icon);}}else if(parsedStyle){if(parsedStyle.iconUrl){var iconAnchor=parsedStyle.iconAnchor;if(!iconAnchor){var style=this.parentLayer.getItemStyle(id);iconAnchor=style.image?[style.sx/2,style.sy/2]:[8,10];}opt.icon=L.icon({iconAnchor:iconAnchor,iconUrl:parsedStyle.iconUrl});}else {opt.icon=L.gmxUtil.getSVGIcon(parsedStyle);}}if(parsedStyle.rotate){marker=L.rotatedMarker(latlng,L.extend(opt,{angle:parsedStyle.rotate}));}else {marker=L.marker(latlng,L.extend(opt,{angle:parsedStyle.rotate}));}this._items[id]=marker;}arr.push(marker);}this.externalLayer.addLayers(arr);}},_openPopup:function _openPopup(propsArr,latlng){var gmx=this.parentLayer._gmx,id=propsArr[0],balloonData=gmx.styleManager.getItemBalloon(id),properties=this.parentLayer.getItemProperties(propsArr),geometry=[propsArr[propsArr.length-1]];if(balloonData&&!balloonData.DisableBalloonOnClick){var style=this.parentLayer.getItemStyle(id);if(style&&style.iconAnchor){var protoOffset=L.Popup.prototype.options.offset;this._popup.options.offset=[-protoOffset[0]-style.iconAnchor[0]+style.sx/2,protoOffset[1]-style.iconAnchor[1]+style.sy/2];}if(this.parentLayer._balloonHook){for(var key in this.parentLayer._balloonHook){properties[key]=L.gmxUtil.parseTemplate(this.parentLayer._balloonHook[key].resStr,properties);}}var content=L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon,{properties:properties,tileAttributeTypes:gmx.tileAttributeTypes,unitOptions:this._map.options||{},geometries:geometry});var contentDiv=L.DomUtil.create('div','');contentDiv.innerHTML=content;this._popup.setLatLng(latlng).setContent(contentDiv).openOn(this._map);if(this.parentLayer._balloonHook){this.parentLayer._callBalloonHook(properties,this._popup.getContent());}}}});L.gmx.VectorLayer.include({bindClusters:function bindClusters(options){if(L.MarkerClusterGroup){if(this._clusters){this._clusters.unbindLayer();}this._clusters=new GmxMarkerCluster(options,this);}return this;},unbindClusters:function unbindClusters(){if(L.MarkerClusterGroup){if(this._clusters){this._clusters.unbindLayer();this._clusters=null;this.enablePopup();}}return this;}});})();(function(){var GmxGridCluster=L.Evented.extend({options:{skipItems:true,pixelDelta:0,styleHook:function styleHook(ctx){ctx.setLineDash([2,4]);// var zn = Math.floor(255 * (1 - it.count / maxCount));
// ctx.fillStyle = 'rgb(' + zn + ',255, ' + zn + ', 0.2)';
},// style: {
// setLineDash: [5, 15]
// },
minZoom:1,maxZoom:6},_layer:null,_markers:null,initialize:function initialize(options,layer){this._layer=layer;options=L.Util.setOptions(this,options);this._markers=new L.FeatureGroup(options);this._layer.on('load',this.checkLoad,this);},checkLoad:function checkLoad(){var tiles=this._layer._tiles,maxCount=0,count=0;for(var key in tiles){var pt=tiles[key];if(pt.count){count+=pt.count;}if(pt._gridData){pt._gridData.forEach(function(it){if(it.count){maxCount=Math.max(maxCount,it.count);}});}}if(count){this._drawMe(maxCount,count);}},_drawMe:function _drawMe(maxCount){var tiles=this._layer._tiles,ts=this._layer.options.tileSize;for(var key in tiles){var pt=tiles[key];if(!pt._drawDone&&pt._gridData){// pt._drawDone = true;
if(pt.el.height!=ts){pt.el.width=pt.el.height=ts;}var ctx=pt.el.getContext('2d');pt._gridData.forEach(function(it){if(it.count){if(this.options.styleHook){this.options.styleHook(ctx,it,maxCount);}var bbox=it.pixelBox;// if (ctx.fillStyle !== '#000000') {
// ctx.fillRect(bbox[0], bbox[1], bbox[2], bbox[3]);
// }
ctx.strokeRect(bbox[0],bbox[1],bbox[2],bbox[3]);}}.bind(this));}}},_zoomClear:null,checkData:function checkData(data){// console.log('ssssssss', data);
var zoom=this._layer._gmx.currentZoom;if(zoom<this.options.minZoom||zoom>this.options.maxZoom){this._layer.enablePopup(true);return false;}this._layer.disablePopup(true);this._parseData(data);if(this._layer._map&&zoom===data.tileElem.coords.z){this._layer._map.addLayer(this._markers);if(!this._zoomClear){this._layer._map.on('zoomstart',function(){this._markers.clearLayers();},this);this._zoomClear=true;}}return this.options.skipItems&&true;},_parseData:function _parseData(data){var tileElem=data.tileElem,tbounds=tileElem.screenTile.tbounds,center=tbounds.getCenter(),bp=this._layer._tileCoordsToNwSe(tileElem.coords),lbounds=L.latLngBounds(bp[0],bp[1]),lcenter=lbounds.getCenter(),arr=[{bounds:L.gmxUtil.bounds([[tbounds.min.x,center[1]],[center[0],tbounds.max.y]]),center:L.latLngBounds(lbounds.getNorthWest(),lcenter).getCenter()},{bounds:L.gmxUtil.bounds([center,[tbounds.max.x,tbounds.max.y]]),center:L.latLngBounds(lbounds.getNorthEast(),lcenter).getCenter()},{bounds:L.gmxUtil.bounds([[tbounds.min.x,tbounds.min.y],center]),center:L.latLngBounds(lbounds.getSouthWest(),lcenter).getCenter()},{bounds:L.gmxUtil.bounds([[center[0],tbounds.min.y],[tbounds.max.x,center[1]]]),center:L.latLngBounds(lbounds.getSouthEast(),lcenter).getCenter()}],cnt=2,delta=256/cnt-this.options.pixelDelta;data.geoItems.forEach(function(it){var item=it.item,bbox=item.bounds;for(var i=0;i<4;i++){var pt=arr[i];if(pt.bounds.intersects(bbox)){var nm=item.currentFilter;if(!pt.counts){pt.counts={};}if(!pt.counts[nm]){pt.counts[nm]=1;}else {pt.counts[nm]++;}break;}}});arr.forEach(function(it,i){if(it.counts){var count=0;for(var key in it.counts){count+=it.counts[key];}it.count=count;it.data=data;it.pixelBox=[128*(i%2)+this.options.pixelDelta,(i>1?128:0)+this.options.pixelDelta,delta,delta];it.marker=this.addMarker(it,count);it.marker.addTo(this._markers);}}.bind(this));tileElem._gridData=arr;},clearLayers:function clearLayers(){if(this._markers){this._markers.clearLayers();if(this._markers._map){this._markers._map.removeLayer(this._markers);}}},addMarker:function addMarker(it,count){var center=it.bounds.toLatLngBounds().getCenter(),marker=L.marker(L.latLng(center.lat,it.center.lng),L.extend({icon:L.divIcon({className:'gmx-style-legend-icon',html:count})},this.options)).bindPopup(Object.keys(it.counts).sort(function(a,b){return it.counts[b]-it.counts[a];}).map(function(key){return this._layer.getStyleIcon(key,it.counts[key]);}.bind(this)).join(''),{minWidth:150});return marker;}});L.gmx.VectorLayer.include({bindGridClusters:function bindGridClusters(options){if(this._gridClusters){this._gridClusters.clearLayers();}this._gridClusters=new GmxGridCluster(options,this);this.redraw().repaint();return this;},unbindGridClusters:function unbindGridClusters(){if(this._gridClusters){this._gridClusters.clearLayers();this._gridClusters=null;this.redraw().repaint();}return this;}});})();(function(){function earcut(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}}else {for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else {p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);var stop=ear,prev,next;// iterate through ears, slicing them one by one
while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){// cut off the triangle
triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertice leads to less sliver triangles
ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
if(ear===stop){// try filtering points and slicing again
if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
}else if(pass===1){ear=cureLocalIntersections(ear,triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
var minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);var p=ear.prevZ,n=ear.nextZ;// look for points inside the triangle in both directions
while(p&&p.z>=minZ&&n&&n.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}// look for remaining points in decreasing z-order
while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}// look for remaining points in increasing z-order
while(n&&n.z<=maxZ){if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}return true;}// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return p;}// try splitting polygon into two and triangulate them independently
function splitEarcut(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
var c=splitPolygon(a,b);// filter colinear points around the cuts
a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m.prev;// hole touches outer segment; pick lower endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
var stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m.next;while(p!==stop){if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
if((tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)){m=p;tanMin=tan;}}p=p.next;}return m;}// interlink polygon nodes in z-order
function indexCurve(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else {e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return (cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b);}// signed area of a triangle
function area(p,q,r){return (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
function intersects(p1,q1,p2,q2){if(equals(p1,q1)&&equals(p2,q2)||equals(p1,q2)&&equals(p2,q1))return true;return area(p1,q1,p2)>0!==area(p1,q1,q2)>0&&area(p2,q2,p1)>0!==area(p2,q2,q1)>0;}// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i,x,y,last){var p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else {p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){// vertice index in coordinates array
this.i=i;// vertex coordinates
this.x=x;this.y=y;// previous and next vertice nodes in a polygon ring
this.prev=null;this.next=null;// z-order curve value
this.z=null;// previous and next nodes in z-order
this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
this.steiner=false;}// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation=function(data,holeIndices,dim,triangles){var hasHoles=holeIndices&&holeIndices.length;var outerLen=hasHoles?holeIndices[0]*dim:data.length;var polygonArea=Math.abs(signedArea(data,0,outerLen,dim));if(hasHoles){for(var i=0,len=holeIndices.length;i<len;i++){var start=holeIndices[i]*dim;var end=i<len-1?holeIndices[i+1]*dim:data.length;polygonArea-=Math.abs(signedArea(data,start,end,dim));}}var trianglesArea=0;for(i=0;i<triangles.length;i+=3){var a=triangles[i]*dim;var b=triangles[i+1]*dim;var c=triangles[i+2]*dim;trianglesArea+=Math.abs((data[a]-data[c])*(data[b+1]-data[a+1])-(data[a]-data[b])*(data[c+1]-data[a+1]));}return polygonArea===0&&trianglesArea===0?0:Math.abs((trianglesArea-polygonArea)/polygonArea);};function signedArea(data,start,end,dim){var sum=0;for(var i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten=function(data){var dim=data[0][0].length,result={vertices:[],holes:[],dimensions:dim},holeIndex=0;for(var i=0;i<data.length;i++){for(var j=0;j<data[i].length;j++){for(var d=0;d<dim;d++){result.vertices.push(data[i][j][d]);}}if(i>0){holeIndex+=data[i-1].length;result.holes.push(holeIndex);}}return result;};L.gmx=L.gmx||{};L.gmx.WebGL=L.gmx.WebGL||{};L.gmx.WebGL.earcut=earcut;})();L.gmx=L.gmx||{};var DEFAULT_HOSTNAME='maps.kosmosnimki.ru';var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET=2000000;//Build in layer classes
L.gmx._layerClasses={'Raster':L.gmx.RasterLayer,'Vector':L.gmx.VectorLayer,'VectorView':L.gmx.DummyLayer};L.gmx._loadingLayerClasses={};L.gmx.addLayerClass=function(type,layerClass){L.gmx._layerClasses[type]=layerClass;};L.gmx._layerClassLoaders=[];L.gmx.addLayerClassLoader=function(layerClassLoader){L.gmx._layerClassLoaders.push(layerClassLoader);//delete all loading promises to ensure that new loader will be invoked
L.gmx._loadingLayerClasses={};};L.gmx._loadLayerClass=function(type){if(!L.gmx._loadingLayerClasses[type]){// var promise = new Promise(function(resolve, reject) {
// }).
var promise=new L.gmx.Deferred();promise.resolve();L.gmx._layerClassLoaders.forEach(function(loader){promise=promise.then(function(layerClass){if(layerClass){L.gmx._layerClasses[type]=layerClass;return layerClass;}return loader(type);},function(){//just skip loader errors
});});promise=promise.then(function(layerClass){if(layerClass){L.gmx._layerClasses[type]=layerClass;return layerClass;}},function(){//just skip loader errors
});L.gmx._loadingLayerClasses[type]=promise;}return L.gmx._loadingLayerClasses[type];};L.gmx.loadLayer=function(mapID,layerID,options){return new Promise(function(resolve,reject){var layerParams={mapID:mapID,layerID:layerID};options=options||{};if(!options.skipTiles){options.skipTiles='All';}for(var p in options){layerParams[p]=options[p];}var hostName=gmxAPIutils.normalizeHostname(options.hostName||DEFAULT_HOSTNAME);layerParams.hostName=hostName;L.gmx.gmxMapManager.loadMapProperties({srs:options.srs||'3857',hostName:hostName,gmxEndPoints:options.gmxEndPoints,apiKey:options.apiKey,mapName:mapID,skipTiles:options.skipTiles}).then(function(){var layerInfo=L.gmx.gmxMapManager.findLayerInfo(hostName,mapID,layerID);if(!layerInfo){reject('There is no layer '+layerID+' in map '+mapID);return;}//to know from what host the layer was loaded
layerInfo.properties.hostName=hostName;var type=layerInfo.properties.ContentID||layerInfo.properties.type;var doCreateLayer=function doCreateLayer(){var layer=L.gmx.createLayer(layerInfo,layerParams);if(layer){resolve(layer);}else {reject('Unknown type of layer '+layerID);}};if(type in L.gmx._layerClasses){doCreateLayer();}else {L.gmx._loadLayerClass(type).then(doCreateLayer);}},function(response){reject('Can\'t load layer '+layerID+' from map '+mapID+': '+response.error);}).catch(console.log);}).catch(console.log);};L.gmx.loadLayers=function(layers,globalOptions){return new Promise(function(resolve){Promise.all(layers.map(function(layerInfo){var options=L.extend({},globalOptions,layerInfo);return L.gmx.loadLayer(layerInfo.mapID,layerInfo.layerID,options);})).then(function(res){resolve(res);});});};L.gmx.loadMap=function(mapID,options){if(L.gmxUtil.debug)console.warn('L.gmx.loadMap:',mapID,options);options=L.extend({},options);options.hostName=gmxAPIutils.normalizeHostname(options.hostName||DEFAULT_HOSTNAME);options.mapName=mapID;if(!options.skipTiles){options.skipTiles='All';}if(!options.srs){options.srs=3857;}if(!options.ftc){options.ftc='osm';}return new Promise(function(resolve,reject){L.gmx.gmxMapManager.loadMapProperties(options).then(function(mapInfo){var mapHash=L.gmx._maps[options.hostName][mapID];if(mapHash.loaded){resolve(mapHash.loaded);}else {var loadedMap=new L.gmx.gmxMap(mapInfo,options);mapHash.loaded=loadedMap;loadedMap.layersCreated.then(function(){if(options.leafletMap||options.setZIndex){var curZIndex=0,visibility=options.visibility,layer,rawProperties;for(var l=loadedMap.layers.length-1;l>=0;l--){layer=loadedMap.layers[l];rawProperties=layer.getGmxProperties();if(mapInfo.properties.LayerOrder==='VectorOnTop'&&layer.setZIndexOffset&&rawProperties.type!=='Raster'){layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);}if(options.setZIndex&&layer.setZIndex){layer.setZIndex(++curZIndex);}if(options.leafletMap&&layer instanceof L.Layer&&(visibility?visibility[rawProperties.name]:rawProperties.visible)){layer.addTo(options.leafletMap);}}}resolve(loadedMap);});}},function(response){var errorMessage=response&&response.ErrorInfo&&response.ErrorInfo.ErrorMessage||'Server error';reject('Can\'t load map '+mapID+' from '+options.hostName+': '+errorMessage);}).catch(console.log);});};L.gmx.DummyLayer=function(props){this.onAdd=this.onRemove=this._layerAdd=function(){};this.getGmxProperties=function(){return props;};};L.gmx.createLayer=function(layerInfo,options){if(!layerInfo){layerInfo={};}if(!layerInfo.properties){layerInfo.properties={type:'Vector'};}var properties=layerInfo.properties,type=properties.ContentID||properties.type||'Vector',layer;if(!options){options=properties;}if(type in L.gmx._layerClasses){try{layer=new L.gmx._layerClasses[type](options||layerInfo.properties);layer=layer.initFromDescription(layerInfo);}catch(e){layer=new L.gmx.DummyLayer(properties);}}else {layer=new L.gmx.DummyLayer(properties);}return layer;};L.gmx=L.gmx||{};L.gmx.gmxAPIutils=gmxAPIutils;

(function () {
  /*
   Spatial Query - a JQuery like Javascript library for handling spatial maths
   Copyright (c) 2009 Chris Zelenak
   Spatial Query is freely distributable under the MIT X11 License - see LICENSE file.
  
   Chris Z
   For work at www.indy.com
   Talked about at www.yeti-factory.org
  
  */
  var _polygon = function _polygon(o) {
    return new _polygon.prototype.assert(o);
  };

  var _vector = function _vector(o) {
    return new _vector.prototype.assert(o);
  };

  var _EF = function _EF(o) {
    return new _EF.prototype.assert(o);
  };

  var $p = _polygon;
  var $v = _vector;
  window.SpatialQuery = {
    $p: $p,
    $v: $v
  }; // Lookup tables for boolean operations (intersection, union, difference)

  var polygonsorientation = Array();
  var fragmenttype = Array();
  var boundaryfragment = Array();
  var resultsorientation = Array();
  _EF.prototype = {
    assert: function assert() {
      this.edge_list = [];
      return this;
    },
    insertE: function insertE(fragment, reg) {
      // Check if the edge is already in the list
      for (var i = 0; i < this.edge_list.length; i++) {
        if (this.edge_list[i][0][0] == fragment[0][0] && this.edge_list[i][0][1] == fragment[0][1] && this.edge_list[i][1][0] == fragment[1][0] && this.edge_list[i][1][1] == fragment[1][1]) {
          // If the edge is already in the list, we are done.
          return;
        }

        if (this.edge_list[i][0][0] == fragment[1][0] && this.edge_list[i][0][1] == fragment[1][1] && this.edge_list[i][1][0] == fragment[0][0] && this.edge_list[i][1][1] == fragment[0][1]) {
          // If the edge is found in the list, but reversed, remove it from the list and we are done.
          this.edge_list.splice(i, 1);
          return;
        }
      }

      this.edge_list.push(fragment);
    },
    deleteE: function deleteE(fragment) {
      // Check if the edge is already in the list
      for (var i = 0; i < this.edge_list.length; i++) {
        if (this.edge_list[i][0][0] == fragment[0][0] && this.edge_list[i][0][1] == fragment[0][1] && this.edge_list[i][1][0] == fragment[1][0] && this.edge_list[i][1][1] == fragment[1][1]) {
          // If the edge is already in the list, delete it
          this.edge_list.splice(i, 1);
          return;
        }
      } // Otherwise there is nothing to remove.
      //console.log("deleteE: no edge to delete.");


      return;
    },
    popnextE: function popnextE(point) {
      // Check if the edge is already in the list
      for (var i = 0; i < this.edge_list.length; i++) {
        if (this.edge_list[i][0][0] == point[0] && this.edge_list[i][0][1] == point[1]) {
          var result = this.edge_list[i];
          this.edge_list.splice(i, 1);
          return result;
        }
      }

      return null;
    },
    searchE: function searchE(fragment) {
      // Check if the edge is already in the list
      for (var i = 0; i < this.edge_list.length; i++) {
        if (this.edge_list[i][0][0] == fragment[0][0] && this.edge_list[i][0][1] == fragment[0][1] && this.edge_list[i][1][0] == fragment[1][0] && this.edge_list[i][1][1] == fragment[1][1]) {
          // If the edge in the list, return it's index.
          return i;
        }
      } //console.log("searchE: no edge found.");


      return -1;
    },
    organizeE: function organizeE() {
      return;
    }
  };
  _vector.prototype = {
    assert: function assert(obj, attribs) {
      this.data = [0, 0, 0];

      if (obj == undefined || obj == null) {
        this.dims = 0;
        this.data = [];
      } else if (obj.vector && typeof obj.vector == "function") {
        var v = obj.vector();
        this.data = v.data;
        this.dims = v.dims;
      } else if (obj.x || obj.y || obj.z) {
        this.data[0] = obj.x || 0.0;
        this.data[1] = obj.y || 0.0;
        this.data[2] = obj.z || 0.0;
      } else if (obj.length) {
        this.data = obj;
        this.dims = obj.length;
      }

      if (attribs != null && attribs != undefined) {
        for (var k in attribs) {
          this[k] = attribs[k];
        }
      }

      return this;
    },
    x: function x() {
      return this.data[0];
    },
    y: function y() {
      return this.data[1];
    },
    z: function z() {
      return this.data[2];
    },
    vector: function vector() {
      return this;
    }
  };

  function init_union_tables() {
    if (polygonsorientation.length > 0) {
      return;
    }

    polygonsorientation = [[[ORIENTATION_SAME, ORIENTATION_SAME, ORIENTATION_OPPOSITE, ORIENTATION_OPPOSITE], [ORIENTATION_OPPOSITE, ORIENTATION_OPPOSITE, ORIENTATION_SAME, ORIENTATION_SAME]], [[ORIENTATION_OPPOSITE, ORIENTATION_OPPOSITE, ORIENTATION_SAME, ORIENTATION_SAME], [ORIENTATION_SAME, ORIENTATION_SAME, ORIENTATION_OPPOSITE, ORIENTATION_OPPOSITE]]];
    fragmenttype = [[[[T_VERTEX_INSIDE, T_VERTEX_INSIDE], [T_VERTEX_OUTSIDE, T_VERTEX_OUTSIDE], [T_VERTEX_OUTSIDE, T_VERTEX_INSIDE], [T_VERTEX_INSIDE, T_VERTEX_OUTSIDE]], [[T_VERTEX_OUTSIDE, T_VERTEX_INSIDE], [T_VERTEX_INSIDE, T_VERTEX_OUTSIDE], [T_VERTEX_INSIDE, T_VERTEX_INSIDE], [T_VERTEX_OUTSIDE, T_VERTEX_OUTSIDE]]], [[[T_VERTEX_INSIDE, T_VERTEX_OUTSIDE], [T_VERTEX_OUTSIDE, T_VERTEX_INSIDE], [T_VERTEX_OUTSIDE, T_VERTEX_OUTSIDE], [T_VERTEX_INSIDE, T_VERTEX_INSIDE]], [[T_VERTEX_OUTSIDE, T_VERTEX_OUTSIDE], [T_VERTEX_INSIDE, T_VERTEX_INSIDE], [T_VERTEX_INSIDE, T_VERTEX_OUTSIDE], [T_VERTEX_OUTSIDE, T_VERTEX_INSIDE]]]];
    boundaryfragment = [[[[[DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_NONE], [DIRECTION_BOTH, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_NONE]], [[DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_FORWARD], [DIRECTION_BOTH, DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_FORWARD]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_BOTH, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE]], [[DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD], [DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_BOTH, DIRECTION_BOTH, DIRECTION_NONE, DIRECTION_NONE]]], [[[DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_FORWARD], [DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_BOTH, DIRECTION_FORWARD]], [[DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_FORWARD], [DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_BOTH, DIRECTION_FORWARD]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_NONE, DIRECTION_NONE, DIRECTION_BOTH, DIRECTION_NONE]], [[DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD], [DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_BOTH, DIRECTION_FORWARD]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_NONE, DIRECTION_NONE, DIRECTION_BOTH, DIRECTION_BOTH]]]], [[[[DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_NONE], [DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_BOTH]], [[DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_NONE], [DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_BOTH]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_BOTH]], [[DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD], [DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_NONE, DIRECTION_NONE, DIRECTION_BOTH, DIRECTION_BOTH]]], [[[DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_FORWARD], [DIRECTION_FORWARD, DIRECTION_BOTH, DIRECTION_NONE, DIRECTION_FORWARD]], [[DIRECTION_FORWARD, DIRECTION_NONE, DIRECTION_FORWARD, DIRECTION_NONE], [DIRECTION_FORWARD, DIRECTION_BOTH, DIRECTION_FORWARD, DIRECTION_NONE]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_NONE, DIRECTION_BOTH, DIRECTION_NONE, DIRECTION_NONE]], [[DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD], [DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD, DIRECTION_FORWARD]], [[DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE, DIRECTION_NONE], [DIRECTION_BOTH, DIRECTION_BOTH, DIRECTION_NONE, DIRECTION_NONE]]]]];
    resultsorientation = [[[1, 1, 1, -1], [1, -1, 1, 1]], [[-1, 1, 1, 1], [1, 1, -1, 1]]];
  }

  _polygon.prototype = {
    assert: function assert(obj, type) {
      init_union_tables();
      this.bound_minX = Number.MAX_VALUE;
      this.bound_maxX = -Number.MAX_VALUE;
      this.bound_minY = Number.MAX_VALUE;
      this.bound_maxY = -Number.MAX_VALUE;

      if (obj == undefined || obj == null) {
        this.head = null;
        this.tail = null;
        this.direciton = null;
        this.holes = [];

        if (type == null || type == undefined) {
          this.type = _polygon.TYPE_ISLAND;
        } else {
          this.type = type;
        }

        this.count = 0;
      } else if (obj.polygon && typeof obj.polygon == "function") {
        var p = obj.polygon();
        this.head = p.head;
        this.tail = p.tail;
        this.direction = p.direction;
        this.count = p.count;
        this.type = p.type;
        this.holes = p.holes;
      } else if (obj.length) {
        this.count = 0;
        this.holes = [];

        for (var i = 0; i < obj.length; i++) {
          this.add_point(obj[i], {
            type: T_VERTEX_BOUNDARY
          });
        }

        this.direction = this.compute_direction();

        if (type == null || type == undefined) {
          this.type = _polygon.TYPE_ISLAND;
        } else {
          this.type = type;
        }
      }

      return this;
    },
    compute_direction: function compute_direction() {
      if (this.count < 3) {
        return _polygon.DIRECTION_INVALID;
      }

      var minXNode = this.head;
      this.foreach(function (node) {
        if (node.x < minXNode.x) {
          minXNode = node;
        }
      });

      if (minXNode.next.y > minXNode.prev.y) {
        return _polygon.DIRECTION_CLOCKWISE;
      } else {
        return _polygon.DIRECTION_COUNTERCLOCKWISE;
      }
    },
    reverse_direction: function reverse_direction() {
      var start = this.head;
      var current = this.head;
      var tmp = null;

      do {
        tmp = current.next;
        current.next = current.prev;
        current.prev = tmp; // 

        current = current.prev;
      } while (current != start);

      this.direction = this.compute_direction();
    },
    union: function union(otherPoly) {
      try {
        return _polygon.prototype.boolean_operation(this, otherPoly, OPERATION_UNION, 0);
      } catch (e) {
        console.log(e);
      }
    },
    boolean_operation: function boolean_operation(A, B, Oper, Reg) {
      var orientationA = A.direction;
      var orientationB = B.direction; // If the operation is union, and bounding boxes dont overlap return right away.

      if (A.bound_maxX < B.bound_minX || A.bound_minX > B.bound_maxX || A.bound_maxY < B.bound_minY || A.bound_minY > B.bound_maxY) {
        return null;
      } // Initialize Edge fragment structure.


      edgeFragments = _EF(); //(function(){
      // Change polygon orientation according to operation table.

      if (polygonsorientation[A.type][B.type][Oper] == ORIENTATION_SAME && orientationA != orientationB) {
        if (orientationA != orientationB) {
          B.reverse_direction();
        }
      } else if (polygonsorientation[A.type][B.type][Oper] == ORIENTATION_OPPOSITE && orientationA == orientationB) {
        B.reverse_direction();
      }

      var nInside = 0; // Classify which vertices are inside the other polygon.

      var node = A.head;

      do {
        node.type = B.point_inside_2d(node);

        if (node.type != T_VERTEX_OUTSIDE) {
          nInside++;
        }

        node = node.next;
      } while (node != A.head);

      var node = B.head;

      do {
        node.type = A.point_inside_2d(node);

        if (node.type != T_VERTEX_OUTSIDE) {
          nInside++;
        }

        node = node.next;
      } while (node != B.head); // If there are no inside or boundary nodes, there is nothing to do, two polygons dont overlap.


      if (nInside == 0 && Oper == OPERATION_UNION) {
        return null;
      } // Find intersections
      var node = A.head;

      do {
        var a_start = node;
        var a_end = node.next;
        var node2 = B.head;

        do {
          var b_start = node2;
          var b_end = node2.next;
          var seg1 = [[a_start.x, a_start.y], [a_end.x, a_end.y]];
          var seg2 = [[b_start.x, b_start.y], [b_end.x, b_end.y]];
          var intersection = pointOfIntersectionForLineSegments(seg1, seg2);

          if (intersection != null) {
            // Only insert intersection if its not already a vertex.
            // Otherwise just change the vertex type.
            if (intersection[2] == 0) {
              a_start.type = T_VERTEX_BOUNDARY;
            } else if (intersection[2] == 1) {
              a_end.type = T_VERTEX_BOUNDARY;
            } else {
              var Point = new _polygon.prototype.vtx(intersection, {
                type: T_VERTEX_BOUNDARY
              });
              A.insert_vertex_after(Point, a_start);
              a_end = node.next;
            }

            if (intersection[3] == 0) {
              b_start.type = T_VERTEX_BOUNDARY;
            } else if (intersection[3] == 1) {
              b_end.type = T_VERTEX_BOUNDARY;
            } else {
              var Point = new _polygon.prototype.vtx(intersection, {
                type: T_VERTEX_BOUNDARY
              });
              B.insert_vertex_after(Point, b_start);
              b_end = node2.next;
            }
          }

          node2 = node2.next;
        } while (node2 != B.head);

        node = node.next;
      } while (node != A.head); //})();
      //(function(){
      // Classify, select and organize edge fragments


      var Type = fragmenttype[A.type][B.type][Oper][0];
      var node = A.head;

      do {
        var start = node;
        var end = node.next;
        var seg = [[start.x, start.y], [end.x, end.y]];

        if (start.type == Type || end.type == Type) {
          edgeFragments.insertE(seg);
        } else if (start.type == T_VERTEX_BOUNDARY && end.type == T_VERTEX_BOUNDARY) {
          var m = [(end.x + start.x) / 2, (end.y + start.y) / 2];
          var res = B.point_inside_2d(m);

          if (res == Type || res == T_VERTEX_BOUNDARY) {
            edgeFragments.insertE(seg);
          }
        }

        node = node.next;
      } while (node != A.head);

      var Type2 = fragmenttype[A.type][B.type][Oper][1];
      var node = B.head;

      do {
        var start = node;
        var end = node.next;
        var seg = [[start.x, start.y], [end.x, end.y]];

        if (start.type == Type2 || end.type == Type2) {
          edgeFragments.insertE(seg);
        } else if (start.type == T_VERTEX_BOUNDARY && end.type == T_VERTEX_BOUNDARY) {
          var m = [(end.x + start.x) / 2, (end.y + start.y) / 2];
          var res = A.point_inside_2d(m);

          if (res == Type2 || res == T_VERTEX_BOUNDARY) {
            edgeFragments.insertE(seg);
          }
        }

        node = node.next;
      } while (node != B.head);
      /*
      for(iEdge = 0;iEdge < edgeFragments.edge_list.length;iEdge++) {
      	seg = edgeFragments.edge_list[iEdge];
      	revEdge = [seg[1],seg[0]];
      	var iRevEdge = edgeFragments.searchE(revEdge);
      	
      	// TODO: Compute situation code
      	var sit = 0;
      	
      	d = boundaryfragment[A.type][B.type][sit][Reg][Oper];
      	
      	if(d == DIRECTION_NONE) {
      		edgeFragments.deleteE(seg);
      		if(iRevEdge >= 0) {
      			edgeFragments.deleteE(revEdge);
      		}
      		// TODO Verify this code is correct
      	} else if(d == DIRECTION_BOTH){
      		edgeFragments.delteE(seg);	
      		// TOdo investigate what to do here exactly, not quiet clear
      	}
      }
      */


      edgeFragments.organizeE(); //})();

      var Out = null;
      var outHoles = [];
      var outPolygons = []; //(function constructResultPolygons(){
      // Construct the result polygons and find their types.

      while (edgeFragments.edge_list.length > 0) {
        var fNext = edgeFragments.popnextE(edgeFragments.edge_list[0][0]);
        var edgeLoop = [];

        do {
          edgeLoop.push(fNext);
          fNext = edgeFragments.popnextE(fNext[1]);
        } while (fNext != null);

        var cEdge = edgeLoop[0];
        var resultPolygon = $p();
        var startPoint = cEdge[0];

        for (var iLoopEdge = 1; iLoopEdge <= edgeLoop.length; iLoopEdge++) {
          var seg1 = cEdge;

          if (iLoopEdge == edgeLoop.length) {
            // Add the first point of the edge loop into the result polygon.
            seg2 = [startPoint, [resultPolygon.head.x, resultPolygon.head.y]];
          } else {
            seg2 = edgeLoop[iLoopEdge];
          }

          var dy1 = seg1[1][1] - seg1[0][1];
          var dy2 = seg2[1][1] - seg2[0][1];
          var slope1 = Number.MAX_VALUE; // Default to Number.MAX_VALUE, when dividing by 0	

          var slope2 = Number.MAX_VALUE;

          if (dy1 != 0) {
            slope1 = (seg1[1][0] - seg1[0][0]) / dy1;
          }

          if (dy2 != 0) {
            slope2 = (seg2[1][0] - seg2[0][0]) / dy2;
          } // Check if the two edges are colinear, if they are join them


          if (slope1 == slope2) {
            cEdge = [seg1[0], seg2[1]];
          } else {
            // Otherwise record the edge in to the output structure
            resultPolygon.add_point(cEdge[1]);
            cEdge = seg2;
          }
        } // Figure out the orientation of the current result polygon


        resultPolygon.direction = resultPolygon.compute_direction();

        if (resultPolygon.direction == orientationA) {
          if (resultsorientation[A.type][B.type][Oper] == ORIENTATION_SAME) {
            resultPolygon.type = Number(A.type);
          } else {
            resultPolygon.type = Number(!A.type);
          }
        } else if (resultsorientation[A.type][B.type][Oper] == ORIENTATION_SAME) {
          resultPolygon.type = Number(!A.type);
        } else {
          resultPolygon.type = Number(A.type);
        }

        if (resultPolygon.type == _polygon.TYPE_ISLAND) {
          outPolygons.push(resultPolygon);
        } else {
          outHoles.push(resultPolygon);
        }
      } //})();


      if (outPolygons.length == 1) {
        Out = outPolygons[0];
        Out.holes = outHoles;
      } else {
        console.log('Output polygons invalid. Length = ' + outPolygons.length);
      }

      return Out;
    },
    vtx: function vtx(pt, attribs) {
      this.x = pt[0] || 0.0;
      this.y = pt[1] || 0.0;
      this.next = null;
      this.prev = null;

      if (attribs != null && attribs != undefined) {
        for (var k in attribs) {
          this[k] = attribs[k];
        }
      }

      return this;
    },
    add_point: function add_point(point, attribs) {
      var v = new _polygon.prototype.vtx(point, attribs);
      this.add_vtx(v);
      return this;
    },
    foreach: function foreach(fn) {
      var node = this.head;

      do {
        fn.apply(this, [node]);
        node = node.next;
      } while (node != this.head);
    },
    add_vtx: function add_vtx(vtx) {
      // Update polygon bounding box.
      if (vtx.x < this.bound_minX) {
        this.bound_minX = vtx.x;
      }

      if (vtx.x > this.bound_maxX) {
        this.bound_maxX = vtx.x;
      }

      if (vtx.y < this.bound_minY) {
        this.bound_minY = vtx.y;
      }

      if (vtx.y > this.bound_maxY) {
        this.bound_maxY = vtx.y;
      }

      if (this.head == null) {
        this.head = vtx;
        this.tail = vtx;
        this.head.prev = this.head;
        this.head.next = this.head;
        this.count++;
      } else {
        this.insert_vertex_after(vtx, this.tail);
      }

      return this;
    },
    insert_vertex_after: function insert_vertex_after(vtx, after) {
      var nxt = after.next;
      after.next = vtx;
      nxt.prev = vtx;
      vtx.prev = after;
      vtx.next = nxt;

      if (this.tail == after) {
        this.tail = vtx;
      }

      this.count++;
      return this;
    },
    to_wkt: function to_wkt() {
      var a = [];
      this.foreach(function (node) {
        a.push([node.x, node.y]);
      });
      var str = "POLYGON(";
      str += "(";

      for (var i = 0; i < a.length; i++) {
        str += a[i][0] + " " + a[i][1] + ",";
      }

      str += a[0][0] + " " + a[0][1];
      str += ")";

      for (var iHole = 0; iHole < this.holes.length; iHole++) {
        var b = [];
        this.holes[iHole].foreach(function (node) {
          b.push([node.x, node.y]);
        });
        str += ",(";

        for (var i = 0; i < b.length; i++) {
          str += b[i][0] + " " + b[i][1] + ",";
        }

        str += b[0][0] + " " + b[0][1];
        str += ")";
      }

      str += ")";
      return str;
    },
    to_point_array_2d: function to_point_array_2d() {
      var a = [];
      this.foreach(function (node) {
        a.push([node.x, node.y]);
      });
      return a;
    },
    point_inside_2d: function point_inside_2d(vtx) {
      var wn = 0; // the winding number counter

      var isBoundary = 0;
      var v_x = 0;
      var v_y = 0;

      if (vtx.x) {
        v_x = vtx.x;
        v_y = vtx.y;
      } else {
        v_x = vtx[0];
        v_y = vtx[1];
      }

      var seg = [[v_x, v_y], [10000000, v_y]]; // loop through all edges of the polygon

      var node = this.head;

      do {
        var nxt = node.next;
        var seg2 = [[node.x, node.y], [nxt.x, nxt.y]];
        var intersection = pointOfIntersectionForLineSegments(seg, seg2);

        if (intersection != null) {
          if (intersection[2] == 0) {
            isBoundary = 1;
          } // E[i] crosses upward ala Rule #1


          if (seg2[0][1] < seg2[1][1]) {
            // For upwards edge ignore ending point
            if (intersection[3] != 1) {
              wn++;
            }
          } else if (seg2[0][1] > seg2[1][1]) {
            // For downward edge ignore starting point
            if (intersection[3] != 0) {
              wn--;
            }
          }
        } else if (seg2[0][1] == v_y && seg2[0][1] == seg2[1][1] && (seg2[0][0] <= v_x || seg2[1][0] <= v_x)) {
          // Check if the point is on the boundary (between two x coordinates of the edge segment)
          if (v_x >= seg2[0][0] && v_x <= seg2[1][0] || v_x >= seg2[1][0] && v_x <= seg2[0][0]) {
            isBoundary = 1;
          }
        }

        node = nxt;
      } while (node != this.head); // Handle case if the point is on the boundary of the polygon


      if (isBoundary) {
        return T_VERTEX_BOUNDARY;
      } else {
        // Flip output for "hole" polygons.
        if (wn == 0 && this.type == 0 || wn != 0 && this.type == 1) {
          return T_VERTEX_OUTSIDE;
        } else {
          return T_VERTEX_INSIDE;
        }
      }
    }
  };

  _vector.numberInRange = function (n, min, max) {
    return n >= min && n <= max;
  };
  /*
  _vector.pointAndTypeOfIntersectionForLineSegments = function{
  	var intersection = pointOfIntersectionForLineSegments(seg_a, seg_b);
  	
  	if(intersection == null){
  		return T_VERTEX_OUTSIDE;
  	} else {
  		var point = [intersection[0],intersection[1]];
  		
  		if(intersection[3] == 0 || intersection[3] == 1 || intersection[3] == 0 || intersection[3] == 1) {
  			return T_VERTEX_INSIDE;
  		} else {
  			return T_VERTEX_BOUNDARY;
  		}
  	}
  }
  */
  // segment: [ [x,y], [x2, y2] ]
  // algo and original code from:
  // http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/


  function pointOfIntersectionForLineSegments(seg_a, seg_b) {
    // Assume lines are horizontal or vertical;
    // If segment a is vertical
    if (seg_a[0][0] == seg_a[1][0]) {
      // If both vertical, return null
      if (seg_b[0][0] == seg_b[1][0]) {
        return null;
      } else {
        // Make sure the segments intersect.
        if (seg_b[0][1] > seg_a[0][1] && seg_b[0][1] > seg_a[1][1] || seg_b[0][1] < seg_a[0][1] && seg_b[0][1] < seg_a[1][1] || seg_a[0][0] > seg_b[0][0] && seg_a[0][0] > seg_b[1][0] || seg_a[0][0] < seg_b[0][0] && seg_a[0][0] < seg_b[1][0]) {
          return null;
        } else {
          // Ua should be 0 if first point is on the line, 1 if last point is on the line, and 0.5 otherwise
          ua = seg_a[0][1] == seg_b[0][1] ? 0 : seg_a[1][1] == seg_b[0][1] ? 1 : 0.5;
          ub = seg_b[0][0] == seg_a[0][0] ? 0 : seg_b[1][0] == seg_a[0][0] ? 1 : 0.5;
          return [seg_a[0][0], seg_b[0][1], ua, ub];
        }
      }
    } else {
      // If both horizontal, return null
      if (seg_b[0][1] == seg_b[1][1]) {
        return null;
      } else {
        // Make sure the segments intersect.
        if (seg_b[0][0] > seg_a[0][0] && seg_b[0][0] > seg_a[1][0] || seg_b[0][0] < seg_a[0][0] && seg_b[0][0] < seg_a[1][0] || seg_a[0][1] > seg_b[0][1] && seg_a[0][1] > seg_b[1][1] || seg_a[0][1] < seg_b[0][1] && seg_a[0][1] < seg_b[1][1]) {
          return null;
        } else {
          // Ua should be 0 if first point is on the line, 1 if last point is on the line, and 0.5 otherwise
          ua = seg_a[0][0] == seg_b[0][0] ? 0 : seg_a[1][0] == seg_b[0][0] ? 1 : 0.5;
          ub = seg_b[0][1] == seg_a[0][1] ? 0 : seg_b[1][1] == seg_a[0][1] ? 1 : 0.5;
          return [seg_b[0][0], seg_a[0][1], ua, ub];
        }
      }
    }
  }

  _vector.pointOfIntersectionForLineSegmentsDiag = function (seg_a, seg_b) {
    var start_a = seg_a[0],
        // v1
    end_a = seg_a[1],
        // v2
    start_b = seg_b[0],
        // v3
    end_b = seg_b[1]; // v4

    var denom = (end_b[1] - start_b[1]) * (end_a[0] - start_a[0]) - (end_b[0] - start_b[0]) * (end_a[1] - start_a[1]);
    if (denom == 0) return null; // parallel

    var numer_a = (end_b[0] - start_b[0]) * (start_a[1] - start_b[1]) - (end_b[1] - start_b[1]) * (start_a[0] - start_b[0]);
    var numer_b = (end_a[0] - start_a[0]) * (start_a[1] - start_b[1]) - (end_a[1] - start_a[1]) * (start_a[0] - start_b[0]);
    if (numer_a == 0 && denom == 0 && numer_a == numer_b) return null; // coincident

    var ua = numer_a / denom,
        ub = numer_b / denom;

    if (_vector.numberInRange(ua, 0.0, 1.0) && _vector.numberInRange(ub, 0.0, 1.0)) {
      return [start_a[0] + ua * (end_a[0] - start_a[0]), start_a[1] + ua * (end_a[1] - start_a[1]), ua, ub]; // return barycenric coordinates for alpha values in greiner-hormann
    }

    return null; // does not intersect
  };

  _polygon.TYPE_ISLAND = 0;
  _polygon.TYPE_HOLE = 1;
  _polygon.DIRECTION_INVALID = 0;
  _polygon.DIRECTION_CLOCKWISE = 1;
  _polygon.DIRECTION_COUNTERCLOCKWISE = -1;
  _polygon.prototype.assert.prototype = _polygon.prototype;
  _vector.prototype.assert.prototype = _vector.prototype;
  _EF.prototype.assert.prototype = _EF.prototype;
  var DIRECTION_NONE = 0,
      DIRECTION_FORWARD = 1,
      DIRECTION_BOTH = 3;
  var OPERATION_UNION = 1;
  var ORIENTATION_SAME = 1,
      ORIENTATION_OPPOSITE = -1;
  var T_VERTEX_OUTSIDE = 0,
      T_VERTEX_INSIDE = 1,
      T_VERTEX_BOUNDARY = 2;
})();

// ÐÐ¸ÑÑÑÐ°Ð»ÑÐ½ÑÐ¹ ÑÐ»Ð¾Ð¹ Ð´Ð»Ñ Ð¿Ð¾Ð¶Ð°ÑÐ¾Ð²
(function () {

  var transHash = {
    rus: {
      "LayerClusterBalloon": "<div style='margin-bottom: 5px;'><b style='color: red;'>ÐÐ¾Ð¶Ð°Ñ</b></div>" + "<b>ÐÐ¾Ð»-Ð²Ð¾ ÑÐµÑÐ¼Ð¾ÑÐ¾ÑÐµÐº:</b> [count]<br/>" + "<b>ÐÑÐµÐ¼Ñ Ð½Ð°Ð±Ð»ÑÐ´ÐµÐ½Ð¸Ñ:</b> [dateRange]<br/>" + "<div>[SUMMARY]</div>",
      "LayerClusterBalloonIndustrial": "<span style='margin-bottom: 5px;'><b style='color: red;'>ÐÐ¾Ð¶Ð°Ñ</b></span> (Ð²ÐµÑÐ¾ÑÑÐ½ÑÐ¹ ÑÐµÑÐ½Ð¾Ð³ÐµÐ½Ð½ÑÐ¹ Ð¸ÑÑÐ¾ÑÐ½Ð¸Ðº <a target='blank' href='http://fires.kosmosnimki.ru/help.html#techno'>?</a>) <br/>" + "<b>ÐÐ¾Ð»-Ð²Ð¾ ÑÐµÑÐ¼Ð¾ÑÐ¾ÑÐµÐº:</b> [count]<br/>" + "<b>ÐÑÐµÐ¼Ñ Ð½Ð°Ð±Ð»ÑÐ´ÐµÐ½Ð¸Ñ:</b> [dateRange]<br/>" + "<div>[SUMMARY]</div>",
      "LayerGeometryBalloon": "<div style='margin-bottom: 5px;'><b style='color: red;'>ÐÐ¾Ð½ÑÑÑ Ð¿Ð¾Ð¶Ð°ÑÐ°</b></div>" + "<b>ÐÐ¾Ð»-Ð²Ð¾ ÑÐµÑÐ¼Ð¾ÑÐ¾ÑÐµÐº:</b> [count]<br/>" + "<b>ÐÑÐµÐ¼Ñ Ð½Ð°Ð±Ð»ÑÐ´ÐµÐ½Ð¸Ñ:</b> [dateRange]<br/>" + "<div>[SUMMARY]</div>",
      "zoomInMessage": "ÐÑÐ¸Ð±Ð»Ð¸Ð·ÑÑÐµ ÐºÐ°ÑÑÑ, ÑÑÐ¾Ð±Ñ ÑÐ²Ð¸Ð´ÐµÑÑ ÐºÐ¾Ð½ÑÑÑ"
    },
    eng: {
      "LayerClusterBalloon": "<div style='margin-bottom: 5px;'><b style='color: red;'>Fire</b></div>" + "<b>Number of hotspots:</b> [count]<br/>" + "<b>Observation period:</b> [dateRange]<br/>" + "<div>[SUMMARY]</div>",
      "LayerClusterBalloonIndustrial": "<span style='margin-bottom: 5px;'><b style='color: red;'>Fire</b></span> (probable industrial hotspot <a target='_blank' href='http://fires.kosmosnimki.ru/help.html#techno'>?</a>)<br/>" + "<b>Number of hotspots:</b> [count]<br/>" + "<b>Observation period:</b> [dateRange]<br/>" + "<div>[SUMMARY]</div>",
      "LayerGeometryBalloon": "<div style='margin-bottom: 5px;'><b style='color: red;'>Fire outline</b></div>" + "<b>Number of hotspots:</b> [count]<br/>" + "<b>Observation period:</b> [dateRange]<br/>" + "<div>[SUMMARY]</div>",
      "zoomInMessage": "Zoom-in to see the outline"
    }
  };

  var initTranslations = function initTranslations() {
    _translationsHash.addtext("rus", {
      FireVirtualLayer: transHash.rus
    });

    _translationsHash.addtext("eng", {
      FireVirtualLayer: transHash.eng
    });
  }; // Lookup table for pixel dimensions based on scan index of the pixel


  var ModisPixelDimensions = [];

  function buildModisPixelDimensionsTable() {
    // Don't rebuild the table if it was already built
    if (ModisPixelDimensions.length > 0) {
      return;
    }

    var h = 705.0; // Terra/Aqua orbit altitude [km]

    var p = 1.0; // nadir pixel resolution [km]

    var EARTH_RADIUS = 6371.0;
    var SAMPLES = 1354;
    var r = EARTH_RADIUS + h;
    /* [km] */

    var s = p / h;
    /* [rad] */

    for (var sample = 0; sample < 1354; sample++) {
      var theta = sample * s + 0.5 * s - 0.5 * SAMPLES * s;
      var cos_theta = Math.cos(theta);
      var temp = Math.pow(EARTH_RADIUS / r, 2.0) - Math.pow(Math.sin(theta), 2.0);
      var sqrt_temp = Math.sqrt(temp);
      var DS = EARTH_RADIUS * s * (cos_theta / sqrt_temp - 1.0) * 1000;
      var DT = r * s * (cos_theta - sqrt_temp) * 1000;
      ModisPixelDimensions[sample] = [DS, DT];
    }
  }

  var _hq = {
    getDistant: function getDistant(cpt, bl) {
      var Vy = bl[1][0] - bl[0][0];
      var Vx = bl[0][1] - bl[1][1];
      return Vx * (cpt[0] - bl[0][0]) + Vy * (cpt[1] - bl[0][1]);
    },
    findMostDistantPointFromBaseLine: function findMostDistantPointFromBaseLine(baseLine, points) {
      var maxD = 0;
      var maxPt = new Array();
      var newPoints = new Array();

      for (var idx in points) {
        var pt = points[idx];
        var d = this.getDistant(pt, baseLine);

        if (d > 0) {
          newPoints.push(pt);
        } else {
          continue;
        }

        if (d > maxD) {
          maxD = d;
          maxPt = pt;
        }
      }

      return {
        'maxPoint': maxPt,
        'newPoints': newPoints
      };
    },
    buildConvexHull: function buildConvexHull(baseLine, points) {
      var convexHullBaseLines = new Array();
      var t = this.findMostDistantPointFromBaseLine(baseLine, points);

      if (t.maxPoint.length) {
        convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints));
        convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints));
        return convexHullBaseLines;
      } else {
        return [baseLine];
      }
    },
    getConvexHull: function getConvexHull(points) {
      if (points.length == 1) return [[points[0], points[0]]]; //find first baseline

      var maxX, minX;
      var maxPt, minPt;

      for (var idx in points) {
        var pt = points[idx];

        if (pt[0] > maxX || !maxX) {
          maxPt = pt;
          maxX = pt[0];
        }

        if (pt[0] < minX || !minX) {
          minPt = pt;
          minX = pt[0];
        }
      }

      var ch = [].concat(this.buildConvexHull([minPt, maxPt], points), this.buildConvexHull([maxPt, minPt], points));
      return ch;
    },
    MultiPolygonUnion: function MultiPolygonUnion(multiPolygon) {
      var matrixMultiPolygon = [],
          unitedMultiPolygon = [],
          nStartPolygons = 0,
          currentPolygon;

      do {
        nStartPolygons = multiPolygon.length;
        unitedMultiPolygon = [];

        while (multiPolygon.length > 0) {
          currentPolygon = multiPolygon.pop();
          var iOther = 0; // Check if it overlaps with any remaining polygons

          while (iOther < multiPolygon.length) {
            var unionResults = currentPolygon.union(multiPolygon[iOther]);

            if (unionResults != null) {
              currentPolygon = unionResults;
              multiPolygon.splice(iOther, 1);
            } else {
              iOther++;
            }
          }

          unitedMultiPolygon.push(currentPolygon);
        }

        multiPolygon = unitedMultiPolygon;
      } while (multiPolygon.length < nStartPolygons);

      for (var i = 0; i < unitedMultiPolygon.length; i++) {
        var poly = unitedMultiPolygon[i].to_point_array_2d();
        poly.push(poly[0]);
        matrixMultiPolygon.push([poly]);
      }

      return matrixMultiPolygon;
    },
    getPixelMultiPolygon: function getPixelMultiPolygon(points) {
      var results = [];

      for (var i = 0; i < points.length; i++) {
        var pt = points[i];
        var dims = ModisPixelDimensions[pt[2]];
        var merc = L.CRS.EPSG3857.project({
          lat: pt[1],
          lng: pt[0]
        });
        var X1 = merc.x;
        var Y1 = merc.y;
        var X2 = X1 + 1000;
        var Y2 = Y1;
        var newLatLng = L.Projection.SphericalMercator.unproject({
          x: X2,
          y: Y2
        });
        var newLat = pt[1];
        var newLon = newLatLng.lng;
        var mdelta = L.gmxUtil.distVincenty(pt[0], pt[1], newLon, newLat);
        var h_scale = dims[0] / mdelta;
        var v_scale = dims[1] / mdelta;
        var h_dx = 0.5 * (X2 - X1) * h_scale;
        var h_dy = 0.5 * (Y2 - Y1) * h_scale;
        var v_dx = 0.5 * (Y2 - Y1) * v_scale;
        var v_dy = 0.5 * (X2 - X1) * v_scale;
        var frontX = X1 + h_dx;
        var frontY = Y1 + h_dy;
        var backX = X1 - h_dx;
        var backY = Y1 - h_dy;
        var corner1x = frontX + v_dx;
        var corner1y = frontY + v_dy;
        var corner2x = frontX - v_dx;
        var corner2y = frontY - v_dy;
        var corner3x = backX - v_dx;
        var corner3y = backY - v_dy;
        var corner4x = backX + v_dx;
        var corner4y = backY + v_dy;
        results.push(SpatialQuery.$p([[corner1x, corner1y], [corner2x, corner2y], [corner3x, corner3y], [corner4x, corner4y]]));
      }

      return results;
    }
  };

  var mercBbox = function mercBbox(latlngBbox) {
    var mercMin = L.CRS.EPSG3857.project({
      lat: latlngBbox.min.y,
      lng: latlngBbox.min.x
    });
    var mercMax = L.CRS.EPSG3857.project({
      lat: latlngBbox.max.y,
      lng: latlngBbox.max.x
    });
    return L.gmxUtil.bounds([[mercMin.x, mercMin.y], [mercMax.x, mercMax.y]]);
  };

  var fromMercBbox = function fromMercBbox(bbox) {
    var min = L.Projection.SphericalMercator.unproject(bbox.min);
    var max = L.Projection.SphericalMercator.unproject(bbox.max);
    return L.gmxUtil.bounds([[min.lng, min.lat], [max.lng, max.lat]]);
  };

  var getExtendedBbox = function getExtendedBbox(mercOld, newBbox) {
    var extendBbox = function extendBbox(bbox) {
      var sx = (bbox.max.x - bbox.min.x) * 0.15,
          sy = (bbox.max.y - bbox.min.y) * 0.15;
      return L.gmxUtil.bounds([[bbox.min.x - sx, bbox.min.y - sy], [bbox.max.x + sx, bbox.max.y + sy]]);
    };

    var mercNew = mercBbox(newBbox);

    if (!mercOld) {
      return fromMercBbox(extendBbox(mercNew));
    }

    var oldSquare = (mercOld.max.x - mercOld.min.x) * (mercOld.max.y - mercOld.min.y),
        newSquare = (mercNew.max.x - mercNew.min.x) * (mercNew.max.y - mercNew.min.y);

    if (!mercOld.contains([mercNew.min.x, mercNew.min.y]) || !mercOld.contains([mercNew.max.x, mercNew.max.y]) || 2 * newSquare < oldSquare) {
      return fromMercBbox(extendBbox(mercNew));
    } else {
      return null;
    }
  };

  var dateToString = function dateToString(timestamp) {
    var date = new Date(timestamp * 1000);

    var lz = function lz(n) {
      return n > 9 ? n : '0' + n;
    };

    return lz(date.getUTCDate()) + '.' + lz(date.getUTCMonth() + 1) + '.' + date.getUTCFullYear();
  };

  if (!window._gtxt) {
    var _gtxt = function _gtxt() {
      return null;
    };
  }

  var FireVirtualLayer = (L.Layer || L.Class).extend({
    options: {
      minClustersZoom: 4,
      minGeomZoom: 8,
      minHotspotZoom: 11,
      hostName: 'maps.kosmosnimki.ru' // mapID
      // hotspotLayerID
      // dailyLayerID

    },
    initialize: function initialize(options) {
      L.setOptions(this, options);
      var nsGmx = window.nsGmx;
      var lang = nsGmx && nsGmx.Translations && nsGmx.Translations.getLanguage ? nsGmx.Translations.getLanguage() : 'rus';
      var titelHash = transHash[lang];
      this._clustersLayer = L.gmx.createLayer({
        properties: {
          title: 'FireClusters',
          attributes: ['scale', 'count', 'label', 'startDate', 'endDate', 'dateRange', 'isIndustrial'],
          styles: [{
            Filter: '"isIndustrial"=0',
            Balloon: _gtxt('FireVirtualLayer.LayerClusterBalloon') || titelHash.LayerClusterBalloon,
            MinZoom: 1,
            MaxZoom: this.options.minGeomZoom - 1,
            RenderStyle: {
              fill: {
                radialGradient: {
                  r1: 0,
                  r2: '[scale]*20',
                  addColorStop: [[0, 0xffff00, 50], [1, 0xff0000, 50]]
                }
              },
              labelHaloColor: 0,
              label: {
                size: 12,
                color: 0xffffff,
                field: 'label',
                align: 'center'
              }
            }
          }, {
            Filter: '"isIndustrial"=1',
            Balloon: _gtxt('FireVirtualLayer.LayerClusterBalloonIndustrial') || titelHash.LayerClusterBalloonIndustrial,
            MinZoom: 1,
            MaxZoom: this.options.minGeomZoom - 1,
            RenderStyle: {
              fill: {
                radialGradient: {
                  r1: 0,
                  r2: '[scale]*20',
                  addColorStop: [[0, 0xffffff, 80], [1, 0xffaa00, 80]]
                }
              }
            }
          }]
        }
      }, {
        srs: 3857
      });
      this._clustersGeomLayer = L.gmx.createLayer({
        properties: {
          type: 'Vector',
          title: 'FirePolygons',
          attributes: ['scale', 'count', 'label', 'startDate', 'endDate', 'dateRange', 'isIndustrial'],
          styles: [{
            Balloon: _gtxt('FireVirtualLayer.LayerGeometryBalloon') || titelHash.LayerGeometryBalloon,
            MinZoom: this.options.minGeomZoom,
            MaxZoom: 21,
            RenderStyle: {
              outline: {
                color: 0xff0000,
                thickness: 2
              },
              fill: {
                color: 0xff0000,
                opacity: 15
              }
            },
            HoverStyle: {
              outline: {
                color: 0xff0000,
                thickness: 3
              },
              fill: {
                color: 0xff0000,
                opacity: 45
              }
            }
          }]
        }
      }, {
        srs: 3857
      });

      if (L.HeatLayer) {
        this._heatmapLayer = new L.HeatLayer([], {
          type: 'heatmap',
          "gradient": {
            "1.00": "#FFFFFF",
            "0.90": "#FFAA00",
            "0.85": "#FF8800",
            "0.75": "#E65C00",
            "0.55": "#DB1D00"
          },
          "blur": 30,
          "radius": 17,
          "minRadius": 7,
          "minOpacity": 0.65
        });
      }

      if (this.options['z_index']) {
        this._clustersLayer.setZIndex(this.options['z_index'] + 100);

        this._clustersGeomLayer.setZIndex(this.options['z_index']);
      }

      var _this = this;

      this._clustersLayer.on('popupopen', function (event) {
        var popup = event.popup,
            html = popup.getContent(),
            title = _gtxt('FireVirtualLayer.zoomInMessage') || titelHash.zoomInMessage,
            cont = L.DomUtil.create('div', '');
        cont.appendChild(html);
        var zoomLink = L.DomUtil.create('div', '', cont); // zoomLink = $('<div style="margin-top: 5px;"><a href="javascript:void(0)"><i>' + title + '</i></a></div>').click(function() {
        // _this._map.closePopup(event.popup);
        // _this._map.setView(event.gmx.latlng, _this.options.minGeomZoom + 3);
        // });
        // var div = $('<div/>').html(html).append(zoomLink);

        zoomLink.style.marginTop = '5px';
        zoomLink.innerHTML = '<a href="javascript:void(0)"><i>' + title + '</i></a>';
        L.DomEvent.on(zoomLink, 'click', function (ev) {
          _this._map.closePopup(event.popup);

          _this._map.setView(event.gmx.latlng, _this.options.minGeomZoom + 3);
        }, this);
        event.popup.setContent(cont); // event.popup.setContent(div[0]);
      });
    },
    onAdd: function onAdd(map) {
      buildModisPixelDimensionsTable();
      this._map = map;
      this._layerIsVisible = true;

      this._lazyLoadDataLayers().then(function () {
        if (!this._map || !this._layerIsVisible) {
          return;
        }

        map.on('zoomend', this._updateLayersVisibility, this);
        map.on('moveend', this._updateBbox, this);

        this._updateLayersVisibility();

        this._updateBbox(); // this._hotspotLayer.setZIndex(this.options.zIndex);
        // this._clustersLayer.setZIndex(this.options.zIndex);
        // this._clustersGeomLayer.setZIndex(this.options.zIndex);


        map.addLayer(this._clustersLayer);
        map.addLayer(this._clustersGeomLayer);
        map.addLayer(this._hotspotLayer);
      }.bind(this));
    },
    onRemove: function onRemove(map) {
      delete this._map;
      this._layerIsVisible = false;
      map.off('moveend', this._updateBbox, this);
      map.off('zoomend', this._updateLayersVisibility, this);

      this._updateLayersVisibility();

      this._lazyLoadDataLayers().then(function () {
        if (this._layerIsVisible) {
          return;
        }

        map.removeLayer(this._clustersGeomLayer);
        map.removeLayer(this._clustersLayer);
        map.removeLayer(this._hotspotLayer);

        if (this._heatmapLayer) {
          map.removeLayer(this._heatmapLayer);
        }
      }.bind(this)); // map.removeLayer(this._clustersGeomLayer);
      // map.removeLayer(this._clustersLayer);
      // map.removeLayer(this._hotspotLayer);

    },
    setDateInterval: function setDateInterval(dateBegin, dateEnd) {
      this._dateBegin = dateBegin;
      this._dateEnd = dateEnd;
      this._rawClusterLayer && this._rawClusterLayer.setDateInterval(dateBegin, dateEnd);
      this._hotspotLayer && this._hotspotLayer.setDateInterval(dateBegin, dateEnd); //this._observerHeatmap && this._observerHeatmap.setDateInterval(dateBegin, dateEnd);

      this._observerClusters && this._observerClusters.setDateInterval(dateBegin, dateEnd);
      this._observerHotspots && this._observerHotspots.setDateInterval(dateBegin, dateEnd);
    },
    _updateBbox: function _updateBbox() {
      var observersBbox = this._observerHotspots.bbox,
          screenBounds = this._map.getBounds(),
          p1 = screenBounds.getNorthWest(),
          p2 = screenBounds.getSouthEast(),
          newBbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]),
          extendedBbox = getExtendedBbox(observersBbox, newBbox);

      if (extendedBbox) {
        this._observerHotspots.setBounds(extendedBbox);

        this._observerClusters.setBounds(extendedBbox);

        if (this._observerHeatmap) {
          this._observerHeatmap.setBounds(extendedBbox);
        }
      }
    },
    //load layers add add observers
    _lazyLoadDataLayers: function _lazyLoadDataLayers() {
      if (this._loadLayersPromise) {
        return this._loadLayersPromise;
      }

      var heatmapLayerID = this.options.heatmapLayerID || this.options.hotspotLayerID;
      this._loadLayersPromise = L.gmx.loadLayers([{
        mapID: this.options.mapID,
        layerID: this.options.hotspotLayerID
      }, {
        mapID: this.options.mapID,
        layerID: this.options.dailyLayerID
      }], {
        hostName: this.options.hostName
      }).then(function (arr) {
        var rawHotspotLayer = arr[0];
        var rawClustersLayer = arr[1];

        if (this.options.minHotspotZoom) {
          var minZoom = this.options.minHotspotZoom;
          rawHotspotLayer.setStyles(rawHotspotLayer.getStyles().map(function (style) {
            style.MinZoom = minZoom;
            return style;
          }));
        }

        var rawHeatmapLayer;

        if (heatmapLayerID === rawHotspotLayer.options.layerID) {
          rawHeatmapLayer = rawHotspotLayer;
        }

        if (heatmapLayerID === rawClustersLayer.options.layerID) {
          rawHeatmapLayer = rawClustersLayer;
        }

        this._hotspotLayer = rawHotspotLayer;

        if (this._dateBegin && this._dateEnd) {
          this._hotspotLayer.setDateInterval(this._dateBegin, this._dateEnd);
        }

        this._rawClusterLayer = rawClustersLayer;

        if (this.options['z_index']) {
          this._hotspotLayer.setZIndex(this.options['z_index'] + 1);

          this._rawClusterLayer.setZIndex(this.options['z_index'] + 2);
        }

        if (this._heatmapLayer) {
          this._observerHeatmap = rawHeatmapLayer._observer = rawHeatmapLayer.addObserver({
            type: 'update',
            callback: this._createHeatmapObserverCallback(rawHeatmapLayer, this._heatmapLayer),
            active: !!this._map,
            dateInterval: [this._dateBegin, this._dateEnd]
          });
        }

        this._observerClusters = rawClustersLayer._observer = rawClustersLayer.addObserver({
          type: 'update',
          callback: this._updateClustersByObject(this._clustersLayer, false, 'ParentClusterId', 'HotSpotCount', rawClustersLayer),
          active: !!this._map,
          dateInterval: [this._dateBegin, this._dateEnd]
        });
        this._observerHotspots = rawHotspotLayer._observer = rawHotspotLayer.addObserver({
          type: 'update',
          callback: this._updateClustersByObject(this._clustersGeomLayer, true, 'ClusterID', null, rawHotspotLayer),
          active: !!this._map,
          dateInterval: [this._dateBegin, this._dateEnd]
        });
      }.bind(this));
      return this._loadLayersPromise;
    },
    _createHeatmapObserverCallback: function _createHeatmapObserverCallback(srcLayer, heatLayer) {
      var pointsBuffer = [];
      var weightFieldsHash = {
        'F2840D287CD943C4B1122882C5B92565': 4,
        'C13B4D9706F7491EBC6DC70DFFA988C0': 4,
        'E58063D97D534BB4BBDFF07FE5CB17F2': 1,
        'F62E1DCBA3D94FA39BF69264FAA6552B': 1,
        '82D0482AC31546CFB80FABC68600103A': 1,
        '3E88643A8AC94AFAB4FD44941220B1CE': 1
      };

      function addData(data) {
        pointsBuffer = pointsBuffer.concat(data);
        return pointsBuffer;
      }

      function removeData(data) {
        pointsBuffer = pointsBuffer.filter(function (it) {
          return !data.find(function (d) {
            return d.id === it.id;
          });
        });
        return pointsBuffer;
      }

      function parser(data) {
        return data.map(function (d) {
          var props = d.properties;
          var latlng = L.Projection.Mercator.unproject({
            y: props[props.length - 1].coordinates[1],
            x: props[props.length - 1].coordinates[0]
          });
          var r = [latlng.lat, latlng.lng];
          var fi = weightFieldsHash[srcLayer.options.layerID];
          fi && props[fi] && r.push(factor(props[fi]));
          return r;
        });
      }

      function factor(w) {
        return 3800 * (Math.pow(Math.log(w + 1), 1.3) / 3.5);
      }

      return function (data) {
        // pointsBuffer = [];
        // data.removed && removeData(data.removed);
        // data.added && addData(data.added);
        data.added && addData(data.added);
        data.removed && removeData(data.removed);
        heatLayer.setLatLngs(parser(pointsBuffer)); // heatLayer.redraw();
      };
    },
    _updateClustersByObject: function _updateClustersByObject(layer, estimeteGeometry, clusterAttr, countAttr, fromLayer) {
      var indexes = fromLayer._gmx.tileAttributeIndexes,
          dateAttr = fromLayer.getGmxProperties().TemporalColumnName,
          idAttr = fromLayer.getGmxProperties().identityField;

      if (!(clusterAttr in indexes)) {
        clusterAttr = idAttr;
      }

      var parseItem = function parseItem(item) {
        var props = item.properties;
        return {
          properties: L.gmxUtil.getPropertiesHash(props, indexes),
          geometry: props[props.length - 1]
        };
      };

      var clusters = {};
      return function (data) {
        var objects = [];
        var clustersToRepaint = {};
        (data.removed || []).map(function (it) {
          objects.push({
            onExtent: false,
            item: parseItem(it)
          });
        });
        (data.added || []).map(function (it) {
          objects.push({
            onExtent: true,
            item: parseItem(it)
          });
        });

        for (var k = 0; k < objects.length; k++) {
          var props = objects[k].item.properties;
          var mult = objects[k].onExtent ? 1 : -1;
          var count = (countAttr ? props[countAttr] : 1) * mult;
          if (!props[clusterAttr]) continue;
          var clusterId = '_' + props[clusterAttr];
          var hotspotId = '_' + props[idAttr];

          if (!clusters[clusterId]) {
            clusters[clusterId] = {
              spots: {},
              lat: 0,
              lng: 0,
              count: 0,
              startDate: Number.POSITIVE_INFINITY,
              endDate: Number.NEGATIVE_INFINITY,
              isIndustrial: false
            };
          }

          var cluster = clusters[clusterId]; //Ð´Ð²Ð° ÑÐ°Ð·Ð° Ð¾Ð´Ð½Ñ Ð¸ ÑÑ Ð¶Ðµ ÑÐ¾ÑÐºÑ Ð½Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼

          if (hotspotId in cluster.spots && objects[k].onExtent) continue;
          var coords = objects[k].item.geometry.coordinates,
              latlng = L.Projection.SphericalMercator.unproject({
            y: coords[1],
            x: coords[0]
          });
          if (objects[k].onExtent) cluster.spots[hotspotId] = [latlng.lng, latlng.lat, 250]; //TODO: Ð²ÑÐ±ÑÐ°ÑÑ Ð¿ÑÐ°Ð²Ð¸Ð»ÑÐ½ÑÐ¹ Ð½Ð¾Ð¼ÐµÑ sample
          else delete cluster.spots[hotspotId];
          var hotspotDate = props[dateAttr];
          cluster.lat += count * coords[1];
          cluster.lng += count * coords[0];
          cluster.count += count;
          cluster.startDate = Math.min(cluster.startDate, hotspotDate);
          cluster.endDate = Math.max(cluster.endDate, hotspotDate);
          cluster.isIndustrial = cluster.isIndustrial || Number(props.FireType) & 1;
          clustersToRepaint[clusterId] = true;
        }

        var clustersToAdd = [],
            itemIDsToRemove = [];

        for (var k in clustersToRepaint) {
          var cluster = clusters[k],
              count = cluster.count;

          if (count) {
            var strStartDate = dateToString(cluster.startDate);
            var strEndDate = dateToString(cluster.endDate);
            var newItem = [k, String(Math.pow(Math.log(count + 1), 1.3) / 3.5), count, count >= 10 ? count : null, cluster.startDate, cluster.endDate, cluster.startDate === cluster.endDate ? strEndDate : strStartDate + '-' + strEndDate, Number(cluster.isIndustrial)];

            if (estimeteGeometry) {
              var points = [];

              for (var p in clusters[k].spots) {
                points.push(clusters[k].spots[p]);
              }

              var multiPolygon = _hq.getPixelMultiPolygon(points);

              var tmpPolygon = _hq.MultiPolygonUnion(multiPolygon);

              newItem.push({
                type: 'MULTIPOLYGON',
                coordinates: tmpPolygon
              });
            } else {
              newItem.push({
                type: 'POINT',
                coordinates: [clusters[k].lng / count, clusters[k].lat / count]
              });
            }

            clustersToAdd.push(newItem);
          } else {
            itemIDsToRemove.push(k);
            delete clusters[k];
          }
        }

        layer.addData(clustersToAdd);
        layer.removeData(itemIDsToRemove);
      };
    },
    _updateLayersVisibility: function _updateLayersVisibility() {
      var map = this._map,
          isVisible = !!map,
          zoom = map && map.getZoom();
      /*
                  map.removeLayer(this._clustersGeomLayer);
                  map.removeLayer(this._clustersLayer);
                  map.removeLayer(this._hotspotLayer);
                  if (this._heatmapLayer) { map.removeLayer(this._heatmapLayer); }
                  // map.addLayer(this._clustersLayer);
                  // map.addLayer(this._clustersGeomLayer);
                  // map.addLayer(this._hotspotLayer);
              if (this._observerHotspots) {
      			this._observerHotspots.toggleActive(isVisible && zoom >= this.options.minGeomZoom);
      			map[this._observerHotspots.active ? 'addLayer' : 'removeLayer'](this._hotspotLayer);
      		}
      
              if (this._observerClusters) {
      			var active = isVisible && zoom <  this.options.minGeomZoom && zoom >= this.options.minClustersZoom;
      			this._observerClusters.toggleActive(active);
      			// if (active) {
      				// map.removeLayer(this._clustersGeomLayer);
      			// } else {
      			// }
      			// map[active ? 'addLayer' : 'removeLayer'](this._clustersLayer);
      		}
      
              if (this._observerHeatmap) {
      			this._observerHeatmap.toggleActive(isVisible && zoom < this.options.minClustersZoom);
      			map[this._observerHeatmap.active ? 'addLayer' : 'removeLayer'](this._heatmapLayer);
      		}
      		*/

      this._observerHotspots && this._observerHotspots.toggleActive(isVisible && zoom >= this.options.minGeomZoom);
      this._observerClusters && this._observerClusters.toggleActive(isVisible && zoom < this.options.minGeomZoom && zoom >= this.options.minClustersZoom);
      this._observerHeatmap && this._observerHeatmap.toggleActive(isVisible && zoom < this.options.minClustersZoom); // this._heatmapLayer && this._heatmapLayer.setVisibility(isVisible && zoom < this.options.minClustersZoom);
      // map && ((isVisible && zoom < this.options.minClustersZoom) ? map.addLayer(this._heatmapLayer) : map.removeLayer(this._heatmapLayer));

      if (map) {
        if (zoom < this.options.minClustersZoom) {
          if (this._heatmapLayer) {
            map.addLayer(this._heatmapLayer);
          }

          map.removeLayer(this._clustersLayer);
        } else {
          map.addLayer(this._clustersLayer);

          if (this._heatmapLayer) {
            map.removeLayer(this._heatmapLayer);
          }
        }
      }
    }
  });

  var FireVirtualFactory = function FireVirtualFactory() {};

  FireVirtualFactory.prototype.initFromDescription = function (layerDescription) {
    var props = layerDescription.properties,
        meta = props.MetaProperties;
    var options = {
      mapID: meta.mapID.Value,
      hotspotLayerID: meta.hotspotLayerID.Value,
      dailyLayerID: meta.dailyLayerID.Value,
      heatmapLayerID: meta.heatmapLayerID && meta.heatmapLayerID.Value,
      z_index: meta.z_index && Number(meta.z_index.Value)
    };

    if ('minGeomZoom' in meta) {
      options.minGeomZoom = Number(meta.minGeomZoom.Value);
    }

    if ('minHotspotZoom' in meta) {
      options.minHotspotZoom = Number(meta.minHotspotZoom.Value);
    }

    if ('minClustersZoom' in meta) {
      options.minClustersZoom = Number(meta.minClustersZoom.Value);
    }

    if ('z_index' in meta) {
      options.zIndex = Number(meta.z_index.Value);
    } // if ('zIndex' in meta) {
    // options.zIndex = Number(meta.zIndex.Value);
    // }


    var layer = new FireVirtualLayer(options);

    layer.getGmxProperties = function () {
      return props;
    };

    return layer;
  };

  L.gmx.addLayerClass('Fire', FireVirtualFactory); // L.gmx.addLayerClass('Fire', FireVirtualLayer);

  if (window.gmxCore) {
    gmxCore.addModule('FireVirtualLayer', {
      layerClass: FireVirtualFactory
    }, {
      css: 'FirePlugin.css',
      init: function init(module, path) {
        initTranslations();
        return gmxCore.loadScriptWithCheck([{
          check: function check() {
            return window.SpatialQuery;
          },
          script: path + 'spatial_query.js'
        }]);
      }
    });
  }
})();

var GmxDrawingContextMenu = /*#__PURE__*/function () {
  function GmxDrawingContextMenu() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      points: [],
      lines: [],
      fill: []
    };

    _classCallCheck(this, GmxDrawingContextMenu);

    this.options = options;
  }

  _createClass(GmxDrawingContextMenu, [{
    key: "insertItem",
    value: function insertItem(obj, index, type) {
      var optKey = type || 'points';

      if (index === undefined) {
        index = this.options[optKey].length;
      }

      this.options[optKey].splice(index, 0, obj);
      return this;
    }
  }, {
    key: "removeItem",
    value: function removeItem(obj, type) {
      var optKey = type || 'points';

      for (var i = 0, len = this.options[optKey].length; i < len; i++) {
        if (this.options[optKey][i].callback === obj.callback) {
          this.options[optKey].splice(i, 1);
          break;
        }
      }

      return this;
    }
  }, {
    key: "removeAllItems",
    value: function removeAllItems(type) {
      if (!type) {
        this.options = {
          points: [],
          lines: []
        };
      } else if (type === 'lines') {
        this.options.lines = [];
      } else {
        this.options.points = [];
      }

      return this;
    }
  }, {
    key: "getItems",
    value: function getItems() {
      return this.options;
    }
  }]);

  return GmxDrawingContextMenu;
}();

L$1.GmxDrawingContextMenu = GmxDrawingContextMenu;
var GmxDrawingContextMenu$1 = L$1.GmxDrawingContextMenu;

var rectDelta = 0.0000001;
var stateVersion = '1.0.0';
L$1.GmxDrawing = L$1.Class.extend({
  options: {
    type: ''
  },
  includes: L$1.Evented ? L$1.Evented.prototype : L$1.Mixin.Events,
  initialize: function initialize(map) {
    this._map = map;
    this.items = [];
    this.current = null;
    this.contextmenu = new GmxDrawingContextMenu$1({
      // points: [], // [{text: 'Remove point'}, {text: 'Delete feature'}],
      points: [{
        text: 'Move'
      }, {
        text: 'Rotate'
      }, {
        text: 'Remove point'
      }, {
        text: 'Delete feature'
      }],
      // , {text: 'Rotate around Point'}
      bbox: [{
        text: 'Save'
      }, {
        text: 'Cancel'
      }],
      fill: [{
        text: 'Rotate'
      }, {
        text: 'Move'
      }]
    });

    if (L$1.gmxUtil && L$1.gmxUtil.prettifyDistance) {
      var svgNS = 'http://www.w3.org/2000/svg';
      var tooltip = document.createElementNS(svgNS, 'g');
      L$1.DomUtil.addClass(tooltip, 'gmxTooltip');
      var bg = document.createElementNS(svgNS, 'rect');
      bg.setAttributeNS(null, 'rx', 4);
      bg.setAttributeNS(null, 'ry', 4);
      bg.setAttributeNS(null, 'height', 16);
      L$1.DomUtil.addClass(bg, 'gmxTooltipBG');
      var text = document.createElementNS(svgNS, 'text');
      var userSelectProperty = L$1.DomUtil.testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);
      text.style[userSelectProperty] = 'none';
      tooltip.appendChild(bg);
      tooltip.appendChild(text);

      this.hideTooltip = function () {
        tooltip.setAttributeNS(null, 'visibility', 'hidden');
      };

      this.showTooltip = function (point, mouseovertext) {
        var x = point.x + 11,
            y = point.y - 14;
        text.setAttributeNS(null, 'x', x);
        text.setAttributeNS(null, 'y', y);
        text.textContent = mouseovertext;

        if (tooltip.getAttributeNS(null, 'visibility') !== 'visible') {
          (this._map._pathRoot || this._map._renderer._container).appendChild(tooltip);

          tooltip.setAttributeNS(null, 'visibility', 'visible');
        }

        var length = text.getComputedTextLength();
        bg.setAttributeNS(null, 'width', length + 8);
        bg.setAttributeNS(null, 'x', x - 4);
        bg.setAttributeNS(null, 'y', y - 12);
      };
    }

    this.on('drawstop drawstart', function (ev) {
      this.drawMode = this._drawMode = ev.mode;

      this._map.doubleClickZoom[this.drawMode === 'edit' ? 'disable' : 'enable']();
    }, this);
  },
  bringToFront: function bringToFront() {
    for (var i = 0, len = this.items.length; i < len; i++) {
      var item = this.items[i];

      if (item._map && 'bringToFront' in item) {
        item.bringToFront();
      }
    }
  },
  addGeoJSON: function addGeoJSON(obj, options) {
    var arr = [],
        isLGeoJSON = obj instanceof L$1.GeoJSON;

    if (!isLGeoJSON) {
      obj = L$1.geoJson(obj, options);
    }

    if (obj instanceof L$1.GeoJSON) {
      var layers = obj.getLayers();

      if (layers) {
        var parseLayer = function parseLayer(it) {
          var _originalStyle = null;

          if (it.setStyle && options && options.lineStyle) {
            _originalStyle = {};

            for (var key in options.lineStyle) {
              _originalStyle[key] = options.lineStyle[key];
            }

            it.setStyle(options.lineStyle);
          }

          var f = this.add(it, options);
          f._originalStyle = _originalStyle;
          arr.push(f);
        };

        for (var i = 0, len = layers.length; i < len; i++) {
          var layer = layers[i];

          if (layer.feature.geometry.type !== 'GeometryCollection') {
            layer = L$1.layerGroup([layer]);
          }

          layer.eachLayer(parseLayer, this);
        }
      }
    }

    return arr;
  },
  add: function add(obj, options) {
    var item = null;
    options = options || {};

    if (obj) {
      if (obj instanceof L$1.GmxDrawing.Feature) {
        item = obj;
      } else {
        var calcOptions = {};

        if (obj.feature && obj.feature.geometry) {
          var type = obj.feature.geometry.type;

          if (type === 'Point') {
            obj = new L$1.Marker(obj._latlng);
          } else if (type === 'MultiPolygon') {
            calcOptions.type = type;
          }
        } // if (!L.MultiPolygon) { L.MultiPolygon = L.Polygon; }
        // if (!L.MultiPolyline) { L.MultiPolyline = L.Polyline; }


        if (!options || !('editable' in options)) {
          calcOptions.editable = true;
        }

        if (obj.geometry) {
          calcOptions.type = obj.geometry.type;
        } else if (obj instanceof L$1.Rectangle) {
          calcOptions.type = 'Rectangle';
        } else if (obj instanceof L$1.Polygon) {
          calcOptions.type = calcOptions.type || 'Polygon';
        } else if (L$1.MultiPolygon && obj instanceof L$1.MultiPolygon) {
          calcOptions.type = 'MultiPolygon';
        } else if (obj instanceof L$1.Polyline) {
          calcOptions.type = 'Polyline';
        } else if (L$1.MultiPolyline && obj instanceof L$1.MultiPolyline) {
          calcOptions.type = 'MultiPolyline';
        } else if (obj.setIcon || obj instanceof L$1.Marker) {
          calcOptions.type = 'Point';
          calcOptions.editable = false;
          obj.options.draggable = true;
        }

        options = this._chkDrawOptions(calcOptions.type, options);
        L$1.extend(options, calcOptions);

        if (obj.geometry) {
          var iconStyle = options.markerStyle && options.markerStyle.iconStyle;

          if (options.type === 'Point' && !options.pointToLayer && iconStyle) {
            options.icon = L$1.icon(iconStyle);

            options.pointToLayer = function (geojson, latlng) {
              return new L$1.Marker(latlng, options);
            };
          }

          return this.addGeoJSON(obj, options);
        }

        item = new L$1.GmxDrawing.Feature(this, obj, options);
      }

      if (!('map' in options)) {
        options.map = true;
      }

      if (options.map && !item._map && this._map) {
        this._map.addLayer(item);
      } else {
        this._addItem(item);
      } //if (!item._map) this._map.addLayer(item);
      //if (item.points) item.points._path.setAttribute('fill-rule', 'inherit');


      if ('setEditMode' in item) {
        item.setEditMode();
      }
    }

    return item;
  },
  _disableDrag: function _disableDrag() {
    if (this._map) {
      this._map.dragging.disable();

      L$1.DomUtil.disableTextSelection();
      L$1.DomUtil.disableImageDrag();

      this._map.doubleClickZoom.removeHooks();
    }
  },
  _enableDrag: function _enableDrag() {
    if (this._map) {
      this._map.dragging.enable();

      L$1.DomUtil.enableTextSelection();
      L$1.DomUtil.enableImageDrag();

      this._map.doubleClickZoom.addHooks();
    }
  },
  clearCreate: function clearCreate() {
    this._clearCreate();
  },
  _clearCreate: function _clearCreate() {
    if (this._createKey && this._map) {
      if (this._createKey.type === 'Rectangle' && L$1.Browser.mobile) {
        L$1.DomEvent.off(this._map._container, 'touchstart', this._createKey.fn, this);
      } else {
        this._map.off(this._createKey.eventName, this._createKey.fn, this);

        this._map.off('mousemove', this._onMouseMove, this);
      }

      this._enableDrag();
    }

    if (this._firstPoint) {
      this._map.removeLayer(this._firstPoint);

      this._firstPoint = null;
    }

    this._createKey = null;
  },
  _chkDrawOptions: function _chkDrawOptions(type, drawOptions) {
    var defaultStyles = L$1.GmxDrawing.utils.defaultStyles,
        resultStyles = {};

    if (!drawOptions) {
      drawOptions = L$1.extend({}, defaultStyles);
    }

    if (type === 'Point') {
      L$1.extend(resultStyles, defaultStyles.markerStyle.options.icon, drawOptions);
    } else {
      L$1.extend(resultStyles, drawOptions);
      resultStyles.lineStyle = L$1.extend({}, defaultStyles.lineStyle, drawOptions.lineStyle);
      resultStyles.pointStyle = L$1.extend({}, defaultStyles.pointStyle, drawOptions.pointStyle);
      resultStyles.holeStyle = L$1.extend({}, defaultStyles.holeStyle, drawOptions.holeStyle);
    }

    if (resultStyles.iconUrl) {
      var iconStyle = {
        iconUrl: resultStyles.iconUrl
      };
      delete resultStyles.iconUrl;

      if (resultStyles.iconAnchor) {
        iconStyle.iconAnchor = resultStyles.iconAnchor;
        delete resultStyles.iconAnchor;
      }

      if (resultStyles.iconSize) {
        iconStyle.iconSize = resultStyles.iconSize;
        delete resultStyles.iconSize;
      }

      if (resultStyles.popupAnchor) {
        iconStyle.popupAnchor = resultStyles.popupAnchor;
        delete resultStyles.popupAnchor;
      }

      if (resultStyles.shadowSize) {
        iconStyle.shadowSize = resultStyles.shadowSize;
        delete resultStyles.shadowSize;
      }

      resultStyles.markerStyle = {
        iconStyle: iconStyle
      };
    }

    return resultStyles;
  },
  create: function create(type, options) {
    this._clearCreate(null);

    if (type && this._map) {
      var map = this._map,
          drawOptions = this._chkDrawOptions(type, options),
          my = this;

      if (type === 'Rectangle') {
        //map._initPathRoot();
        map.dragging.disable();
      }

      this._createKey = {
        type: type,
        eventName: type === 'Rectangle' ? L$1.Browser.mobile ? 'touchstart' : 'mousedown' : 'click',
        fn: function fn(ev) {
          var originalEvent = ev && ev.originalEvent,
              ctrlKey = false,
              shiftKey = false,
              altKey = false;

          if (originalEvent) {
            ctrlKey = originalEvent.ctrlKey;
            shiftKey = originalEvent.shiftKey;
            altKey = originalEvent.altKey;
            var clickOnTag = originalEvent.target.tagName;

            if (clickOnTag === 'g' || clickOnTag === 'path') {
              return;
            }
          }

          my._createType = '';
          var obj,
              key,
              opt = {},
              latlng = ev.latlng;

          for (key in drawOptions) {
            if (!(key in L$1.GmxDrawing.utils.defaultStyles)) {
              opt[key] = drawOptions[key];
            }
          }

          if (ctrlKey && my._firstPoint && my._firstPoint._snaped) {
            latlng = my._firstPoint._snaped;
          }

          if (type === 'Point') {
            var markerStyle = drawOptions.markerStyle || {},
                markerOpt = {
              draggable: true
            };

            if (originalEvent) {
              markerOpt.ctrlKey = ctrlKey;
              markerOpt.shiftKey = shiftKey;
              markerOpt.altKey = altKey;
            }

            if (markerStyle.iconStyle) {
              markerOpt.icon = L$1.icon(markerStyle.iconStyle);
            }

            obj = my.add(new L$1.Marker(latlng, markerOpt), opt);
          } else {
            if (drawOptions.pointStyle) {
              opt.pointStyle = drawOptions.pointStyle;
            }

            if (drawOptions.lineStyle) {
              opt.lineStyle = drawOptions.lineStyle;
            }

            if (type === 'Rectangle') {
              // if (L.Browser.mobile) {
              // var downAttr = L.GmxDrawing.utils.getDownType.call(my, ev, my._map);
              // latlng = downAttr.latlng;
              // }
              opt.mode = 'edit';
              obj = my.add(L$1.rectangle(L$1.latLngBounds(L$1.latLng(latlng.lat + rectDelta, latlng.lng - rectDelta), latlng)), opt);

              if (L$1.Browser.mobile) {
                obj._startTouchMove(ev, true);
              } else {
                obj._pointDown(ev);
              }

              obj.rings[0].ring._drawstop = true;
            } else if (type === 'Polygon') {
              opt.mode = 'add';
              obj = my.add(L$1.polygon([latlng]), opt);
              obj.setAddMode();
            } else if (type === 'Polyline') {
              opt.mode = 'add';
              obj = my.add(L$1.polyline([latlng]), opt).setAddMode();
            }
          }

          my._clearCreate();
        }
      };

      if (type === 'Rectangle' && L$1.Browser.mobile) {
        L$1.DomEvent.on(map._container, 'touchstart', this._createKey.fn, this);
      } else {
        map.on(this._createKey.eventName, this._createKey.fn, this);
        map.on('mousemove', this._onMouseMove, this);
      }

      this._createType = type;
      L$1.DomUtil.addClass(map._mapPane, 'leaflet-clickable');
      this.fire('drawstart', {
        mode: type
      });
    }

    this.options.type = type;
  },
  _onMouseMove: function _onMouseMove(ev) {
    var latlngs = [ev.latlng];

    if (!this._firstPoint) {
      this._firstPoint = new L$1.GmxDrawing.PointMarkers(latlngs, {
        interactive: false
      });

      this._map.addLayer(this._firstPoint);
    } else {
      this._firstPoint.setLatLngs(latlngs);
    }
  },
  extendDefaultStyles: function extendDefaultStyles(drawOptions) {
    var defaultStyles = L$1.GmxDrawing.utils.defaultStyles;
    drawOptions = drawOptions || {};

    if (drawOptions.iconUrl) {
      var iconStyle = defaultStyles.markerStyle.options.icon;
      iconStyle.iconUrl = drawOptions.iconUrl;
      delete drawOptions.iconUrl;

      if (drawOptions.iconAnchor) {
        iconStyle.iconAnchor = drawOptions.iconAnchor;
        delete drawOptions.iconAnchor;
      }

      if (drawOptions.iconSize) {
        iconStyle.iconSize = drawOptions.iconSize;
        delete drawOptions.iconSize;
      }

      if (drawOptions.popupAnchor) {
        iconStyle.popupAnchor = drawOptions.popupAnchor;
        delete drawOptions.popupAnchor;
      }

      if (drawOptions.shadowSize) {
        iconStyle.shadowSize = drawOptions.shadowSize;
        delete drawOptions.shadowSize;
      }
    }

    if (drawOptions.lineStyle) {
      L$1.extend(defaultStyles.lineStyle, drawOptions.lineStyle);
      delete drawOptions.lineStyle;
    }

    if (drawOptions.pointStyle) {
      L$1.extend(defaultStyles.pointStyle, drawOptions.pointStyle);
      delete drawOptions.pointStyle;
    }

    if (drawOptions.holeStyle) {
      L$1.extend(defaultStyles.holeStyle, drawOptions.holeStyle);
      delete drawOptions.holeStyle;
    }

    L$1.extend(defaultStyles, drawOptions);
    return this;
  },
  getFeatures: function getFeatures() {
    var out = [];

    for (var i = 0, len = this.items.length; i < len; i++) {
      out.push(this.items[i]);
    }

    return out;
  },
  loadState: function loadState(data) {
    //if (data.version !== stateVersion) return;
    var _this = this,
        featureCollection = data.featureCollection;

    L$1.geoJson(featureCollection, {
      onEachFeature: function onEachFeature(feature, layer) {
        var options = feature.properties,
            popupOpened = options.popupOpened;

        if (options.type === 'Rectangle') {
          layer = L$1.rectangle(layer.getBounds());
        } else if (options.type === 'Point') {
          options = options.options;
          var icon = options.icon;

          if (icon) {
            delete options.icon;

            if (icon.iconUrl) {
              options.icon = L$1.icon(icon);
            }
          }

          layer = L$1.marker(layer.getLatLng(), options);
        }

        if (layer.setStyle && options && options.lineStyle) {
          layer.setStyle(options.lineStyle);
        }

        _this.add(layer, options);

        if (popupOpened) {
          layer.openPopup();
        }
      }
    });
  },
  saveState: function saveState() {
    var featureGroup = L$1.featureGroup();
    var points = [];

    for (var i = 0, len = this.items.length; i < len; i++) {
      var it = this.items[i];

      if (it.options.type === 'Point') {
        var geojson = it.toGeoJSON();
        geojson.properties = L$1.GmxDrawing.utils.getNotDefaults(it.options, L$1.GmxDrawing.utils.defaultStyles.markerStyle);

        if (!it._map) {
          geojson.properties.map = false;
        } else if (it._map.hasLayer(it.getPopup())) {
          geojson.properties.popupOpened = true;
        }

        var res = L$1.GmxDrawing.utils.getNotDefaults(it._obj.options, L$1.GmxDrawing.utils.defaultStyles.markerStyle.options);

        if (Object.keys(res).length) {
          geojson.properties.options = res;
        }

        res = L$1.GmxDrawing.utils.getNotDefaults(it._obj.options.icon.options, L$1.GmxDrawing.utils.defaultStyles.markerStyle.options.icon);

        if (Object.keys(res).length) {
          if (!geojson.properties.options) {
            geojson.properties.options = {};
          }

          geojson.properties.options.icon = res;
        }

        points.push(geojson);
      } else {
        featureGroup.addLayer(it);
      }
    }

    var featureCollection = featureGroup.toGeoJSON();
    featureCollection.features = featureCollection.features.concat(points);
    return {
      version: stateVersion,
      featureCollection: featureCollection
    };
  },
  _addItem: function _addItem(item) {
    var addFlag = true;

    for (var i = 0, len = this.items.length; i < len; i++) {
      var it = this.items[i];

      if (it === item) {
        addFlag = false;
        break;
      }
    }

    if (addFlag) {
      this.items.push(item);
    }

    this.fire('add', {
      mode: item.mode,
      object: item
    });
  },
  _removeItem: function _removeItem(obj, remove) {
    for (var i = 0, len = this.items.length; i < len; i++) {
      var item = this.items[i];

      if (item === obj) {
        if (remove) {
          this.items.splice(i, 1);
          var ev = {
            type: item.options.type,
            mode: item.mode,
            object: item
          };
          this.fire('remove', ev);
          item.fire('remove', ev);
        }

        return item;
      }
    }

    return null;
  },
  clear: function clear() {
    for (var i = 0, len = this.items.length; i < len; i++) {
      var item = this.items[i];

      if (item && item._map) {
        item._map.removeLayer(item);
      }

      var ev = {
        type: item.options.type,
        mode: item.mode,
        object: item
      };
      this.fire('remove', ev);
      item.fire('remove', ev);
    }

    this.items = [];
    return this;
  },
  remove: function remove(obj) {
    var item = this._removeItem(obj, true);

    if (item && item._map) {
      item._map.removeLayer(item);
    }

    return item;
  }
});
L$1.Map.addInitHook(function () {
  this.gmxDrawing = new L$1.GmxDrawing(this);
});
L$1.GmxDrawing;

L$1.GmxDrawing.Feature = L$1.LayerGroup.extend({
  options: {
    endTooltip: '',
    smoothFactor: 0,
    mode: '' // add, edit

  },
  includes: L$1.Evented ? L$1.Evented.prototype : L$1.Mixin.Events,
  simplify: function simplify() {
    var i, j, len, len1, hole;

    for (i = 0, len = this.rings.length; i < len; i++) {
      var it = this.rings[i],
          ring = it.ring;
      ring.setLatLngs(ring.points.getPathLatLngs());

      for (j = 0, len1 = it.holes.length; j < len1; j++) {
        hole = it.holes[j];
        hole.setLatLngs(hole.points.getPathLatLngs());
      }
    }

    return this;
  },
  bringToFront: function bringToFront() {
    this.rings.forEach(function (it) {
      it.ring.bringToFront();
    });
    return this; // return this.invoke('bringToFront');
  },
  bringToBack: function bringToBack() {
    this.rings.forEach(function (it) {
      it.ring.bringToBack();
    });
    return this; // return this.invoke('bringToBack');
  },
  onAdd: function onAdd(map) {
    L$1.LayerGroup.prototype.onAdd.call(this, map);

    this._parent._addItem(this);

    if (this.options.type === 'Point') {
      map.addLayer(this._obj);
      requestIdleCallback(function () {
        this._fireEvent('drawstop', this._obj.options);
      }.bind(this), {
        timeout: 0
      });
    } else {
      var svgContainer = this._map._pathRoot || this._map._renderer && this._map._renderer._container;

      if (svgContainer && svgContainer.getAttribute('pointer-events') !== 'visible') {
        svgContainer.setAttribute('pointer-events', 'visible');
      }
    }

    this._fireEvent('addtomap');
  },
  onRemove: function onRemove(map) {
    if ('hideTooltip' in this) {
      this.hideTooltip();
    }

    this._removeStaticTooltip();

    L$1.LayerGroup.prototype.onRemove.call(this, map);

    if (this.options.type === 'Point') {
      map.removeLayer(this._obj);
    }

    this._fireEvent('removefrommap');
  },
  remove: function remove(ring) {
    if (ring) {
      var i, j, len, len1, hole;

      for (i = 0, len = this.rings.length; i < len; i++) {
        if (ring.options.hole) {
          for (j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
            hole = this.rings[i].holes[j];

            if (ring === hole) {
              this.rings[i].holes.splice(j, 1);

              if (hole._map) {
                hole._map.removeLayer(hole);
              }

              break;
            }
          }

          if (!ring._map) {
            break;
          }
        } else if (ring === this.rings[i].ring) {
          for (j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
            hole = this.rings[i].holes[j];

            if (hole._map) {
              hole._map.removeLayer(hole);
            }
          }

          this.rings.splice(i, 1);

          if (ring._map) {
            ring._map.removeLayer(ring);
          }

          break;
        }
      }
    } else {
      this.rings = [];
    }

    if (this.rings.length < 1) {
      if (this._originalStyle) {
        this._obj.setStyle(this._originalStyle);
      }

      this._parent.remove(this);
    }

    return this;
  },
  _fireEvent: function _fireEvent(name, options) {
    //console.log('_fireEvent', name);
    if (name === 'removefrommap' && this.rings.length > 1) {
      return;
    }

    var event = L$1.extend({}, {
      mode: this.mode || '',
      object: this
    }, options);
    this.fire(name, event);

    this._parent.fire(name, event);

    if (name === 'drawstop' && this._map) {
      L$1.DomUtil.removeClass(this._map._mapPane, 'leaflet-clickable');
    }
  },
  getStyle: function getStyle() {
    var resultStyles = L$1.extend({}, this._drawOptions);
    delete resultStyles.holeStyle;

    if (resultStyles.type === 'Point') {
      L$1.extend(resultStyles, resultStyles.markerStyle.iconStyle);
      delete resultStyles.markerStyle;
    }

    return resultStyles;
  },
  setOptions: function setOptions(options) {
    if (options.lineStyle) {
      this._setStyleOptions(options.lineStyle, 'lines');
    }

    if (options.pointStyle) {
      this._setStyleOptions(options.pointStyle, 'points');
    }

    if ('editable' in options) {
      if (options.editable) {
        this.enableEdit();
      } else {
        this.disableEdit();
      }
    }

    L$1.setOptions(this, options);

    this._fireEvent('optionschange');

    return this;
  },
  _setStyleOptions: function _setStyleOptions(options, type) {
    for (var i = 0, len = this.rings.length; i < len; i++) {
      var it = this.rings[i].ring[type];
      it.setStyle(options);
      it.redraw();

      for (var j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
        it = this.rings[i].holes[j][type];
        it.setStyle(options);
        it.redraw();
      }
    }

    this._fireEvent('stylechange');
  },
  _setLinesStyle: function _setLinesStyle(options) {
    this._setStyleOptions(options, 'lines');
  },
  _setPointsStyle: function _setPointsStyle(options) {
    this._setStyleOptions(options, 'points');
  },
  getOptions: function getOptions() {
    var options = this.options,
        data = L$1.extend({}, options);
    data.lineStyle = options.lineStyle;
    data.pointStyle = options.pointStyle;
    var res = L$1.GmxDrawing.utils.getNotDefaults(data, L$1.GmxDrawing.utils.defaultStyles);

    if (!Object.keys(res.lineStyle).length) {
      delete res.lineStyle;
    }

    if (!Object.keys(res.pointStyle).length) {
      delete res.pointStyle;
    }

    if (!this._map) {
      res.map = false;
    }

    if (options.type === 'Point') {
      var opt = L$1.GmxDrawing.utils.getNotDefaults(this._obj.options, L$1.GmxDrawing.utils.defaultStyles.markerStyle.options);

      if (Object.keys(opt).length) {
        res.options = opt;
      }

      opt = L$1.GmxDrawing.utils.getNotDefaults(this._obj.options.icon.options, L$1.GmxDrawing.utils.defaultStyles.markerStyle.options.icon);

      if (Object.keys(opt).length) {
        res.options.icon = opt;
      }
    }

    return res;
  },
  _latLngsToCoords: function _latLngsToCoords(latlngs, closed) {
    var coords = L$1.GeoJSON.latLngsToCoords(L$1.GmxDrawing.utils.isOldVersion ? latlngs : latlngs[0]);

    if (closed) {
      var lastCoord = coords[coords.length - 1];

      if (lastCoord[0] !== coords[0][0] || lastCoord[1] !== coords[0][1]) {
        coords.push(coords[0]);
      }
    }

    return coords;
  },
  _latlngsAddShift: function _latlngsAddShift(latlngs, shiftPixel) {
    var arr = [];

    for (var i = 0, len = latlngs.length; i < len; i++) {
      arr.push(L$1.GmxDrawing.utils.getShiftLatlng(latlngs[i], this._map, shiftPixel));
    }

    return arr;
  },
  getPixelOffset: function getPixelOffset() {
    var p = this.shiftPixel;

    if (!p && this._map) {
      var mInPixel = 256 / L$1.gmxUtil.tileSizes[this._map._zoom];
      p = this.shiftPixel = new L$1.Point(Math.floor(mInPixel * this._dx), -Math.floor(mInPixel * this._dy));
    }

    return p || new L$1.Point(0, 0);
  },
  setOffsetToGeometry: function setOffsetToGeometry(dx, dy) {
    var i,
        len,
        j,
        len1,
        ring,
        latlngs,
        mInPixel = 256 / L$1.gmxUtil.tileSizes[this._map._zoom],
        shiftPixel = new L$1.Point(mInPixel * (this._dx || dx || 0), -mInPixel * (this._dy || dy || 0));

    for (i = 0, len = this.rings.length; i < len; i++) {
      var it = this.rings[i];
      ring = it.ring;
      latlngs = ring.points.getLatLngs();
      ring.setLatLngs(this._latlngsAddShift(latlngs, shiftPixel));

      if (it.holes && it.holes.length) {
        for (j = 0, len1 = it.holes.length; j < len1; j++) {
          ring = it.holes[j].ring;
          latlngs = ring.points.getLatLngs();
          ring.setLatLngs(this._latlngsAddShift(latlngs, shiftPixel));
        }
      }
    }

    this.setPositionOffset();
    return this;
  },
  setPositionOffset: function setPositionOffset(mercX, mercY) {
    this._dx = mercX || 0;
    this._dy = mercY || 0;

    if (this._map) {
      this.shiftPixel = null;
      var p = this.getPixelOffset();

      for (var i = 0, len = this.rings.length; i < len; i++) {
        this.rings[i].ring.setPositionOffset(p);

        for (var j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
          this.rings[i].holes[j].setPositionOffset(p);
        }
      }
    }
  },
  _getCoords: function _getCoords(withoutShift) {
    var type = this.options.type,
        closed = type === 'Polygon' || type === 'Rectangle' || type === 'MultiPolygon',
        shiftPixel = withoutShift ? null : this.shiftPixel,
        coords = [];

    for (var i = 0, len = this.rings.length; i < len; i++) {
      var it = this.rings[i],
          arr = this._latLngsToCoords(it.ring.points.getLatLngs(), closed, shiftPixel);

      if (closed) {
        arr = [arr];
      }

      if (it.holes && it.holes.length) {
        for (var j = 0, len1 = it.holes.length; j < len1; j++) {
          arr.push(this._latLngsToCoords(it.holes[j].points.getLatLngs(), closed, shiftPixel));
        }
      }

      coords.push(arr);
    }

    if (type === 'Polyline' || closed && type !== 'MultiPolygon') {
      coords = coords[0];
    }

    return coords;
  },
  _geoJsonToLayer: function _geoJsonToLayer(geoJson) {
    return L$1.geoJson(geoJson).getLayers()[0];
  },
  setGeoJSON: function setGeoJSON(geoJson) {
    this._initialize(this._parent, geoJson);

    return this;
  },
  toGeoJSON: function toGeoJSON() {
    return this._toGeoJSON(true);
  },
  _toGeoJSON: function _toGeoJSON(withoutShift) {
    var type = this.options.type,
        properties = this.getOptions(),
        coords;
    delete properties.mode;

    if (!this.options.editable || type === 'Point') {
      var obj = this._obj;

      if (obj instanceof L$1.GeoJSON) {
        obj = L$1.GmxDrawing.utils._getLastObject(obj).getLayers()[0];
      }

      var geojson = obj.toGeoJSON();
      geojson.properties = properties;
      return geojson;
    } else if (this.rings) {
      coords = this._getCoords(withoutShift);

      if (type === 'Rectangle') {
        type = 'Polygon';
      } else if (type === 'Polyline') {
        type = 'LineString';
      } else if (type === 'MultiPolyline') {
        type = 'MultiLineString';
      }
    }

    return L$1.GeoJSON.getFeature({
      feature: {
        type: 'Feature',
        properties: properties
      }
    }, {
      type: type,
      coordinates: coords
    });
  },
  getType: function getType() {
    return this.options.type;
  },
  hideFill: function hideFill() {
    if (this._fill._map) {
      this._map.removeLayer(this._fill);
    }
  },
  showFill: function showFill() {
    var geoJSON = this.toGeoJSON(),
        obj = L$1.GeoJSON.geometryToLayer(geoJSON, null, null, {
      weight: 0
    });

    this._fill.clearLayers();

    if (obj instanceof L$1.LayerGroup) {
      obj.eachLayer(function (layer) {
        this._fill.addLayer(layer);
      }, this);
    } else {
      obj.setStyle({
        smoothFactor: 0,
        weight: 0,
        fill: true,
        fillColor: '#0033ff'
      });

      this._fill.addLayer(obj);
    }

    if (!this._fill._map) {
      this._map.addLayer(this._fill);

      this._fill.bringToBack();
    }

    return this;
  },
  getBounds: function getBounds() {
    var bounds = new L$1.LatLngBounds();

    if (this.options.type === 'Point') {
      var latLng = this._obj.getLatLng();

      bounds.extend(latLng);
    } else {
      bounds = this._getBounds();
    }

    return bounds;
  },
  _getBounds: function _getBounds(item) {
    var layer = item || this,
        bounds = new L$1.LatLngBounds(),
        latLng;

    if (layer instanceof L$1.LayerGroup) {
      layer.eachLayer(function (it) {
        latLng = this._getBounds(it);
        bounds.extend(latLng);
      }, this);
      return bounds;
    } else if (layer instanceof L$1.Marker) {
      latLng = layer.getLatLng();
    } else {
      latLng = layer.getBounds();
    }

    bounds.extend(latLng);
    return bounds;
  },
  initialize: function initialize(parent, obj, options) {
    options = options || {};
    this.contextmenu = new L$1.GmxDrawingContextMenu();
    options.mode = '';
    this._drawOptions = L$1.extend({}, options);
    var type = options.type;

    if (type === 'Point') {
      delete options.pointStyle;
      delete options.lineStyle;
    } else {
      delete options.iconUrl;
      delete options.iconAnchor;
      delete options.iconSize;
      delete options.popupAnchor;
      delete options.shadowSize;
      delete options.markerStyle;
    }

    delete options.holeStyle;
    L$1.setOptions(this, options);
    this._layers = {};
    this._obj = obj;
    this._parent = parent;
    this._dx = 0;
    this._dy = 0;

    this._initialize(parent, obj);
  },
  enableEdit: function enableEdit() {
    this.options.mode = 'edit';
    var type = this.options.type;

    if (type !== 'Point') {
      // for (var i = 0, len = this.rings.length; i < len; i++) {
      // var it = this.rings[i];
      // it.ring.options.editable = this.options.editable;
      // it.ring.setEditMode();
      // for (var j = 0, len1 = it.holes.length; j < len1; j++) {
      // var hole = it.holes[j];
      // hole.options.editable = this.options.editable;
      // hole.setEditMode();
      // }
      // }
      var geojson = L$1.geoJson(this.toGeoJSON()),
          items = geojson.getLayers();
      this.options.editable = true;

      if (items.length) {
        this._initialize(this._parent, items[0]);
      }
    }

    return this;
  },
  disableEdit: function disableEdit() {
    var type = this.options.type;

    if (type !== 'Point') {
      this._originalStyle = this.options.lineStyle;
      var geojson = L$1.geoJson(this.toGeoJSON().geometry, this._originalStyle).getLayers()[0];

      for (var i = 0, len = this.rings.length; i < len; i++) {
        var it = this.rings[i];
        it.ring.removeEditMode();
        it.ring.options.editable = false;

        for (var j = 0, len1 = it.holes.length; j < len1; j++) {
          var hole = it.holes[j];
          hole.removeEditMode();
          hole.options.editable = false;
        }
      }

      this._obj = geojson;
      this.options.editable = false;

      this._initialize(this._parent, this._obj);
    }

    return this;
  },
  getArea: function getArea() {
    var out = 0;

    if (L$1.gmxUtil.geoJSONGetArea) {
      out = L$1.gmxUtil.geoJSONGetArea(this.toGeoJSON());
    }

    return out;
  },
  getLength: function getLength() {
    var out = 0;

    if (L$1.gmxUtil.geoJSONGetLength) {
      out = L$1.gmxUtil.geoJSONGetLength(this.toGeoJSON());
    }

    return out;
  },
  getLatLng: function getLatLng() {
    return this.lastAddLatLng;
  },
  _getTooltipAnchor: function _getTooltipAnchor() {
    return this.lastAddLatLng;
  },
  getSummary: function getSummary() {
    var str = '',
        mapOpt = this._map ? this._map.options : {},
        type = this.options.type;

    if (type === 'Polyline' || type === 'MultiPolyline') {
      str = L$1.gmxUtil.prettifyDistance(this.getLength(), mapOpt.distanceUnit);
    } else if (type === 'Polygon' || type === 'MultiPolygon' || type === 'Rectangle') {
      str = L$1.gmxUtil.prettifyArea(this.getArea(), mapOpt.squareUnit);
    } else if (type === 'Point') {
      var latLng = this._obj.getLatLng();

      str = L$1.gmxUtil.formatCoordinates(latLng);
    }

    return str;
  },
  _initialize: function _initialize(parent, obj) {
    var _this2 = this;

    this.clearLayers();
    this.rings = [];
    this.mode = '';
    this.lastAddLatLng = L$1.latLng(0, 0); // Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÑÑ Ð¸Ð· Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð½ÑÑ ÑÐ¾ÑÐµÐº

    this._fill = L$1.featureGroup();

    if (this._fill.options) {
      this._fill.options.smoothFactor = 0;
    }

    if (this.options.editable) {
      var arr = [];

      if (L$1.GmxDrawing.utils.isOldVersion) {
        arr = obj.getLayers ? L$1.GmxDrawing.utils._getLastObject(obj).getLayers() : [obj];
      } else {
        arr = obj.getLayers ? L$1.GmxDrawing.utils._getLastObject(obj) : [obj];

        if (obj.type && obj.coordinates) {
          var type = obj.type;
          obj = this._geoJsonToLayer(obj);

          if (type === 'Polygon') {
            var it1 = obj.getLatLngs();
            arr = [{
              _latlngs: it1.shift(),
              _holes: it1
            }];
          } else if (type === 'MultiPolygon') {
            arr = obj.getLatLngs().map(function (it) {
              return {
                _latlngs: it.shift(),
                _holes: it
              };
            });
          } else if (type === 'LineString') {
            arr = [{
              _latlngs: obj.getLatLngs()
            }];
          } else if (type === 'MultiLineString') {
            arr = obj.getLatLngs().map(function (it) {
              return {
                _latlngs: it
              };
            });
          } else if (type === 'Point') {
            this._obj = new L$1.Marker(obj.getLatLng(), {
              draggable: true
            });

            this._setMarker(this._obj);

            return;
          } else if (type === 'MultiPoint') {
            obj.getLayers().forEach(function (it) {
              this._setMarker(new L$1.Marker(it.getLatLng(), {
                draggable: true
              }));
            }.bind(this));
            return;
          }
        } else if (this.options.type === 'MultiPolygon') {
          arr = (obj.getLayers ? obj.getLayers()[0] : obj).getLatLngs().map(function (it) {
            return {
              _latlngs: it.shift(),
              _holes: it
            };
          });
        } else if (this.options.type === 'Polygon') {
          var _latlngs = (obj.getLayers ? obj.getLayers()[0] : obj).getLatLngs();

          arr = [{
            _latlngs: _latlngs.shift(),
            _holes: _latlngs
          }];
        }
      }

      for (var i = 0, len = arr.length; i < len; i++) {
        var it = arr[i],
            holes = [],
            ring = new L$1.GmxDrawing.Ring(this, it._latlngs, {
          ring: true,
          editable: this.options.editable
        });
        ring.on('click', function (e) {
          _this2.fire('click', e);
        });
        this.addLayer(ring);

        if (it._holes) {
          for (var j = 0, len1 = it._holes.length; j < len1; j++) {
            var hole = new L$1.GmxDrawing.Ring(this, it._holes[j], {
              hole: true,
              editable: this.options.editable
            });
            this.addLayer(hole);
            holes.push(hole);
          }
        }

        this.rings.push({
          ring: ring,
          holes: holes
        });
      }

      if (this.options.endTooltip && L$1.tooltip) {
        this._initStaticTooltip();
      }

      if (L$1.gmxUtil && L$1.gmxUtil.prettifyDistance && !this._showTooltip) {
        var _gtxt = L$1.GmxDrawing.utils.getLocale;
        var my = this;

        this._showTooltip = function (type, ev) {
          var ring = ev.ring,
              originalEvent = ev.originalEvent,
              down = type !== 'angle' && (originalEvent.buttons || originalEvent.button);

          if (ring && (ring.downObject || !down)) {
            var mapOpt = my._map ? my._map.options : {},
                distanceUnit = mapOpt.distanceUnit,
                squareUnit = mapOpt.squareUnit,
                azimutUnit = mapOpt.azimutUnit || false,
                str = '';

            if (type === 'Area' && ring.mode === 'add') {
              type = 'Length';
            }

            if (type === 'Area') {
              if (!L$1.gmxUtil.getArea) {
                return;
              }

              if (originalEvent && originalEvent.ctrlKey) {
                str = _gtxt('Perimeter') + ': ' + L$1.gmxUtil.prettifyDistance(my.getLength(), distanceUnit);
              } else {
                str = _gtxt(type) + ': ' + L$1.gmxUtil.prettifyArea(my.getArea(), squareUnit);
              }

              my._parent.showTooltip(ev.layerPoint, str);
            } else if (type === 'Length') {
              var downAttr = L$1.GmxDrawing.utils.getDownType.call(my, ev, my._map, my),
                  angleLeg = azimutUnit ? ring.getAngleLength(downAttr) : null;

              if (angleLeg && angleLeg.length && (my.options.type === 'Polyline' || ring.mode === 'add')) {
                str = _gtxt('angleLength') + ': ' + angleLeg.angle + '(' + L$1.gmxUtil.prettifyDistance(angleLeg.length, distanceUnit) + ')';
              } else {
                var length = ring.getLength(downAttr),
                    titleName = (downAttr.mode === 'edit' || downAttr.num > 1 ? downAttr.type : '') + type,
                    title = _gtxt(titleName);

                str = (title === titleName ? _gtxt(type) : title) + ': ' + L$1.gmxUtil.prettifyDistance(length, distanceUnit);
              }

              my._parent.showTooltip(ev.layerPoint, str);
            } else if (type === 'angle') {
              str = _gtxt('Angle') + ': ' + Math.floor(180.0 * ring._angle / Math.PI) + 'Â°';

              my._parent.showTooltip(ev.layerPoint, str);
            }

            my._fireEvent('onMouseOver');
          }
        };

        this.hideTooltip = function () {
          this._parent.hideTooltip();

          this._fireEvent('onMouseOut');
        };

        this.getTitle = _gtxt;
      }
    } else if (this.options.type === 'Point') {
      this._setMarker(obj);
    } else {
      this.addLayer(obj);
    }
  },
  _initStaticTooltip: function _initStaticTooltip() {
    this.on('drawstop editstop', function (ev) {
      if (this.staticTooltip) {
        this._removeStaticTooltip();
      }

      var latlng = ev.latlng,
          map = this._map,
          mapOpt = map ? map.options : {},
          distanceUnit = mapOpt.distanceUnit,
          squareUnit = mapOpt.squareUnit,
          tCont = L$1.DomUtil.create('div', 'content'),
          info = L$1.DomUtil.create('div', 'infoTooltip', tCont),
          closeBtn = L$1.DomUtil.create('div', 'closeBtn', tCont),
          polygon = this.options.type === 'Polygon',
          tOptions = {
        interactive: true,
        sticky: true,
        permanent: true,
        className: 'staticTooltip'
      };

      if (polygon) {
        if (this.options.endTooltip === 'center') {
          tOptions.direction = 'center';
          latlng = this.getBounds().getCenter();
        }

        info.innerHTML = L$1.gmxUtil.prettifyArea(this.getArea(), squareUnit);
      } else {
        tOptions.offset = L$1.point(10, 0);
        var arr = this.rings[0].ring.points.getLatLngs()[0];
        latlng = arr[arr.length - 1];
        info.innerHTML = L$1.gmxUtil.prettifyDistance(this.getLength(), distanceUnit);
      }

      closeBtn.innerHTML = 'Ã';
      L$1.DomEvent.on(closeBtn, 'click', function () {
        this._removeStaticTooltip();

        this.remove();
      }, this);
      this.staticTooltip = L$1.tooltip(tOptions).setLatLng(latlng).setContent(tCont).addTo(this._map);
      requestIdleCallback(function () {
        this.on('edit', this._removeStaticTooltip, this);
      }.bind(this), {
        timeout: 0
      });
    }, this);
  },
  _removeStaticTooltip: function _removeStaticTooltip() {
    if (this.staticTooltip) {
      this._map.removeLayer(this.staticTooltip);

      this.staticTooltip = null;
    }
  },
  _enableDrag: function _enableDrag() {
    this._parent._enableDrag();
  },
  _disableDrag: function _disableDrag() {
    this._parent._disableDrag();
  },
  _setMarker: function _setMarker(marker) {
    var _this = this,
        _parent = this._parent,
        _map = _parent._map,
        mapOpt = _map ? _map.options : {};

    marker.bindPopup(null, {
      maxWidth: 1000,
      closeOnClick: mapOpt.maxPopupCount > 1 ? false : true
    }).on('dblclick', function () {
      if (_map) {
        _map.removeLayer(this);
      }

      _this.remove(); //_parent.remove(this);

    }).on('dragstart', function () {
      _this._fireEvent('dragstart');
    }).on('drag', function (ev) {
      if (ev.originalEvent && ev.originalEvent.ctrlKey) {
        marker.setLatLng(L$1.GmxDrawing.utils.snapPoint(marker.getLatLng(), marker, _map));
      }

      _this._fireEvent('drag');

      _this._fireEvent('edit');
    }).on('dragend', function () {
      _this._fireEvent('dragend');
    }).on('popupopen', function (ev) {
      var popup = ev.popup;

      if (!popup._input) {
        popup._input = L$1.DomUtil.create('textarea', 'leaflet-gmx-popup-textarea', popup._contentNode); // popup._input.placeholder = _this.options.title || marker.options.title || '';

        popup._input.value = _this.options.title || marker.options.title || '';
        popup._contentNode.style.width = 'auto';
      }

      L$1.DomEvent.on(popup._input, 'keyup', function () {
        var rows = this.value.split('\n'),
            cols = this.cols || 0;
        rows.forEach(function (str) {
          if (str.length > cols) {
            cols = str.length;
          }
        });
        this.rows = rows.length;

        if (cols) {
          this.cols = cols;
        }

        popup.update();
        _this.options.title = marker.options.title = this.value;
        this.focus();
      }, popup._input);
      popup.update();
    });

    _map.addLayer(marker);

    _this.openPopup = marker.openPopup = function () {
      if (marker._popup && marker._map && !marker._map.hasLayer(marker._popup)) {
        marker._popup.setLatLng(marker._latlng);

        var gmxDrawing = marker._map.gmxDrawing;

        if (gmxDrawing._drawMode) {
          marker._map.fire(gmxDrawing._createType ? 'click' : 'mouseup', {
            latlng: marker._latlng,
            delta: 1
          });
        } else {
          marker._popup.addTo(marker._map);

          marker._popup._isOpen = true;
        }
      }

      return marker;
    };
  },
  setAddMode: function setAddMode() {
    if (this.rings.length) {
      this.rings[0].ring.setAddMode();
    }

    return this;
  },
  _pointDown: function _pointDown(ev) {
    if (this.rings.length) {
      this.rings[0].ring._pointDown(ev);
    }
  },
  getPopup: function getPopup() {
    if (this.options.type === 'Point') {
      return this._obj.getPopup();
    }
  }
});
L$1.GmxDrawing.Feature;

L$1.GmxDrawing.utils = {
  snaping: 10,
  // snap distance
  isOldVersion: L$1.version.substr(0, 3) === '0.7',
  defaultStyles: {
    mode: '',
    map: true,
    editable: true,
    holeStyle: {
      opacity: 0.5,
      color: '#003311'
    },
    lineStyle: {
      opacity: 1,
      weight: 2,
      clickable: false,
      className: 'leaflet-drawing-lines',
      color: '#0033ff',
      dashArray: null,
      lineCap: null,
      lineJoin: null,
      fill: false,
      fillColor: null,
      fillOpacity: 0.2,
      smoothFactor: 0,
      noClip: true,
      stroke: true
    },
    pointStyle: {
      className: 'leaflet-drawing-points',
      smoothFactor: 0,
      noClip: true,
      opacity: 1,
      shape: 'circle',
      fill: true,
      fillColor: '#ffffff',
      fillOpacity: 1,
      size: L$1.Browser.mobile ? 40 : 8,
      weight: 2,
      clickable: true,
      color: '#0033ff',
      dashArray: null,
      lineCap: null,
      lineJoin: null,
      stroke: true
    },
    markerStyle: {
      mode: '',
      editable: false,
      title: 'Text example',
      options: {
        alt: '',
        //title: '',
        clickable: true,
        draggable: false,
        keyboard: true,
        opacity: 1,
        zIndexOffset: 0,
        riseOffset: 250,
        riseOnHover: false,
        icon: {
          className: '',
          iconUrl: '',
          iconAnchor: [12, 41],
          iconSize: [25, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        }
      }
    }
  },
  getClosestOnGeometry: function getClosestOnGeometry(latlng, gmxGeoJson, map) {
    if (L$1.GeometryUtil && map) {
      return L$1.GeometryUtil.closestLayerSnap(map, [L$1.geoJson(L$1.gmxUtil.geometryToGeoJSON(gmxGeoJson, true, true))], latlng, Number(map.options.snaping || L$1.GmxDrawing.utils.snaping), true);
    }

    return null;
  },
  snapPoint: function snapPoint(latlng, obj, map) {
    var res = latlng;

    if (L$1.GeometryUtil) {
      var drawingObjects = map.gmxDrawing.getFeatures().filter(function (it) {
        return it !== obj._parent && it._obj !== obj;
      }).map(function (it) {
        return it.options.type === 'Point' ? it._obj : it;
      }),
          snaping = Number(map.options.snaping || L$1.GmxDrawing.utils.snaping),
          closest = L$1.GeometryUtil.closestLayerSnap(map, drawingObjects, latlng, snaping, true);

      if (closest) {
        res = closest.latlng;
      }
    }

    return res;
  },
  getNotDefaults: function getNotDefaults(from, def) {
    var res = {};

    for (var key in from) {
      if (key === 'icon' || key === 'map') {
        continue;
      } else if (key === 'iconAnchor' || key === 'iconSize' || key === 'popupAnchor' || key === 'shadowSize') {
        if (!def[key]) {
          continue;
        }

        if (def[key][0] !== from[key][0] || def[key][1] !== from[key][1]) {
          res[key] = from[key];
        }
      } else if (key === 'lineStyle' || key === 'pointStyle' || key === 'markerStyle') {
        res[key] = this.getNotDefaults(from[key], def[key]);
      } else if (!def || def[key] !== from[key] || key === 'fill') {
        res[key] = from[key];
      }
    }

    return res;
  },
  getShiftLatlng: function getShiftLatlng(latlng, map, shiftPixel) {
    if (shiftPixel && map) {
      var p = map.latLngToLayerPoint(latlng)._add(shiftPixel);

      latlng = map.layerPointToLatLng(p);
    }

    return latlng;
  },
  getDownType: function getDownType(ev, map, feature) {
    var layerPoint = ev.layerPoint,
        originalEvent = ev.originalEvent,
        ctrlKey = false,
        shiftKey = false,
        altKey = false,
        latlng = ev.latlng;

    if (originalEvent) {
      ctrlKey = originalEvent.ctrlKey;
      shiftKey = originalEvent.shiftKey;
      altKey = originalEvent.altKey;
    }

    if (ev.touches && ev.touches.length === 1) {
      var first = ev.touches[0],
          containerPoint = map.mouseEventToContainerPoint(first);
      layerPoint = map.containerPointToLayerPoint(containerPoint);
      latlng = map.layerPointToLatLng(layerPoint);
    }

    var out = {
      type: '',
      latlng: latlng,
      ctrlKey: ctrlKey,
      shiftKey: shiftKey,
      altKey: altKey
    },
        ring = this.points ? this : ev.ring || ev.relatedEvent,
        points = ring.points._originalPoints || ring.points._parts[0] || [],
        len = points.length;

    if (len === 0) {
      return out;
    }

    var size = (ring.points.options.size || 10) / 2;
    size += 1 + (ring.points.options.weight || 2);
    var cursorBounds = new L$1.Bounds(L$1.point(layerPoint.x - size, layerPoint.y - size), L$1.point(layerPoint.x + size, layerPoint.y + size)),
        prev = points[len - 1],
        lastIndex = len - (ring.mode === 'add' ? 2 : 1);
    out = {
      mode: ring.mode,
      layerPoint: ev.layerPoint,
      ctrlKey: ctrlKey,
      shiftKey: shiftKey,
      altKey: altKey,
      latlng: latlng
    };

    for (var i = 0; i < len; i++) {
      var point = points[i];

      if (feature.shiftPixel) {
        point = points[i].add(feature.shiftPixel);
      }

      if (cursorBounds.contains(point)) {
        out.type = 'node';
        out.num = i;
        out.end = i === 0 || i === lastIndex ? true : false;
        break;
      }

      var dist = L$1.LineUtil.pointToSegmentDistance(layerPoint, prev, point);

      if (dist < size) {
        out.type = 'edge';
        out.num = i === 0 ? len : i;
      }

      prev = point;
    }

    return out;
  },
  _getLastObject: function _getLastObject(obj) {
    if (obj.getLayers) {
      var layer = obj.getLayers().shift();
      return layer.getLayers ? this._getLastObject(layer) : obj;
    }

    return obj;
  },
  getMarkerByPos: function getMarkerByPos(pos, features) {
    for (var i = 0, len = features.length; i < len; i++) {
      var feature = features[i],
          fobj = feature._obj ? feature._obj : null,
          mpos = fobj && fobj._icon ? fobj._icon._leaflet_pos : null;

      if (mpos && mpos.x === pos.x && mpos.y === pos.y) {
        return fobj._latlng;
      }
    }

    return null;
  },
  getLocale: function getLocale(key) {
    var res = L$1.gmxLocale ? L$1.gmxLocale.getText(key) : null;
    return res || key;
  }
};
var Utils = L$1.GmxDrawing.utils;

L$1.GmxDrawing.Ring = L$1.LayerGroup.extend({
  options: {
    className: 'leaflet-drawing-ring',
    //noClip: true,
    maxPoints: 0,
    smoothFactor: 0,
    noClip: true,
    opacity: 1,
    shape: 'circle',
    fill: true,
    fillColor: '#ffffff',
    fillOpacity: 1,
    size: L$1.Browser.mobile ? 40 : 8,
    weight: 2
  },
  includes: L$1.Evented ? L$1.Evented.prototype : L$1.Mixin.Events,
  initialize: function initialize(parent, coords, options) {
    options = options || {};
    this.contextmenu = new GmxDrawingContextMenu$1();
    options.mode = '';
    this._activeZIndex = options.activeZIndex || 7;
    this._notActiveZIndex = options.notActiveZIndex || 6;
    this.options = L$1.extend({}, this.options, parent.getStyle(), options);
    this._layers = {};
    this._coords = coords;
    this._legLength = [];
    this._parent = parent;

    this._initialize(parent, coords);
  },
  _initialize: function _initialize(parent, coords) {
    var _this2 = this;

    this.clearLayers();
    delete this.lines;
    delete this.fill;
    delete this.points;
    this.downObject = false;
    this.mode = '';
    this.lineType = this.options.type.indexOf('Polyline') !== -1;

    if (this.options.type === 'Rectangle') {
      this.options.disableAddPoints = true;
    }

    var pointStyle = this.options.pointStyle;
    var lineStyle = {
      opacity: 1,
      weight: 2,
      noClip: true,
      clickable: false,
      className: 'leaflet-drawing-lines'
    };

    if (!this.lineType) {
      lineStyle.fill = 'fill' in this.options ? this.options.fill : true;
    }

    if (this.options.lineStyle) {
      for (var key in this.options.lineStyle) {
        if (key !== 'fill' || !this.lineType) {
          lineStyle[key] = this.options.lineStyle[key];
        }
      }
    }

    if (this.options.hole) {
      lineStyle = L$1.extend({}, lineStyle, Utils.defaultStyles.holeStyle);
      pointStyle = L$1.extend({}, pointStyle, Utils.defaultStyles.holeStyle);
    }

    var latlngs = coords,
        _this = this,
        mode = this.options.mode || (latlngs.length ? 'edit' : 'add');

    this.fill = new L$1.Polyline(latlngs, {
      className: 'leaflet-drawing-lines-fill',
      opacity: 0,
      smoothFactor: 0,
      noClip: true,
      fill: false,
      size: 10,
      weight: 10
    });
    this.fill.on('click', function (e) {
      _this2._parent.fire('click', e);
    });
    this.addLayer(this.fill);
    this.lines = new L$1.Polyline(latlngs, lineStyle);
    this.addLayer(this.lines);

    if (!this.lineType && mode === 'edit') {
      var latlng = latlngs[0][0] || latlngs[0];
      this.lines.addLatLng(latlng);
      this.fill.addLatLng(latlng);
    }

    this.mode = mode;
    this.points = new L$1.GmxDrawing.PointMarkers(latlngs, pointStyle);
    this.points._parent = this;
    this.addLayer(this.points);
    this.points.on('mouseover', function (ev) {
      this.toggleTooltip(ev, true, _this.lineType ? 'Length' : 'Area');

      if (ev.type === 'mouseover') {
        _this._recheckContextItems('points', _this._map);
      }
    }, this).on('mouseout', this.toggleTooltip, this);
    this.fill.on('mouseover mousemove', function (ev) {
      this.toggleTooltip(ev, true);
    }, this).on('mouseout', this.toggleTooltip, this);

    if (this.points.bindContextMenu) {
      this.points.bindContextMenu({
        contextmenu: false,
        contextmenuInheritItems: false,
        contextmenuItems: []
      });
    }

    if (this.fill.bindContextMenu) {
      this.fill.bindContextMenu({
        contextmenu: false,
        contextmenuInheritItems: false,
        contextmenuItems: []
      });
      this.fill.on('mouseover', function (ev) {
        if (ev.type === 'mouseover') {
          this._recheckContextItems('fill', this._map);
        }
      }, this);
    }

    this._parent.on('rotate', function (ev) {
      this.toggleTooltip(ev, true, 'angle');
    }, this);

    L$1.DomEvent.on(document, 'keydown keyup', this._toggleBboxClass, this);
  },
  bringToFront: function bringToFront() {
    if (this.lines) {
      this.lines.bringToFront();
    }

    if (this.fill) {
      this.fill.bringToFront();
    }

    if (this.points) {
      this.points.bringToFront();
    }

    return this;
  },
  bringToBack: function bringToBack() {
    if (this.lines) {
      this.lines.bringToBack();
    }

    if (this.fill) {
      this.fill.bringToBack();
    }

    if (this.points) {
      this.points.bringToBack();
    }

    return this;
  },
  _toggleBboxClass: function _toggleBboxClass(ev) {
    if (ev.type === 'keydown' && this.mode === 'add') {
      var key = ev.key,
          points = this._getLatLngsArr();

      if (key === 'Backspace') {
        this._legLength = [];
        points.splice(points.length - 1, 1);

        this._setPoint(points[0], 0);
      }

      if (key === 'Escape' || key === 'Backspace' && points.length < 2) {
        this._parent.remove(this);

        this._parent._parent._clearCreate();

        this._fireEvent('drawstop');
      }
    }

    if (this.bbox) {
      var flagRotate = this._needRotate;

      if (!ev.altKey) {
        flagRotate = !flagRotate;
      }

      if (ev.type === 'keyup' && !ev.altKey) {
        flagRotate = !this._needRotate;
      }

      L$1.DomUtil[flagRotate ? 'removeClass' : 'addClass'](this.bbox._path, 'Rotate');
    }
  },
  toggleTooltip: function toggleTooltip(ev, flag, type) {
    if ('hideTooltip' in this._parent) {
      ev.ring = this;

      if (flag) {
        type = type || 'Length';

        this._parent._showTooltip(type, ev);
      } else if (this.mode !== 'add') {
        this._parent.hideTooltip(ev);
      }
    }
  },
  _recheckContextItems: function _recheckContextItems(type, map) {
    var _this = this;

    this[type].options.contextmenuItems = (map.gmxDrawing.contextmenu.getItems()[type] || []).concat(this._parent.contextmenu.getItems()[type] || []).concat(this.contextmenu.getItems()[type] || []).map(function (obj) {
      var ph = {
        id: obj.text,
        text: Utils.getLocale(obj.text),
        icon: obj.icon,
        retinaIcon: obj.retinaIcon,
        iconCls: obj.iconCls,
        retinaIconCls: obj.retinaIconCls,
        callback: function callback(ev) {
          _this._eventsCmd(obj, ev);
        },
        context: obj.context || _this,
        disabled: 'disabled' in obj ? obj.disabled : false,
        separator: obj.separator,
        hideOnSelect: 'hideOnSelect' in obj ? obj.hideOnSelect : true
      };
      return ph;
    });
    return this[type].options.contextmenuItems;
  },
  _eventsCmd: function _eventsCmd(obj, ev) {
    var ring = ev.relatedTarget && ev.relatedTarget._parent || this;
    var downAttr = Utils.getDownType.call(this, ev, this._map, this._parent);

    if (downAttr) {
      var type = obj.text;

      if (obj.callback) {
        obj.callback(downAttr, this._parent);
      } else if (type === 'Delete feature') {
        this._parent.remove(this); // this._parent._parent._clearCreate();


        this._fireEvent('drawstop');
      } else if (type === 'Remove point') {
        ring._removePoint(downAttr.num);

        this._fireEvent('editstop', ev);
      } else if (type === 'Save' || type === 'Move' || type === 'Rotate' || type === 'Rotate around Point') {
        this._toggleRotate(type, downAttr);
      } else if (type === 'Cancel' && this._editHistory.length) {
        if (this._editHistory.length) {
          this.setLatLngs(this._editHistory[0]);
          this._editHistory = [];
        }

        this._toggleRotate('Save', downAttr);
      }
    }
  },
  getFeature: function getFeature() {
    return this._parent;
  },
  onAdd: function onAdd(map) {
    L$1.LayerGroup.prototype.onAdd.call(this, map);
    this.setEditMode();

    if (this.points.bindContextMenu) {
      var contextmenuItems = this._recheckContextItems('points', map);

      this.points.bindContextMenu({
        contextmenu: true,
        contextmenuInheritItems: false,
        contextmenuItems: contextmenuItems
      });
    }
  },
  onRemove: function onRemove(map) {
    if (this.points) {
      this._pointUp();

      this.removeAddMode();
      this.removeEditMode();

      if ('hideTooltip' in this._parent) {
        this._parent.hideTooltip();
      }
    }

    L$1.LayerGroup.prototype.onRemove.call(this, map);

    if (this.options.type === 'Point') {
      map.removeLayer(this._obj);
    }

    this._fireEvent('removefrommap');
  },
  getAngleLength: function getAngleLength(downAttr) {
    if (L$1.GeometryUtil && downAttr && downAttr.num) {
      var num = downAttr.num,
          latlngs = this.points._latlngs[0],
          prev = latlngs[num - 1],
          curr = latlngs[num] || downAttr.latlng,
          _parts = this.points._parts[0],
          angle = L$1.GeometryUtil.computeAngle(_parts[num - 1], _parts[num] || downAttr.layerPoint);
      angle += 90;
      angle %= 360;
      angle += angle < 0 ? 360 : 0;
      return {
        length: L$1.gmxUtil.distVincenty(prev.lng, prev.lat, curr.lng, curr.lat),
        angle: L$1.gmxUtil.formatDegrees(angle, 0)
      };
    }

    return null;
  },
  getLength: function getLength(downAttr) {
    var length = 0,
        latlngs = this._getLatLngsArr(),
        len = latlngs.length;

    if (len) {
      var beg = 1,
          prev = latlngs[0];

      if (downAttr) {
        if (downAttr.type === 'node') {
          len = downAttr.num + 1;
        } else {
          beg = downAttr.num;

          if (beg === len) {
            prev = latlngs[beg - 1];
            beg = 0;
          } else {
            prev = latlngs[beg - 1];
          }

          len = beg + 1;
        }
      }

      for (var i = beg; i < len; i++) {
        var leg = this._legLength[i] || null;

        if (leg === null) {
          leg = L$1.gmxUtil.distVincenty(prev.lng, prev.lat, latlngs[i].lng, latlngs[i].lat);
          this._legLength[i] = leg;
        }

        prev = latlngs[i];
        length += leg;
      }
    }

    return length;
  },
  _setPoint: function _setPoint(latlng, nm, type) {
    if (!this.points) {
      return;
    }

    var latlngs = this._getLatLngsArr();

    if (this.options.type === 'Rectangle') {
      if (type === 'edge') {
        nm--;

        if (nm === 0) {
          latlngs[0].lng = latlngs[1].lng = latlng.lng;
        } else if (nm === 1) {
          latlngs[1].lat = latlngs[2].lat = latlng.lat;
        } else if (nm === 2) {
          latlngs[2].lng = latlngs[3].lng = latlng.lng;
        } else if (nm === 3) {
          latlngs[0].lat = latlngs[3].lat = latlng.lat;
        }
      } else {
        latlngs[nm] = latlng;

        if (nm === 0) {
          latlngs[3].lat = latlng.lat;
          latlngs[1].lng = latlng.lng;
        } else if (nm === 1) {
          latlngs[2].lat = latlng.lat;
          latlngs[0].lng = latlng.lng;
        } else if (nm === 2) {
          latlngs[1].lat = latlng.lat;
          latlngs[3].lng = latlng.lng;
        } else if (nm === 3) {
          latlngs[0].lat = latlng.lat;
          latlngs[2].lng = latlng.lng;
        }
      }

      this._legLength = [];
    } else {
      latlngs[nm] = latlng;
      this._legLength[nm] = null;
      this._legLength[nm + 1] = null;
    }

    this.setLatLngs(latlngs);
  },
  addLatLng: function addLatLng(point, delta) {
    this._legLength = [];

    if (this.points) {
      var points = this._getLatLngsArr(),
          maxPoints = this.options.maxPoints,
          len = points.length,
          lastPoint = points[len - 2],
          flag = !lastPoint || !lastPoint.equals(point);

      if (maxPoints && len >= maxPoints) {
        this.setEditMode();

        this._fireEvent('drawstop', {
          latlng: point
        });

        len--;
      }

      if (flag) {
        if (delta) {
          len -= delta;
        } // reset existing point


        this._setPoint(point, len, 'node');
      }

      this._parent.lastAddLatLng = point;
    } else if ('addLatLng' in this._obj) {
      this._obj.addLatLng(point);
    }
  },
  setPositionOffset: function setPositionOffset(p) {
    L$1.DomUtil.setPosition(this.points._container, p);
    L$1.DomUtil.setPosition(this.fill._container, p);
    L$1.DomUtil.setPosition(this.lines._container, p);
  },
  setLatLngs: function setLatLngs(latlngs) {
    // TODO: latlngs Ð½Ðµ ÑÑÐ¸ÑÑÐ²Ð°ÐµÑ Ð´ÑÑÐºÐ¸ Ð¿Ð¾Ð»Ð¸Ð³Ð¾Ð½Ð¾Ð²
    if (this.points) {
      var points = this.points;
      this.fill.setLatLngs(latlngs);
      this.lines.setLatLngs(latlngs);

      if (!this.lineType && this.mode === 'edit' && latlngs.length > 2) {
        this.lines.addLatLng(latlngs[0]);
        this.fill.addLatLng(latlngs[0]);
      }

      if (this.bbox) {
        this.bbox.setBounds(this.lines._bounds);
      }

      points.setLatLngs(latlngs);
    } else if ('setLatLngs' in this._obj) {
      this._obj.setLatLngs(latlngs);
    }

    this._fireEvent('edit');
  },
  _getLatLngsArr: function _getLatLngsArr() {
    return Utils.isOldVersion ? this.points._latlngs : this.points._latlngs[0];
  },
  // edit mode
  _pointDown: function _pointDown(ev) {
    if (!this._map) {
      return;
    }

    if (L$1.Browser.ie || L$1.gmxUtil && L$1.gmxUtil.gtIE11) {
      this._map.dragging._draggable._onUp(ev); // error in IE

    }

    if (ev.originalEvent) {
      var originalEvent = ev.originalEvent;

      if (originalEvent.altKey) {
        // altKey, shiftKey
        this._onDragStart(ev);

        return;
      } else if (originalEvent.which !== 1 && originalEvent.button !== 1) {
        return;
      }
    }

    var downAttr = Utils.getDownType.call(this, ev, this._map, this._parent),
        type = downAttr.type,
        opt = this.options;
    this._lastDownTime = Date.now() + 100;
    this.down = downAttr;

    if (type === 'edge' && downAttr.ctrlKey && opt.type !== 'Rectangle') {
      if (opt.disableAddPoints) {
        return;
      }

      this._legLength = [];

      var num = downAttr.num,
          points = this._getLatLngsArr();

      points.splice(num, 0, points[num]);

      this._setPoint(ev.latlng, num, type);
    }

    this.downObject = true;

    this._parent._disableDrag();

    this._map.on('mousemove', this._pointMove, this).on('mouseup', this._mouseupPoint, this);
  },
  _mouseupPoint: function _mouseupPoint(ev) {
    this._pointUp(ev);

    if (this.__mouseupPointTimer) {
      cancelIdleCallback(this.__mouseupPointTimer);
    }

    this.__mouseupPointTimer = requestIdleCallback(function () {
      this._fireEvent('editstop', ev);
    }.bind(this), {
      timeout: 250
    });
  },
  _pointMove: function _pointMove(ev) {
    if (this.down && this._lastDownTime < Date.now()) {
      if (!this.lineType) {
        this._parent.showFill();
      }

      this._clearLineAddPoint();

      this._moved = true;
      var latlng = ev.originalEvent.ctrlKey ? Utils.snapPoint(ev.latlng, this, this._map) : ev.latlng;

      this._setPoint(latlng, this.down.num, this.down.type);

      if ('_showTooltip' in this._parent) {
        ev.ring = this;

        this._parent._showTooltip(this.lineType ? 'Length' : 'Area', ev);
      }
    }
  },
  _pointUp: function _pointUp(ev) {
    this.downObject = false;

    this._parent._enableDrag();

    if (!this.points) {
      return;
    }

    if (this._map) {
      this._map.off('mousemove', this._pointMove, this).off('mouseup', this._mouseupPoint, this);

      var target = ev && ev.originalEvent ? ev.originalEvent.target : null;

      if (target && target._leaflet_pos && /leaflet-marker-icon/.test(target.className)) {
        var latlng = Utils.getMarkerByPos(target._leaflet_pos, this._map.gmxDrawing.getFeatures());

        this._setPoint(latlng, this.down.num, this.down.type);
      }

      this._map._skipClick = true; // for EventsManager
    }

    if (this._drawstop) {
      this._fireEvent('drawstop', ev);
    }

    this._drawstop = false;
    this.down = null;
    var lineStyle = this.options.lineStyle || {};

    if (!lineStyle.fill && !this.lineType) {
      this._parent.hideFill();
    }
  },
  _lastPointClickTime: 0,
  // Hack for emulate dblclick on Point
  _removePoint: function _removePoint(num) {
    var points = this._getLatLngsArr();

    if (points.length > num) {
      this._legLength = [];
      points.splice(num, 1);

      if (this.options.type === 'Rectangle' || points.length < 2 || points.length < 3 && !this.lineType) {
        this._parent.remove(this);
      } else {
        this._setPoint(points[0], 0);
      }
    }
  },
  _clearLineAddPoint: function _clearLineAddPoint() {
    if (this._lineAddPointID) {
      clearTimeout(this._lineAddPointID);
    }

    this._lineAddPointID = null;
  },
  _pointDblClick: function _pointDblClick(ev) {
    this._clearLineAddPoint();

    if (!this.options.disableAddPoints && (!this._lastAddTime || Date.now() > this._lastAddTime)) {
      var downAttr = Utils.getDownType.call(this, ev, this._map, this._parent);

      this._removePoint(downAttr.num);
    }
  },
  _pointClick: function _pointClick(ev) {
    if (ev.originalEvent && ev.originalEvent.ctrlKey) {
      return;
    }

    var clickTime = Date.now(),
        prevClickTime = this._lastPointClickTime;
    this._lastPointClickTime = clickTime + 300;

    if (this._moved || clickTime < prevClickTime) {
      this._moved = false;
      return;
    }

    var downAttr = Utils.getDownType.call(this, ev, this._map, this._parent),
        mode = this.mode;

    if (downAttr.type === 'node') {
      var num = downAttr.num;

      if (downAttr.end) {
        // this is click on first or last Point
        if (mode === 'add') {
          this._pointUp();

          this.setEditMode();

          if (this.lineType && num === 0) {
            this._parent.options.type = this.options.type = 'Polygon';
            this.lineType = false;

            this._removePoint(this._getLatLngsArr().length - 1);
          }

          this._fireEvent('drawstop', downAttr);

          this._fireEvent('editstop', downAttr);

          this._removePoint(num);
        } else if (this.lineType) {
          this._clearLineAddPoint();

          this._lineAddPointID = setTimeout(function () {
            if (num === 0) {
              this._getLatLngsArr().reverse();
            }

            this.points.addLatLng(downAttr.latlng);
            this.setAddMode();

            this._fireEvent('drawstop', downAttr);
          }.bind(this), 250);
        }
      } else if (mode === 'add') {
        // this is add pont
        this.addLatLng(ev.latlng);
      }
    }
  },
  _editHistory: [],
  // _dragType: 'Save',
  _needRotate: false,
  _toggleRotate: function _toggleRotate(type, downAttr) {
    this._needRotate = type === 'Rotate' || type === 'Rotate around Point';
    this._editHistory = [];

    if (this.bbox) {
      this.bbox.off('contextmenu', this._onContextmenu, this).off('mousedown', this._onRotateStart, this);
      this.removeLayer(this.bbox);
      this.bbox = null;
    } else {
      L$1.DomUtil.TRANSFORM_ORIGIN = L$1.DomUtil.TRANSFORM_ORIGIN || L$1.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin']);
      this.bbox = L$1.rectangle(this.lines.getBounds(), {
        color: this.lines.options.color,
        //||'rgb(51, 136, 255)',
        opacity: this.lines.options.opacity,
        className: 'leaflet-drawing-bbox ' + type,
        dashArray: '6, 3',
        smoothFactor: 0,
        noClip: true,
        fillOpacity: 0,
        fill: true,
        weight: 1
      });
      this.addLayer(this.bbox);
      this.bbox.on('contextmenu', this._onContextmenu, this).on('mousedown', this._onRotateStart, this);

      if (this.bbox.bindContextMenu) {
        this.bbox.bindContextMenu({
          contextmenu: false,
          contextmenuInheritItems: false,
          contextmenuItems: []
        });
      }

      this._recheckContextItems('bbox', this._map);

      this._rotateCenterPoint = type === 'Rotate' ? this.bbox.getCenter() : downAttr.latlng;
    }
  },
  _onContextmenu: function _onContextmenu() {
    this.bbox.options.contextmenuItems[1].disabled = this._editHistory.length < 1;
  },
  _isContextMenuEvent: function _isContextMenuEvent(ev) {
    var e = ev.originalEvent;
    return e.which !== 1 && e.button !== 1 && !e.touches;
  },
  _onRotateStart: function _onRotateStart(ev) {
    if (this._isContextMenuEvent(ev)) {
      return;
    }

    this._editHistory.push(this._getLatLngsArr().map(function (it) {
      return it.clone();
    }));

    var flagRotate = this._needRotate;

    if (ev.originalEvent.altKey) {
      flagRotate = !flagRotate;
    }

    if (this._map.contextmenu) {
      this._map.contextmenu.hide();
    }

    if (flagRotate) {
      this._rotateStartPoint = ev.latlng;
      this._rotateCenter = this._rotateCenterPoint;

      this._map.on('mouseup', this._onRotateEnd, this).on('mousemove', this._onRotate, this);

      this._parent._disableDrag();

      this._fireEvent('rotatestart', ev);
    } else {
      this._onDragStart(ev);
    }
  },
  _onRotateEnd: function _onRotateEnd(ev) {
    // TODO: Ð½Ðµ ÑÑÐ¸ÑÑÐ²Ð°ÐµÑ Ð´ÑÑÐºÐ¸ Ð¿Ð¾Ð»Ð¸Ð³Ð¾Ð½Ð¾Ð²
    this._map.off('mouseup', this._onRotateEnd, this).off('mousemove', this._onRotate, this);

    this.toggleTooltip(ev);

    if (this._center) {
      var center = this._center,
          shiftPoint = this._map.getPixelOrigin().add(center),
          cos = Math.cos(-this._angle),
          sin = Math.sin(-this._angle),
          map = this._map,
          _latlngs = this.points._parts[0].map(function (p) {
        var ps = p.subtract(center);
        return map.unproject(L$1.point(ps.x * cos + ps.y * sin, ps.y * cos - ps.x * sin).add(shiftPoint));
      });

      this.setLatLngs(_latlngs);

      this._rotateItem();

      this.bbox.setBounds(this.lines._bounds); // console.log('_onRotateEnd', this.mode, this.points._latlngs, _latlngs);
    }

    this._parent._enableDrag();

    this._fireEvent('rotateend', ev);
  },
  _onRotate: function _onRotate(ev) {
    var pos = ev.latlng,
        // ÑÐµÐºÑÑÐ°Ñ ÑÐ¾ÑÐºÐ°
    s = this._rotateStartPoint,
        // ÑÐ¾ÑÐºÐ° Ð½Ð°ÑÐ°Ð»Ð° Ð²ÑÐ°ÑÐµÐ½Ð¸Ñ
    c = this._rotateCenter; // ÑÐµÐ½ÑÑ Ð¾Ð±ÑÐµÐºÑÐ°

    this._rotateItem(Math.atan2(s.lat - c.lat, s.lng - c.lng) - Math.atan2(pos.lat - c.lat, pos.lng - c.lng), this._map.project(c).subtract(this._map.getPixelOrigin()));

    this._fireEvent('rotate', ev);
  },
  _rotateItem: function _rotateItem(angle, center) {
    var originStr = '',
        rotate = '';

    if (center) {
      originStr = center.x + 'px ' + center.y + 'px';
      rotate = 'rotate(' + angle + 'rad)';
    }

    this._angle = angle;
    this._center = center;
    [this.bbox, this.lines, this.fill, this.points].forEach(function (it) {
      it._path.style[L$1.DomUtil.TRANSFORM_ORIGIN] = originStr;
      it._path.style.transform = rotate;
    });
  },
  _onDragEnd: function _onDragEnd() {
    this._map.off('mouseup', this._onDragEnd, this).off('mousemove', this._onDrag, this);

    this._parent._enableDrag();

    this._fireEvent('dragend');
  },
  _onDragStart: function _onDragStart(ev) {
    this._dragstartPoint = ev.latlng;

    this._map.on('mouseup', this._onDragEnd, this).on('mousemove', this._onDrag, this);

    this._parent._disableDrag();

    this._fireEvent('dragstart');
  },
  _onDrag: function _onDrag(ev) {
    var lat = this._dragstartPoint.lat - ev.latlng.lat,
        lng = this._dragstartPoint.lng - ev.latlng.lng,
        points = this._getLatLngsArr();

    points.forEach(function (item) {
      item.lat -= lat;
      item.lng -= lng;
    });
    this._dragstartPoint = ev.latlng;
    this._legLength = [];
    this.setLatLngs(points);

    this._fireEvent('drag');
  },
  _fireEvent: function _fireEvent(name, options) {
    this._parent._fireEvent(name, options);
  },
  _startTouchMove: function _startTouchMove(ev, drawstop) {
    var downAttr = Utils.getDownType.call(this, ev, this._map, this._parent);

    if (downAttr.type === 'node') {
      this._parent._disableDrag();

      this.down = downAttr; //var num = downAttr.num;

      var my = this;

      var _touchmove = function _touchmove(ev) {
        downAttr = Utils.getDownType.call(my, ev, my._map, this._parent);

        if (ev.touches.length === 1) {
          // Only deal with one finger
          my._pointMove(downAttr);
        }
      };

      var _touchend = function _touchend() {
        L$1.DomEvent.off(my._map._container, 'touchmove', _touchmove, my).off(my._map._container, 'touchend', _touchend, my);

        my._parent._enableDrag();

        if (drawstop) {
          my._parent.fire('drawstop', {
            mode: my.options.type,
            object: my
          });
        }
      };

      L$1.DomEvent.on(my._map._container, 'touchmove', _touchmove, my).on(my._map._container, 'touchend', _touchend, my);
    }
  },
  _editHandlers: function _editHandlers(flag) {
    //if (!this.points) { return; }
    var stop = L$1.DomEvent.stopPropagation,
        prevent = L$1.DomEvent.preventDefault;

    if (this.touchstart) {
      L$1.DomEvent.off(this.points._container, 'touchstart', this.touchstart, this);
    }

    if (this.touchstartFill) {
      L$1.DomEvent.off(this.fill._container, 'touchstart', this.touchstartFill, this);
    }

    this.touchstart = null;
    this.touchstartFill = null;

    if (flag) {
      this.points.on('dblclick click', stop, this).on('dblclick click', prevent, this).on('dblclick', this._pointDblClick, this).on('click', this._pointClick, this);

      if (L$1.Browser.mobile) {
        if (this._EditOpacity) {
          this._parent._setPointsStyle({
            fillOpacity: this._EditOpacity
          });
        }

        var my = this;

        this.touchstart = function (ev) {
          my._startTouchMove(ev);
        };

        L$1.DomEvent.on(this.points._container, 'touchstart', this.touchstart, this);

        this.touchstartFill = function (ev) {
          var downAttr = Utils.getDownType.call(my, ev, my._map, this._parent);

          if (downAttr.type === 'edge' && my.options.type !== 'Rectangle') {
            var points = my.points._latlngs;
            points.splice(downAttr.num, 0, points[downAttr.num]);
            my._legLength = [];

            my._setPoint(downAttr.latlng, downAttr.num, downAttr.type);
          }
        };

        L$1.DomEvent.on(this.fill._container, 'touchstart', this.touchstartFill, this);
      } else {
        this.points.on('mousemove', stop).on('mousedown', this._pointDown, this);
        this.lines.on('mousedown', this._pointDown, this);
        this.fill.on('dblclick click', stop, this).on('mousedown', this._pointDown, this);

        this._fireEvent('editmode');
      }
    } else {
      this._pointUp();

      this.points.off('dblclick click', stop, this).off('dblclick click', prevent, this).off('dblclick', this._pointDblClick, this).off('click', this._pointClick, this);

      if (!L$1.Browser.mobile) {
        this.points.off('mousemove', stop).off('mousedown', this._pointDown, this);
        this.lines.off('mousedown', this._pointDown, this);
        this.fill.off('dblclick click', stop, this).off('mousedown', this._pointDown, this);
      }
    }
  },
  _createHandlers: function _createHandlers(flag) {
    if (!this.points || !this._map) {
      return;
    }

    var stop = L$1.DomEvent.stopPropagation;

    if (flag) {
      if (this._map.contextmenu) {
        this._map.contextmenu.disable();
      }

      this._parent._enableDrag();

      this._map.on('dblclick', stop).on('mousedown', this._mouseDown, this).on('mouseup', this._mouseUp, this).on('mousemove', this._moseMove, this);

      this.points.on('click', this._pointClick, this);

      this._fireEvent('addmode');

      if (!this.lineType) {
        this.lines.setStyle({
          fill: true
        });
      }
    } else {
      if (this._map) {
        this._map.off('dblclick', stop).off('mouseup', this._mouseUp, this).off('mousemove', this._moseMove, this);

        this.points.off('click', this._pointClick, this);
      }

      var lineStyle = this.options.lineStyle || {};

      if (!this.lineType && !lineStyle.fill) {
        this.lines.setStyle({
          fill: false
        });
      }
    }
  },
  setEditMode: function setEditMode() {
    if (this.options.editable) {
      this._editHandlers(false);

      this._createHandlers(false);

      this._editHandlers(true);

      this.mode = 'edit';
    }

    return this;
  },
  setAddMode: function setAddMode() {
    if (this.options.editable) {
      this._editHandlers(false);

      this._createHandlers(false);

      this._createHandlers(true);

      this.mode = 'add';
    }

    return this;
  },
  removeAddMode: function removeAddMode() {
    this._createHandlers(false);

    this.mode = '';
  },
  removeEditMode: function removeEditMode() {
    this._editHandlers(false);

    this.mode = '';
  },
  // add mode
  _moseMove: function _moseMove(ev) {
    if (this.points) {
      var points = this._getLatLngsArr(),
          latlng = ev.latlng;

      if (ev.originalEvent.ctrlKey) {
        latlng = Utils.snapPoint(latlng, this, this._map);
      }

      if (points.length === 1) {
        this._setPoint(latlng, 1);
      }

      this._setPoint(latlng, points.length - 1);

      this.toggleTooltip(ev, true, this.lineType ? 'Length' : 'Area');
    }
  },
  _mouseDown: function _mouseDown() {
    this._lastMouseDownTime = Date.now() + 200;

    if (this._map && this._map.contextmenu) {
      this._map.contextmenu.hide();
    }

    if ('hideTooltip' in this._parent) {
      this._parent.hideTooltip();
    }
  },
  _mouseUp: function _mouseUp(ev) {
    var timeStamp = Date.now();

    if (ev.delta || timeStamp < this._lastMouseDownTime) {
      this._lastAddTime = timeStamp + 1000;

      var _latlngs = this._getLatLngsArr();

      if (ev.originalEvent && ev.originalEvent.which === 3 && this.points && _latlngs && _latlngs.length) {
        // for click right button
        this.setEditMode();

        this._removePoint(_latlngs.length - 1);

        this._pointUp();

        this._fireEvent('drawstop');

        if (this._map && this._map.contextmenu) {
          requestIdleCallback(this._map.contextmenu.enable.bind(this._map.contextmenu), {
            timeout: 250
          });
        }
      } else {
        var latlng = ev._latlng || ev.latlng;

        if (ev.delta) {
          this.addLatLng(latlng, ev.delta);
        } // for click on marker


        this.addLatLng(latlng);
      }

      this._parent._parent._clearCreate();
    }
  }
});
L$1.GmxDrawing.Ring;

L$1.GmxDrawing.PointMarkers = L$1.Polygon.extend({
  options: {
    className: 'leaflet-drawing-points',
    noClip: true,
    smoothFactor: 0,
    opacity: 1,
    shape: 'circle',
    fill: true,
    fillColor: '#ffffff',
    fillOpacity: 1,
    size: L$1.Browser.mobile ? 40 : 8,
    weight: 2
  },
  _convertLatLngs: function _convertLatLngs(latlngs) {
    return L$1.Polyline.prototype._convertLatLngs.call(this, latlngs);
  },
  getRing: function getRing() {
    return this._parent;
  },
  getFeature: function getFeature() {
    return this.getRing()._parent;
  },
  getPathLatLngs: function getPathLatLngs() {
    var out = [],
        size = this.options.size,
        dontsmooth = this._parent.options.type === 'Rectangle',
        points = this._parts[0],
        prev;

    for (var i = 0, len = points.length, p; i < len; i++) {
      p = points[i];

      if (i === 0 || dontsmooth || Math.abs(prev.x - p.x) > size || Math.abs(prev.y - p.y) > size) {
        out.push(this._latlngs[i]);
        prev = p;
      }
    }

    return out;
  },
  _getPathPartStr: function _getPathPartStr(points) {
    var round = L$1.Path.VML,
        size = this.options.size / 2,
        dontsmooth = this._parent && this._parent.options.type === 'Rectangle',
        skipLastPoint = this._parent && this._parent.mode === 'add' && !L$1.Browser.mobile ? 1 : 0,
        radius = this.options.shape === 'circle' ? true : false,
        prev;

    for (var j = 0, len2 = points.length - skipLastPoint, str = '', p; j < len2; j++) {
      p = points[j];

      if (round) {
        p._round();
      }

      if (j === 0 || dontsmooth || Math.abs(prev.x - p.x) > this.options.size || Math.abs(prev.y - p.y) > this.options.size) {
        if (radius) {
          str += 'M' + p.x + ',' + (p.y - size) + ' A' + size + ',' + size + ',0,1,1,' + (p.x - 0.1) + ',' + (p.y - size) + ' ';
        } else {
          var px = p.x,
              px1 = px - size,
              px2 = px + size,
              py = p.y,
              py1 = py - size,
              py2 = py + size;
          str += 'M' + px1 + ' ' + py1 + 'L' + px2 + ' ' + py1 + 'L' + px2 + ' ' + py2 + 'L' + px1 + ' ' + py2 + 'L' + px1 + ' ' + py1;
        }

        prev = p;
      }
    }

    return str;
  },
  _onMouseClick: function _onMouseClick(e) {
    //if (this._map.dragging && this._map.dragging.moved()) { return; }
    this._fireMouseEvent(e);
  },
  _updatePath: function _updatePath() {
    if (Utils.isOldVersion) {
      if (!this._map) {
        return;
      }

      this._clipPoints();

      this.projectLatlngs();
      var pathStr = this.getPathString();

      if (pathStr !== this._pathStr) {
        this._pathStr = pathStr;

        if (this._path.getAttribute('fill-rule') !== 'inherit') {
          this._path.setAttribute('fill-rule', 'inherit');
        }

        this._path.setAttribute('d', this._pathStr || 'M0 0');
      }
    } else {
      var str = this._parts.length ? this._getPathPartStr(this._parts[0]) : '';

      this._renderer._setPath(this, str);
    }
  }
});
L$1.GmxDrawing.PointMarkers;

L$1.GmxDrawing.utils = {
  snaping: 10,
  // snap distance
  isOldVersion: L$1.version.substr(0, 3) === '0.7',
  defaultStyles: {
    mode: '',
    map: true,
    editable: true,
    holeStyle: {
      opacity: 0.5,
      color: '#003311'
    },
    lineStyle: {
      opacity: 1,
      weight: 2,
      clickable: false,
      className: 'leaflet-drawing-lines',
      color: '#0033ff',
      dashArray: null,
      lineCap: null,
      lineJoin: null,
      fill: false,
      fillColor: null,
      fillOpacity: 0.2,
      smoothFactor: 0,
      noClip: true,
      stroke: true
    },
    pointStyle: {
      className: 'leaflet-drawing-points',
      smoothFactor: 0,
      noClip: true,
      opacity: 1,
      shape: 'circle',
      fill: true,
      fillColor: '#ffffff',
      fillOpacity: 1,
      size: L$1.Browser.mobile ? 40 : 8,
      weight: 2,
      clickable: true,
      color: '#0033ff',
      dashArray: null,
      lineCap: null,
      lineJoin: null,
      stroke: true
    },
    markerStyle: {
      mode: '',
      editable: false,
      title: 'Text example',
      options: {
        alt: '',
        //title: '',
        clickable: true,
        draggable: false,
        keyboard: true,
        opacity: 1,
        zIndexOffset: 0,
        riseOffset: 250,
        riseOnHover: false,
        icon: {
          className: '',
          iconUrl: '',
          iconAnchor: [12, 41],
          iconSize: [25, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        }
      }
    }
  },
  getClosestOnGeometry: function getClosestOnGeometry(latlng, gmxGeoJson, map) {
    if (L$1.GeometryUtil && map) {
      return L$1.GeometryUtil.closestLayerSnap(map, [L$1.geoJson(L$1.gmxUtil.geometryToGeoJSON(gmxGeoJson, true, true))], latlng, Number(map.options.snaping || L$1.GmxDrawing.utils.snaping), true);
    }

    return null;
  },
  snapPoint: function snapPoint(latlng, obj, map) {
    var res = latlng;

    if (L$1.GeometryUtil) {
      var drawingObjects = map.gmxDrawing.getFeatures().filter(function (it) {
        return it !== obj._parent && it._obj !== obj;
      }).map(function (it) {
        return it.options.type === 'Point' ? it._obj : it;
      }),
          snaping = Number(map.options.snaping || L$1.GmxDrawing.utils.snaping),
          closest = L$1.GeometryUtil.closestLayerSnap(map, drawingObjects, latlng, snaping, true);

      if (closest) {
        res = closest.latlng;
      }
    }

    return res;
  },
  getNotDefaults: function getNotDefaults(from, def) {
    var res = {};

    for (var key in from) {
      if (key === 'icon' || key === 'map') {
        continue;
      } else if (key === 'iconAnchor' || key === 'iconSize' || key === 'popupAnchor' || key === 'shadowSize') {
        if (!def[key]) {
          continue;
        }

        if (def[key][0] !== from[key][0] || def[key][1] !== from[key][1]) {
          res[key] = from[key];
        }
      } else if (key === 'lineStyle' || key === 'pointStyle' || key === 'markerStyle') {
        res[key] = this.getNotDefaults(from[key], def[key]);
      } else if (!def || def[key] !== from[key] || key === 'fill') {
        res[key] = from[key];
      }
    }

    return res;
  },
  getShiftLatlng: function getShiftLatlng(latlng, map, shiftPixel) {
    if (shiftPixel && map) {
      var p = map.latLngToLayerPoint(latlng)._add(shiftPixel);

      latlng = map.layerPointToLatLng(p);
    }

    return latlng;
  },
  getDownType: function getDownType(ev, map, feature) {
    var layerPoint = ev.layerPoint,
        originalEvent = ev.originalEvent,
        ctrlKey = false,
        shiftKey = false,
        altKey = false,
        latlng = ev.latlng;

    if (originalEvent) {
      ctrlKey = originalEvent.ctrlKey;
      shiftKey = originalEvent.shiftKey;
      altKey = originalEvent.altKey;
    }

    if (ev.touches && ev.touches.length === 1) {
      var first = ev.touches[0],
          containerPoint = map.mouseEventToContainerPoint(first);
      layerPoint = map.containerPointToLayerPoint(containerPoint);
      latlng = map.layerPointToLatLng(layerPoint);
    }

    var out = {
      type: '',
      latlng: latlng,
      ctrlKey: ctrlKey,
      shiftKey: shiftKey,
      altKey: altKey
    },
        ring = this.points ? this : ev.ring || ev.relatedEvent,
        points = ring.points._originalPoints || ring.points._parts[0] || [],
        len = points.length;

    if (len === 0) {
      return out;
    }

    var size = (ring.points.options.size || 10) / 2;
    size += 1 + (ring.points.options.weight || 2);
    var cursorBounds = new L$1.Bounds(L$1.point(layerPoint.x - size, layerPoint.y - size), L$1.point(layerPoint.x + size, layerPoint.y + size)),
        prev = points[len - 1],
        lastIndex = len - (ring.mode === 'add' ? 2 : 1);
    out = {
      mode: ring.mode,
      layerPoint: ev.layerPoint,
      ctrlKey: ctrlKey,
      shiftKey: shiftKey,
      altKey: altKey,
      latlng: latlng
    };

    for (var i = 0; i < len; i++) {
      var point = points[i];

      if (feature.shiftPixel) {
        point = points[i].add(feature.shiftPixel);
      }

      if (cursorBounds.contains(point)) {
        out.type = 'node';
        out.num = i;
        out.end = i === 0 || i === lastIndex ? true : false;
        break;
      }

      var dist = L$1.LineUtil.pointToSegmentDistance(layerPoint, prev, point);

      if (dist < size) {
        out.type = 'edge';
        out.num = i === 0 ? len : i;
      }

      prev = point;
    }

    return out;
  },
  _getLastObject: function _getLastObject(obj) {
    if (obj.getLayers) {
      var layer = obj.getLayers().shift();
      return layer.getLayers ? this._getLastObject(layer) : obj;
    }

    return obj;
  },
  getMarkerByPos: function getMarkerByPos(pos, features) {
    for (var i = 0, len = features.length; i < len; i++) {
      var feature = features[i],
          fobj = feature._obj ? feature._obj : null,
          mpos = fobj && fobj._icon ? fobj._icon._leaflet_pos : null;

      if (mpos && mpos.x === pos.x && mpos.y === pos.y) {
        return fobj._latlng;
      }
    }

    return null;
  },
  getLocale: function getLocale(key) {
    var res = L$1.gmxLocale ? L$1.gmxLocale.getText(key) : null;
    return res || key;
  }
};
L$1.GmxDrawing.utils;

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

function getObjectCenter(_x, _x2, _x3) {
  return _getObjectCenter.apply(this, arguments);
}

function _getObjectCenter() {
  _getObjectCenter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(gmxPath, layerID, id) {
    var fd, response, _yield$response$json, Status, Result, fields, values, i, _L$gmxUtil$convertGeo, coordinates, g, b;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            fd = new FormData();
            fd.append('query', "[id]='".concat(id, "'"));
            fd.append('page', '0');
            fd.append('pagesize', '1');
            fd.append('geometry', 'true');
            fd.append('layer', layerID);
            _context.next = 8;
            return fetch("".concat(gmxPath, "/VectorLayer/Search.ashx?WrapStyle=None"), {
              method: 'POST',
              credentials: 'include',
              body: fd
            });

          case 8:
            response = _context.sent;
            _context.next = 11;
            return response.json();

          case 11:
            _yield$response$json = _context.sent;
            Status = _yield$response$json.Status;
            Result = _yield$response$json.Result;

            if (!(Status === 'ok')) {
              _context.next = 23;
              break;
            }

            fields = Result.fields, values = Result.values;
            i = fields.indexOf('geomixergeojson');
            _L$gmxUtil$convertGeo = L$1.gmxUtil.convertGeometry(values[0][i], true), coordinates = _L$gmxUtil$convertGeo.coordinates;
            g = L$1.geoJSON({
              type: 'Feature',
              geometry: {
                type: 'Polygon',
                coordinates: coordinates
              }
            });
            b = g.getBounds();
            return _context.abrupt("return", b.getCenter());

          case 23:
            return _context.abrupt("return", null);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getObjectCenter.apply(this, arguments);
}

var m = function m(v) {
  return v && v.toLocaleString('ru-RU', {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }) || '';
};

var ha = function ha(v) {
  return v && v.toLocaleString('ru-RU', {
    minimumFractionDigits: 1,
    maximumFractionDigits: 1
  }) || '';
};

var rub = function rub(v) {
  return v && v.toLocaleString('ru-RU', {
    style: 'currency',
    currency: 'RUB'
  }) || '';
};

var fmt = function fmt(v) {
  return v && v.toLocaleString('ru-RU', {
    minimumFractionDigits: 1,
    maximumFractionDigits: 1
  }) || '';
};

var date = function date(v) {
  return v && v.toLocaleDateString() || '';
};

var copy = function copy(source) {
  switch (_typeof(source)) {
    case 'number':
    case 'string':
    case 'function':
    default:
      return source;

    case 'object':
      if (source === null) {
        return null;
      } else if (Array.isArray(source)) {
        return source.map(function (item) {
          return copy(item);
        });
      } else if (source instanceof Date) {
        return source;
      } else {
        return Object.keys(source).reduce(function (a, k) {
          a[k] = copy(source[k]);
          return a;
        }, {});
      }

  }
};

var extend = function extend(target, source) {
  if (target === source) {
    return target;
  } else {
    return Object.keys(source).reduce(function (a, k) {
      var value = source[k];

      if (_typeof(a[k]) === 'object' && k in a) {
        a[k] = extend(a[k], value);
      } else {
        a[k] = copy(value);
      }

      return a;
    }, copy(target));
  }
};

var DEFAULT_LANGUAGE = 'rus';

var Translations = /*#__PURE__*/function () {
  function Translations() {
    _classCallCheck(this, Translations);

    this._hash = {};
  }

  _createClass(Translations, [{
    key: "setLanguage",
    value: function setLanguage(lang) {
      this._language = lang;
    }
  }, {
    key: "getLanguage",
    value: function getLanguage() {
      return window.language || this._language || DEFAULT_LANGUAGE;
    }
  }, {
    key: "addText",
    value: function addText(lang, tran) {
      this._hash[lang] = extend(this._hash[lang] || {}, tran);
      return this;
    }
  }, {
    key: "getText",
    value: function getText(key) {
      if (key && typeof key === 'string') {
        var locale = this._hash[this.getLanguage()];

        if (locale) {
          return key.split('.').reduce(function (a, k) {
            return a[k];
          }, locale);
        }
      }

      return null;
    }
  }]);

  return Translations;
}();

window.Scanex = window.Scanex || {};
window.Scanex.Translations = window.Scanex.Translations || {};
window.Scanex.translations = window.Scanex.translations || new Translations();
var T = window.Scanex.translations;

var translate = T.getText.bind(T);
T.addText('rus', {
  baseLayers: {
    title: 'ÐÐ¾Ð´Ð»Ð¾Ð¶ÐºÐ¸',
    Rostelecom: 'Ð Ð¾ÑÑÐµÐ»ÐµÐºÐ¾Ð¼'
  }
});
var iconPrefix = 'images'; //'//maps.kosmosnimki.ru/api/img/baseLayers/';

var hybrid = L$1.tileLayer('//{s}tilecart.kosmosnimki.ru/kosmohyb/{z}/{x}/{y}.png', {
  zIndex: -999999,
  maxNativeZoom: 18
});
var baseLayers = {
  sputnik: {
    rus: 'Ð¡Ð¿ÑÑÐ½Ð¸Ðº ÑÑ',
    eng: 'Sputnik RU',
    icon: "".concat(iconPrefix, "/lv_map.png"),
    layers: [L$1.tileLayer('//tilessputnik.ru/{z}/{x}/{y}.png?sw=1', {
      zIndex: -1000000,
      maxZoom: 22,
      maxNativeZoom: 18,
      attribution: '<a href="http://maps.sputnik.ru">Ð¡Ð¿ÑÑÐ½Ð¸Ðº</a> Â© ' + translate('baseLayers.Rostelecom') + ' | Â© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    })]
  },
  // satellite: {
  // 	mapID: '1D30C72D02914C5FB90D1D448159CAB6',
  // 	layerID: '63E083C0916F4414A2F6B78242F56CA6', // satellite
  // 	type: 'satellite',
  // 	rus: 'Ð¡Ð½Ð¸Ð¼ÐºÐ¸',
  // 	eng: 'Satellite',
  // 	overlayColor: '#ffffff',
  // 	icon: `${iconPrefix}/basemap_satellite.png`,
  //     layers: []
  // },
  OSMHybrid: {
    rus: 'ÐÐ¸Ð±ÑÐ¸Ð´',
    eng: 'Hybrid',
    overlayColor: '#ffffff',
    icon: "".concat(iconPrefix, "/lv_hyb.png"),
    layers: []
  }
};
var BaseLayers = L$1.Control.extend({
  includes: L$1.Evented.prototype,
  options: {
    position: 'topright',
    apiKey: 'LX3YKLVMUF'
  },
  onAdd: function onAdd(map) {
    var _this = this;

    this._container = L$1.DomUtil.create('div', 'scanex-baselayers baselayer-map-right ');
    this._icon = L$1.DomUtil.create('div', 'map-right', this._container);
    L$1.DomUtil.create('div', 'substrates', this._icon);
    this._content = L$1.DomUtil.create('div', 'table-baselayers-popup hidden', this._container);
    this._content.innerHTML = "<table>\n            <thead>\n                <tr>                    \n                    <td colspan=\"3\">\n                        <label>".concat(translate('baseLayers.title'), "</label>\n                    </td>\n                </tr>\n            </thead>            \n            <tbody>\n                <tr class=\"line\">").concat(Object.keys(baseLayers).map(function (k) {
      return "<td><img src=\"".concat(baseLayers[k].icon, "\" class=\"baseLayer\" data=\"").concat(k, "\" /></td>");
    }).join(''), "</tr>\n             </tbody>\n        </table>");
    L$1.DomEvent.on(this._icon, 'click', function (e) {
      L$1.DomEvent.stopPropagation(e);
      _this._active = !_this._active;

      _this.showPanel(_this._active);

      _this.fire('activate', {
        active: _this._active
      });
    });

    this._content.getElementsByClassName('baseLayer').forEach(function (node) {
      var key = node.getAttribute('data');
      baseLayers[key].node = node;
      L$1.DomEvent.on(node, 'click', function (e) {
        L$1.DomEvent.stopPropagation(e);
        var visible = !L$1.DomUtil.hasClass(node, 'active');

        _this.fire('click', {
          id: key,
          visible: visible
        });

        _this.toggle(key);
      }, _this);
    }, this);

    this._getLayers();

    return this._container;
  },
  onRemove: function onRemove(map) {},
  _getLayers: function _getLayers() {
    L$1.gmx.loadLayers([{
      apiKey: this.options.apiKey,
      mapID: '1D30C72D02914C5FB90D1D448159CAB6',
      layerID: '4EE5E84381E94E369784464FD41EED5A',
      // satellite
      type: 'satellite',
      rus: 'Ð¡Ð½Ð¸Ð¼ÐºÐ¸',
      eng: 'Satellite',
      overlayColor: '#ffffff',
      icon: "".concat(iconPrefix, "/lv_hyb.png")
    }], {}).then(function (arr) {
      var satellite = arr[0];
      satellite.options.zIndex = -1000000; // baseLayers.satellite.layers = [satellite];

      baseLayers.OSMHybrid.layers = [satellite, hybrid];
    });
  },
  unload: function unload() {
    var _this2 = this;

    if (this._activeID) {
      var baseLayer = baseLayers[this._activeID];

      if (baseLayer) {
        baseLayer.layers.forEach(function (it) {
          _this2._map.removeLayer(it);
        });
        L$1.DomUtil.removeClass(baseLayer.node, 'active');
      }

      this._activeID = null;
    }

    return this;
  },
  toggle: function toggle(id) {
    var _this3 = this;

    if (this._activeID !== id) {
      var baseLayer = baseLayers[this._activeID];

      if (this._activeID && baseLayer) {
        baseLayer.layers.forEach(function (it) {
          _this3._map.removeLayer(it);
        });
        L$1.DomUtil.removeClass(baseLayer.node, 'active');
      }

      this._activeID = id;
      baseLayer = baseLayers[this._activeID];

      if (baseLayer) {
        baseLayer.layers.forEach(function (it) {
          if (it._map && it._map !== _this3._map) {
            it._map.removeLayer(it);
          }

          _this3._map.addLayer(it);
        });
      }

      L$1.DomUtil.addClass(baseLayer.node, 'active');
    }
  },
  showPanel: function showPanel(visible) {
    this._active = visible;

    if (this._active) {
      L$1.DomUtil.addClass(this._icon, 'active');
      L$1.DomUtil.removeClass(this._content, 'hidden');
    } else {
      L$1.DomUtil.removeClass(this._icon, 'active');
      L$1.DomUtil.addClass(this._content, 'hidden');
    }
  }
});

L$1.Control.GmxCenter = L$1.Control.extend({
  options: {
    position: 'center',
    id: 'center',
    notHide: true,
    color: '#216b9c'
  },
  onRemove: function onRemove(map) {
    if (map.gmxControlsManager) {
      map.gmxControlsManager.remove(this);
    }

    map.fire('controlremove', this);
  },
  onAdd: function onAdd(map) {
    var className = 'leaflet-gmx-center',
        svgNS = 'http://www.w3.org/2000/svg',
        container = L$1.DomUtil.create('div', className),
        div = L$1.DomUtil.create('div', className),
        svg = document.createElementNS(svgNS, 'svg'),
        g = document.createElementNS(svgNS, 'g'),
        path = document.createElementNS(svgNS, 'path');
    this._container = container;
    container._id = this.options.id;

    if (this.options.notHide) {
      container._notHide = true;
    }

    path.setAttribute('stroke-width', 1);
    path.setAttribute('stroke-opacity', 1);
    path.setAttribute('d', 'M6 0L6 12M0 6L12 6');
    this._path = path;
    g.appendChild(path);
    svg.appendChild(g);
    svg.setAttribute('width', 12);
    svg.setAttribute('height', 12);
    div.appendChild(svg);
    container.appendChild(div);
    this.setColor(this.options.color);
    map.fire('controladd', this);

    if (map.gmxControlsManager) {
      map.gmxControlsManager.add(this);
    }

    return container;
  },
  setColor: function setColor(color) {
    this.options.color = color;

    if (this._map) {
      this._path.setAttribute('stroke', color);
    }

    return this;
  }
});
L$1.Control.gmxCenter = L$1.Control.GmxCenter;

L$1.control.gmxCenter = function (options) {
  return new L$1.Control.GmxCenter(options);
};

var gmxCenter = L$1.Control.GmxCenter;

var Content = L$1.Control.extend({
  options: {
    position: 'bottomleft'
  },
  initialize: function initialize() {
    this._current = null;
    this._views = {};
  },
  onAdd: function onAdd(map) {
    this._container = L$1.DomUtil.create('div', 'scanex-forestry-content');
    L$1.DomEvent.disableScrollPropagation(this._container);
    L$1.DomEvent.disableClickPropagation(this._container);
    return this._container;
  },
  onRemove: function onRemove(map) {},
  add: function add(id, View, options) {
    var _this = this;

    if (!this.has(id)) {
      var container = L$1.DomUtil.create('div', 'view hidden', this._container);
      container.setAttribute('data-id', id);
      this._views[id] = new View(container, options);

      this._views[id].on('open', function () {
        _this.close();

        container.classList.remove('hidden');
        _this._current = id;
      }).on('close', function () {
        container.classList.add('hidden');
        _this._current = null;
      });
    }

    return this._views[id];
  },
  has: function has(id) {
    return !!this._views[id];
  },
  close: function close() {
    var _this2 = this;

    Object.keys(this._views).forEach(function (id) {
      return _this2._views[id].close();
    });
  },
  isDefault: function isDefault() {
    return !this.getCurrentId();
  },
  getCurrent: function getCurrent() {
    var id = this.getCurrentId();
    return this._views[id];
  },
  getCurrentId: function getCurrentId() {
    return this._current;
  }
});

var tzm = new Date().getTimezoneOffset() * 60000,
    getUTCTimeString = function getUTCTimeString(time) {
  var arr = time.toISOString().split('T'),
      tm = arr[1].split(':');
  return arr[0].split('-').reverse().join('.') + ' ' + tm[0] + ':' + tm[1] + ':' + tm[2].substring(0, 2);
},
    getTimeString = function getTimeString(dt) {
  var pad2 = L.gmxUtil.pad2;
  return [pad2(dt.getDate()), pad2(dt.getMonth() + 1), dt.getFullYear()].join('.') + ' ' + [pad2(dt.getHours()), pad2(dt.getMinutes() + (dt.getSeconds() > 0 ? 1 : 0))].join(':');
}; // divDot.title = this.start.toLocaleString();
// tzm = 0;

/**
 * @file timeline.js
 * http://almende.github.io/chap-links-library/js/timeline/doc/#Example
 * @brief
 * The Timeline is an interactive visualization chart to visualize events in
 * time, having a start and end date.
 * You can freely move and zoom in the timeline by dragging
 * and scrolling in the Timeline. Items are optionally dragable. The time
 * scale on the axis is adjusted automatically, and supports scales ranging
 * from milliseconds to years.
 *
 * Timeline is part of the CHAP Links library.
 *
 * Timeline is tested on Firefox 3.6, Safari 5.0, Chrome 6.0, Opera 10.6, and
 * Internet Explorer 6+.
 *
 * @license
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Copyright (c) 2011-2015 Almende B.V.
 *
 * @author  Jos de Jong, <jos@almende.org>
 * @date    2015-03-04
 * @version 2.9.1
 */

/*
 * i18n mods by github user iktuz (https://gist.github.com/iktuz/3749287/)
 * added to v2.4.1 with da_DK language by @bjarkebech
 */

/*
 * TODO
 *
 * Add zooming with pinching on Android
 *
 * Bug: when an item contains a javascript onclick or a link, this does not work
 *      when the item is not selected (when the item is being selected,
 *      it is redrawn, which cancels any onclick or link action)
 * Bug: when an item contains an image without size, or a css max-width, it is not sized correctly
 * Bug: neglect items when they have no valid start/end, instead of throwing an error
 * Bug: Pinching on ipad does not work very well, sometimes the page will zoom when pinching vertically
 * Bug: cannot set max width for an item, like div.timeline-event-content {white-space: normal; max-width: 100px;}
 * Bug on IE in Quirks mode. When you have groups, and delete an item, the groups become invisible
 */

/**
 * Declare a unique namespace for CHAP's Common Hybrid Visualisation Library,
 * "links"
 */


var links = {}; // if (typeof links === 'undefined') {
// links = {};
// important: do not use var, as "var links = {};" will overwrite
//            the existing links variable value with undefined in IE8, IE7.
// }

/**
 * Ensure the variable google exists
 */
// if (typeof google === 'undefined') {

window.google = undefined; // important: do not use var, as "var google = undefined;" will overwrite
//            the existing google variable value with undefined in IE8, IE7.
// }
// Internet Explorer 8 and older does not support Array.indexOf,
// so we define it here in that case
// http://soledadpenades.com/2007/05/17/arrayindexof-in-internet-explorer/

if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (obj) {
    for (var i = 0; i < this.length; i++) {
      if (this[i] == obj) {
        return i;
      }
    }

    return -1;
  };
} // Internet Explorer 8 and older does not support Array.forEach,
// so we define it here in that case
// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach


if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (fn, scope) {
    for (var i = 0, len = this.length; i < len; ++i) {
      fn.call(scope || this, this[i], i, this);
    }
  };
}
/**
 * @constructor links.Timeline
 * The timeline is a visualization chart to visualize events in time.
 *
 * The timeline is developed in javascript as a Google Visualization Chart.
 *
 * @param {Element} container   The DOM element in which the Timeline will
 *                              be created. Normally a div element.
 * @param {Object} options      A name/value map containing settings for the
 *                              timeline. Optional.
 */


links.Timeline = function (container, options) {
  if (!container) {
    // this call was probably only for inheritance, no constructor-code is required
    return;
  }

  this.getUTCTimeString = getUTCTimeString; // create variables and set default values

  this.dom = {};
  this.conversion = {};
  this.eventParams = {}; // stores parameters for mouse events

  this.groups = [];
  this.groupIndexes = {};
  this.items = [];
  this.renderQueue = {
    show: [],
    // Items made visible but not yet added to DOM
    hide: [],
    // Items currently visible but not yet removed from DOM
    update: [] // Items with changed data but not yet adjusted DOM

  };
  this.renderedItems = []; // Items currently rendered in the DOM

  this.clusterGenerator = new links.Timeline.ClusterGenerator(this);
  this.currentClusters = [];
  this.selection = undefined; // stores index and item which is currently selected

  this.listeners = {}; // event listener callbacks
  // Initialize sizes.
  // Needed for IE (which gives an error when you try to set an undefined
  // value in a style)

  this.size = {
    'actualHeight': 0,
    'axis': {
      'characterMajorHeight': 0,
      'characterMajorWidth': 0,
      'characterMinorHeight': 0,
      'characterMinorWidth': 0,
      'height': 0,
      'labelMajorTop': 0,
      'labelMinorTop': 0,
      'line': 0,
      'lineMajorWidth': 0,
      'lineMinorHeight': 0,
      'lineMinorTop': 0,
      'lineMinorWidth': 0,
      'top': 0
    },
    'contentHeight': 0,
    'contentLeft': 0,
    'contentWidth': 0,
    'frameHeight': 0,
    'frameWidth': 0,
    'groupsLeft': 0,
    'groupsWidth': 0,
    'items': {
      'top': 0
    }
  };
  this.dom.container = container; //
  // Let's set the default options first
  //

  this.options = {
    'width': "100%",
    'height': "auto",
    'minHeight': 0,
    // minimal height in pixels
    'groupMinHeight': 0,
    'autoHeight': true,
    'eventMargin': 10,
    // minimal margin between events
    'eventMarginAxis': 20,
    // minimal margin between events and the axis
    'dragAreaWidth': 10,
    // pixels
    'min': undefined,
    'max': undefined,
    'zoomMin': 10,
    // milliseconds
    'zoomMax': 1000 * 60 * 60 * 24 * 365 * 10000,
    // milliseconds
    'moveable': true,
    'zoomable': true,
    'selectable': true,
    'unselectable': true,
    'editable': false,
    'snapEvents': true,
    'groupsChangeable': true,
    'timeChangeable': true,
    'showCurrentTime': true,
    // show a red bar displaying the current time
    'showCustomTime': false,
    // show a blue, draggable bar displaying a custom time
    'showMajorLabels': true,
    'showMinorLabels': true,
    'showNavigation': false,
    'showButtonNew': false,
    'groupsOnRight': false,
    'groupsOrder': true,
    'axisOnTop': false,
    'stackEvents': true,
    'animate': true,
    'animateZoom': true,
    'cluster': false,
    'clusterMaxItems': 5,
    'style': 'box',
    'customStackOrder': false,
    //a function(a,b) for determining stackorder amongst a group of items. Essentially a comparator, -ve value for "a before b" and vice versa
    // i18n: Timeline only has built-in English text per default. Include timeline-locales.js to support more localized text.
    'locale': 'en',
    'MONTHS': ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    'MONTHS_SHORT': ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    'DAYS': ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    'DAYS_SHORT': ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    'ZOOM_IN': "Zoom in",
    'ZOOM_OUT': "Zoom out",
    'MOVE_LEFT': "Move left",
    'MOVE_RIGHT': "Move right",
    'NEW': "New",
    'CREATE_NEW_EVENT': "Create new event"
  };
  this.clientTimeOffset = 0; // difference between client time and the time
  // set via Timeline.setCurrentTime()

  var dom = this.dom; // remove all elements from the container element.

  while (dom.container.hasChildNodes()) {
    dom.container.removeChild(dom.container.firstChild);
  } // create a step for drawing the axis


  this.step = new links.Timeline.StepDate(); // add standard item types

  this.itemTypes = {
    box: links.Timeline.ItemBox,
    range: links.Timeline.ItemRange,
    floatingRange: links.Timeline.ItemFloatingRange,
    dot: links.Timeline.ItemDot
  }; // initialize data

  this.data = [];
  this.firstDraw = true; // date interval must be initialized

  this.setVisibleChartRange(undefined, undefined, false); // apply provided options

  this.setOptions(options); // render for the first time

  this.render(); // fire the ready event

  var me = this;
  setTimeout(function () {
    me.trigger('ready');
  }, 0);
};
/**
 * Main drawing logic. This is the function that needs to be called
 * in the html page, to draw the timeline.
 *
 * A data table with the events must be provided, and an options table.
 *
 * @param {google.visualization.DataTable}      data
 *                                 The data containing the events for the timeline.
 *                                 Object DataTable is defined in
 *                                 google.visualization.DataTable
 * @param {Object} options         A name/value map containing settings for the
 *                                 timeline. Optional. The use of options here
 *                                 is deprecated. Pass timeline options in the
 *                                 constructor or use setOptions()
 */


links.Timeline.prototype.draw = function (data, options) {
  if (options) {
    console.log("WARNING: Passing options in draw() is deprecated. Pass options to the constructur or use setOptions() instead!");
    this.setOptions(options);
  }

  if (this.options.selectable) {
    links.Timeline.addClassName(this.dom.frame, "timeline-selectable");
  } // read the data


  this.setData(data);

  if (this.firstDraw) {
    this.setVisibleChartRangeAuto();
  }

  this.firstDraw = false;
};
/**
 * Set options for the timeline.
 * Timeline must be redrawn afterwards
 * @param {Object} options A name/value map containing settings for the
 *                                 timeline. Optional.
 */


links.Timeline.prototype.setOptions = function (options) {
  if (options) {
    // retrieve parameter values
    for (var i in options) {
      if (options.hasOwnProperty(i)) {
        this.options[i] = options[i];
      }
    } // prepare i18n dependent on set locale


    if (typeof links.locales !== 'undefined' && this.options.locale !== 'en') {
      var localeOpts = links.locales[this.options.locale];

      if (localeOpts) {
        for (var l in localeOpts) {
          if (localeOpts.hasOwnProperty(l)) {
            this.options[l] = localeOpts[l];
          }
        }
      }
    } // check for deprecated options


    if (options.showButtonAdd != undefined) {
      this.options.showButtonNew = options.showButtonAdd;
      console.log('WARNING: Option showButtonAdd is deprecated. Use showButtonNew instead');
    }

    if (options.intervalMin != undefined) {
      this.options.zoomMin = options.intervalMin;
      console.log('WARNING: Option intervalMin is deprecated. Use zoomMin instead');
    }

    if (options.intervalMax != undefined) {
      this.options.zoomMax = options.intervalMax;
      console.log('WARNING: Option intervalMax is deprecated. Use zoomMax instead');
    }

    if (options.scale && options.step) {
      this.step.setScale(options.scale, options.step);
    }
  } // validate options


  this.options.autoHeight = this.options.height === "auto";
};
/**
 * Get options for the timeline.
 *
 * @return the options object
 */


links.Timeline.prototype.getOptions = function () {
  return this.options;
};
/**
 * Add new type of items
 * @param {String} typeName  Name of new type
 * @param {links.Timeline.Item} typeFactory Constructor of items
 */


links.Timeline.prototype.addItemType = function (typeName, typeFactory) {
  this.itemTypes[typeName] = typeFactory;
};
/**
 * Retrieve a map with the column indexes of the columns by column name.
 * For example, the method returns the map
 *     {
 *         start: 0,
 *         end: 1,
 *         content: 2,
 *         group: undefined,
 *         className: undefined
 *         editable: undefined
 *         type: undefined
 *     }
 * @param {google.visualization.DataTable} dataTable
 * @type {Object} map
 */


links.Timeline.mapColumnIds = function (dataTable) {
  var cols = {},
      colCount = dataTable.getNumberOfColumns(),
      allUndefined = true; // loop over the columns, and map the column id's to the column indexes

  for (var col = 0; col < colCount; col++) {
    var id = dataTable.getColumnId(col) || dataTable.getColumnLabel(col);
    cols[id] = col;

    if (id == 'start' || id == 'end' || id == 'content' || id == 'group' || id == 'className' || id == 'editable' || id == 'type') {
      allUndefined = false;
    }
  } // if no labels or ids are defined, use the default mapping
  // for start, end, content, group, className, editable, type


  if (allUndefined) {
    cols.start = 0;
    cols.end = 1;
    cols.content = 2;

    if (colCount > 3) {
      cols.group = 3;
    }

    if (colCount > 4) {
      cols.className = 4;
    }

    if (colCount > 5) {
      cols.editable = 5;
    }

    if (colCount > 6) {
      cols.type = 6;
    }
  }

  return cols;
};
/**
 * Set data for the timeline
 * @param {google.visualization.DataTable | Array} data
 */


links.Timeline.prototype.setData = function (data) {
  // unselect any previously selected item
  this.unselectItem();

  if (!data) {
    data = [];
  } // clear all data


  this.stackCancelAnimation();
  this.clearItems();
  this.data = data;
  var items = this.items;
  this.deleteGroups();

  if (google && google.visualization && data instanceof google.visualization.DataTable) {
    // map the datatable columns
    var cols = links.Timeline.mapColumnIds(data); // read DataTable

    for (var row = 0, rows = data.getNumberOfRows(); row < rows; row++) {
      items.push(this.createItem({
        'start': cols.start != undefined ? data.getValue(row, cols.start) : undefined,
        'end': cols.end != undefined ? data.getValue(row, cols.end) : undefined,
        'content': cols.content != undefined ? data.getValue(row, cols.content) : undefined,
        'group': cols.group != undefined ? data.getValue(row, cols.group) : undefined,
        'className': cols.className != undefined ? data.getValue(row, cols.className) : undefined,
        'editable': cols.editable != undefined ? data.getValue(row, cols.editable) : undefined,
        'type': cols.type != undefined ? data.getValue(row, cols.type) : undefined
      }));
    }
  } else if (links.Timeline.isArray(data)) {
    // read JSON array
    for (var row = 0, rows = data.length; row < rows; row++) {
      var itemData = data[row];
      var item = this.createItem(itemData);
      items.push(item);
    }
  } else {
    throw "Unknown data type. DataTable or Array expected.";
  } // prepare data for clustering, by filtering and sorting by type


  if (this.options.cluster) {
    this.clusterGenerator.setData(this.items);
  }

  this.render({
    animate: false
  });
};
/**
 * Return the original data table.
 * @return {google.visualization.DataTable | Array} data
 */


links.Timeline.prototype.getData = function () {
  return this.data;
};
/**
 * Update the original data with changed start, end or group.
 *
 * @param {Number} index
 * @param {Object} values   An object containing some of the following parameters:
 *                          {Date} start,
 *                          {Date} end,
 *                          {String} content,
 *                          {String} group
 */


links.Timeline.prototype.updateData = function (index, values) {
  var data = this.data,
      prop;

  if (google && google.visualization && data instanceof google.visualization.DataTable) {
    // update the original google DataTable
    var missingRows = index + 1 - data.getNumberOfRows();

    if (missingRows > 0) {
      data.addRows(missingRows);
    } // map the column id's by name


    var cols = links.Timeline.mapColumnIds(data); // merge all fields from the provided data into the current data

    for (prop in values) {
      if (values.hasOwnProperty(prop)) {
        var col = cols[prop];

        if (col == undefined) {
          // create new column
          var value = values[prop];
          var valueType = 'string';

          if (typeof value == 'number') {
            valueType = 'number';
          } else if (typeof value == 'boolean') {
            valueType = 'boolean';
          } else if (value instanceof Date) {
            valueType = 'datetime';
          }

          col = data.addColumn(valueType, prop);
        }

        data.setValue(index, col, values[prop]); // TODO: correctly serialize the start and end Date to the desired type (Date, String, or Number)
      }
    }
  } else if (links.Timeline.isArray(data)) {
    // update the original JSON table
    var row = data[index];

    if (row == undefined) {
      row = {};
      data[index] = row;
    } // merge all fields from the provided data into the current data


    for (prop in values) {
      if (values.hasOwnProperty(prop)) {
        row[prop] = values[prop]; // TODO: correctly serialize the start and end Date to the desired type (Date, String, or Number)
      }
    }
  } else {
    throw "Cannot update data, unknown type of data";
  }
};
/**
 * Find the item index from a given HTML element
 * If no item index is found, undefined is returned
 * @param {Element} element
 * @return {Number | undefined} index
 */


links.Timeline.prototype.getItemIndex = function (element) {
  var e = element,
      dom = this.dom,
      frame = dom.items.frame,
      items = this.items,
      index = undefined; // try to find the frame where the items are located in

  while (e.parentNode && e.parentNode !== frame) {
    e = e.parentNode;
  }

  if (e.parentNode === frame) {
    // yes! we have found the parent element of all items
    // retrieve its id from the array with items
    for (var i = 0, iMax = items.length; i < iMax; i++) {
      if (items[i].dom === e) {
        index = i;
        break;
      }
    }
  }

  return index;
};
/**
 * Find the cluster index from a given HTML element
 * If no cluster index is found, undefined is returned
 * @param {Element} element
 * @return {Number | undefined} index
 */


links.Timeline.prototype.getClusterIndex = function (element) {
  var e = element,
      dom = this.dom,
      frame = dom.items.frame,
      clusters = this.clusters,
      index = undefined;

  if (this.clusters) {
    // try to find the frame where the clusters are located in
    while (e.parentNode && e.parentNode !== frame) {
      e = e.parentNode;
    }

    if (e.parentNode === frame) {
      // yes! we have found the parent element of all clusters
      // retrieve its id from the array with clusters
      for (var i = 0, iMax = clusters.length; i < iMax; i++) {
        if (clusters[i].dom === e) {
          index = i;
          break;
        }
      }
    }
  }

  return index;
};
/**
 * Find all elements within the start and end range
 * If no element is found, returns an empty array
 * @param start time
 * @param end time
 * @return Array itemsInRange
 */


links.Timeline.prototype.getVisibleItems = function (start, end) {
  var items = this.items;
  var itemsInRange = [];

  if (items) {
    for (var i = 0, iMax = items.length; i < iMax; i++) {
      var item = items[i];

      if (item.end) {
        // Time range object // NH use getLeft and getRight here
        if (start <= item.start && item.end <= end) {
          itemsInRange.push({
            "row": i
          });
        }
      } else {
        // Point object
        if (start <= item.start && item.start <= end) {
          itemsInRange.push({
            "row": i
          });
        }
      }
    }
  } //     var sel = [];
  // if (this.selection) {
  //     sel.push({"row": this.selection.index});
  // }
  // return sel;


  return itemsInRange;
};
/**
 * Set a new size for the timeline
 * @param {string} width   Width in pixels or percentage (for example "800px"
 *                         or "50%")
 * @param {string} height  Height in pixels or percentage  (for example "400px"
 *                         or "30%")
 */


links.Timeline.prototype.setSize = function (width, height) {
  if (width) {
    this.options.width = width;
    this.dom.frame.style.width = width;
  }

  if (height) {
    this.options.height = height;
    this.options.autoHeight = this.options.height === "auto";

    if (height !== "auto") {
      this.dom.frame.style.height = height;
    }
  }

  this.render({
    animate: false
  });
};
/**
 * Set a new value for the visible range int the timeline.
 * Set start undefined to include everything from the earliest date to end.
 * Set end undefined to include everything from start to the last date.
 * Example usage:
 *    myTimeline.setVisibleChartRange(new Date("2010-08-22"),
 *                                    new Date("2010-09-13"));
 * @param {Date}   start     The start date for the timeline. optional
 * @param {Date}   end       The end date for the timeline. optional
 * @param {boolean} redraw   Optional. If true (default) the Timeline is
 *                           directly redrawn
 */


links.Timeline.prototype.setVisibleChartRange = function (start, end, redraw) {
  var range = {};

  if (!start || !end) {
    // retrieve the date range of the items
    range = this.getDataRange(true);
  }

  if (!start) {
    if (end) {
      if (range.min && range.min.valueOf() < end.valueOf()) {
        // start of the data
        start = range.min;
      } else {
        // 7 days before the end
        start = new Date(end.valueOf());
        start.setDate(start.getDate() - 7);
      }
    } else {
      // default of 3 days ago
      start = new Date();
      start.setDate(start.getDate() - 3);
    }
  }

  if (!end) {
    if (range.max) {
      // end of the data
      end = range.max;
    } else {
      // 7 days after start
      end = new Date(start.valueOf());
      end.setDate(end.getDate() + 7);
    }
  } // prevent start Date <= end Date


  if (end <= start) {
    end = new Date(start.valueOf());
    end.setDate(end.getDate() + 7);
  } // limit to the allowed range (don't let this do by applyRange,
  // because that method will try to maintain the interval (end-start)


  var min = this.options.min ? this.options.min : undefined; // date

  if (min != undefined && start.valueOf() < min.valueOf()) {
    start = new Date(min.valueOf()); // date
  }

  var max = this.options.max ? this.options.max : undefined; // date

  if (max != undefined && end.valueOf() > max.valueOf()) {
    end = new Date(max.valueOf()); // date
  }

  this.applyRange(start, end);

  if (redraw == undefined || redraw == true) {
    this.render({
      animate: false
    }); // TODO: optimize, no reflow needed
  } else {
    this.recalcConversion();
  }
};
/**
 * Change the visible chart range such that all items become visible
 */


links.Timeline.prototype.setVisibleChartRangeAuto = function () {
  var range = this.getDataRange(true);
  this.setVisibleChartRange(range.min, range.max);
};
/**
 * Adjust the visible range such that the current time is located in the center
 * of the timeline
 */


links.Timeline.prototype.setVisibleChartRangeNow = function () {
  var now = new Date();
  var diff = this.end.valueOf() - this.start.valueOf();
  var startNew = new Date(now.valueOf() - diff / 2);
  var endNew = new Date(startNew.valueOf() + diff);
  this.setVisibleChartRange(startNew, endNew);
};
/**
 * Retrieve the current visible range in the timeline.
 * @return {Object} An object with start and end properties
 */


links.Timeline.prototype.getVisibleChartRange = function () {
  return {
    'start': new Date(this.start.valueOf()),
    'end': new Date(this.end.valueOf())
  };
};
/**
 * Get the date range of the items.
 * @param {boolean} [withMargin]  If true, 5% of whitespace is added to the
 *                                left and right of the range. Default is false.
 * @return {Object} range    An object with parameters min and max.
 *                           - {Date} min is the lowest start date of the items
 *                           - {Date} max is the highest start or end date of the items
 *                           If no data is available, the values of min and max
 *                           will be undefined
 */


links.Timeline.prototype.getDataRange = function (withMargin) {
  var items = this.items,
      min = undefined,
      // number
  max = undefined; // number

  if (items) {
    for (var i = 0, iMax = items.length; i < iMax; i++) {
      var item = items[i],
          start = item.start != undefined ? item.start.valueOf() : undefined,
          end = item.end != undefined ? item.end.valueOf() : start;

      if (start != undefined) {
        min = min != undefined ? Math.min(min.valueOf(), start.valueOf()) : start;
      }

      if (end != undefined) {
        max = max != undefined ? Math.max(max.valueOf(), end.valueOf()) : end;
      }
    }
  }

  if (min && max && withMargin) {
    // zoom out 5% such that you have a little white space on the left and right
    var diff = max - min;
    min = min - diff * 0.05;
    max = max + diff * 0.05;
  }

  return {
    'min': min != undefined ? new Date(min) : undefined,
    'max': max != undefined ? new Date(max) : undefined
  };
};
/**
 * Re-render (reflow and repaint) all components of the Timeline: frame, axis,
 * items, ...
 * @param {Object} [options]  Available options:
 *                            {boolean} renderTimesLeft   Number of times the
 *                                                        render may be repeated
 *                                                        5 times by default.
 *                            {boolean} animate           takes options.animate
 *                                                        as default value
 */


links.Timeline.prototype.render = function (options) {
  var frameResized = this.reflowFrame();
  var axisResized = this.reflowAxis();
  var groupsResized = this.reflowGroups();
  var itemsResized = this.reflowItems();
  // if (resized) {

  var animate = this.options.animate;

  if (options && options.animate != undefined) {
    animate = options.animate;
  }

  this.recalcConversion();
  this.clusterItems();
  this.filterItems();
  this.stackItems(animate);
  this.recalcItems(); // TODO: only repaint when resized or when filterItems or stackItems gave a change?

  var needsReflow = this.repaint(); // re-render once when needed (prevent endless re-render loop)

  if (needsReflow) {
    var renderTimesLeft = options ? options.renderTimesLeft : undefined;

    if (renderTimesLeft == undefined) {
      renderTimesLeft = 5;
    }

    if (renderTimesLeft > 0) {
      this.render({
        'animate': options ? options.animate : undefined,
        'renderTimesLeft': renderTimesLeft - 1
      });
    }
  }
};
/**
 * Repaint all components of the Timeline
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */


links.Timeline.prototype.repaint = function () {
  var frameNeedsReflow = this.repaintFrame();
  var axisNeedsReflow = this.repaintAxis();
  var groupsNeedsReflow = this.repaintGroups();
  var itemsNeedsReflow = this.repaintItems();
  this.repaintCurrentTime();
  this.repaintCustomTime();
  return frameNeedsReflow || axisNeedsReflow || groupsNeedsReflow || itemsNeedsReflow;
};
/**
 * Reflow the timeline frame
 * @return {boolean} resized    Returns true if any of the frame elements
 *                              have been resized.
 */


links.Timeline.prototype.reflowFrame = function () {
  var dom = this.dom,
      options = this.options,
      size = this.size,
      resized = false; // Note: IE7 has issues with giving frame.clientWidth, therefore I use offsetWidth instead

  var frameWidth = dom.frame ? dom.frame.offsetWidth : 0,
      frameHeight = dom.frame ? dom.frame.clientHeight : 0;
  resized = resized || size.frameWidth !== frameWidth;
  resized = resized || size.frameHeight !== frameHeight;
  size.frameWidth = frameWidth;
  size.frameHeight = frameHeight;
  return resized;
};
/**
 * repaint the Timeline frame
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */


links.Timeline.prototype.repaintFrame = function () {
  var needsReflow = false,
      dom = this.dom,
      options = this.options,
      size = this.size; // main frame

  if (!dom.frame) {
    dom.frame = document.createElement("DIV");
    dom.frame.className = "timeline-frame";
    dom.container.appendChild(dom.frame);
    needsReflow = true;
  }

  var height = options.autoHeight ? size.actualHeight + "px" : options.height || "100%";
  var width = options.width || "100%";
  needsReflow = needsReflow || dom.frame.style.height != height;
  needsReflow = needsReflow || dom.frame.style.width != width;
  dom.frame.style.height = height;
  dom.frame.style.width = width; // contents

  if (!dom.content) {
    // create content box where the axis and items will be created
    dom.content = document.createElement("DIV");
    dom.content.className = "timeline-content";
    dom.frame.appendChild(dom.content);
    var timelines = document.createElement("DIV");
    timelines.style.position = "absolute";
    timelines.style.left = "0px";
    timelines.style.top = "0px";
    timelines.style.height = "100%";
    timelines.style.width = "0px";
    dom.content.appendChild(timelines);
    dom.contentTimelines = timelines;
    var params = this.eventParams,
        me = this;

    if (!params.onMouseDown) {
      params.onMouseDown = function (event) {
        me.onMouseDown(event);
      };

      links.Timeline.addEventListener(dom.content, "mousedown", params.onMouseDown);
    }

    if (!params.onTouchStart) {
      params.onTouchStart = function (event) {
        me.onTouchStart(event);
      };

      links.Timeline.addEventListener(dom.content, "touchstart", params.onTouchStart);
    }

    if (!params.onMouseWheel) {
      params.onMouseWheel = function (event) {
        me.onMouseWheel(event);
      };

      links.Timeline.addEventListener(dom.content, "mousewheel", params.onMouseWheel);
    }

    if (!params.onDblClick) {
      params.onDblClick = function (event) {
        me.onDblClick(event);
      };

      links.Timeline.addEventListener(dom.content, "dblclick", params.onDblClick);
    }

    needsReflow = true;
  }

  dom.content.style.left = size.contentLeft + "px";
  dom.content.style.top = "0px";
  dom.content.style.width = size.contentWidth + "px";
  dom.content.style.height = size.frameHeight + "px";
  this.repaintNavigation();
  return needsReflow;
};
/**
 * Reflow the timeline axis. Calculate its height, width, positioning, etc...
 * @return {boolean} resized    returns true if the axis is resized
 */


links.Timeline.prototype.reflowAxis = function () {
  var resized = false,
      dom = this.dom,
      options = this.options,
      size = this.size,
      axisDom = dom.axis;
  var characterMinorWidth = axisDom && axisDom.characterMinor ? axisDom.characterMinor.clientWidth : 0,
      characterMinorHeight = axisDom && axisDom.characterMinor ? axisDom.characterMinor.clientHeight : 0,
      characterMajorWidth = axisDom && axisDom.characterMajor ? axisDom.characterMajor.clientWidth : 0,
      characterMajorHeight = axisDom && axisDom.characterMajor ? axisDom.characterMajor.clientHeight : 0,
      axisHeight = (options.showMinorLabels ? characterMinorHeight : 0) + (options.showMajorLabels ? characterMajorHeight : 0);
  var axisTop = options.axisOnTop ? 0 : size.frameHeight - axisHeight,
      axisLine = options.axisOnTop ? axisHeight : axisTop;
  resized = resized || size.axis.top !== axisTop;
  resized = resized || size.axis.line !== axisLine;
  resized = resized || size.axis.height !== axisHeight;
  size.axis.top = axisTop;
  size.axis.line = axisLine;
  size.axis.height = axisHeight;
  size.axis.labelMajorTop = options.axisOnTop ? 0 : axisLine + (options.showMinorLabels ? characterMinorHeight : 0);
  size.axis.labelMinorTop = options.axisOnTop ? options.showMajorLabels ? characterMajorHeight : 0 : axisLine;
  size.axis.lineMinorTop = options.axisOnTop ? size.axis.labelMinorTop : 0;
  size.axis.lineMinorHeight = options.showMajorLabels ? size.frameHeight - characterMajorHeight : size.frameHeight;

  if (axisDom && axisDom.minorLines && axisDom.minorLines.length) {
    size.axis.lineMinorWidth = axisDom.minorLines[0].offsetWidth;
  } else {
    size.axis.lineMinorWidth = 1;
  }

  if (axisDom && axisDom.majorLines && axisDom.majorLines.length) {
    size.axis.lineMajorWidth = axisDom.majorLines[0].offsetWidth;
  } else {
    size.axis.lineMajorWidth = 1;
  }

  resized = resized || size.axis.characterMinorWidth !== characterMinorWidth;
  resized = resized || size.axis.characterMinorHeight !== characterMinorHeight;
  resized = resized || size.axis.characterMajorWidth !== characterMajorWidth;
  resized = resized || size.axis.characterMajorHeight !== characterMajorHeight;
  size.axis.characterMinorWidth = characterMinorWidth;
  size.axis.characterMinorHeight = characterMinorHeight;
  size.axis.characterMajorWidth = characterMajorWidth;
  size.axis.characterMajorHeight = characterMajorHeight;
  var contentHeight = Math.max(size.frameHeight - axisHeight, 0);
  size.contentLeft = options.groupsOnRight ? 0 : size.groupsWidth;
  size.contentWidth = Math.max(size.frameWidth - size.groupsWidth, 0);
  size.contentHeight = contentHeight;
  return resized;
};
/**
 * Redraw the timeline axis with minor and major labels
 * @return {boolean} needsReflow     Returns true if the DOM is changed such
 *                                   that a reflow is needed.
 */


links.Timeline.prototype.repaintAxis = function () {
  var needsReflow = false,
      dom = this.dom,
      options = this.options,
      size = this.size,
      step = this.step;
  var axis = dom.axis;

  if (!axis) {
    axis = {};
    dom.axis = axis;
  }

  if (!size.axis.properties) {
    size.axis.properties = {};
  }

  if (!axis.minorTexts) {
    axis.minorTexts = [];
  }

  if (!axis.minorLines) {
    axis.minorLines = [];
  }

  if (!axis.majorTexts) {
    axis.majorTexts = [];
  }

  if (!axis.majorLines) {
    axis.majorLines = [];
  }

  if (!axis.frame) {
    axis.frame = document.createElement("DIV");
    axis.frame.style.position = "absolute";
    axis.frame.style.left = "0px";
    axis.frame.style.top = "0px";
    dom.content.appendChild(axis.frame);
  } // take axis offline


  dom.content.removeChild(axis.frame);
  axis.frame.style.width = size.contentWidth + "px";
  axis.frame.style.height = size.axis.height + "px"; // the drawn axis is more wide than the actual visual part, such that
  // the axis can be dragged without having to redraw it each time again.

  var start = this.screenToTime(0);
  var end = this.screenToTime(size.contentWidth); // calculate minimum step (in milliseconds) based on character size

  if (size.axis.characterMinorWidth) {
    this.minimumStep = this.screenToTime(size.axis.characterMinorWidth * 6) - this.screenToTime(0);
    step.setRange(start, end, this.minimumStep);
  }

  var charsNeedsReflow = this.repaintAxisCharacters();
  needsReflow = needsReflow || charsNeedsReflow; // The current labels on the axis will be re-used (much better performance),
  // therefore, the repaintAxis method uses the mechanism with
  // repaintAxisStartOverwriting, repaintAxisEndOverwriting, and
  // this.size.axis.properties is used.

  this.repaintAxisStartOverwriting();
  step.start();
  var xFirstMajorLabel = undefined;
  var max = 0;

  while (!step.end() && max < 1000) {
    max++;
    var cur = step.getCurrent(),
        x = this.timeToScreen(cur),
        isMajor = step.isMajor();

    if (options.showMinorLabels) {
      this.repaintAxisMinorText(x, step.getLabelMinor(options));
    }

    if (isMajor && options.showMajorLabels) {
      if (x > 0) {
        if (xFirstMajorLabel == undefined) {
          xFirstMajorLabel = x;
        }

        this.repaintAxisMajorText(x, step.getLabelMajor(options));
      }

      this.repaintAxisMajorLine(x);
    } else {
      this.repaintAxisMinorLine(x);
    }

    step.next();
  } // create a major label on the left when needed


  if (options.showMajorLabels) {
    var leftTime = this.screenToTime(0),
        leftText = this.step.getLabelMajor(options, leftTime),
        width = leftText.length * size.axis.characterMajorWidth + 10; // upper bound estimation

    if (xFirstMajorLabel == undefined || width < xFirstMajorLabel) {
      this.repaintAxisMajorText(0, leftText, leftTime);
    }
  } // cleanup left over labels


  this.repaintAxisEndOverwriting();
  this.repaintAxisHorizontal(); // put axis online

  dom.content.insertBefore(axis.frame, dom.content.firstChild);
  return needsReflow;
};
/**
 * Create characters used to determine the size of text on the axis
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */


links.Timeline.prototype.repaintAxisCharacters = function () {
  // calculate the width and height of a single character
  // this is used to calculate the step size, and also the positioning of the
  // axis
  var needsReflow = false,
      dom = this.dom,
      axis = dom.axis,
      text;

  if (!axis.characterMinor) {
    text = document.createTextNode("0");
    var characterMinor = document.createElement("DIV");
    characterMinor.className = "timeline-axis-text timeline-axis-text-minor";
    characterMinor.appendChild(text);
    characterMinor.style.position = "absolute";
    characterMinor.style.visibility = "hidden";
    characterMinor.style.paddingLeft = "0px";
    characterMinor.style.paddingRight = "0px";
    axis.frame.appendChild(characterMinor);
    axis.characterMinor = characterMinor;
    needsReflow = true;
  }

  if (!axis.characterMajor) {
    text = document.createTextNode("0");
    var characterMajor = document.createElement("DIV");
    characterMajor.className = "timeline-axis-text timeline-axis-text-major";
    characterMajor.appendChild(text);
    characterMajor.style.position = "absolute";
    characterMajor.style.visibility = "hidden";
    characterMajor.style.paddingLeft = "0px";
    characterMajor.style.paddingRight = "0px";
    axis.frame.appendChild(characterMajor);
    axis.characterMajor = characterMajor;
    needsReflow = true;
  }

  return needsReflow;
};
/**
 * Initialize redraw of the axis. All existing labels and lines will be
 * overwritten and reused.
 */


links.Timeline.prototype.repaintAxisStartOverwriting = function () {
  var properties = this.size.axis.properties;
  properties.minorTextNum = 0;
  properties.minorLineNum = 0;
  properties.majorTextNum = 0;
  properties.majorLineNum = 0;
};
/**
 * End of overwriting HTML DOM elements of the axis.
 * remaining elements will be removed
 */


links.Timeline.prototype.repaintAxisEndOverwriting = function () {
  var dom = this.dom,
      props = this.size.axis.properties,
      frame = this.dom.axis.frame,
      num; // remove leftovers

  var minorTexts = dom.axis.minorTexts;
  num = props.minorTextNum;

  while (minorTexts.length > num) {
    var minorText = minorTexts[num];
    frame.removeChild(minorText);
    minorTexts.splice(num, 1);
  }

  var minorLines = dom.axis.minorLines;
  num = props.minorLineNum;

  while (minorLines.length > num) {
    var minorLine = minorLines[num];
    frame.removeChild(minorLine);
    minorLines.splice(num, 1);
  }

  var majorTexts = dom.axis.majorTexts;
  num = props.majorTextNum;

  while (majorTexts.length > num) {
    var majorText = majorTexts[num];
    frame.removeChild(majorText);
    majorTexts.splice(num, 1);
  }

  var majorLines = dom.axis.majorLines;
  num = props.majorLineNum;

  while (majorLines.length > num) {
    var majorLine = majorLines[num];
    frame.removeChild(majorLine);
    majorLines.splice(num, 1);
  }
};
/**
 * Repaint the horizontal line and background of the axis
 */


links.Timeline.prototype.repaintAxisHorizontal = function () {
  var axis = this.dom.axis,
      size = this.size,
      options = this.options; // line behind all axis elements (possibly having a background color)

  var hasAxis = options.showMinorLabels || options.showMajorLabels;

  if (hasAxis) {
    if (!axis.backgroundLine) {
      // create the axis line background (for a background color or so)
      var backgroundLine = document.createElement("DIV");
      backgroundLine.className = "timeline-axis";
      backgroundLine.style.position = "absolute";
      backgroundLine.style.left = "0px";
      backgroundLine.style.width = "100%";
      backgroundLine.style.border = "none";
      axis.frame.insertBefore(backgroundLine, axis.frame.firstChild);
      axis.backgroundLine = backgroundLine;
    }

    if (axis.backgroundLine) {
      axis.backgroundLine.style.top = size.axis.top + "px";
      axis.backgroundLine.style.height = size.axis.height + "px";
    }
  } else {
    if (axis.backgroundLine) {
      axis.frame.removeChild(axis.backgroundLine);
      delete axis.backgroundLine;
    }
  } // line before all axis elements


  if (hasAxis) {
    if (axis.line) {
      // put this line at the end of all childs
      var line = axis.frame.removeChild(axis.line);
      axis.frame.appendChild(line);
    } else {
      // make the axis line
      var line = document.createElement("DIV");
      line.className = "timeline-axis";
      line.style.position = "absolute";
      line.style.left = "0px";
      line.style.width = "100%";
      line.style.height = "0px";
      axis.frame.appendChild(line);
      axis.line = line;
    }

    axis.line.style.top = size.axis.line + "px";
  } else {
    if (axis.line && axis.line.parentElement) {
      axis.frame.removeChild(axis.line);
      delete axis.line;
    }
  }
};
/**
 * Create a minor label for the axis at position x
 * @param {Number} x
 * @param {String} text
 */


links.Timeline.prototype.repaintAxisMinorText = function (x, text) {
  var size = this.size,
      dom = this.dom,
      props = size.axis.properties,
      frame = dom.axis.frame,
      minorTexts = dom.axis.minorTexts,
      index = props.minorTextNum,
      label;

  if (index < minorTexts.length) {
    label = minorTexts[index];
  } else {
    // create new label
    var content = document.createTextNode("");
    label = document.createElement("DIV");
    label.appendChild(content);
    label.className = "timeline-axis-text timeline-axis-text-minor";
    label.style.position = "absolute";
    frame.appendChild(label);
    minorTexts.push(label);
  }

  label.childNodes[0].nodeValue = text;
  label.style.left = x + "px";
  label.style.top = size.axis.labelMinorTop + "px"; //label.title = title;  // TODO: this is a heavy operation

  props.minorTextNum++;
};
/**
 * Create a minor line for the axis at position x
 * @param {Number} x
 */


links.Timeline.prototype.repaintAxisMinorLine = function (x) {
  var axis = this.size.axis,
      dom = this.dom,
      props = axis.properties,
      frame = dom.axis.frame,
      minorLines = dom.axis.minorLines,
      index = props.minorLineNum,
      line;

  if (index < minorLines.length) {
    line = minorLines[index];
  } else {
    // create vertical line
    line = document.createElement("DIV");
    line.className = "timeline-axis-grid timeline-axis-grid-minor";
    line.style.position = "absolute";
    line.style.width = "0px";
    frame.appendChild(line);
    minorLines.push(line);
  }

  line.style.top = axis.lineMinorTop + "px";
  line.style.height = axis.lineMinorHeight + "px";
  line.style.left = x - axis.lineMinorWidth / 2 + "px";
  props.minorLineNum++;
};
/**
 * Create a Major label for the axis at position x
 * @param {Number} x
 * @param {String} text
 */


links.Timeline.prototype.repaintAxisMajorText = function (x, text) {
  var size = this.size,
      props = size.axis.properties,
      frame = this.dom.axis.frame,
      majorTexts = this.dom.axis.majorTexts,
      index = props.majorTextNum,
      label;

  if (index < majorTexts.length) {
    label = majorTexts[index];
  } else {
    // create label
    var content = document.createTextNode(text);
    label = document.createElement("DIV");
    label.className = "timeline-axis-text timeline-axis-text-major";
    label.appendChild(content);
    label.style.position = "absolute";
    label.style.top = "0px";
    frame.appendChild(label);
    majorTexts.push(label);
  }

  label.childNodes[0].nodeValue = text;
  label.style.top = size.axis.labelMajorTop + "px";
  label.style.left = x + "px"; //label.title = title; // TODO: this is a heavy operation

  props.majorTextNum++;
};
/**
 * Create a Major line for the axis at position x
 * @param {Number} x
 */


links.Timeline.prototype.repaintAxisMajorLine = function (x) {
  var size = this.size,
      props = size.axis.properties,
      axis = this.size.axis,
      frame = this.dom.axis.frame,
      majorLines = this.dom.axis.majorLines,
      index = props.majorLineNum,
      line;

  if (index < majorLines.length) {
    line = majorLines[index];
  } else {
    // create vertical line
    line = document.createElement("DIV");
    line.className = "timeline-axis-grid timeline-axis-grid-major";
    line.style.position = "absolute";
    line.style.top = "0px";
    line.style.width = "0px";
    frame.appendChild(line);
    majorLines.push(line);
  }

  line.style.left = x - axis.lineMajorWidth / 2 + "px";
  line.style.height = size.frameHeight + "px";
  props.majorLineNum++;
};
/**
 * Reflow all items, retrieve their actual size
 * @return {boolean} resized    returns true if any of the items is resized
 */


links.Timeline.prototype.reflowItems = function () {
  var resized = false,
      i,
      iMax,
      group,
      groups = this.groups,
      renderedItems = this.renderedItems;

  if (groups) {
    // TODO: need to check if labels exists?
    // loop through all groups to reset the items height
    groups.forEach(function (group) {
      group.itemsHeight = group.labelHeight || 0;
    });
  } // loop through the width and height of all visible items


  for (i = 0, iMax = renderedItems.length; i < iMax; i++) {
    var item = renderedItems[i],
        domItem = item.dom;
    group = item.group;

    if (domItem) {
      // TODO: move updating width and height into item.reflow
      var width = domItem ? domItem.clientWidth : 0;
      var height = domItem ? domItem.clientHeight : 0;
      resized = resized || item.width != width;
      resized = resized || item.height != height;
      item.width = width;
      item.height = height; //item.borderWidth = (domItem.offsetWidth - domItem.clientWidth - 2) / 2; // TODO: borderWidth

      item.reflow();
    }

    if (group) {
      group.itemsHeight = Math.max(this.options.groupMinHeight, group.itemsHeight ? Math.max(group.itemsHeight, item.height) : item.height);
    }
  }

  return resized;
};
/**
 * Recalculate item properties:
 * - the height of each group.
 * - the actualHeight, from the stacked items or the sum of the group heights
 * @return {boolean} resized    returns true if any of the items properties is
 *                              changed
 */


links.Timeline.prototype.recalcItems = function () {
  var resized = false,
      i,
      iMax,
      item,
      finalItem,
      finalItems,
      group,
      groups = this.groups,
      size = this.size,
      options = this.options,
      renderedItems = this.renderedItems;
  var actualHeight = 0;

  if (groups.length == 0) {
    // calculate actual height of the timeline when there are no groups
    // but stacked items
    if (options.autoHeight || options.cluster) {
      var min = 0,
          max = 0;

      if (this.stack && this.stack.finalItems) {
        // adjust the offset of all finalItems when the actualHeight has been changed
        finalItems = this.stack.finalItems;
        finalItem = finalItems[0];

        if (finalItem && finalItem.top) {
          min = finalItem.top;
          max = finalItem.top + finalItem.height;
        }

        for (i = 1, iMax = finalItems.length; i < iMax; i++) {
          finalItem = finalItems[i];
          min = Math.min(min, finalItem.top);
          max = Math.max(max, finalItem.top + finalItem.height);
        }
      } else {
        item = renderedItems[0];

        if (item && item.top) {
          min = item.top;
          max = item.top + item.height;
        }

        for (i = 1, iMax = renderedItems.length; i < iMax; i++) {
          item = renderedItems[i];

          if (item.top) {
            min = Math.min(min, item.top);
            max = Math.max(max, item.top + item.height);
          }
        }
      }

      actualHeight = max - min + 2 * options.eventMarginAxis + size.axis.height;

      if (actualHeight < options.minHeight) {
        actualHeight = options.minHeight;
      }

      if (size.actualHeight != actualHeight && options.autoHeight && !options.axisOnTop) {
        // adjust the offset of all items when the actualHeight has been changed
        var diff = actualHeight - size.actualHeight;

        if (this.stack && this.stack.finalItems) {
          finalItems = this.stack.finalItems;

          for (i = 0, iMax = finalItems.length; i < iMax; i++) {
            finalItems[i].top += diff;
            finalItems[i].item.top += diff;
          }
        } else {
          for (i = 0, iMax = renderedItems.length; i < iMax; i++) {
            renderedItems[i].top += diff;
          }
        }
      }
    }
  } else {
    // loop through all groups to get the height of each group, and the
    // total height
    actualHeight = size.axis.height + 2 * options.eventMarginAxis;

    for (i = 0, iMax = groups.length; i < iMax; i++) {
      group = groups[i]; //
      // TODO: Do we want to apply a max height? how ?
      //

      var groupHeight = group.itemsHeight;
      resized = resized || groupHeight != group.height;
      group.height = Math.max(groupHeight, options.groupMinHeight);
      actualHeight += groups[i].height + options.eventMargin;
    } // calculate top positions of the group labels and lines


    var eventMargin = options.eventMargin,
        top = options.axisOnTop ? options.eventMarginAxis + eventMargin / 2 : size.contentHeight - options.eventMarginAxis + eventMargin / 2,
        axisHeight = size.axis.height;

    for (i = 0, iMax = groups.length; i < iMax; i++) {
      group = groups[i];

      if (options.axisOnTop) {
        group.top = top + axisHeight;
        group.labelTop = top + axisHeight + (group.height - group.labelHeight) / 2;
        group.lineTop = top + axisHeight + group.height + eventMargin / 2;
        top += group.height + eventMargin;
      } else {
        top -= group.height + eventMargin;
        group.top = top;
        group.labelTop = top + (group.height - group.labelHeight) / 2;
        group.lineTop = top - eventMargin / 2;
      }
    }

    resized = true;
  }

  if (actualHeight < options.minHeight) {
    actualHeight = options.minHeight;
  }

  resized = resized || actualHeight != size.actualHeight;
  size.actualHeight = actualHeight;
  return resized;
};
/**
 * This method clears the (internal) array this.items in a safe way: neatly
 * cleaning up the DOM, and accompanying arrays this.renderedItems and
 * the created clusters.
 */


links.Timeline.prototype.clearItems = function () {
  // add all visible items to the list to be hidden
  var hideItems = this.renderQueue.hide;
  this.renderedItems.forEach(function (item) {
    hideItems.push(item);
  }); // clear the cluster generator

  this.clusterGenerator.clear(); // actually clear the items

  this.items = [];
};
/**
 * Repaint all items
 * @return {boolean} needsReflow   Returns true if the DOM is changed such that
 *                                 a reflow is needed.
 */


links.Timeline.prototype.repaintItems = function () {
  var item, index;
  var needsReflow = false,
      dom = this.dom,
      size = this.size,
      timeline = this,
      renderedItems = this.renderedItems;

  if (!dom.items) {
    dom.items = {};
  } // draw the frame containing the items


  var frame = dom.items.frame;

  if (!frame) {
    frame = document.createElement("DIV");
    frame.style.position = "relative";
    dom.content.appendChild(frame);
    dom.items.frame = frame;
  }

  frame.style.left = "0px";
  frame.style.top = size.items.top + "px";
  frame.style.height = "0px"; // Take frame offline (for faster manipulation of the DOM)

  dom.content.removeChild(frame); // process the render queue with changes

  var queue = this.renderQueue;
  var newImageUrls = [];
  needsReflow = needsReflow || queue.show.length > 0 || queue.update.length > 0 || queue.hide.length > 0; // TODO: reflow needed on hide of items?

  while (item = queue.show.shift()) {
    item.showDOM(frame, timeline);
    item.getImageUrls(newImageUrls);
    renderedItems.push(item);
  }

  while (item = queue.update.shift()) {
    item.updateDOM(frame);
    item.getImageUrls(newImageUrls);
    index = this.renderedItems.indexOf(item);

    if (index == -1) {
      renderedItems.push(item);
    }
  }

  while (item = queue.hide.shift()) {
    item.hideDOM(frame);
    index = this.renderedItems.indexOf(item);

    if (index != -1) {
      renderedItems.splice(index, 1);
    }
  } // reposition all visible items


  renderedItems.forEach(function (item) {
    item.updatePosition(timeline);
  }); // redraw the delete button and dragareas of the selected item (if any)

  this.repaintDeleteButton();
  this.repaintDragAreas(); // put frame online again

  dom.content.appendChild(frame);

  if (newImageUrls.length) {
    // retrieve all image sources from the items, and set a callback once
    // all images are retrieved
    var callback = function callback() {
      timeline.render();
    };

    var sendCallbackWhenAlreadyLoaded = false;
    links.imageloader.loadAll(newImageUrls, callback, sendCallbackWhenAlreadyLoaded);
  }

  return needsReflow;
};
/**
 * Reflow the size of the groups
 * @return {boolean} resized    Returns true if any of the frame elements
 *                              have been resized.
 */


links.Timeline.prototype.reflowGroups = function () {
  var resized = false,
      options = this.options,
      size = this.size,
      dom = this.dom; // calculate the groups width and height
  // TODO: only update when data is changed! -> use an updateSeq

  var groupsWidth = 0; // loop through all groups to get the labels width and height

  var groups = this.groups;
  var labels = this.dom.groups ? this.dom.groups.labels : [];

  for (var i = 0, iMax = groups.length; i < iMax; i++) {
    var group = groups[i];
    var label = labels[i];
    group.labelWidth = label ? label.clientWidth : 0;
    group.labelHeight = label ? label.clientHeight : 0;
    group.width = group.labelWidth; // TODO: group.width is redundant with labelWidth

    groupsWidth = Math.max(groupsWidth, group.width);
  } // limit groupsWidth to the groups width in the options


  if (options.groupsWidth !== undefined) {
    groupsWidth = dom.groups && dom.groups.frame ? dom.groups.frame.clientWidth : 0;
  } // compensate for the border width. TODO: calculate the real border width


  groupsWidth += 1;
  var groupsLeft = options.groupsOnRight ? size.frameWidth - groupsWidth : 0;
  resized = resized || size.groupsWidth !== groupsWidth;
  resized = resized || size.groupsLeft !== groupsLeft;
  size.groupsWidth = groupsWidth;
  size.groupsLeft = groupsLeft;
  return resized;
};
/**
 * Redraw the group labels
 */


links.Timeline.prototype.repaintGroups = function () {
  var dom = this.dom,
      timeline = this,
      options = this.options,
      size = this.size,
      groups = this.groups;

  if (dom.groups === undefined) {
    dom.groups = {};
  }

  var labels = dom.groups.labels;

  if (!labels) {
    labels = [];
    dom.groups.labels = labels;
  }

  var labelLines = dom.groups.labelLines;

  if (!labelLines) {
    labelLines = [];
    dom.groups.labelLines = labelLines;
  }

  var itemLines = dom.groups.itemLines;

  if (!itemLines) {
    itemLines = [];
    dom.groups.itemLines = itemLines;
  } // create the frame for holding the groups


  var frame = dom.groups.frame;

  if (!frame) {
    frame = document.createElement("DIV");
    frame.className = "timeline-groups-axis";
    frame.style.position = "absolute";
    frame.style.overflow = "hidden";
    frame.style.top = "0px";
    frame.style.height = "100%";
    dom.frame.appendChild(frame);
    dom.groups.frame = frame;
  }

  frame.style.left = size.groupsLeft + "px";
  frame.style.width = options.groupsWidth !== undefined ? options.groupsWidth : size.groupsWidth + "px"; // hide groups axis when there are no groups

  if (groups.length == 0) {
    frame.style.display = 'none';
  } else {
    frame.style.display = '';
  } // TODO: only create/update groups when data is changed.
  // create the items


  var current = labels.length,
      needed = groups.length; // overwrite existing group labels

  for (var i = 0, iMax = Math.min(current, needed); i < iMax; i++) {
    var group = groups[i];
    var label = labels[i];
    label.innerHTML = this.getGroupName(group);
    label.style.display = '';
  } // append new items when needed


  for (var i = current; i < needed; i++) {
    var group = groups[i]; // create text label

    var label = document.createElement("DIV");
    label.className = "timeline-groups-text";
    label.style.position = "absolute";

    if (options.groupsWidth === undefined) {
      label.style.whiteSpace = "nowrap";
    }

    label.innerHTML = this.getGroupName(group);
    frame.appendChild(label);
    labels[i] = label; // create the grid line between the group labels

    var labelLine = document.createElement("DIV");
    labelLine.className = "timeline-axis-grid timeline-axis-grid-minor";
    labelLine.style.position = "absolute";
    labelLine.style.left = "0px";
    labelLine.style.width = "100%";
    labelLine.style.height = "0px";
    labelLine.style.borderTopStyle = "solid";
    frame.appendChild(labelLine);
    labelLines[i] = labelLine; // create the grid line between the items

    var itemLine = document.createElement("DIV");
    itemLine.className = "timeline-axis-grid timeline-axis-grid-minor";
    itemLine.style.position = "absolute";
    itemLine.style.left = "0px";
    itemLine.style.width = "100%";
    itemLine.style.height = "0px";
    itemLine.style.borderTopStyle = "solid";
    dom.content.insertBefore(itemLine, dom.content.firstChild);
    itemLines[i] = itemLine;
  } // remove redundant items from the DOM when needed


  for (var i = needed; i < current; i++) {
    var label = labels[i],
        labelLine = labelLines[i],
        itemLine = itemLines[i];
    frame.removeChild(label);
    frame.removeChild(labelLine);
    dom.content.removeChild(itemLine);
  }

  labels.splice(needed, current - needed);
  labelLines.splice(needed, current - needed);
  itemLines.splice(needed, current - needed);
  links.Timeline.addClassName(frame, options.groupsOnRight ? 'timeline-groups-axis-onright' : 'timeline-groups-axis-onleft'); // position the groups

  for (var i = 0, iMax = groups.length; i < iMax; i++) {
    var group = groups[i],
        label = labels[i],
        labelLine = labelLines[i],
        itemLine = itemLines[i];
    label.style.top = group.labelTop + "px";
    labelLine.style.top = group.lineTop + "px";
    itemLine.style.top = group.lineTop + "px";
    itemLine.style.width = size.contentWidth + "px";
  }

  if (!dom.groups.background) {
    // create the axis grid line background
    var background = document.createElement("DIV");
    background.className = "timeline-axis";
    background.style.position = "absolute";
    background.style.left = "0px";
    background.style.width = "100%";
    background.style.border = "none";
    frame.appendChild(background);
    dom.groups.background = background;
  }

  dom.groups.background.style.top = size.axis.top + 'px';
  dom.groups.background.style.height = size.axis.height + 'px';

  if (!dom.groups.line) {
    // create the axis grid line
    var line = document.createElement("DIV");
    line.className = "timeline-axis";
    line.style.position = "absolute";
    line.style.left = "0px";
    line.style.width = "100%";
    line.style.height = "0px";
    frame.appendChild(line);
    dom.groups.line = line;
  }

  dom.groups.line.style.top = size.axis.line + 'px'; // create a callback when there are images which are not yet loaded
  // TODO: more efficiently load images in the groups

  if (dom.groups.frame && groups.length) {
    var imageUrls = [];
    links.imageloader.filterImageUrls(dom.groups.frame, imageUrls);

    if (imageUrls.length) {
      // retrieve all image sources from the items, and set a callback once
      // all images are retrieved
      var callback = function callback() {
        timeline.render();
      };

      var sendCallbackWhenAlreadyLoaded = false;
      links.imageloader.loadAll(imageUrls, callback, sendCallbackWhenAlreadyLoaded);
    }
  }
};
/**
 * Redraw the current time bar
 */


links.Timeline.prototype.repaintCurrentTime = function () {
  var options = this.options,
      dom = this.dom,
      size = this.size;

  if (!options.showCurrentTime) {
    if (dom.currentTime) {
      dom.contentTimelines.removeChild(dom.currentTime);
      delete dom.currentTime;
    }

    return;
  }

  if (!dom.currentTime) {
    // create the current time bar
    var currentTime = document.createElement("DIV");
    currentTime.className = "timeline-currenttime";
    currentTime.style.position = "absolute";
    currentTime.style.top = "0px";
    currentTime.style.height = "100%";
    dom.contentTimelines.appendChild(currentTime);
    dom.currentTime = currentTime;
  }

  var now = new Date();
  var nowOffset = new Date(now.valueOf() + this.clientTimeOffset);
  var x = this.timeToScreen(nowOffset);
  var visible = x > -size.contentWidth && x < 2 * size.contentWidth;
  dom.currentTime.style.display = visible ? '' : 'none';
  dom.currentTime.style.left = x + "px";
  dom.currentTime.title = "Current time: " + getUTCTimeString(now); // start a timer to adjust for the new time

  if (this.currentTimeTimer != undefined) {
    clearTimeout(this.currentTimeTimer);
    delete this.currentTimeTimer;
  }

  var timeline = this;

  var onTimeout = function onTimeout() {
    timeline.repaintCurrentTime();
  }; // the time equal to the width of one pixel, divided by 2 for more smoothness


  var interval = 1 / this.conversion.factor / 2;
  if (interval < 30) interval = 30;
  this.currentTimeTimer = setTimeout(onTimeout, interval);
};
/**
 * Redraw the custom time bar
 */


links.Timeline.prototype.repaintCustomTime = function () {
  var options = this.options,
      dom = this.dom,
      size = this.size;

  if (!options.showCustomTime) {
    if (dom.customTime) {
      dom.contentTimelines.removeChild(dom.customTime);
      delete dom.customTime;
    }

    return;
  }

  if (!dom.customTime) {
    var customTime = document.createElement("DIV");
    customTime.className = "timeline-customtime";
    customTime.style.position = "absolute";
    customTime.style.top = "0px";
    customTime.style.height = "100%";
    var drag = document.createElement("DIV");
    drag.style.position = "relative";
    drag.style.top = "0px";
    drag.style.left = "-10px";
    drag.style.height = "100%";
    drag.style.width = "20px";
    customTime.appendChild(drag);
    dom.contentTimelines.appendChild(customTime);
    dom.customTime = customTime; // initialize parameter

    this.customTime = new Date();
  }

  var x = this.timeToScreen(this.customTime),
      visible = x > -size.contentWidth && x < 2 * size.contentWidth;
  dom.customTime.style.display = visible ? '' : 'none';
  dom.customTime.style.left = x + "px";
  var str = String(this.customTime);
  dom.customTime.title = "Time: " + str;
};
/**
 * Redraw the delete button, on the top right of the currently selected item
 * if there is no item selected, the button is hidden.
 */


links.Timeline.prototype.repaintDeleteButton = function () {
  var dom = this.dom,
      frame = dom.items.frame;
  var deleteButton = dom.items.deleteButton;

  if (!deleteButton) {
    // create a delete button
    deleteButton = document.createElement("DIV");
    deleteButton.className = "timeline-navigation-delete";
    deleteButton.style.position = "absolute";
    frame.appendChild(deleteButton);
    dom.items.deleteButton = deleteButton;
  }

  var index = this.selection && this.selection.index !== undefined ? this.selection.index : -1,
      item = this.selection && this.selection.index !== undefined ? this.items[index] : undefined;

  if (item && item.rendered && this.isEditable(item)) {
    var right = item.getRight(this),
        top = item.top;
    deleteButton.style.left = right + 'px';
    deleteButton.style.top = top + 'px';
    deleteButton.style.display = '';
    frame.removeChild(deleteButton);
    frame.appendChild(deleteButton);
  } else {
    deleteButton.style.display = 'none';
  }
};
/**
 * Redraw the drag areas. When an item (ranges only) is selected,
 * it gets a drag area on the left and right side, to change its width
 */


links.Timeline.prototype.repaintDragAreas = function () {
  var options = this.options,
      dom = this.dom,
      frame = this.dom.items.frame; // create left drag area

  var dragLeft = dom.items.dragLeft;

  if (!dragLeft) {
    dragLeft = document.createElement("DIV");
    dragLeft.className = "timeline-event-range-drag-left";
    dragLeft.style.position = "absolute";
    frame.appendChild(dragLeft);
    dom.items.dragLeft = dragLeft;
  } // create right drag area


  var dragRight = dom.items.dragRight;

  if (!dragRight) {
    dragRight = document.createElement("DIV");
    dragRight.className = "timeline-event-range-drag-right";
    dragRight.style.position = "absolute";
    frame.appendChild(dragRight);
    dom.items.dragRight = dragRight;
  } // reposition left and right drag area


  var index = this.selection && this.selection.index !== undefined ? this.selection.index : -1,
      item = this.selection && this.selection.index !== undefined ? this.items[index] : undefined;

  if (item && item.rendered && this.isEditable(item) && (item instanceof links.Timeline.ItemRange || item instanceof links.Timeline.ItemFloatingRange)) {
    var left = item.getLeft(this),
        // NH change to getLeft
    right = item.getRight(this),
        // NH change to getRight
    top = item.top,
        height = item.height;
    dragLeft.style.left = left + 'px';
    dragLeft.style.top = top + 'px';
    dragLeft.style.width = options.dragAreaWidth + "px";
    dragLeft.style.height = height + 'px';
    dragLeft.style.display = '';
    frame.removeChild(dragLeft);
    frame.appendChild(dragLeft);
    dragRight.style.left = right - options.dragAreaWidth + 'px';
    dragRight.style.top = top + 'px';
    dragRight.style.width = options.dragAreaWidth + "px";
    dragRight.style.height = height + 'px';
    dragRight.style.display = '';
    frame.removeChild(dragRight);
    frame.appendChild(dragRight);
  } else {
    dragLeft.style.display = 'none';
    dragRight.style.display = 'none';
  }
};
/**
 * Create the navigation buttons for zooming and moving
 */


links.Timeline.prototype.repaintNavigation = function () {
  var timeline = this,
      options = this.options,
      dom = this.dom,
      frame = dom.frame,
      navBar = dom.navBar;

  if (!navBar) {
    var showButtonNew = options.showButtonNew && options.editable;
    var showNavigation = options.showNavigation && (options.zoomable || options.moveable);

    if (showNavigation || showButtonNew) {
      // create a navigation bar containing the navigation buttons
      navBar = document.createElement("DIV");
      navBar.style.position = "absolute";
      navBar.className = "timeline-navigation";

      if (options.groupsOnRight) {
        navBar.style.left = '10px';
      } else {
        navBar.style.right = '10px';
      }

      if (options.axisOnTop) {
        navBar.style.bottom = '10px';
      } else {
        navBar.style.top = '10px';
      }

      dom.navBar = navBar;
      frame.appendChild(navBar);
    }

    if (showButtonNew) {
      // create a new in button
      navBar.addButton = document.createElement("DIV");
      navBar.addButton.className = "timeline-navigation-new";
      navBar.addButton.title = options.CREATE_NEW_EVENT;
      var addIconSpan = document.createElement("SPAN");
      addIconSpan.className = "ui-icon ui-icon-circle-plus";
      navBar.addButton.appendChild(addIconSpan);

      var onAdd = function onAdd(event) {
        links.Timeline.preventDefault(event);
        links.Timeline.stopPropagation(event); // create a new event at the center of the frame

        var w = timeline.size.contentWidth;
        var x = w / 2;
        var xstart = timeline.screenToTime(x);

        if (options.snapEvents) {
          timeline.step.snap(xstart);
        }

        var content = options.NEW;
        var group = timeline.groups.length ? timeline.groups[0].content : undefined;
        var preventRender = true;
        timeline.addItem({
          'start': xstart,
          'content': content,
          'group': group
        }, preventRender);
        var index = timeline.items.length - 1;
        timeline.selectItem(index);
        timeline.applyAdd = true; // fire an add event.
        // Note that the change can be canceled from within an event listener if
        // this listener calls the method cancelAdd().

        timeline.trigger('add');

        if (timeline.applyAdd) {
          // render and select the item
          timeline.render({
            animate: false
          });
          timeline.selectItem(index);
        } else {
          // undo an add
          timeline.deleteItem(index);
        }
      };

      links.Timeline.addEventListener(navBar.addButton, "mousedown", onAdd);
      navBar.appendChild(navBar.addButton);
    }

    if (showButtonNew && showNavigation) {
      // create a separator line
      links.Timeline.addClassName(navBar.addButton, 'timeline-navigation-new-line');
    }

    if (showNavigation) {
      if (options.zoomable) {
        // create a zoom in button
        navBar.zoomInButton = document.createElement("DIV");
        navBar.zoomInButton.className = "timeline-navigation-zoom-in";
        navBar.zoomInButton.title = this.options.ZOOM_IN;
        var ziIconSpan = document.createElement("SPAN");
        ziIconSpan.className = "ui-icon ui-icon-circle-zoomin";
        navBar.zoomInButton.appendChild(ziIconSpan);

        var onZoomIn = function onZoomIn(event) {
          links.Timeline.preventDefault(event);
          links.Timeline.stopPropagation(event);
          timeline.zoom(0.4);
          timeline.trigger("rangechange");
          timeline.trigger("rangechanged");
        };

        links.Timeline.addEventListener(navBar.zoomInButton, "mousedown", onZoomIn);
        navBar.appendChild(navBar.zoomInButton); // create a zoom out button

        navBar.zoomOutButton = document.createElement("DIV");
        navBar.zoomOutButton.className = "timeline-navigation-zoom-out";
        navBar.zoomOutButton.title = this.options.ZOOM_OUT;
        var zoIconSpan = document.createElement("SPAN");
        zoIconSpan.className = "ui-icon ui-icon-circle-zoomout";
        navBar.zoomOutButton.appendChild(zoIconSpan);

        var onZoomOut = function onZoomOut(event) {
          links.Timeline.preventDefault(event);
          links.Timeline.stopPropagation(event);
          timeline.zoom(-0.4);
          timeline.trigger("rangechange");
          timeline.trigger("rangechanged");
        };

        links.Timeline.addEventListener(navBar.zoomOutButton, "mousedown", onZoomOut);
        navBar.appendChild(navBar.zoomOutButton);
      }

      if (options.moveable) {
        // create a move left button
        navBar.moveLeftButton = document.createElement("DIV");
        navBar.moveLeftButton.className = "timeline-navigation-move-left";
        navBar.moveLeftButton.title = this.options.MOVE_LEFT;
        var mlIconSpan = document.createElement("SPAN");
        mlIconSpan.className = "ui-icon ui-icon-circle-arrow-w";
        navBar.moveLeftButton.appendChild(mlIconSpan);

        var onMoveLeft = function onMoveLeft(event) {
          links.Timeline.preventDefault(event);
          links.Timeline.stopPropagation(event);
          timeline.move(-0.2);
          timeline.trigger("rangechange");
          timeline.trigger("rangechanged");
        };

        links.Timeline.addEventListener(navBar.moveLeftButton, "mousedown", onMoveLeft);
        navBar.appendChild(navBar.moveLeftButton); // create a move right button

        navBar.moveRightButton = document.createElement("DIV");
        navBar.moveRightButton.className = "timeline-navigation-move-right";
        navBar.moveRightButton.title = this.options.MOVE_RIGHT;
        var mrIconSpan = document.createElement("SPAN");
        mrIconSpan.className = "ui-icon ui-icon-circle-arrow-e";
        navBar.moveRightButton.appendChild(mrIconSpan);

        var onMoveRight = function onMoveRight(event) {
          links.Timeline.preventDefault(event);
          links.Timeline.stopPropagation(event);
          timeline.move(0.2);
          timeline.trigger("rangechange");
          timeline.trigger("rangechanged");
        };

        links.Timeline.addEventListener(navBar.moveRightButton, "mousedown", onMoveRight);
        navBar.appendChild(navBar.moveRightButton);
      }
    }
  }
};
/**
 * Set current time. This function can be used to set the time in the client
 * timeline equal with the time on a server.
 * @param {Date} time
 */


links.Timeline.prototype.setCurrentTime = function (time) {
  var now = new Date();
  this.clientTimeOffset = time.valueOf() - now.valueOf();
  this.repaintCurrentTime();
};
/**
 * Get current time. The time can have an offset from the real time, when
 * the current time has been changed via the method setCurrentTime.
 * @return {Date} time
 */


links.Timeline.prototype.getCurrentTime = function () {
  var now = new Date();
  return new Date(now.valueOf() + this.clientTimeOffset);
};
/**
 * Set custom time.
 * The custom time bar can be used to display events in past or future.
 * @param {Date} time
 */


links.Timeline.prototype.setCustomTime = function (time) {
  this.customTime = new Date(time.valueOf());
  this.repaintCustomTime();
};
/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */


links.Timeline.prototype.getCustomTime = function () {
  return new Date(this.customTime.valueOf());
};
/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale(SCALE.MINUTES, 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {links.Timeline.StepDate.SCALE} scale
 *                               A scale. Choose from SCALE.MILLISECOND,
 *                               SCALE.SECOND, SCALE.MINUTE, SCALE.HOUR,
 *                               SCALE.WEEKDAY, SCALE.DAY, SCALE.MONTH,
 *                               SCALE.YEAR.
 * @param {int}        step   A step size, by default 1. Choose for
 *                               example 1, 2, 5, or 10.
 */


links.Timeline.prototype.setScale = function (scale, step) {
  this.step.setScale(scale, step);
  this.render(); // TODO: optimize: only reflow/repaint axis
};
/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true or not defined, autoscaling is enabled.
 *                          If false, autoscaling is disabled.
 */


links.Timeline.prototype.setAutoScale = function (enable) {
  this.step.setAutoScale(enable);
  this.render(); // TODO: optimize: only reflow/repaint axis
};
/**
 * Redraw the timeline
 * Reloads the (linked) data table and redraws the timeline when resized.
 * See also the method checkResize
 */


links.Timeline.prototype.redraw = function () {
  this.setData(this.data);
};
/**
 * Check if the timeline is resized, and if so, redraw the timeline.
 * Useful when the webpage is resized.
 */


links.Timeline.prototype.checkResize = function () {
  // TODO: re-implement the method checkResize, or better, make it redundant as this.render will be smarter
  this.render();
};
/**
 * Check whether a given item is editable
 * @param {links.Timeline.Item} item
 * @return {boolean} editable
 */


links.Timeline.prototype.isEditable = function (item) {
  if (item) {
    if (item.editable != undefined) {
      return item.editable;
    } else {
      return this.options.editable;
    }
  }

  return false;
};
/**
 * Calculate the factor and offset to convert a position on screen to the
 * corresponding date and vice versa.
 * After the method calcConversionFactor is executed once, the methods screenToTime and
 * timeToScreen can be used.
 */


links.Timeline.prototype.recalcConversion = function () {
  this.conversion.offset = this.start.valueOf() + tzm;
  this.conversion.factor = this.size.contentWidth / (this.end.valueOf() - this.start.valueOf());
};
/**
 * Convert a position on screen (pixels) to a datetime
 * Before this method can be used, the method calcConversionFactor must be
 * executed once.
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 */


links.Timeline.prototype.screenToTime = function (x) {
  var conversion = this.conversion;
  return new Date(x / conversion.factor + conversion.offset);
};
/**
 * Convert a datetime (Date object) into a position on the screen
 * Before this method can be used, the method calcConversionFactor must be
 * executed once.
 * @param {Date}   time A date
 * @return {int}   x    The position on the screen in pixels which corresponds
 *                      with the given date.
 */


links.Timeline.prototype.timeToScreen = function (time) {
  var conversion = this.conversion;
  return (time.valueOf() - conversion.offset) * conversion.factor;
};
/**
 * Event handler for touchstart event on mobile devices
 */


links.Timeline.prototype.onTouchStart = function (event) {
  var params = this.eventParams,
      me = this;

  if (params.touchDown) {
    // if already moving, return
    return;
  }

  params.touchDown = true;
  params.zoomed = false;
  this.onMouseDown(event);

  if (!params.onTouchMove) {
    params.onTouchMove = function (event) {
      me.onTouchMove(event);
    };

    links.Timeline.addEventListener(document, "touchmove", params.onTouchMove);
  }

  if (!params.onTouchEnd) {
    params.onTouchEnd = function (event) {
      me.onTouchEnd(event);
    };

    links.Timeline.addEventListener(document, "touchend", params.onTouchEnd);
  }
  /* TODO
   // check for double tap event
   var delta = 500; // ms
   var doubleTapStart = (new Date()).valueOf();
   var target = links.Timeline.getTarget(event);
   var doubleTapItem = this.getItemIndex(target);
   if (params.doubleTapStart &&
   (doubleTapStart - params.doubleTapStart) < delta &&
   doubleTapItem == params.doubleTapItem) {
   delete params.doubleTapStart;
   delete params.doubleTapItem;
   me.onDblClick(event);
   params.touchDown = false;
   }
   params.doubleTapStart = doubleTapStart;
   params.doubleTapItem = doubleTapItem;
   */
  // store timing for double taps


  var target = links.Timeline.getTarget(event);
  var item = this.getItemIndex(target);
  params.doubleTapStartPrev = params.doubleTapStart;
  params.doubleTapStart = new Date().valueOf();
  params.doubleTapItemPrev = params.doubleTapItem;
  params.doubleTapItem = item;
  links.Timeline.preventDefault(event);
};
/**
 * Event handler for touchmove event on mobile devices
 */


links.Timeline.prototype.onTouchMove = function (event) {
  var params = this.eventParams;

  if (event.scale && event.scale !== 1) {
    params.zoomed = true;
  }

  if (!params.zoomed) {
    // move
    this.onMouseMove(event);
  } else {
    if (this.options.zoomable) {
      // pinch
      // TODO: pinch only supported on iPhone/iPad. Create something manually for Android?
      params.zoomed = true;
      var scale = event.scale,
          oldWidth = params.end.valueOf() - params.start.valueOf(),
          newWidth = oldWidth / scale,
          diff = newWidth - oldWidth,
          start = new Date(parseInt(params.start.valueOf() - diff / 2)),
          end = new Date(parseInt(params.end.valueOf() + diff / 2)); // TODO: determine zoom-around-date from touch positions?

      this.setVisibleChartRange(start, end);
      this.trigger("rangechange");
    }
  }

  links.Timeline.preventDefault(event);
};
/**
 * Event handler for touchend event on mobile devices
 */


links.Timeline.prototype.onTouchEnd = function (event) {
  var params = this.eventParams;
  var me = this;
  params.touchDown = false;

  if (params.zoomed) {
    this.trigger("rangechanged");
  }

  if (params.onTouchMove) {
    links.Timeline.removeEventListener(document, "touchmove", params.onTouchMove);
    delete params.onTouchMove;
  }

  if (params.onTouchEnd) {
    links.Timeline.removeEventListener(document, "touchend", params.onTouchEnd);
    delete params.onTouchEnd;
  }

  this.onMouseUp(event); // check for double tap event

  var delta = 500; // ms

  var doubleTapEnd = new Date().valueOf();
  var target = links.Timeline.getTarget(event);
  var doubleTapItem = this.getItemIndex(target);

  if (params.doubleTapStartPrev && doubleTapEnd - params.doubleTapStartPrev < delta && params.doubleTapItem == params.doubleTapItemPrev) {
    params.touchDown = true;
    me.onDblClick(event);
    params.touchDown = false;
  }

  links.Timeline.preventDefault(event);
};
/**
 * Start a moving operation inside the provided parent element
 * @param {Event} event       The event that occurred (required for
 *                             retrieving the  mouse position)
 */


links.Timeline.prototype.onMouseDown = function (event) {
  event = event || window.event;
  var params = this.eventParams,
      options = this.options,
      dom = this.dom; // only react on left mouse button down

  var leftButtonDown = event.which ? event.which == 1 : event.button == 1;

  if (!leftButtonDown && !params.touchDown) {
    return;
  } // get mouse position


  params.mouseX = links.Timeline.getPageX(event);
  params.mouseY = links.Timeline.getPageY(event);
  params.frameLeft = links.Timeline.getAbsoluteLeft(this.dom.content);
  params.frameTop = links.Timeline.getAbsoluteTop(this.dom.content);
  params.previousLeft = 0;
  params.previousOffset = 0;
  params.moved = false;
  params.start = new Date(this.start.valueOf());
  params.end = new Date(this.end.valueOf());
  params.target = links.Timeline.getTarget(event);
  var dragLeft = dom.items && dom.items.dragLeft ? dom.items.dragLeft : undefined;
  var dragRight = dom.items && dom.items.dragRight ? dom.items.dragRight : undefined;
  params.itemDragLeft = params.target === dragLeft;
  params.itemDragRight = params.target === dragRight;

  if (params.itemDragLeft || params.itemDragRight) {
    params.itemIndex = this.selection && this.selection.index !== undefined ? this.selection.index : undefined;
    delete params.clusterIndex;
  } else {
    params.itemIndex = this.getItemIndex(params.target);
    params.clusterIndex = this.getClusterIndex(params.target);
  }

  params.customTime = params.target === dom.customTime || params.target.parentNode === dom.customTime ? this.customTime : undefined;
  params.addItem = options.editable && event.ctrlKey;

  if (params.addItem) {
    // create a new event at the current mouse position
    var x = params.mouseX - params.frameLeft;
    var y = params.mouseY - params.frameTop;
    var xstart = this.screenToTime(x);

    if (options.snapEvents) {
      this.step.snap(xstart);
    }

    var xend = new Date(xstart.valueOf());
    var content = options.NEW;
    var group = this.getGroupFromHeight(y);
    this.addItem({
      'start': xstart,
      'end': xend,
      'content': content,
      'group': this.getGroupName(group)
    });
    params.itemIndex = this.items.length - 1;
    delete params.clusterIndex;
    this.selectItem(params.itemIndex);
    params.itemDragRight = true;
  }

  var item = this.items[params.itemIndex];
  var isSelected = this.isSelected(params.itemIndex);
  params.editItem = isSelected && this.isEditable(item);

  if (params.editItem) {
    params.itemStart = item.start;
    params.itemEnd = item.end;
    params.itemGroup = item.group;
    params.itemLeft = item.getLeft(this); // NH Use item.getLeft here

    params.itemRight = item.getRight(this); // NH Use item.getRight here
  } else {
    this.dom.frame.style.cursor = 'move';
  }

  if (!params.touchDown) {
    // add event listeners to handle moving the contents
    // we store the function onmousemove and onmouseup in the timeline, so we can
    // remove the eventlisteners lateron in the function mouseUp()
    var me = this;

    if (!params.onMouseMove) {
      params.onMouseMove = function (event) {
        me.onMouseMove(event);
      };

      links.Timeline.addEventListener(document, "mousemove", params.onMouseMove);
    }

    if (!params.onMouseUp) {
      params.onMouseUp = function (event) {
        me.onMouseUp(event);
      };

      links.Timeline.addEventListener(document, "mouseup", params.onMouseUp);
    }

    links.Timeline.preventDefault(event);
  }
};
/**
 * Perform moving operating.
 * This function activated from within the funcion links.Timeline.onMouseDown().
 * @param {Event}   event  Well, eehh, the event
 */


links.Timeline.prototype.onMouseMove = function (event) {
  event = event || window.event;
  var params = this.eventParams,
      size = this.size,
      dom = this.dom,
      options = this.options; // calculate change in mouse position

  var mouseX = links.Timeline.getPageX(event);
  var mouseY = links.Timeline.getPageY(event);

  if (params.mouseX == undefined) {
    params.mouseX = mouseX;
  }

  if (params.mouseY == undefined) {
    params.mouseY = mouseY;
  }

  var diffX = mouseX - params.mouseX;
  var diffY = mouseY - params.mouseY; // if mouse movement is big enough, register it as a "moved" event

  if (Math.abs(diffX) >= 1) {
    params.moved = true;
  }

  if (params.customTime) {
    var x = this.timeToScreen(params.customTime);
    var xnew = x + diffX;
    this.customTime = this.screenToTime(xnew);
    this.repaintCustomTime(); // fire a timechange event

    this.trigger('timechange');
  } else if (params.editItem) {
    var item = this.items[params.itemIndex],
        left,
        right;

    if (params.itemDragLeft && options.timeChangeable) {
      // move the start of the item
      left = params.itemLeft + diffX;
      right = params.itemRight;
      item.start = this.screenToTime(left);

      if (options.snapEvents) {
        this.step.snap(item.start);
        left = this.timeToScreen(item.start);
      }

      if (left > right) {
        left = right;
        item.start = this.screenToTime(left);
      }

      this.trigger('change');
    } else if (params.itemDragRight && options.timeChangeable) {
      // move the end of the item
      left = params.itemLeft;
      right = params.itemRight + diffX;
      item.end = this.screenToTime(right);

      if (options.snapEvents) {
        this.step.snap(item.end);
        right = this.timeToScreen(item.end);
      }

      if (right < left) {
        right = left;
        item.end = this.screenToTime(right);
      }

      this.trigger('change');
    } else if (options.timeChangeable) {
      // move the item
      left = params.itemLeft + diffX;
      item.start = this.screenToTime(left);

      if (options.snapEvents) {
        this.step.snap(item.start);
        left = this.timeToScreen(item.start);
      }

      if (item.end) {
        right = left + (params.itemRight - params.itemLeft);
        item.end = this.screenToTime(right);
      }

      this.trigger('change');
    }

    item.setPosition(left, right);
    var dragging = params.itemDragLeft || params.itemDragRight;

    if (this.groups.length && !dragging) {
      // move item from one group to another when needed
      var y = mouseY - params.frameTop;
      var group = this.getGroupFromHeight(y);

      if (options.groupsChangeable && item.group !== group) {
        // move item to the other group
        var index = this.items.indexOf(item);
        this.changeItem(index, {
          'group': this.getGroupName(group)
        });
      } else {
        this.repaintDeleteButton();
        this.repaintDragAreas();
      }
    } else {
      // TODO: does not work well in FF, forces redraw with every mouse move it seems
      this.render(); // TODO: optimize, only redraw the items?
      // Note: when animate==true, no redraw is needed here, its done by stackItems animation
    }
  } else if (options.moveable) {
    var interval = params.end.valueOf() - params.start.valueOf();
    var diffMillisecs = Math.round(-diffX / size.contentWidth * interval);
    var newStart = new Date(params.start.valueOf() + diffMillisecs);
    var newEnd = new Date(params.end.valueOf() + diffMillisecs);
    this.applyRange(newStart, newEnd); // if the applied range is moved due to a fixed min or max,
    // change the diffMillisecs accordingly

    var appliedDiff = this.start.valueOf() - newStart.valueOf();

    if (appliedDiff) {
      diffMillisecs += appliedDiff;
    }

    this.recalcConversion(); // move the items by changing the left position of their frame.
    // this is much faster than repositioning all elements individually via the
    // repaintFrame() function (which is done once at mouseup)
    // note that we round diffX to prevent wrong positioning on millisecond scale

    var previousLeft = params.previousLeft || 0;
    var currentLeft = parseFloat(dom.items.frame.style.left) || 0;
    var previousOffset = params.previousOffset || 0;
    var frameOffset = previousOffset + (currentLeft - previousLeft);
    var frameLeft = -diffMillisecs / interval * size.contentWidth + frameOffset;
    dom.items.frame.style.left = frameLeft + "px"; // read the left again from DOM (IE8- rounds the value)

    params.previousOffset = frameOffset;
    params.previousLeft = parseFloat(dom.items.frame.style.left) || frameLeft;
    this.repaintCurrentTime();
    this.repaintCustomTime();
    this.repaintAxis(); // fire a rangechange event

    this.trigger('rangechange');
  }

  links.Timeline.preventDefault(event);
};
/**
 * Stop moving operating.
 * This function activated from within the funcion links.Timeline.onMouseDown().
 * @param {event}  event   The event
 */


links.Timeline.prototype.onMouseUp = function (event) {
  var params = this.eventParams,
      options = this.options;
  event = event || window.event;
  this.dom.frame.style.cursor = 'auto'; // remove event listeners here, important for Safari

  if (params.onMouseMove) {
    links.Timeline.removeEventListener(document, "mousemove", params.onMouseMove);
    delete params.onMouseMove;
  }

  if (params.onMouseUp) {
    links.Timeline.removeEventListener(document, "mouseup", params.onMouseUp);
    delete params.onMouseUp;
  } //links.Timeline.preventDefault(event);


  if (params.customTime) {
    // fire a timechanged event
    this.trigger('timechanged');
  } else if (params.editItem) {
    var item = this.items[params.itemIndex];

    if (params.moved || params.addItem) {
      this.applyChange = true;
      this.applyAdd = true;
      this.updateData(params.itemIndex, {
        'start': item.start,
        'end': item.end
      }); // fire an add or changed event.
      // Note that the change can be canceled from within an event listener if
      // this listener calls the method cancelChange().

      this.trigger(params.addItem ? 'add' : 'changed'); //retrieve item data again to include changes made to it in the triggered event handlers

      item = this.items[params.itemIndex];

      if (params.addItem) {
        if (this.applyAdd) {
          this.updateData(params.itemIndex, {
            'start': item.start,
            'end': item.end,
            'content': item.content,
            'group': this.getGroupName(item.group)
          });
        } else {
          // undo an add
          this.deleteItem(params.itemIndex);
        }
      } else {
        if (this.applyChange) {
          this.updateData(params.itemIndex, {
            'start': item.start,
            'end': item.end
          });
        } else {
          // undo a change
          delete this.applyChange;
          delete this.applyAdd;
          var item = this.items[params.itemIndex],
              domItem = item.dom;
          item.start = params.itemStart;
          item.end = params.itemEnd;
          item.group = params.itemGroup; // TODO: original group should be restored too

          item.setPosition(params.itemLeft, params.itemRight);
          this.updateData(params.itemIndex, {
            'start': params.itemStart,
            'end': params.itemEnd
          });
        }
      } // prepare data for clustering, by filtering and sorting by type


      if (this.options.cluster) {
        this.clusterGenerator.updateData();
      }

      this.render();
    }
  } else {
    if (!params.moved && !params.zoomed) {
      // mouse did not move -> user has selected an item
      if (params.target === this.dom.items.deleteButton) {
        // delete item
        if (this.selection && this.selection.index !== undefined) {
          this.confirmDeleteItem(this.selection.index);
        }
      } else if (options.selectable) {
        // select/unselect item
        if (params.itemIndex != undefined) {
          if (!this.isSelected(params.itemIndex)) {
            this.selectItem(params.itemIndex);
            this.trigger('select', {
              index: params.itemIndex,
              originalEvent: event
            });
          }
        } else if (params.clusterIndex != undefined) {
          this.selectCluster(params.clusterIndex);
          this.trigger('select');
        } else {
          if (options.unselectable) {
            this.unselectItem();
            this.trigger('select', {
              date: event.target._date,
              originalEvent: event
            });
          }
        }
      }
    } else {
      // timeline is moved
      // TODO: optimize: no need to reflow and cluster again?
      this.render();

      if (params.moved && options.moveable || params.zoomed && options.zoomable) {
        // fire a rangechanged event
        this.trigger('rangechanged');
      }
    }
  }
};
/**
 * Double click event occurred for an item
 * @param {Event}  event
 */


links.Timeline.prototype.onDblClick = function (event) {
  var params = this.eventParams,
      options = this.options,
      dom = this.dom,
      size = this.size;
  event = event || window.event;

  if (params.itemIndex != undefined) {
    var item = this.items[params.itemIndex];

    if (item && this.isEditable(item)) {
      // fire the edit event
      this.trigger('edit');
    }
  } else {
    if (options.editable) {
      // create a new item
      // get mouse position
      params.mouseX = links.Timeline.getPageX(event);
      params.mouseY = links.Timeline.getPageY(event);
      var x = params.mouseX - links.Timeline.getAbsoluteLeft(dom.content);
      var y = params.mouseY - links.Timeline.getAbsoluteTop(dom.content); // create a new event at the current mouse position

      var xstart = this.screenToTime(x);

      if (options.snapEvents) {
        this.step.snap(xstart);
      }

      var content = options.NEW;
      var group = this.getGroupFromHeight(y); // (group may be undefined)

      var preventRender = true;
      this.addItem({
        'start': xstart,
        'content': content,
        'group': this.getGroupName(group)
      }, preventRender);
      params.itemIndex = this.items.length - 1;
      this.selectItem(params.itemIndex);
      this.applyAdd = true; // fire an add event.
      // Note that the change can be canceled from within an event listener if
      // this listener calls the method cancelAdd().

      this.trigger('add');

      if (this.applyAdd) {
        // render and select the item
        this.render({
          animate: false
        });
        this.selectItem(params.itemIndex);
      } else {
        // undo an add
        this.deleteItem(params.itemIndex);
      }
    }
  }

  links.Timeline.preventDefault(event);
};
/**
 * Event handler for mouse wheel event, used to zoom the timeline
 * Code from http://adomas.org/javascript-mouse-wheel/
 * @param {Event}  event   The event
 */


links.Timeline.prototype.onMouseWheel = function (event) {
  if (!this.options.zoomable) return;

  if (!event) {
    /* For IE. */
    event = window.event;
  } // retrieve delta


  var delta = 0;

  if (event.wheelDelta) {
    /* IE/Opera. */
    delta = event.wheelDelta / 120;
  } else if (event.detail) {
    /* Mozilla case. */
    // In Mozilla, sign of delta is different than in IE.
    // Also, delta is multiple of 3.
    delta = -event.detail / 3;
  } // If delta is nonzero, handle it.
  // Basically, delta is now positive if wheel was scrolled up,
  // and negative, if wheel was scrolled down.


  if (delta) {
    // TODO: on FireFox, the window is not redrawn within repeated scroll-events
    // -> use a delayed redraw? Make a zoom queue?
    var timeline = this;

    var zoom = function zoom() {
      // perform the zoom action. Delta is normally 1 or -1
      var zoomFactor = delta / 5.0;
      var frameLeft = links.Timeline.getAbsoluteLeft(timeline.dom.content);
      var mouseX = links.Timeline.getPageX(event);
      var zoomAroundDate = mouseX != undefined && frameLeft != undefined ? timeline.screenToTime(mouseX - frameLeft) : undefined;
      zoomAroundDate = new Date(zoomAroundDate.getTime() + tzm);
      timeline.zoom(zoomFactor, zoomAroundDate); // fire a rangechange and a rangechanged event

      timeline.trigger("rangechange");
      timeline.trigger("rangechanged");
    };

    var scroll = function scroll() {
      // Scroll the timeline
      timeline.move(delta * -0.2);
      timeline.trigger("rangechange");
      timeline.trigger("rangechanged");
    };

    if (event.shiftKey) {
      scroll();
    } else {
      zoom();
    }
  } // Prevent default actions caused by mouse wheel.
  // That might be ugly, but we handle scrolls somehow
  // anyway, so don't bother here...


  links.Timeline.preventDefault(event);
};
/**
 * Zoom the timeline the given zoomfactor in or out. Start and end date will
 * be adjusted, and the timeline will be redrawn. You can optionally give a
 * date around which to zoom.
 * For example, try zoomfactor = 0.1 or -0.1
 * @param {Number} zoomFactor      Zooming amount. Positive value will zoom in,
 *                                 negative value will zoom out
 * @param {Date}   zoomAroundDate  Date around which will be zoomed. Optional
 */


links.Timeline.prototype.zoom = function (zoomFactor, zoomAroundDate) {
  // if zoomAroundDate is not provided, take it half between start Date and end Date
  if (zoomAroundDate == undefined) {
    zoomAroundDate = new Date((this.start.valueOf() + this.end.valueOf()) / 2);
  } // prevent zoom factor larger than 1 or smaller than -1 (larger than 1 will
  // result in a start>=end )


  if (zoomFactor >= 1) {
    zoomFactor = 0.9;
  }

  if (zoomFactor <= -1) {
    zoomFactor = -0.9;
  } // adjust a negative factor such that zooming in with 0.1 equals zooming
  // out with a factor -0.1


  if (zoomFactor < 0) {
    zoomFactor = zoomFactor / (1 + zoomFactor);
  } // zoom start Date and end Date relative to the zoomAroundDate


  var startDiff = this.start.valueOf() - zoomAroundDate;
  var endDiff = this.end.valueOf() - zoomAroundDate; // calculate new dates

  var newStart = new Date(this.start.valueOf() - startDiff * zoomFactor - 0);
  var newEnd = new Date(this.end.valueOf() - endDiff * zoomFactor - 0); // only zoom in when interval is larger than minimum interval (to prevent
  // sliding to left/right when having reached the minimum zoom level)

  var interval = newEnd.valueOf() - newStart.valueOf();
  var zoomMin = Number(this.options.zoomMin) || 10;

  if (zoomMin < 10) {
    zoomMin = 10;
  }

  if (interval >= zoomMin) {
    this.applyRange(newStart, newEnd, zoomAroundDate);
    this.render({
      animate: this.options.animate && this.options.animateZoom
    });
  }
};
/**
 * Move the timeline the given movefactor to the left or right. Start and end
 * date will be adjusted, and the timeline will be redrawn.
 * For example, try moveFactor = 0.1 or -0.1
 * @param {Number}  moveFactor      Moving amount. Positive value will move right,
 *                                 negative value will move left
 */


links.Timeline.prototype.move = function (moveFactor) {
  // zoom start Date and end Date relative to the zoomAroundDate
  var diff = this.end.valueOf() - this.start.valueOf(); // apply new dates

  var newStart = new Date(this.start.valueOf() + diff * moveFactor);
  var newEnd = new Date(this.end.valueOf() + diff * moveFactor);
  this.applyRange(newStart, newEnd);
  this.render(); // TODO: optimize, no need to reflow, only to recalc conversion and repaint
};
/**
 * Apply a visible range. The range is limited to feasible maximum and minimum
 * range.
 * @param {Date} start
 * @param {Date} end
 * @param {Date}   zoomAroundDate  Optional. Date around which will be zoomed.
 */


links.Timeline.prototype.applyRange = function (start, end, zoomAroundDate) {
  // calculate new start and end value
  var startValue = start.valueOf(); // number

  var endValue = end.valueOf(); // number

  var interval = endValue - startValue; // determine maximum and minimum interval

  var options = this.options;
  var year = 1000 * 60 * 60 * 24 * 365;
  var zoomMin = Number(options.zoomMin) || 10;

  if (zoomMin < 10) {
    zoomMin = 10;
  }

  var zoomMax = Number(options.zoomMax) || 10000 * year;

  if (zoomMax > 10000 * year) {
    zoomMax = 10000 * year;
  }

  if (zoomMax < zoomMin) {
    zoomMax = zoomMin;
  } // determine min and max date value


  var min = options.min ? options.min.valueOf() : undefined; // number

  var max = options.max ? options.max.valueOf() : undefined; // number

  if (min != undefined && max != undefined) {
    if (min >= max) {
      // empty range
      var day = 1000 * 60 * 60 * 24;
      max = min + day;
    }

    if (zoomMax > max - min) {
      zoomMax = max - min;
    }

    if (zoomMin > max - min) {
      zoomMin = max - min;
    }
  } // prevent empty interval


  if (startValue >= endValue) {
    endValue += 1000 * 60 * 60 * 24;
  } // prevent too small scale
  // TODO: IE has problems with milliseconds


  if (interval < zoomMin) {
    var diff = zoomMin - interval;
    var f = zoomAroundDate ? (zoomAroundDate.valueOf() - startValue) / interval : 0.5;
    startValue -= Math.round(diff * f);
    endValue += Math.round(diff * (1 - f));
  } // prevent too large scale


  if (interval > zoomMax) {
    var diff = interval - zoomMax;
    var f = zoomAroundDate ? (zoomAroundDate.valueOf() - startValue) / interval : 0.5;
    startValue += Math.round(diff * f);
    endValue -= Math.round(diff * (1 - f));
  } // prevent to small start date


  if (min != undefined) {
    var diff = startValue - min;

    if (diff < 0) {
      startValue -= diff;
      endValue -= diff;
    }
  } // prevent to large end date


  if (max != undefined) {
    var diff = max - endValue;

    if (diff < 0) {
      startValue += diff;
      endValue += diff;
    }
  } // apply new dates


  this.start = new Date(startValue);
  this.end = new Date(endValue);
};
/**
 * Delete an item after a confirmation.
 * The deletion can be cancelled by executing .cancelDelete() during the
 * triggered event 'delete'.
 * @param {int} index   Index of the item to be deleted
 */


links.Timeline.prototype.confirmDeleteItem = function (index) {
  this.applyDelete = true; // select the event to be deleted

  if (!this.isSelected(index)) {
    this.selectItem(index);
  } // fire a delete event trigger.
  // Note that the delete event can be canceled from within an event listener if
  // this listener calls the method cancelChange().


  this.trigger('delete');

  if (this.applyDelete) {
    this.deleteItem(index);
  }

  delete this.applyDelete;
};
/**
 * Delete an item
 * @param {int} index   Index of the item to be deleted
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 *                                          (optimization for multiple delete)
 */


links.Timeline.prototype.deleteItem = function (index, preventRender) {
  if (index >= this.items.length) {
    throw "Cannot delete row, index out of range";
  }

  if (this.selection && this.selection.index !== undefined) {
    // adjust the selection
    if (this.selection.index == index) {
      // item to be deleted is selected
      this.unselectItem();
    } else if (this.selection.index > index) {
      // update selection index
      this.selection.index--;
    }
  } // actually delete the item and remove it from the DOM


  var item = this.items.splice(index, 1)[0];
  this.renderQueue.hide.push(item); // delete the row in the original data table

  if (this.data) {
    if (google && google.visualization && this.data instanceof google.visualization.DataTable) {
      this.data.removeRow(index);
    } else if (links.Timeline.isArray(this.data)) {
      this.data.splice(index, 1);
    } else {
      throw "Cannot delete row from data, unknown data type";
    }
  } // prepare data for clustering, by filtering and sorting by type


  if (this.options.cluster) {
    this.clusterGenerator.updateData();
  }

  if (!preventRender) {
    this.render();
  }
};
/**
 * Delete all items
 */


links.Timeline.prototype.deleteAllItems = function () {
  this.unselectItem(); // delete the loaded items

  this.clearItems(); // delete the groups

  this.deleteGroups(); // empty original data table

  if (this.data) {
    if (google && google.visualization && this.data instanceof google.visualization.DataTable) {
      this.data.removeRows(0, this.data.getNumberOfRows());
    } else if (links.Timeline.isArray(this.data)) {
      this.data.splice(0, this.data.length);
    } else {
      throw "Cannot delete row from data, unknown data type";
    }
  } // prepare data for clustering, by filtering and sorting by type


  if (this.options.cluster) {
    this.clusterGenerator.updateData();
  }

  this.render();
};
/**
 * Find the group from a given height in the timeline
 * @param {Number} height   Height in the timeline
 * @return {Object | undefined} group   The group object, or undefined if out
 *                                      of range
 */


links.Timeline.prototype.getGroupFromHeight = function (height) {
  var i,
      group,
      groups = this.groups;

  if (groups.length) {
    if (this.options.axisOnTop) {
      for (i = groups.length - 1; i >= 0; i--) {
        group = groups[i];

        if (height > group.top) {
          return group;
        }
      }
    } else {
      for (i = 0; i < groups.length; i++) {
        group = groups[i];

        if (height > group.top) {
          return group;
        }
      }
    }

    return group; // return the last group
  }

  return undefined;
};
/**
 * @constructor links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group, type, editable.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */


links.Timeline.Item = function (data, options) {
  if (data) {
    /* TODO: use parseJSONDate as soon as it is tested and working (in two directions)
     this.start = links.Timeline.parseJSONDate(data.start);
     this.end = links.Timeline.parseJSONDate(data.end);
     */
    this.utm = data.utm;
    this.start = data.start;
    this.end = data.end;
    this.content = data.content;
    this.className = data.className;
    this.editable = data.editable;
    this.group = data.group;
    this.type = data.type;
    this.count = data.items;
  }

  this.top = 0;
  this.left = 0;
  this.width = 0;
  this.height = 0;
  this.lineWidth = 0;
  this.dotWidth = 0;
  this.dotHeight = 0;
  this.rendered = false; // true when the item is draw in the Timeline DOM

  if (options) {
    // override the default properties
    for (var option in options) {
      if (options.hasOwnProperty(option)) {
        this[option] = options[option];
      }
    }
  }
};
/**
 * Reflow the Item: retrieve its actual size from the DOM
 * @return {boolean} resized    returns true if the axis is resized
 */


links.Timeline.Item.prototype.reflow = function () {
  // Should be implemented by sub-prototype
  return false;
};
/**
 * Append all image urls present in the items DOM to the provided array
 * @param {String[]} imageUrls
 */


links.Timeline.Item.prototype.getImageUrls = function (imageUrls) {
  if (this.dom) {
    links.imageloader.filterImageUrls(this.dom, imageUrls);
  }
};
/**
 * Select the item
 */


links.Timeline.Item.prototype.select = function () {// Should be implemented by sub-prototype
};
/**
 * Unselect the item
 */


links.Timeline.Item.prototype.unselect = function () {// Should be implemented by sub-prototype
};
/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 */


links.Timeline.Item.prototype.createDOM = function () {// Should be implemented by sub-prototype
};
/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 */


links.Timeline.Item.prototype.showDOM = function (container) {// Should be implemented by sub-prototype
};
/**
 * Remove the items DOM from the current HTML container
 * @param {Element} container
 */


links.Timeline.Item.prototype.hideDOM = function (container) {// Should be implemented by sub-prototype
};
/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 */


links.Timeline.Item.prototype.updateDOM = function () {// Should be implemented by sub-prototype
};
/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options.
 * @param {links.Timeline} timeline
 */


links.Timeline.Item.prototype.updatePosition = function (timeline) {// Should be implemented by sub-prototype
};
/**
 * Check if the item is drawn in the timeline (i.e. the DOM of the item is
 * attached to the frame. You may also just request the parameter item.rendered
 * @return {boolean} rendered
 */


links.Timeline.Item.prototype.isRendered = function () {
  return this.rendered;
};
/**
 * Check if the item is located in the visible area of the timeline, and
 * not part of a cluster
 * @param {Date} start
 * @param {Date} end
 * @return {boolean} visible
 */


links.Timeline.Item.prototype.isVisible = function (start, end) {
  // Should be implemented by sub-prototype
  return false;
};
/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 */


links.Timeline.Item.prototype.setPosition = function (left, right) {// Should be implemented by sub-prototype
};
/**
 * Calculate the left position of the item
 * @param {links.Timeline} timeline
 * @return {Number} left
 */


links.Timeline.Item.prototype.getLeft = function (timeline) {
  // Should be implemented by sub-prototype
  return 0;
};
/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 */


links.Timeline.Item.prototype.getRight = function (timeline) {
  // Should be implemented by sub-prototype
  return 0;
};
/**
 * Calculate the width of the item
 * @param {links.Timeline} timeline
 * @return {Number} width
 */


links.Timeline.Item.prototype.getWidth = function (timeline) {
  // Should be implemented by sub-prototype
  return this.width || 0; // last rendered width
};
/**
 * @constructor links.Timeline.ItemBox
 * @extends links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group, type, className, editable.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */


links.Timeline.ItemBox = function (data, options) {
  links.Timeline.Item.call(this, data, options);
};

links.Timeline.ItemBox.prototype = new links.Timeline.Item();
/**
 * Reflow the Item: retrieve its actual size from the DOM
 * @return {boolean} resized    returns true if the axis is resized
 * @override
 */

links.Timeline.ItemBox.prototype.reflow = function () {
  var dom = this.dom,
      dotHeight = dom.dot.offsetHeight,
      dotWidth = dom.dot.offsetWidth,
      lineWidth = dom.line.offsetWidth,
      resized = this.dotHeight != dotHeight || this.dotWidth != dotWidth || this.lineWidth != lineWidth;
  this.dotHeight = dotHeight;
  this.dotWidth = dotWidth;
  this.lineWidth = lineWidth;
  return resized;
};
/**
 * Select the item
 * @override
 */


links.Timeline.ItemBox.prototype.select = function () {
  var dom = this.dom;
  links.Timeline.addClassName(dom, 'timeline-event-selected');
  links.Timeline.addClassName(dom.line, 'timeline-event-selected');
  links.Timeline.addClassName(dom.dot, 'timeline-event-selected');
};
/**
 * Unselect the item
 * @override
 */


links.Timeline.ItemBox.prototype.unselect = function () {
  var dom = this.dom;
  links.Timeline.removeClassName(dom, 'timeline-event-selected');
  links.Timeline.removeClassName(dom.line, 'timeline-event-selected');
  links.Timeline.removeClassName(dom.dot, 'timeline-event-selected');
};
/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 * @override
 */


links.Timeline.ItemBox.prototype.createDOM = function () {
  // background box
  var divBox = document.createElement("DIV");
  divBox.style.position = "absolute";
  divBox.style.left = this.left + "px";
  divBox.style.top = this.top + "px"; // contents box (inside the background box). used for making margins

  var divContent = document.createElement("DIV");
  divContent.className = "timeline-event-content";
  divContent.innerHTML = this.content;
  divBox.appendChild(divContent); // line to axis

  var divLine = document.createElement("DIV");
  divLine.style.position = "absolute";
  divLine.style.width = "0px"; // important: the vertical line is added at the front of the list of elements,
  // so it will be drawn behind all boxes and ranges

  divBox.line = divLine; // dot on axis

  var divDot = document.createElement("DIV");
  divDot.style.position = "absolute";
  divDot.style.width = "0px";
  divDot.style.height = "0px";
  divBox.dot = divDot;
  divDot._date = this.start;
  this.dom = divBox;
  this.updateDOM();
  return divBox;
};
/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 * @override
 */


links.Timeline.ItemBox.prototype.showDOM = function (container) {
  var dom = this.dom;

  if (!dom) {
    dom = this.createDOM();
  }

  if (dom.parentNode != container) {
    if (dom.parentNode) {
      // container is changed. remove from old container
      this.hideDOM();
    } // append to this container


    container.appendChild(dom);
    container.insertBefore(dom.line, container.firstChild); // Note: line must be added in front of the this,
    //       such that it stays below all this

    container.appendChild(dom.dot);
    this.rendered = true;
  }
};
/**
 * Remove the items DOM from the current HTML container, but keep the DOM in
 * memory
 * @override
 */


links.Timeline.ItemBox.prototype.hideDOM = function () {
  var dom = this.dom;

  if (dom) {
    if (dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }

    if (dom.line && dom.line.parentNode) {
      dom.line.parentNode.removeChild(dom.line);
    }

    if (dom.dot && dom.dot.parentNode) {
      dom.dot.parentNode.removeChild(dom.dot);
    }

    this.rendered = false;
  }
};
/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 * @override
 */


links.Timeline.ItemBox.prototype.updateDOM = function () {
  var divBox = this.dom;

  if (divBox) {
    var divLine = divBox.line;
    var divDot = divBox.dot; // update contents

    divBox.firstChild.innerHTML = this.content; // update class

    divBox.className = "timeline-event timeline-event-box";
    divLine.className = "timeline-event timeline-event-line";
    divDot.className = "timeline-event timeline-event-dot";

    if (this.isCluster) {
      links.Timeline.addClassName(divBox, 'timeline-event-cluster');
      links.Timeline.addClassName(divLine, 'timeline-event-cluster');
      links.Timeline.addClassName(divDot, 'timeline-event-cluster');
    } // add item specific class name when provided


    if (this.className) {
      links.Timeline.addClassName(divBox, this.className);
      links.Timeline.addClassName(divLine, this.className);
      links.Timeline.addClassName(divDot, this.className);
    } // TODO: apply selected className?

  }
};
/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options.
 * @param {links.Timeline} timeline
 * @override
 */


links.Timeline.ItemBox.prototype.updatePosition = function (timeline) {
  var dom = this.dom;

  if (dom) {
    var left = timeline.timeToScreen(this.start),
        axisOnTop = timeline.options.axisOnTop,
        axisTop = timeline.size.axis.top,
        axisHeight = timeline.size.axis.height,
        boxAlign = timeline.options.box && timeline.options.box.align ? timeline.options.box.align : undefined;
    dom.style.top = this.top + "px";

    if (boxAlign == 'right') {
      dom.style.left = left - this.width + "px";
    } else if (boxAlign == 'left') {
      dom.style.left = left + "px";
    } else {
      // default or 'center'
      dom.style.left = left - this.width / 2 + "px";
    }

    var line = dom.line;
    var dot = dom.dot;
    line.style.left = left - this.lineWidth / 2 + "px";
    dot.style.left = left - this.dotWidth / 2 + "px";

    if (axisOnTop) {
      line.style.top = axisHeight + "px";
      line.style.height = Math.max(this.top - axisHeight, 0) + "px";
      dot.style.top = axisHeight - this.dotHeight / 2 + "px";
    } else {
      line.style.top = this.top + this.height + "px";
      line.style.height = Math.max(axisTop - this.top - this.height, 0) + "px";
      dot.style.top = axisTop - this.dotHeight / 2 + "px";
    }
  }
};
/**
 * Check if the item is visible in the timeline, and not part of a cluster
 * @param {Date} start
 * @param {Date} end
 * @return {Boolean} visible
 * @override
 */


links.Timeline.ItemBox.prototype.isVisible = function (start, end) {
  if (this.cluster) {
    return false;
  }

  return this.start > start && this.start < end;
};
/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 * @override
 */


links.Timeline.ItemBox.prototype.setPosition = function (left, right) {
  var dom = this.dom;
  dom.style.left = left - this.width / 2 + "px";
  dom.line.style.left = left - this.lineWidth / 2 + "px";
  dom.dot.style.left = left - this.dotWidth / 2 + "px";

  if (this.group) {
    this.top = this.group.top;
    dom.style.top = this.top + 'px';
  }
};
/**
 * Calculate the left position of the item
 * @param {links.Timeline} timeline
 * @return {Number} left
 * @override
 */


links.Timeline.ItemBox.prototype.getLeft = function (timeline) {
  var boxAlign = timeline.options.box && timeline.options.box.align ? timeline.options.box.align : undefined;
  var left = timeline.timeToScreen(this.start);

  if (boxAlign == 'right') {
    left = left - width;
  } else {
    // default or 'center'
    left = left - this.width / 2;
  }

  return left;
};
/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 * @override
 */


links.Timeline.ItemBox.prototype.getRight = function (timeline) {
  var boxAlign = timeline.options.box && timeline.options.box.align ? timeline.options.box.align : undefined;
  var left = timeline.timeToScreen(this.start);
  var right;

  if (boxAlign == 'right') {
    right = left;
  } else if (boxAlign == 'left') {
    right = left + this.width;
  } else {
    // default or 'center'
    right = left + this.width / 2;
  }

  return right;
};
/**
 * @constructor links.Timeline.ItemRange
 * @extends links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group, type, className, editable.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */


links.Timeline.ItemRange = function (data, options) {
  links.Timeline.Item.call(this, data, options);
};

links.Timeline.ItemRange.prototype = new links.Timeline.Item();
/**
 * Select the item
 * @override
 */

links.Timeline.ItemRange.prototype.select = function () {
  var dom = this.dom;
  links.Timeline.addClassName(dom, 'timeline-event-selected');
};
/**
 * Unselect the item
 * @override
 */


links.Timeline.ItemRange.prototype.unselect = function () {
  var dom = this.dom;
  links.Timeline.removeClassName(dom, 'timeline-event-selected');
};
/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 * @override
 */


links.Timeline.ItemRange.prototype.createDOM = function () {
  // background box
  var divBox = document.createElement("DIV");
  divBox.style.position = "absolute"; // contents box

  var divContent = document.createElement("DIV");
  divContent.className = "timeline-event-content";
  divBox.appendChild(divContent);
  this.dom = divBox;
  this.updateDOM();
  return divBox;
};
/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 * @override
 */


links.Timeline.ItemRange.prototype.showDOM = function (container) {
  var dom = this.dom;

  if (!dom) {
    dom = this.createDOM();
  }

  if (dom.parentNode != container) {
    if (dom.parentNode) {
      // container changed. remove the item from the old container
      this.hideDOM();
    } // append to the new container


    container.appendChild(dom);
    this.rendered = true;
  }
};
/**
 * Remove the items DOM from the current HTML container
 * The DOM will be kept in memory
 * @override
 */


links.Timeline.ItemRange.prototype.hideDOM = function () {
  var dom = this.dom;

  if (dom) {
    if (dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }

    this.rendered = false;
  }
};
/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 * @override
 */


links.Timeline.ItemRange.prototype.updateDOM = function () {
  var divBox = this.dom;

  if (divBox) {
    // update contents
    divBox.firstChild.innerHTML = this.content; // update class

    divBox.className = "timeline-event timeline-event-range";

    if (this.isCluster) {
      links.Timeline.addClassName(divBox, 'timeline-event-cluster');
    } // add item specific class name when provided


    if (this.className) {
      links.Timeline.addClassName(divBox, this.className);
    } // TODO: apply selected className?

  }
};
/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options. *
 * @param {links.Timeline} timeline
 * @override
 */


links.Timeline.ItemRange.prototype.updatePosition = function (timeline) {
  var dom = this.dom;

  if (dom) {
    var contentWidth = timeline.size.contentWidth,
        left = timeline.timeToScreen(this.start),
        right = timeline.timeToScreen(this.end); // limit the width of the this, as browsers cannot draw very wide divs

    if (left < -contentWidth) {
      left = -contentWidth;
    }

    if (right > 2 * contentWidth) {
      right = 2 * contentWidth;
    }

    dom.style.top = this.top + "px";
    dom.style.left = left + "px"; //dom.style.width = Math.max(right - left - 2 * this.borderWidth, 1) + "px"; // TODO: borderWidth

    dom.style.width = Math.max(right - left, 1) + "px";
  }
};
/**
 * Check if the item is visible in the timeline, and not part of a cluster
 * @param {Number} start
 * @param {Number} end
 * @return {boolean} visible
 * @override
 */


links.Timeline.ItemRange.prototype.isVisible = function (start, end) {
  if (this.cluster) {
    return false;
  }

  return this.end > start && this.start < end;
};
/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 * @override
 */


links.Timeline.ItemRange.prototype.setPosition = function (left, right) {
  var dom = this.dom;
  dom.style.left = left + 'px';
  dom.style.width = right - left + 'px';

  if (this.group) {
    this.top = this.group.top;
    dom.style.top = this.top + 'px';
  }
};
/**
 * Calculate the left position of the item
 * @param {links.Timeline} timeline
 * @return {Number} left
 * @override
 */


links.Timeline.ItemRange.prototype.getLeft = function (timeline) {
  return timeline.timeToScreen(this.start);
};
/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 * @override
 */


links.Timeline.ItemRange.prototype.getRight = function (timeline) {
  return timeline.timeToScreen(this.end);
};
/**
 * Calculate the width of the item
 * @param {links.Timeline} timeline
 * @return {Number} width
 * @override
 */


links.Timeline.ItemRange.prototype.getWidth = function (timeline) {
  return timeline.timeToScreen(this.end) - timeline.timeToScreen(this.start);
};
/**
 * @constructor links.Timeline.ItemFloatingRange
 * @extends links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group, type, className, editable.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */


links.Timeline.ItemFloatingRange = function (data, options) {
  links.Timeline.Item.call(this, data, options);
};

links.Timeline.ItemFloatingRange.prototype = new links.Timeline.Item();
/**
 * Select the item
 * @override
 */

links.Timeline.ItemFloatingRange.prototype.select = function () {
  var dom = this.dom;
  links.Timeline.addClassName(dom, 'timeline-event-selected');
};
/**
 * Unselect the item
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.unselect = function () {
  var dom = this.dom;
  links.Timeline.removeClassName(dom, 'timeline-event-selected');
};
/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.createDOM = function () {
  // background box
  var divBox = document.createElement("DIV");
  divBox.style.position = "absolute"; // contents box

  var divContent = document.createElement("DIV");
  divContent.className = "timeline-event-content";
  divBox.appendChild(divContent);
  this.dom = divBox;
  this.updateDOM();
  return divBox;
};
/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.showDOM = function (container) {
  var dom = this.dom;

  if (!dom) {
    dom = this.createDOM();
  }

  if (dom.parentNode != container) {
    if (dom.parentNode) {
      // container changed. remove the item from the old container
      this.hideDOM();
    } // append to the new container


    container.appendChild(dom);
    this.rendered = true;
  }
};
/**
 * Remove the items DOM from the current HTML container
 * The DOM will be kept in memory
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.hideDOM = function () {
  var dom = this.dom;

  if (dom) {
    if (dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }

    this.rendered = false;
  }
};
/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.updateDOM = function () {
  var divBox = this.dom;

  if (divBox) {
    // update contents
    divBox.firstChild.innerHTML = this.content; // update class

    divBox.className = "timeline-event timeline-event-range";

    if (this.isCluster) {
      links.Timeline.addClassName(divBox, 'timeline-event-cluster');
    } // add item specific class name when provided


    if (this.className) {
      links.Timeline.addClassName(divBox, this.className);
    } // TODO: apply selected className?

  }
};
/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options. *
 * @param {links.Timeline} timeline
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.updatePosition = function (timeline) {
  var dom = this.dom;

  if (dom) {
    var contentWidth = timeline.size.contentWidth,
        left = this.getLeft(timeline),
        // NH use getLeft
    right = this.getRight(timeline); // NH use getRight;
    // limit the width of the this, as browsers cannot draw very wide divs

    if (left < -contentWidth) {
      left = -contentWidth;
    }

    if (right > 2 * contentWidth) {
      right = 2 * contentWidth;
    }

    dom.style.top = this.top + "px";
    dom.style.left = left + "px"; //dom.style.width = Math.max(right - left - 2 * this.borderWidth, 1) + "px"; // TODO: borderWidth

    dom.style.width = Math.max(right - left, 1) + "px";
  }
};
/**
 * Check if the item is visible in the timeline, and not part of a cluster
 * @param {Number} start
 * @param {Number} end
 * @return {boolean} visible
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.isVisible = function (start, end) {
  if (this.cluster) {
    return false;
  } // NH check for no end value


  if (this.end && this.start) {
    return this.end > start && this.start < end;
  } else if (this.start) {
    return this.start < end;
  } else if (this.end) {
    return this.end > start;
  } else {
    return true;
  }
};
/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.setPosition = function (left, right) {
  var dom = this.dom;
  dom.style.left = left + 'px';
  dom.style.width = right - left + 'px';

  if (this.group) {
    this.top = this.group.top;
    dom.style.top = this.top + 'px';
  }
};
/**
 * Calculate the left position of the item
 * @param {links.Timeline} timeline
 * @return {Number} left
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.getLeft = function (timeline) {
  // NH check for no start value
  if (this.start) {
    return timeline.timeToScreen(this.start);
  } else {
    return 0;
  }
};
/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.getRight = function (timeline) {
  // NH check for no end value
  if (this.end) {
    return timeline.timeToScreen(this.end);
  } else {
    return timeline.size.contentWidth;
  }
};
/**
 * Calculate the width of the item
 * @param {links.Timeline} timeline
 * @return {Number} width
 * @override
 */


links.Timeline.ItemFloatingRange.prototype.getWidth = function (timeline) {
  return this.getRight(timeline) - this.getLeft(timeline);
};
/**
 * @constructor links.Timeline.ItemDot
 * @extends links.Timeline.Item
 * @param {Object} data       Object containing parameters start, end
 *                            content, group, type, className, editable.
 * @param {Object} [options]  Options to set initial property values
 *                                {Number} top
 *                                {Number} left
 *                                {Number} width
 *                                {Number} height
 */


links.Timeline.ItemDot = function (data, options) {
  links.Timeline.Item.call(this, data, options);
};

links.Timeline.ItemDot.prototype = new links.Timeline.Item();
/**
 * Reflow the Item: retrieve its actual size from the DOM
 * @return {boolean} resized    returns true if the axis is resized
 * @override
 */

links.Timeline.ItemDot.prototype.reflow = function () {
  var dom = this.dom,
      dotHeight = dom.dot.offsetHeight,
      dotWidth = dom.dot.offsetWidth,
      contentHeight = dom.content.offsetHeight,
      resized = this.dotHeight != dotHeight || this.dotWidth != dotWidth || this.contentHeight != contentHeight;
  this.dotHeight = dotHeight;
  this.dotWidth = dotWidth;
  this.contentHeight = contentHeight;
  return resized;
};
/**
 * Select the item
 * @override
 */


links.Timeline.ItemDot.prototype.select = function () {
  var dom = this.dom;
  links.Timeline.addClassName(dom, 'timeline-event-selected');
};
/**
 * Unselect the item
 * @override
 */


links.Timeline.ItemDot.prototype.unselect = function () {
  var dom = this.dom;
  links.Timeline.removeClassName(dom, 'timeline-event-selected');
};
/**
 * Creates the DOM for the item, depending on its type
 * @return {Element | undefined}
 * @override
 */


links.Timeline.ItemDot.prototype.createDOM = function () {
  // background box
  var divBox = document.createElement("DIV");
  divBox.style.position = "absolute"; // contents box, right from the dot

  var divContent = document.createElement("DIV");
  divContent.className = "timeline-event-content";
  divBox.appendChild(divContent); // dot at start

  var divDot = document.createElement("DIV"); // divDot.style.position = "absolute";

  divDot.style.width = "0px";
  divDot.style.height = "0px";
  divBox.appendChild(divDot);
  divBox.content = divContent;
  divBox.dot = divDot;
  this.dom = divBox;
  this.updateDOM();
  return divBox;
};
/**
 * Append the items DOM to the given HTML container. If items DOM does not yet
 * exist, it will be created first.
 * @param {Element} container
 * @override
 */


links.Timeline.ItemDot.prototype.showDOM = function (container, timeline) {
  var dom = this.dom;

  if (!dom) {
    dom = this.createDOM();
    dom._gmxLeft = Math.round(timeline.timeToScreen(this.start));
  }

  if (dom.parentNode != container) {
    if (dom.parentNode) {
      // container changed. remove it from old container first
      this.hideDOM();
    } // append to container


    if (dom._gmxLeft === 0 || container.lastChild && container.lastChild._gmxLeft !== dom._gmxLeft) {
      container.appendChild(dom);
    }

    this.rendered = true;
  }
};
/**
 * Remove the items DOM from the current HTML container
 * @override
 */


links.Timeline.ItemDot.prototype.hideDOM = function () {
  var dom = this.dom;

  if (dom) {
    if (dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }

    this.rendered = false;
  }
};
/**
 * Update the DOM of the item. This will update the content and the classes
 * of the item
 * @override
 */


links.Timeline.ItemDot.prototype.updateDOM = function () {
  if (this.dom) {
    var divBox = this.dom;
    var divDot = divBox.dot; // update contents

    divBox.firstChild.innerHTML = this.content; // update classes

    divBox.className = "timeline-event-dot-container";
    divDot.className = "timeline-event timeline-event-dot";
    var title = getTimeString(this.start) + (this.count > 1 ? ' (' + this.count + ')' : '');
    divDot.title = title;

    if (this.isCluster) {
      links.Timeline.addClassName(divBox, 'timeline-event-cluster');
      links.Timeline.addClassName(divDot, 'timeline-event-cluster');
    } // add item specific class name when provided


    if (this.className) {
      links.Timeline.addClassName(divBox, this.className); // links.Timeline.addClassName(divDot, this.className);
    } // TODO: apply selected className?

  }
};
/**
 * Reposition the item, recalculate its left, top, and width, using the current
 * range of the timeline and the timeline options. *
 * @param {links.Timeline} timeline
 * @override
 */


links.Timeline.ItemDot.prototype.updatePosition = function (timeline) {
  var dom = this.dom;

  if (dom) {
    var left = Math.round(timeline.timeToScreen(this.start)); // dom.style.top = this.top + "px";

    dom.style.left = left - this.dotWidth / 2 + "px"; // dom.content.style.marginLeft = (1.5 * this.dotWidth) + "px";
    //dom.content.style.marginRight = (0.5 * this.dotWidth) + "px"; // TODO
    // dom.dot.style.top = ((this.height - this.dotHeight) / 2) + "px";
  }
};
/**
 * Check if the item is visible in the timeline, and not part of a cluster.
 * @param {Date} start
 * @param {Date} end
 * @return {boolean} visible
 * @override
 */


links.Timeline.ItemDot.prototype.isVisible = function (start, end) {
  if (this.cluster) {
    return false;
  }

  return this.start > start && this.start < end;
};
/**
 * Reposition the item
 * @param {Number} left
 * @param {Number} right
 * @override
 */


links.Timeline.ItemDot.prototype.setPosition = function (left, right) {
  var dom = this.dom;
  dom.style.left = left - this.dotWidth / 2 + "px";

  if (this.group) {
    this.top = this.group.top;
    dom.style.top = this.top + 'px';
  }
};
/**
 * Calculate the left position of the item
 * @param {links.Timeline} timeline
 * @return {Number} left
 * @override
 */


links.Timeline.ItemDot.prototype.getLeft = function (timeline) {
  return timeline.timeToScreen(this.start);
};
/**
 * Calculate the right position of the item
 * @param {links.Timeline} timeline
 * @return {Number} right
 * @override
 */


links.Timeline.ItemDot.prototype.getRight = function (timeline) {
  return timeline.timeToScreen(this.start) + this.width;
};
/**
 * Retrieve the properties of an item.
 * @param {Number} index
 * @return {Object} itemData    Object containing item properties:<br>
 *                              {Date} start (required),
 *                              {Date} end (optional),
 *                              {String} content (required),
 *                              {String} group (optional),
 *                              {String} className (optional)
 *                              {boolean} editable (optional)
 *                              {String} type (optional)
 */


links.Timeline.prototype.getItem = function (index) {
  if (index >= this.items.length) {
    throw "Cannot get item, index out of range";
  } // take the original data as start, includes foreign fields


  var data = this.data,
      itemData;

  if (google && google.visualization && data instanceof google.visualization.DataTable) {
    // map the datatable columns
    var cols = links.Timeline.mapColumnIds(data);
    itemData = {};

    for (var col in cols) {
      if (cols.hasOwnProperty(col)) {
        itemData[col] = this.data.getValue(index, cols[col]);
      }
    }
  } else if (links.Timeline.isArray(this.data)) {
    // read JSON array
    itemData = links.Timeline.clone(this.data[index]);
  } else {
    throw "Unknown data type. DataTable or Array expected.";
  } // override the data with current settings of the item (should be the same)


  var item = this.items[index];
  itemData.start = new Date(item.start.valueOf());

  if (item.end) {
    itemData.end = new Date(item.end.valueOf());
  }

  itemData.content = item.content;

  if (item.group) {
    itemData.group = this.getGroupName(item.group);
  }

  if (item.className) {
    itemData.className = item.className;
  }

  if (typeof item.editable !== 'undefined') {
    itemData.editable = item.editable;
  }

  if (item.type) {
    itemData.type = item.type;
  }

  return itemData;
};
/**
 * Retrieve the properties of a cluster.
 * @param {Number} index
 * @return {Object} clusterdata    Object containing cluster properties:<br>
 *                              {Date} start (required),
 *                              {String} type (optional)
 *                              {Array} array with item data as is in getItem()
 */


links.Timeline.prototype.getCluster = function (index) {
  if (index >= this.clusters.length) {
    throw "Cannot get cluster, index out of range";
  }

  var clusterData = {},
      cluster = this.clusters[index],
      clusterItems = cluster.items;
  clusterData.start = new Date(cluster.start.valueOf());

  if (cluster.type) {
    clusterData.type = cluster.type;
  } // push cluster item data


  clusterData.items = [];

  for (var i = 0; i < clusterItems.length; i++) {
    for (var j = 0; j < this.items.length; j++) {
      // TODO could be nicer to be able to have the item index into the cluster
      if (this.items[j] == clusterItems[i]) {
        clusterData.items.push(this.getItem(j));
        break;
      }
    }
  }

  return clusterData;
};
/**
 * Add a new item.
 * @param {Object} itemData     Object containing item properties:<br>
 *                              {Date} start (required),
 *                              {Date} end (optional),
 *                              {String} content (required),
 *                              {String} group (optional)
 *                              {String} className (optional)
 *                              {Boolean} editable (optional)
 *                              {String} type (optional)
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 */


links.Timeline.prototype.addItem = function (itemData, preventRender) {
  var itemsData = [itemData];
  this.addItems(itemsData, preventRender);
};
/**
 * Add new items.
 * @param {Array} itemsData An array containing Objects.
 *                          The objects must have the following parameters:
 *                            {Date} start,
 *                            {Date} end,
 *                            {String} content with text or HTML code,
 *                            {String} group (optional)
 *                            {String} className (optional)
 *                            {String} editable (optional)
 *                            {String} type (optional)
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 */


links.Timeline.prototype.addItems = function (itemsData, preventRender) {
  var timeline = this,
      items = this.items; // append the items

  itemsData.forEach(function (itemData) {
    var index = items.length;
    items.push(timeline.createItem(itemData));
    timeline.updateData(index, itemData); // note: there is no need to add the item to the renderQueue, that
    // will be done when this.render() is executed and all items are
    // filtered again.
  }); // prepare data for clustering, by filtering and sorting by type

  if (this.options.cluster) {
    this.clusterGenerator.updateData();
  }

  if (!preventRender) {
    this.render({
      animate: false
    });
  }
};
/**
 * Create an item object, containing all needed parameters
 * @param {Object} itemData  Object containing parameters start, end
 *                           content, group.
 * @return {Object} item
 */


links.Timeline.prototype.createItem = function (itemData) {
  var type = itemData.type || (itemData.end ? 'range' : this.options.style);
  var data = links.Timeline.clone(itemData);
  data.type = type;
  data.group = this.getGroup(itemData.group); // TODO: optimize this, when creating an item, all data is copied twice...
  // TODO: is initialTop needed?

  var initialTop,
      options = this.options;

  if (options.axisOnTop) {
    initialTop = this.size.axis.height + options.eventMarginAxis + options.eventMargin / 2;
  } else {
    initialTop = this.size.contentHeight - options.eventMarginAxis - options.eventMargin / 2;
  }

  if (type in this.itemTypes) {
    return new this.itemTypes[type](data, {
      'top': initialTop
    });
  }

  console.log('ERROR: Unknown event type "' + type + '"');
  return new links.Timeline.Item(data, {
    'top': initialTop
  });
};
/**
 * Edit an item
 * @param {Number} index
 * @param {Object} itemData     Object containing item properties:<br>
 *                              {Date} start (required),
 *                              {Date} end (optional),
 *                              {String} content (required),
 *                              {String} group (optional)
 * @param {boolean} [preventRender=false]   Do not re-render timeline if true
 */


links.Timeline.prototype.changeItem = function (index, itemData, preventRender) {
  var oldItem = this.items[index];

  if (!oldItem) {
    throw "Cannot change item, index out of range";
  } // replace item, merge the changes


  var newItem = this.createItem({
    'start': itemData.hasOwnProperty('start') ? itemData.start : oldItem.start,
    'end': itemData.hasOwnProperty('end') ? itemData.end : oldItem.end,
    'content': itemData.hasOwnProperty('content') ? itemData.content : oldItem.content,
    'group': itemData.hasOwnProperty('group') ? itemData.group : this.getGroupName(oldItem.group),
    'className': itemData.hasOwnProperty('className') ? itemData.className : oldItem.className,
    'editable': itemData.hasOwnProperty('editable') ? itemData.editable : oldItem.editable,
    'type': itemData.hasOwnProperty('type') ? itemData.type : oldItem.type
  });
  this.items[index] = newItem; // append the changes to the render queue

  this.renderQueue.hide.push(oldItem);
  this.renderQueue.show.push(newItem); // update the original data table

  this.updateData(index, itemData); // prepare data for clustering, by filtering and sorting by type

  if (this.options.cluster) {
    this.clusterGenerator.updateData();
  }

  if (!preventRender) {
    // redraw timeline
    this.render({
      animate: false
    });

    if (this.selection && this.selection.index == index) {
      newItem.select();
    }
  }
};
/**
 * Delete all groups
 */


links.Timeline.prototype.deleteGroups = function () {
  this.groups = [];
  this.groupIndexes = {};
};
/**
 * Get a group by the group name. When the group does not exist,
 * it will be created.
 * @param {String} groupName   the name of the group
 * @return {Object} groupObject
 */


links.Timeline.prototype.getGroup = function (groupName) {
  var groups = this.groups,
      groupIndexes = this.groupIndexes,
      groupObj = undefined;
  var groupIndex = groupIndexes[groupName];

  if (groupIndex == undefined && groupName != undefined) {
    // not null or undefined
    groupObj = {
      'content': groupName,
      'labelTop': 0,
      'lineTop': 0 // note: this object will lateron get addition information,
      //       such as height and width of the group

    };
    groups.push(groupObj); // sort the groups

    if (this.options.groupsOrder == true) {
      groups = groups.sort(function (a, b) {
        if (a.content > b.content) {
          return 1;
        }

        if (a.content < b.content) {
          return -1;
        }

        return 0;
      });
    } else if (typeof this.options.groupsOrder == "function") {
      groups = groups.sort(this.options.groupsOrder);
    } // rebuilt the groupIndexes


    for (var i = 0, iMax = groups.length; i < iMax; i++) {
      groupIndexes[groups[i].content] = i;
    }
  } else {
    groupObj = groups[groupIndex];
  }

  return groupObj;
};
/**
 * Get the group name from a group object.
 * @param {Object} groupObj
 * @return {String} groupName   the name of the group, or undefined when group
 *                              was not provided
 */


links.Timeline.prototype.getGroupName = function (groupObj) {
  return groupObj ? groupObj.content : undefined;
};
/**
 * Cancel a change item
 * This method can be called insed an event listener which catches the "change"
 * event. The changed event position will be undone.
 */


links.Timeline.prototype.cancelChange = function () {
  this.applyChange = false;
};
/**
 * Cancel deletion of an item
 * This method can be called insed an event listener which catches the "delete"
 * event. Deletion of the event will be undone.
 */


links.Timeline.prototype.cancelDelete = function () {
  this.applyDelete = false;
};
/**
 * Cancel creation of a new item
 * This method can be called insed an event listener which catches the "new"
 * event. Creation of the new the event will be undone.
 */


links.Timeline.prototype.cancelAdd = function () {
  this.applyAdd = false;
};
/**
 * Select an event. The visible chart range will be moved such that the selected
 * event is placed in the middle.
 * For example selection = [{row: 5}];
 * @param {Array} selection   An array with a column row, containing the row
 *                           number (the id) of the event to be selected.
 * @return {boolean}         true if selection is succesfully set, else false.
 */


links.Timeline.prototype.setSelection = function (selection) {
  if (selection != undefined && selection.length > 0) {
    if (selection[0].row != undefined) {
      var index = selection[0].row;

      if (this.items[index]) {
        var item = this.items[index];
        this.selectItem(index); // move the visible chart range to the selected event.

        var start = item.start;
        var end = item.end;
        var middle; // number

        if (end != undefined) {
          middle = (end.valueOf() + start.valueOf()) / 2;
        } else {
          middle = start.valueOf();
        }

        var diff = this.end.valueOf() - this.start.valueOf(),
            newStart = new Date(middle - diff / 2),
            newEnd = new Date(middle + diff / 2);
        this.setVisibleChartRange(newStart, newEnd);
        return true;
      }
    }
  } else {
    // unselect current selection
    this.unselectItem();
  }

  return false;
};
/**
 * Retrieve the currently selected event
 * @return {Array} sel  An array with a column row, containing the row number
 *                      of the selected event. If there is no selection, an
 *                      empty array is returned.
 */


links.Timeline.prototype.getSelection = function () {
  var sel = [];

  if (this.selection) {
    if (this.selection.index !== undefined) {
      sel.push({
        "row": this.selection.index
      });
    } else {
      sel.push({
        "cluster": this.selection.cluster
      });
    }
  }

  return sel;
};
/**
 * Select an item by its index
 * @param {Number} index
 */


links.Timeline.prototype.selectItem = function (index) {
  this.unselectItem();
  this.selection = undefined;

  if (this.items[index] != undefined) {
    var item = this.items[index],
        domItem = item.dom;
    this.selection = {
      'index': index
    };

    if (item && item.dom) {
      // TODO: move adjusting the domItem to the item itself
      if (this.isEditable(item)) {
        item.dom.style.cursor = 'move';
      }

      item.select();
    }

    this.repaintDeleteButton();
    this.repaintDragAreas();
  }
};
/**
 * Select an cluster by its index
 * @param {Number} index
 */


links.Timeline.prototype.selectCluster = function (index) {
  this.unselectItem();
  this.selection = undefined;

  if (this.clusters[index] != undefined) {
    this.selection = {
      'cluster': index
    };
    this.repaintDeleteButton();
    this.repaintDragAreas();
  }
};
/**
 * Check if an item is currently selected
 * @param {Number} index
 * @return {boolean} true if row is selected, else false
 */


links.Timeline.prototype.isSelected = function (index) {
  return this.selection && this.selection.index == index;
};
/**
 * Unselect the currently selected event (if any)
 */


links.Timeline.prototype.unselectItem = function () {
  if (this.selection && this.selection.index !== undefined) {
    var item = this.items[this.selection.index];

    if (item && item.dom) {
      var domItem = item.dom;
      domItem.style.cursor = '';
      item.unselect();
    }

    this.selection = undefined;
    this.repaintDeleteButton();
    this.repaintDragAreas();
  }
};
/**
 * Stack the items such that they don't overlap. The items will have a minimal
 * distance equal to options.eventMargin.
 * @param {boolean | undefined} animate    if animate is true, the items are
 *                                         moved to their new position animated
 *                                         defaults to false.
 */


links.Timeline.prototype.stackItems = function (animate) {
  if (animate == undefined) {
    animate = false;
  } // calculate the order and final stack position of the items


  var stack = this.stack;

  if (!stack) {
    stack = {};
    this.stack = stack;
  }

  stack.sortedItems = this.stackOrder(this.renderedItems);
  stack.finalItems = this.stackCalculateFinal(stack.sortedItems);

  if (animate || stack.timer) {
    // move animated to the final positions
    var timeline = this;

    var step = function step() {
      var arrived = timeline.stackMoveOneStep(stack.sortedItems, stack.finalItems);
      timeline.repaint();

      if (!arrived) {
        stack.timer = setTimeout(step, 30);
      } else {
        delete stack.timer;
      }
    };

    if (!stack.timer) {
      stack.timer = setTimeout(step, 30);
    }
  } else {
    // move immediately to the final positions
    this.stackMoveToFinal(stack.sortedItems, stack.finalItems);
  }
};
/**
 * Cancel any running animation
 */


links.Timeline.prototype.stackCancelAnimation = function () {
  if (this.stack && this.stack.timer) {
    clearTimeout(this.stack.timer);
    delete this.stack.timer;
  }
};

links.Timeline.prototype.getItemsByGroup = function (items) {
  var itemsByGroup = {};

  for (var i = 0; i < items.length; ++i) {
    var item = items[i];
    var group = "undefined";

    if (item.group) {
      if (item.group.content) {
        group = item.group.content;
      } else {
        group = item.group;
      }
    }

    if (!itemsByGroup[group]) {
      itemsByGroup[group] = [];
    }

    itemsByGroup[group].push(item);
  }

  return itemsByGroup;
};
/**
 * Order the items in the array this.items. The default order is determined via:
 * - Ranges go before boxes and dots.
 * - The item with the oldest start time goes first
 * If a custom function has been provided via the stackorder option, then this will be used.
 * @param {Array} items        Array with items
 * @return {Array} sortedItems Array with sorted items
 */


links.Timeline.prototype.stackOrder = function (items) {
  // TODO: store the sorted items, to have less work later on
  var sortedItems = items.concat([]); //if a customer stack order function exists, use it.

  var f = this.options.customStackOrder && typeof this.options.customStackOrder === 'function' ? this.options.customStackOrder : function (a, b) {
    if ((a instanceof links.Timeline.ItemRange || a instanceof links.Timeline.ItemFloatingRange) && !(b instanceof links.Timeline.ItemRange || b instanceof links.Timeline.ItemFloatingRange)) {
      return -1;
    }

    if (!(a instanceof links.Timeline.ItemRange || a instanceof links.Timeline.ItemFloatingRange) && (b instanceof links.Timeline.ItemRange || b instanceof links.Timeline.ItemFloatingRange)) {
      return 1;
    }

    return a.left - b.left;
  };
  sortedItems.sort(f);
  return sortedItems;
};
/**
 * Adjust vertical positions of the events such that they don't overlap each
 * other.
 * @param {timeline.Item[]} items
 * @return {Object[]} finalItems
 */


links.Timeline.prototype.stackCalculateFinal = function (items) {
  var size = this.size,
      options = this.options,
      axisOnTop = options.axisOnTop,
      eventMargin = options.eventMargin,
      eventMarginAxis = options.eventMarginAxis,
      groupBase = axisOnTop ? size.axis.height + eventMarginAxis + eventMargin / 2 : size.contentHeight - eventMarginAxis - eventMargin / 2,
      groupedItems,
      groupFinalItems,
      finalItems = [];
  groupedItems = this.getItemsByGroup(items); //
  // groupedItems contains all items by group, plus it may contain an
  // additional "undefined" group which contains all items with no group. We
  // first process the grouped items, and then the ungrouped
  //

  for (var j = 0; j < this.groups.length; ++j) {
    var group = this.groups[j];

    if (!groupedItems[group.content]) {
      if (axisOnTop) {
        groupBase += options.groupMinHeight + eventMargin;
      } else {
        groupBase -= options.groupMinHeight + eventMargin;
      }

      continue;
    } // initialize final positions and fill finalItems


    groupFinalItems = this.finalItemsPosition(groupedItems[group.content], groupBase, group);
    groupFinalItems.forEach(function (item) {
      finalItems.push(item);
    });

    if (axisOnTop) {
      groupBase += group.itemsHeight + eventMargin;
    } else {
      groupBase -= group.itemsHeight + eventMargin;
    }
  } //
  // Ungrouped items' turn now!
  //


  if (groupedItems["undefined"]) {
    // initialize final positions and fill finalItems
    groupFinalItems = this.finalItemsPosition(groupedItems["undefined"], groupBase);
    groupFinalItems.forEach(function (item) {
      finalItems.push(item);
    });
  }

  return finalItems;
};

links.Timeline.prototype.finalItemsPosition = function (items, groupBase, group) {
  var i,
      iMax,
      options = this.options,
      axisOnTop = options.axisOnTop,
      eventMargin = options.eventMargin,
      groupFinalItems; // initialize final positions and fill finalItems

  groupFinalItems = this.initialItemsPosition(items, groupBase); // calculate new, non-overlapping positions

  for (var i = 0, iMax = groupFinalItems.length; i < iMax; i++) {
    var finalItem = groupFinalItems[i];
    var collidingItem = null;

    if (this.options.stackEvents) {
      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //  you only need to check for items from the next item on, not from zero
        collidingItem = this.stackItemsCheckOverlap(groupFinalItems, i, 0, i - 1);

        if (collidingItem != null) {
          // There is a collision. Reposition the event above the colliding element
          if (axisOnTop) {
            finalItem.top = collidingItem.top + collidingItem.height + eventMargin;
          } else {
            finalItem.top = collidingItem.top - finalItem.height - eventMargin;
          }

          finalItem.bottom = finalItem.top + finalItem.height;
        }
      } while (collidingItem);
    }

    if (group) {
      if (axisOnTop) {
        group.itemsHeight = group.itemsHeight ? Math.max(group.itemsHeight, finalItem.bottom - groupBase) : finalItem.height + eventMargin;
      } else {
        group.itemsHeight = group.itemsHeight ? Math.max(group.itemsHeight, groupBase - finalItem.top) : finalItem.height + eventMargin;
      }
    }
  }

  return groupFinalItems;
};

links.Timeline.prototype.initialItemsPosition = function (items, groupBase) {
  var options = this.options,
      axisOnTop = options.axisOnTop,
      finalItems = [];

  for (var i = 0, iMax = items.length; i < iMax; ++i) {
    var item = items[i],
        top,
        bottom,
        height = item.height,
        width = item.getWidth(this),
        right = item.getRight(this),
        left = right - width;
    top = axisOnTop ? groupBase : groupBase - height;
    bottom = top + height;
    finalItems.push({
      'left': left,
      'top': top,
      'right': right,
      'bottom': bottom,
      'height': height,
      'item': item
    });
  }

  return finalItems;
};
/**
 * Move the events one step in the direction of their final positions
 * @param {Array} currentItems   Array with the real items and their current
 *                               positions
 * @param {Array} finalItems     Array with objects containing the final
 *                               positions of the items
 * @return {boolean} arrived     True if all items have reached their final
 *                               location, else false
 */


links.Timeline.prototype.stackMoveOneStep = function (currentItems, finalItems) {
  var arrived = true; // apply new positions animated

  for (var i = 0, iMax = finalItems.length; i < iMax; i++) {
    var finalItem = finalItems[i],
        item = finalItem.item;
    var topNow = parseInt(item.top);
    var topFinal = parseInt(finalItem.top);
    var diff = topFinal - topNow;

    if (diff) {
      var step = topFinal == topNow ? 0 : topFinal > topNow ? 1 : -1;
      if (Math.abs(diff) > 4) step = diff / 4;
      var topNew = parseInt(topNow + step);

      if (topNew != topFinal) {
        arrived = false;
      }

      item.top = topNew;
      item.bottom = item.top + item.height;
    } else {
      item.top = finalItem.top;
      item.bottom = finalItem.bottom;
    }

    item.left = finalItem.left;
    item.right = finalItem.right;
  }

  return arrived;
};
/**
 * Move the events from their current position to the final position
 * @param {Array} currentItems   Array with the real items and their current
 *                               positions
 * @param {Array} finalItems     Array with objects containing the final
 *                               positions of the items
 */


links.Timeline.prototype.stackMoveToFinal = function (currentItems, finalItems) {
  // Put the events directly at there final position
  for (var i = 0, iMax = finalItems.length; i < iMax; i++) {
    var finalItem = finalItems[i],
        current = finalItem.item;
    current.left = finalItem.left;
    current.top = finalItem.top;
    current.right = finalItem.right;
    current.bottom = finalItem.bottom;
  }
};
/**
 * Check if the destiny position of given item overlaps with any
 * of the other items from index itemStart to itemEnd.
 * @param {Array} items      Array with items
 * @param {int}  itemIndex   Number of the item to be checked for overlap
 * @param {int}  itemStart   First item to be checked.
 * @param {int}  itemEnd     Last item to be checked.
 * @return {Object}          colliding item, or undefined when no collisions
 */


links.Timeline.prototype.stackItemsCheckOverlap = function (items, itemIndex, itemStart, itemEnd) {
  var eventMargin = this.options.eventMargin,
      collision = this.collision; // we loop from end to start, as we suppose that the chance of a
  // collision is larger for items at the end, so check these first.

  var item1 = items[itemIndex];

  for (var i = itemEnd; i >= itemStart; i--) {
    var item2 = items[i];

    if (collision(item1, item2, eventMargin)) {
      if (i != itemIndex) {
        return item2;
      }
    }
  }

  return undefined;
};
/**
 * Test if the two provided items collide
 * The items must have parameters left, right, top, and bottom.
 * @param {Element} item1       The first item
 * @param {Element} item2       The second item
 * @param {Number}              margin  A minimum required margin. Optional.
 *                              If margin is provided, the two items will be
 *                              marked colliding when they overlap or
 *                              when the margin between the two is smaller than
 *                              the requested margin.
 * @return {boolean}            true if item1 and item2 collide, else false
 */


links.Timeline.prototype.collision = function (item1, item2, margin) {
  // set margin if not specified
  if (margin == undefined) {
    margin = 0;
  } // calculate if there is overlap (collision)


  return item1.left - margin < item2.right && item1.right + margin > item2.left && item1.top - margin < item2.bottom && item1.bottom + margin > item2.top;
};
/**
 * fire an event
 * @param {String} event   The name of an event, for example "rangechange" or "edit"
 */


links.Timeline.prototype.trigger = function (event, params) {
  // built up properties
  var properties = null;

  switch (event) {
    case 'rangechange':
    case 'rangechanged':
      properties = {
        'start': new Date(this.start.valueOf()),
        'end': new Date(this.end.valueOf())
      };
      break;

    case 'timechange':
    case 'timechanged':
      properties = {
        'time': new Date(this.customTime.valueOf())
      };
      break;

    case 'select':
      // added for GMXtimeline
      properties = params;
      break;
  } // trigger the links event bus


  links.events.trigger(this, event, properties); // trigger the google event bus

  if (google && google.visualization) {
    google.visualization.events.trigger(this, event, properties);
  }
};
/**
 * Cluster the events
 */


links.Timeline.prototype.clusterItems = function () {
  if (!this.options.cluster) {
    return;
  }

  var clusters = this.clusterGenerator.getClusters(this.conversion.factor, this.options.clusterMaxItems);

  if (this.clusters != clusters) {
    // cluster level changed
    var queue = this.renderQueue; // remove the old clusters from the scene

    if (this.clusters) {
      this.clusters.forEach(function (cluster) {
        queue.hide.push(cluster); // unlink the items

        cluster.items.forEach(function (item) {
          item.cluster = undefined;
        });
      });
    } // append the new clusters


    clusters.forEach(function (cluster) {
      // don't add to the queue.show here, will be done in .filterItems()
      // link all items to the cluster
      cluster.items.forEach(function (item) {
        item.cluster = cluster;
      });
    });
    this.clusters = clusters;
  }
};
/**
 * Filter the visible events
 */


links.Timeline.prototype.filterItems = function () {
  var queue = this.renderQueue,
      window = this.end - this.start,
      start = new Date(this.start.valueOf() - window),
      end = new Date(this.end.valueOf() + window);

  function filter(arr) {
    arr.forEach(function (item) {
      var rendered = item.rendered;
      var visible = item.isVisible(start, end);

      if (rendered != visible) {
        if (rendered) {
          queue.hide.push(item); // item is rendered but no longer visible
        }

        if (visible && queue.show.indexOf(item) == -1) {
          queue.show.push(item); // item is visible but neither rendered nor queued up to be rendered
        }
      }
    });
  } // filter all items and all clusters


  filter(this.items);

  if (this.clusters) {
    filter(this.clusters);
  }
};
/** ------------------------------------------------------------------------ **/

/**
 * @constructor links.Timeline.ClusterGenerator
 * Generator which creates clusters of items, based on the visible range in
 * the Timeline. There is a set of cluster levels which is cached.
 * @param {links.Timeline} timeline
 */


links.Timeline.ClusterGenerator = function (timeline) {
  this.timeline = timeline;
  this.clear();
};
/**
 * Clear all cached clusters and data, and initialize all variables
 */


links.Timeline.ClusterGenerator.prototype.clear = function () {
  // cache containing created clusters for each cluster level
  this.items = [];
  this.groups = {};
  this.clearCache();
};
/**
 * Clear the cached clusters
 */


links.Timeline.ClusterGenerator.prototype.clearCache = function () {
  // cache containing created clusters for each cluster level
  this.cache = {};
  this.cacheLevel = -1;
  this.cache[this.cacheLevel] = [];
};
/**
 * Set the items to be clustered.
 * This will clear cached clusters.
 * @param {Item[]} items
 * @param {Object} [options]  Available options:
 *                            {boolean} applyOnChangedLevel
 *                                If true (default), the changed data is applied
 *                                as soon the cluster level changes. If false,
 *                                The changed data is applied immediately
 */


links.Timeline.ClusterGenerator.prototype.setData = function (items, options) {
  this.items = items || [];
  this.dataChanged = true;
  this.applyOnChangedLevel = true;

  if (options && options.applyOnChangedLevel) {
    this.applyOnChangedLevel = options.applyOnChangedLevel;
  } // console.log('clustergenerator setData applyOnChangedLevel=' + this.applyOnChangedLevel); // TODO: cleanup

};
/**
 * Update the current data set: clear cache, and recalculate the clustering for
 * the current level
 */


links.Timeline.ClusterGenerator.prototype.updateData = function () {
  this.dataChanged = true;
  this.applyOnChangedLevel = false;
};
/**
 * Filter the items per group.
 * @private
 */


links.Timeline.ClusterGenerator.prototype.filterData = function () {
  // filter per group
  var items = this.items || [];
  var groups = {};
  this.groups = groups; // split the items per group

  items.forEach(function (item) {
    // put the item in the correct group
    var groupName = item.group ? item.group.content : '';
    var group = groups[groupName];

    if (!group) {
      group = [];
      groups[groupName] = group;
    }

    group.push(item); // calculate the center of the item

    if (item.start) {
      if (item.end) {
        // range
        item.center = (item.start.valueOf() + item.end.valueOf()) / 2;
      } else {
        // box, dot
        item.center = item.start.valueOf();
      }
    }
  }); // sort the items per group

  for (var groupName in groups) {
    if (groups.hasOwnProperty(groupName)) {
      groups[groupName].sort(function (a, b) {
        return a.center - b.center;
      });
    }
  }

  this.dataChanged = false;
};
/**
 * Cluster the events which are too close together
 * @param {Number} scale     The scale of the current window,
 *                           defined as (windowWidth / (endDate - startDate))
 * @return {Item[]} clusters
 */


links.Timeline.ClusterGenerator.prototype.getClusters = function (scale, maxItems) {
  var level = -1,
      granularity = 2,
      // TODO: what granularity is needed for the cluster levels?
  timeWindow = 0; // milliseconds

  if (scale > 0) {
    level = Math.round(Math.log(100 / scale) / Math.log(granularity));
    timeWindow = Math.pow(granularity, level);
  } // clear the cache when and re-filter the data when needed.


  if (this.dataChanged) {
    var levelChanged = level != this.cacheLevel;
    var applyDataNow = this.applyOnChangedLevel ? levelChanged : true;

    if (applyDataNow) {
      // TODO: currently drawn clusters should be removed! mark them as invisible?
      this.clearCache();
      this.filterData(); // console.log('clustergenerator: cache cleared...'); // TODO: cleanup
    }
  }

  this.cacheLevel = level;
  var clusters = this.cache[level];

  if (!clusters) {
    // console.log('clustergenerator: create cluster level ' + level); // TODO: cleanup
    clusters = []; // TODO: spit this method, it is too large

    for (var groupName in this.groups) {
      if (this.groups.hasOwnProperty(groupName)) {
        var items = this.groups[groupName];
        var iMax = items.length;
        var i = 0;

        while (i < iMax) {
          // find all items around current item, within the timeWindow
          var item = items[i];
          var neighbors = 1; // start at 1, to include itself)
          // loop through items left from the current item

          var j = i - 1;

          while (j >= 0 && item.center - items[j].center < timeWindow / 2) {
            if (!items[j].cluster) {
              neighbors++;
            }

            j--;
          } // loop through items right from the current item


          var k = i + 1;

          while (k < items.length && items[k].center - item.center < timeWindow / 2) {
            neighbors++;
            k++;
          } // loop through the created clusters


          var l = clusters.length - 1;

          while (l >= 0 && item.center - clusters[l].center < timeWindow / 2) {
            if (item.group == clusters[l].group) {
              neighbors++;
            }

            l--;
          } // aggregate until the number of items is within maxItems


          if (neighbors > maxItems) {
            // too busy in this window.
            var num = neighbors - maxItems + 1;
            var clusterItems = []; // append the items to the cluster,
            // and calculate the average start for the cluster

            var avg = undefined; // number. average of all start dates

            var min = undefined; // number. minimum of all start dates

            var max = undefined; // number. maximum of all start and end dates

            var containsRanges = false;
            var count = 0;
            var m = i;

            while (clusterItems.length < num && m < items.length) {
              var p = items[m];
              var start = p.start.valueOf();
              var end = p.end ? p.end.valueOf() : p.start.valueOf();
              clusterItems.push(p);

              if (count) {
                // calculate new average (use fractions to prevent overflow)
                avg = count / (count + 1) * avg + 1 / (count + 1) * p.center;
              } else {
                avg = p.center;
              }

              min = min != undefined ? Math.min(min, start) : start;
              max = max != undefined ? Math.max(max, end) : end;
              containsRanges = containsRanges || p instanceof links.Timeline.ItemRange || p instanceof links.Timeline.ItemFloatingRange;
              count++;
              m++;
            }

            var cluster;
            var title = 'Cluster containing ' + count + ' events. Zoom in to see the individual events.';
            var content = '<div title="' + title + '" data-cluster-index="' + clusters.length + '" class="timeline-cluster">' + count + ' events</div>';
            var group = item.group ? item.group.content : undefined;

            if (containsRanges) {
              // boxes and/or ranges
              cluster = this.timeline.createItem({
                'start': new Date(min),
                'end': new Date(max),
                'content': content,
                'group': group
              });
            } else {
              // boxes only
              cluster = this.timeline.createItem({
                'start': new Date(avg),
                'content': content,
                'group': group
              });
            }

            cluster.isCluster = true;
            cluster.items = clusterItems;
            cluster.items.forEach(function (item) {
              item.cluster = cluster;
            });
            clusters.push(cluster);
            i += num;
          } else {
            delete item.cluster;
            i += 1;
          }
        }
      }
    }

    this.cache[level] = clusters;
  }

  return clusters;
};
/** ------------------------------------------------------------------------ **/

/**
 * Event listener (singleton)
 */


links.events = links.events || {
  'listeners': [],

  /**
   * Find a single listener by its object
   * @param {Object} object
   * @return {Number} index  -1 when not found
   */
  'indexOf': function indexOf(object) {
    var listeners = this.listeners;

    for (var i = 0, iMax = this.listeners.length; i < iMax; i++) {
      var listener = listeners[i];

      if (listener && listener.object == object) {
        return i;
      }
    }

    return -1;
  },

  /**
   * Add an event listener
   * @param {Object} object
   * @param {String} event       The name of an event, for example 'select'
   * @param {function} callback  The callback method, called when the
   *                             event takes place
   */
  'addListener': function addListener(object, event, callback) {
    var index = this.indexOf(object);
    var listener = this.listeners[index];

    if (!listener) {
      listener = {
        'object': object,
        'events': {}
      };
      this.listeners.push(listener);
    }

    var callbacks = listener.events[event];

    if (!callbacks) {
      callbacks = [];
      listener.events[event] = callbacks;
    } // add the callback if it does not yet exist


    if (callbacks.indexOf(callback) == -1) {
      callbacks.push(callback);
    }
  },

  /**
   * Remove an event listener
   * @param {Object} object
   * @param {String} event       The name of an event, for example 'select'
   * @param {function} callback  The registered callback method
   */
  'removeListener': function removeListener(object, event, callback) {
    var index = this.indexOf(object);
    var listener = this.listeners[index];

    if (listener) {
      var callbacks = listener.events[event];

      if (callbacks) {
        var index = callbacks.indexOf(callback);

        if (index != -1) {
          callbacks.splice(index, 1);
        } // remove the array when empty


        if (callbacks.length == 0) {
          delete listener.events[event];
        }
      } // count the number of registered events. remove listener when empty


      var count = 0;
      var events = listener.events;

      for (var e in events) {
        if (events.hasOwnProperty(e)) {
          count++;
        }
      }

      if (count == 0) {
        delete this.listeners[index];
      }
    }
  },

  /**
   * Remove all registered event listeners
   */
  'removeAllListeners': function removeAllListeners() {
    this.listeners = [];
  },

  /**
   * Trigger an event. All registered event handlers will be called
   * @param {Object} object
   * @param {String} event
   * @param {Object} properties (optional)
   */
  'trigger': function trigger(object, event, properties) {
    var index = this.indexOf(object);
    var listener = this.listeners[index];

    if (listener) {
      var callbacks = listener.events[event];

      if (callbacks) {
        for (var i = 0, iMax = callbacks.length; i < iMax; i++) {
          callbacks[i](properties);
        }
      }
    }
  }
};
/** ------------------------------------------------------------------------ **/

/**
 * @constructor  links.Timeline.StepDate
 * The class StepDate is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing start(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function end(). After each step, you can
 * retrieve the current date via get().
 * The class step has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 * @param {Date} start          The start date, for example new Date(2010, 9, 21)
 *                              or new Date(2010, 9, 21, 23, 45, 00)
 * @param {Date} end            The end date
 * @param {Number}  minimumStep Optional. Minimum step size in milliseconds
 */

links.Timeline.StepDate = function (start, end, minimumStep) {
  // variables
  this.current = new Date();
  this._start = new Date();
  this._end = new Date();
  this.autoScale = true;
  this.scale = links.Timeline.StepDate.SCALE.DAY;
  this.step = 1; // initialize the range

  this.setRange(start, end, minimumStep);
}; /// enum scale


links.Timeline.StepDate.SCALE = {
  MILLISECOND: 1,
  SECOND: 2,
  MINUTE: 3,
  HOUR: 4,
  DAY: 5,
  WEEKDAY: 6,
  MONTH: 7,
  YEAR: 8
};
/**
 * Set a new range
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 * @param {Date} start        The start date and time.
 * @param {Date} end          The end date and time.
 * @param {int}  minimumStep  Optional. Minimum step size in milliseconds
 */

links.Timeline.StepDate.prototype.setRange = function (start, end, minimumStep) {
  if (!(start instanceof Date) || !(end instanceof Date)) {
    //throw  "No legal start or end date in method setRange";
    return;
  }

  this._start = start != undefined ? new Date(start.valueOf()) : new Date();
  this._end = end != undefined ? new Date(end.valueOf()) : new Date();

  if (this.autoScale) {
    this.setMinimumStep(minimumStep);
  }
};
/**
 * Set the step iterator to the start date.
 */


links.Timeline.StepDate.prototype.start = function () {
  this.current = new Date(this._start.valueOf());
  this.roundToMinor();
};
/**
 * Round the current date to the first minor date value
 * This must be executed once when the current date is set to start Date
 */


links.Timeline.StepDate.prototype.roundToMinor = function () {
  // round to floor
  // IMPORTANT: we have no breaks in this switch! (this is no bug)
  //noinspection FallthroughInSwitchStatementJS
  switch (this.scale) {
    case links.Timeline.StepDate.SCALE.YEAR:
      this.current.setFullYear(this.step * Math.floor(this.current.getFullYear() / this.step));
      this.current.setMonth(0);

    case links.Timeline.StepDate.SCALE.MONTH:
      this.current.setDate(1);

    case links.Timeline.StepDate.SCALE.DAY: // intentional fall through

    case links.Timeline.StepDate.SCALE.WEEKDAY:
      this.current.setHours(0);

    case links.Timeline.StepDate.SCALE.HOUR:
      this.current.setMinutes(0);

    case links.Timeline.StepDate.SCALE.MINUTE:
      this.current.setSeconds(0);

    case links.Timeline.StepDate.SCALE.SECOND:
      this.current.setMilliseconds(0);
    //case links.Timeline.StepDate.SCALE.MILLISECOND: // nothing to do for milliseconds
  }

  if (this.step != 1) {
    // round down to the first minor value that is a multiple of the current step size
    switch (this.scale) {
      case links.Timeline.StepDate.SCALE.MILLISECOND:
        this.current.setMilliseconds(this.current.getMilliseconds() - this.current.getMilliseconds() % this.step);
        break;

      case links.Timeline.StepDate.SCALE.SECOND:
        this.current.setSeconds(this.current.getSeconds() - this.current.getSeconds() % this.step);
        break;

      case links.Timeline.StepDate.SCALE.MINUTE:
        this.current.setMinutes(this.current.getMinutes() - this.current.getMinutes() % this.step);
        break;

      case links.Timeline.StepDate.SCALE.HOUR:
        this.current.setHours(this.current.getHours() - this.current.getHours() % this.step);
        break;

      case links.Timeline.StepDate.SCALE.WEEKDAY: // intentional fall through

      case links.Timeline.StepDate.SCALE.DAY:
        this.current.setDate(this.current.getDate() - 1 - (this.current.getDate() - 1) % this.step + 1);
        break;

      case links.Timeline.StepDate.SCALE.MONTH:
        this.current.setMonth(this.current.getMonth() - this.current.getMonth() % this.step);
        break;

      case links.Timeline.StepDate.SCALE.YEAR:
        this.current.setFullYear(this.current.getFullYear() - this.current.getFullYear() % this.step);
        break;
    }
  }
};
/**
 * Check if the end date is reached
 * @return {boolean}  true if the current date has passed the end date
 */


links.Timeline.StepDate.prototype.end = function () {
  return this.current.valueOf() > this._end.valueOf();
};
/**
 * Do the next step
 */


links.Timeline.StepDate.prototype.next = function () {
  var prev = this.current.valueOf(); // Two cases, needed to prevent issues with switching daylight savings
  // (end of March and end of October)

  if (this.current.getMonth() < 6) {
    switch (this.scale) {
      case links.Timeline.StepDate.SCALE.MILLISECOND:
        this.current = new Date(this.current.valueOf() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.SECOND:
        this.current = new Date(this.current.valueOf() + this.step * 1000);
        break;

      case links.Timeline.StepDate.SCALE.MINUTE:
        this.current = new Date(this.current.valueOf() + this.step * 1000 * 60);
        break;

      case links.Timeline.StepDate.SCALE.HOUR:
        this.current = new Date(this.current.valueOf() + this.step * 1000 * 60 * 60); // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)

        var h = this.current.getHours();
        this.current.setHours(h - h % this.step);
        break;

      case links.Timeline.StepDate.SCALE.WEEKDAY: // intentional fall through

      case links.Timeline.StepDate.SCALE.DAY:
        this.current.setDate(this.current.getDate() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.MONTH:
        this.current.setMonth(this.current.getMonth() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.YEAR:
        this.current.setFullYear(this.current.getFullYear() + this.step);
        break;
    }
  } else {
    switch (this.scale) {
      case links.Timeline.StepDate.SCALE.MILLISECOND:
        this.current = new Date(this.current.valueOf() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.SECOND:
        this.current.setSeconds(this.current.getSeconds() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.MINUTE:
        this.current.setMinutes(this.current.getMinutes() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.HOUR:
        this.current.setHours(this.current.getHours() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.WEEKDAY: // intentional fall through

      case links.Timeline.StepDate.SCALE.DAY:
        this.current.setDate(this.current.getDate() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.MONTH:
        this.current.setMonth(this.current.getMonth() + this.step);
        break;

      case links.Timeline.StepDate.SCALE.YEAR:
        this.current.setFullYear(this.current.getFullYear() + this.step);
        break;
    }
  }

  if (this.step != 1) {
    // round down to the correct major value
    switch (this.scale) {
      case links.Timeline.StepDate.SCALE.MILLISECOND:
        if (this.current.getMilliseconds() < this.step) this.current.setMilliseconds(0);
        break;

      case links.Timeline.StepDate.SCALE.SECOND:
        if (this.current.getSeconds() < this.step) this.current.setSeconds(0);
        break;

      case links.Timeline.StepDate.SCALE.MINUTE:
        if (this.current.getMinutes() < this.step) this.current.setMinutes(0);
        break;

      case links.Timeline.StepDate.SCALE.HOUR:
        if (this.current.getHours() < this.step) this.current.setHours(0);
        break;

      case links.Timeline.StepDate.SCALE.WEEKDAY: // intentional fall through

      case links.Timeline.StepDate.SCALE.DAY:
        if (this.current.getDate() < this.step + 1) this.current.setDate(1);
        break;

      case links.Timeline.StepDate.SCALE.MONTH:
        if (this.current.getMonth() < this.step) this.current.setMonth(0);
        break;

      case links.Timeline.StepDate.SCALE.YEAR:
        break;
    }
  } // safety mechanism: if current time is still unchanged, move to the end


  if (this.current.valueOf() == prev) {
    this.current = new Date(this._end.valueOf());
  }
};
/**
 * Get the current datetime
 * @return {Date}  current The current date
 */


links.Timeline.StepDate.prototype.getCurrent = function () {
  return this.current;
};
/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale(SCALE.MINUTES, 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {links.Timeline.StepDate.SCALE} newScale
 *                               A scale. Choose from SCALE.MILLISECOND,
 *                               SCALE.SECOND, SCALE.MINUTE, SCALE.HOUR,
 *                               SCALE.WEEKDAY, SCALE.DAY, SCALE.MONTH,
 *                               SCALE.YEAR.
 * @param {Number}     newStep   A step size, by default 1. Choose for
 *                               example 1, 2, 5, or 10.
 */


links.Timeline.StepDate.prototype.setScale = function (newScale, newStep) {
  this.scale = newScale;

  if (newStep > 0) {
    this.step = newStep;
  }

  this.autoScale = false;
};
/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true, autoascaling is set true
 */


links.Timeline.StepDate.prototype.setAutoScale = function (enable) {
  this.autoScale = enable;
};
/**
 * Automatically determine the scale that bests fits the provided minimum step
 * @param {Number} minimumStep  The minimum step size in milliseconds
 */


links.Timeline.StepDate.prototype.setMinimumStep = function (minimumStep) {
  if (minimumStep == undefined) {
    return;
  }

  var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
  var stepMonth = 1000 * 60 * 60 * 24 * 30;
  var stepDay = 1000 * 60 * 60 * 24;
  var stepHour = 1000 * 60 * 60;
  var stepMinute = 1000 * 60;
  var stepSecond = 1000;
  var stepMillisecond = 1; // find the smallest step that is larger than the provided minimumStep

  if (stepYear * 1000 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.YEAR;
    this.step = 1000;
  }

  if (stepYear * 500 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.YEAR;
    this.step = 500;
  }

  if (stepYear * 100 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.YEAR;
    this.step = 100;
  }

  if (stepYear * 50 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.YEAR;
    this.step = 50;
  }

  if (stepYear * 10 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.YEAR;
    this.step = 10;
  }

  if (stepYear * 5 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.YEAR;
    this.step = 5;
  }

  if (stepYear > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.YEAR;
    this.step = 1;
  }

  if (stepMonth * 3 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MONTH;
    this.step = 3;
  }

  if (stepMonth > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MONTH;
    this.step = 1;
  }

  if (stepDay * 5 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.DAY;
    this.step = 5;
  }

  if (stepDay * 2 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.DAY;
    this.step = 2;
  }

  if (stepDay > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.DAY;
    this.step = 1;
  }

  if (stepDay / 2 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.WEEKDAY;
    this.step = 1;
  }

  if (stepHour * 4 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.HOUR;
    this.step = 4;
  }

  if (stepHour > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.HOUR;
    this.step = 1;
  }

  if (stepMinute * 15 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MINUTE;
    this.step = 15;
  }

  if (stepMinute * 10 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MINUTE;
    this.step = 10;
  }

  if (stepMinute * 5 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MINUTE;
    this.step = 5;
  }

  if (stepMinute > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MINUTE;
    this.step = 1;
  }

  if (stepSecond * 15 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.SECOND;
    this.step = 15;
  }

  if (stepSecond * 10 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.SECOND;
    this.step = 10;
  }

  if (stepSecond * 5 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.SECOND;
    this.step = 5;
  }

  if (stepSecond > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.SECOND;
    this.step = 1;
  }

  if (stepMillisecond * 200 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MILLISECOND;
    this.step = 200;
  }

  if (stepMillisecond * 100 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MILLISECOND;
    this.step = 100;
  }

  if (stepMillisecond * 50 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MILLISECOND;
    this.step = 50;
  }

  if (stepMillisecond * 10 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MILLISECOND;
    this.step = 10;
  }

  if (stepMillisecond * 5 > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MILLISECOND;
    this.step = 5;
  }

  if (stepMillisecond > minimumStep) {
    this.scale = links.Timeline.StepDate.SCALE.MILLISECOND;
    this.step = 1;
  }
};
/**
 * Snap a date to a rounded value. The snap intervals are dependent on the
 * current scale and step.
 * @param {Date} date   the date to be snapped
 */


links.Timeline.StepDate.prototype.snap = function (date) {
  if (this.scale == links.Timeline.StepDate.SCALE.YEAR) {
    var year = date.getFullYear() + Math.round(date.getMonth() / 12);
    date.setFullYear(Math.round(year / this.step) * this.step);
    date.setMonth(0);
    date.setDate(0);
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
  } else if (this.scale == links.Timeline.StepDate.SCALE.MONTH) {
    if (date.getDate() > 15) {
      date.setDate(1);
      date.setMonth(date.getMonth() + 1); // important: first set Date to 1, after that change the month.
    } else {
      date.setDate(1);
    }

    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
  } else if (this.scale == links.Timeline.StepDate.SCALE.DAY || this.scale == links.Timeline.StepDate.SCALE.WEEKDAY) {
    switch (this.step) {
      case 5:
      case 2:
        date.setHours(Math.round(date.getHours() / 24) * 24);
        break;

      default:
        date.setHours(Math.round(date.getHours() / 12) * 12);
        break;
    }

    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
  } else if (this.scale == links.Timeline.StepDate.SCALE.HOUR) {
    switch (this.step) {
      case 4:
        date.setMinutes(Math.round(date.getMinutes() / 60) * 60);
        break;

      default:
        date.setMinutes(Math.round(date.getMinutes() / 30) * 30);
        break;
    }

    date.setSeconds(0);
    date.setMilliseconds(0);
  } else if (this.scale == links.Timeline.StepDate.SCALE.MINUTE) {
    switch (this.step) {
      case 15:
      case 10:
        date.setMinutes(Math.round(date.getMinutes() / 5) * 5);
        date.setSeconds(0);
        break;

      case 5:
        date.setSeconds(Math.round(date.getSeconds() / 60) * 60);
        break;

      default:
        date.setSeconds(Math.round(date.getSeconds() / 30) * 30);
        break;
    }

    date.setMilliseconds(0);
  } else if (this.scale == links.Timeline.StepDate.SCALE.SECOND) {
    switch (this.step) {
      case 15:
      case 10:
        date.setSeconds(Math.round(date.getSeconds() / 5) * 5);
        date.setMilliseconds(0);
        break;

      case 5:
        date.setMilliseconds(Math.round(date.getMilliseconds() / 1000) * 1000);
        break;

      default:
        date.setMilliseconds(Math.round(date.getMilliseconds() / 500) * 500);
        break;
    }
  } else if (this.scale == links.Timeline.StepDate.SCALE.MILLISECOND) {
    var step = this.step > 5 ? this.step / 2 : 1;
    date.setMilliseconds(Math.round(date.getMilliseconds() / step) * step);
  }
};
/**
 * Check if the current step is a major step (for example when the step
 * is DAY, a major step is each first day of the MONTH)
 * @return {boolean} true if current date is major, else false.
 */


links.Timeline.StepDate.prototype.isMajor = function () {
  switch (this.scale) {
    case links.Timeline.StepDate.SCALE.MILLISECOND:
      return this.current.getMilliseconds() == 0;

    case links.Timeline.StepDate.SCALE.SECOND:
      return this.current.getSeconds() == 0;

    case links.Timeline.StepDate.SCALE.MINUTE:
      return this.current.getHours() == 0 && this.current.getMinutes() == 0;
    // Note: this is no bug. Major label is equal for both minute and hour scale

    case links.Timeline.StepDate.SCALE.HOUR:
      return this.current.getHours() == 0;

    case links.Timeline.StepDate.SCALE.WEEKDAY: // intentional fall through

    case links.Timeline.StepDate.SCALE.DAY:
      return this.current.getDate() == 1;

    case links.Timeline.StepDate.SCALE.MONTH:
      return this.current.getMonth() == 0;

    case links.Timeline.StepDate.SCALE.YEAR:
      return false;

    default:
      return false;
  }
};
/**
 * Returns formatted text for the minor axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the current time is
 * formatted as "hh:mm".
 * @param {Object} options
 * @param {Date} [date] custom date. if not provided, current date is taken
 */


links.Timeline.StepDate.prototype.getLabelMinor = function (options, date) {
  if (date == undefined) {
    date = this.current;
  }

  switch (this.scale) {
    case links.Timeline.StepDate.SCALE.MILLISECOND:
      return String(date.getMilliseconds());

    case links.Timeline.StepDate.SCALE.SECOND:
      return String(date.getSeconds());

    case links.Timeline.StepDate.SCALE.MINUTE:
      return this.addZeros(date.getHours(), 2) + ":" + this.addZeros(date.getMinutes(), 2);

    case links.Timeline.StepDate.SCALE.HOUR:
      return this.addZeros(date.getHours(), 2) + ":" + this.addZeros(date.getMinutes(), 2);

    case links.Timeline.StepDate.SCALE.WEEKDAY:
      return options.DAYS_SHORT[date.getDay()] + ' ' + date.getDate();

    case links.Timeline.StepDate.SCALE.DAY:
      return String(date.getDate());

    case links.Timeline.StepDate.SCALE.MONTH:
      return options.MONTHS_SHORT[date.getMonth()];
    // month is zero based

    case links.Timeline.StepDate.SCALE.YEAR:
      return String(date.getFullYear());

    default:
      return "";
  }
};
/**
 * Returns formatted text for the major axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the major scale is
 * hours, and the hour will be formatted as "hh".
 * @param {Object} options
 * @param {Date} [date] custom date. if not provided, current date is taken
 */


links.Timeline.StepDate.prototype.getLabelMajor = function (options, date) {
  if (date == undefined) {
    date = this.current;
  }

  switch (this.scale) {
    case links.Timeline.StepDate.SCALE.MILLISECOND:
      return this.addZeros(date.getHours(), 2) + ":" + this.addZeros(date.getMinutes(), 2) + ":" + this.addZeros(date.getSeconds(), 2);

    case links.Timeline.StepDate.SCALE.SECOND:
      return date.getDate() + " " + options.MONTHS[date.getMonth()] + " " + this.addZeros(date.getHours(), 2) + ":" + this.addZeros(date.getMinutes(), 2);

    case links.Timeline.StepDate.SCALE.MINUTE:
      return options.DAYS[date.getDay()] + " " + date.getDate() + " " + options.MONTHS[date.getMonth()] + " " + date.getFullYear();

    case links.Timeline.StepDate.SCALE.HOUR:
      return options.DAYS[date.getDay()] + " " + date.getDate() + " " + options.MONTHS[date.getMonth()] + " " + date.getFullYear();

    case links.Timeline.StepDate.SCALE.WEEKDAY:
    case links.Timeline.StepDate.SCALE.DAY:
      return options.MONTHS[date.getMonth()] + " " + date.getFullYear();

    case links.Timeline.StepDate.SCALE.MONTH:
      return String(date.getFullYear());

    default:
      return "";
  }
};
/**
 * Add leading zeros to the given value to match the desired length.
 * For example addZeros(123, 5) returns "00123"
 * @param {int} value   A value
 * @param {int} len     Desired final length
 * @return {string}     value with leading zeros
 */


links.Timeline.StepDate.prototype.addZeros = function (value, len) {
  var str = "" + value;

  while (str.length < len) {
    str = "0" + str;
  }

  return str;
};
/** ------------------------------------------------------------------------ **/

/**
 * Image Loader service.
 * can be used to get a callback when a certain image is loaded
 *
 */


links.imageloader = function () {
  var urls = {}; // the loaded urls

  var callbacks = {}; // the urls currently being loaded. Each key contains
  // an array with callbacks

  /**
   * Check if an image url is loaded
   * @param {String} url
   * @return {boolean} loaded   True when loaded, false when not loaded
   *                            or when being loaded
   */

  function isLoaded(url) {
    if (urls[url] == true) {
      return true;
    }

    var image = new Image();
    image.src = url;

    if (image.complete) {
      return true;
    }

    return false;
  }
  /**
   * Check if an image url is being loaded
   * @param {String} url
   * @return {boolean} loading   True when being loaded, false when not loading
   *                             or when already loaded
   */


  function isLoading(url) {
    return callbacks[url] != undefined;
  }
  /**
   * Load given image url
   * @param {String} url
   * @param {function} callback
   * @param {boolean} sendCallbackWhenAlreadyLoaded  optional
   */


  function load(url, callback, sendCallbackWhenAlreadyLoaded) {
    if (sendCallbackWhenAlreadyLoaded == undefined) {
      sendCallbackWhenAlreadyLoaded = true;
    }

    if (isLoaded(url)) {
      if (sendCallbackWhenAlreadyLoaded) {
        callback(url);
      }

      return;
    }

    if (isLoading(url) && !sendCallbackWhenAlreadyLoaded) {
      return;
    }

    var c = callbacks[url];

    if (!c) {
      var image = new Image();
      image.src = url;
      c = [];
      callbacks[url] = c;

      image.onload = function (event) {
        urls[url] = true;
        delete callbacks[url];

        for (var i = 0; i < c.length; i++) {
          c[i](url);
        }
      };
    }

    if (c.indexOf(callback) == -1) {
      c.push(callback);
    }
  }
  /**
   * Load a set of images, and send a callback as soon as all images are
   * loaded
   * @param {String[]} urls
   * @param {function } callback
   * @param {boolean} sendCallbackWhenAlreadyLoaded
   */


  function loadAll(urls, callback, sendCallbackWhenAlreadyLoaded) {
    // list all urls which are not yet loaded
    var urlsLeft = [];
    urls.forEach(function (url) {
      if (!isLoaded(url)) {
        urlsLeft.push(url);
      }
    });

    if (urlsLeft.length) {
      // there are unloaded images
      var countLeft = urlsLeft.length;
      urlsLeft.forEach(function (url) {
        load(url, function () {
          countLeft--;

          if (countLeft == 0) {
            // done!
            callback();
          }
        }, sendCallbackWhenAlreadyLoaded);
      });
    } else {
      // we are already done!
      if (sendCallbackWhenAlreadyLoaded) {
        callback();
      }
    }
  }
  /**
   * Recursively retrieve all image urls from the images located inside a given
   * HTML element
   * @param {Node} elem
   * @param {String[]} urls   Urls will be added here (no duplicates)
   */


  function filterImageUrls(elem, urls) {
    var child = elem.firstChild;

    while (child) {
      if (child.tagName == 'IMG') {
        var url = child.src;

        if (urls.indexOf(url) == -1) {
          urls.push(url);
        }
      }

      filterImageUrls(child, urls);
      child = child.nextSibling;
    }
  }

  return {
    'isLoaded': isLoaded,
    'isLoading': isLoading,
    'load': load,
    'loadAll': loadAll,
    'filterImageUrls': filterImageUrls
  };
}();
/** ------------------------------------------------------------------------ **/

/**
 * Add and event listener. Works for all browsers
 * @param {Element} element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     useCapture
 */


links.Timeline.addEventListener = function (element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent("on" + action, listener); // IE browsers
  }
};
/**
 * Remove an event listener from an element
 * @param {Element}  element   An html dom element
 * @param {string}       action    The name of the event, for example "mousedown"
 * @param {function}     listener  The listener function
 * @param {boolean}      useCapture
 */


links.Timeline.removeEventListener = function (element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // IE browsers
    element.detachEvent("on" + action, listener);
  }
};
/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */


links.Timeline.getTarget = function (event) {
  // code from http://www.quirksmode.org/js/events_properties.html
  if (!event) {
    event = window.event;
  }

  var target;

  if (event.target) {
    target = event.target;
  } else if (event.srcElement) {
    target = event.srcElement;
  }

  if (target.nodeType != undefined && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;
  }

  return target;
};
/**
 * Stop event propagation
 */


links.Timeline.stopPropagation = function (event) {
  if (!event) event = window.event;

  if (event.stopPropagation) {
    event.stopPropagation(); // non-IE browsers
  } else {
    event.cancelBubble = true; // IE browsers
  }
};
/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 */


links.Timeline.preventDefault = function (event) {
  if (!event) event = window.event;

  if (event.preventDefault) {
    event.preventDefault(); // non-IE browsers
  } else {
    event.returnValue = false; // IE browsers
  }
};
/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */


links.Timeline.getAbsoluteLeft = function (elem) {
  var doc = document.documentElement;
  var body = document.body;
  var left = elem.offsetLeft;
  var e = elem.offsetParent;

  while (e != null && e != body && e != doc) {
    left += e.offsetLeft;
    left -= e.scrollLeft;
    e = e.offsetParent;
  }

  return left;
};
/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */


links.Timeline.getAbsoluteTop = function (elem) {
  var doc = document.documentElement;
  var body = document.body;
  var top = elem.offsetTop;
  var e = elem.offsetParent;

  while (e != null && e != body && e != doc) {
    top += e.offsetTop;
    top -= e.scrollTop;
    e = e.offsetParent;
  }

  return top;
};
/**
 * Get the absolute, vertical mouse position from an event.
 * @param {Event} event
 * @return {Number} pageY
 */


links.Timeline.getPageY = function (event) {
  if ('targetTouches' in event && event.targetTouches.length) {
    event = event.targetTouches[0];
  }

  if ('pageY' in event) {
    return event.pageY;
  } // calculate pageY from clientY


  var clientY = event.clientY;
  var doc = document.documentElement;
  var body = document.body;
  return clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
};
/**
 * Get the absolute, horizontal mouse position from an event.
 * @param {Event} event
 * @return {Number} pageX
 */


links.Timeline.getPageX = function (event) {
  if ('targetTouches' in event && event.targetTouches.length) {
    event = event.targetTouches[0];
  }

  if ('pageX' in event) {
    return event.pageX;
  } // calculate pageX from clientX


  var clientX = event.clientX;
  var doc = document.documentElement;
  var body = document.body;
  return clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
};
/**
 * Adds one or more className's to the given elements style
 * @param {Element} elem
 * @param {String} className
 */


links.Timeline.addClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  var classesToAdd = className.split(' ');
  var added = false;

  for (var i = 0; i < classesToAdd.length; i++) {
    if (classes.indexOf(classesToAdd[i]) == -1) {
      classes.push(classesToAdd[i]); // add the class to the array

      added = true;
    }
  }

  if (added) {
    elem.className = classes.join(' ');
  }
};
/**
 * Removes one or more className's from the given elements style
 * @param {Element} elem
 * @param {String} className
 */


links.Timeline.removeClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  var classesToRemove = className.split(' ');
  var removed = false;

  for (var i = 0; i < classesToRemove.length; i++) {
    var index = classes.indexOf(classesToRemove[i]);

    if (index != -1) {
      classes.splice(index, 1); // remove the class from the array

      removed = true;
    }
  }

  if (removed) {
    elem.className = classes.join(' ');
  }
};
/**
 * Check if given object is a Javascript Array
 * @param {*} obj
 * @return {Boolean} isArray    true if the given object is an array
 */
// See http://stackoverflow.com/questions/2943805/javascript-instanceof-typeof-in-gwt-jsni


links.Timeline.isArray = function (obj) {
  if (obj instanceof Array) {
    return true;
  }

  return Object.prototype.toString.call(obj) === '[object Array]';
};
/**
 * Shallow clone an object
 * @param {Object} object
 * @return {Object} clone
 */


links.Timeline.clone = function (object) {
  var clone = {};

  for (var prop in object) {
    if (object.hasOwnProperty(prop)) {
      clone[prop] = object[prop];
    }
  }

  return clone;
};
/**
 * parse a JSON date
 * @param {Date | String | Number} date    Date object to be parsed. Can be:
 *                                         - a Date object like new Date(),
 *                                         - a long like 1356970529389,
 *                                         an ISO String like "2012-12-31T16:16:07.213Z",
 *                                         or a .Net Date string like
 *                                         "\/Date(1356970529389)\/"
 * @return {Date} parsedDate
 */


links.Timeline.parseJSONDate = function (date) {
  if (date == undefined) {
    return undefined;
  } //test for date


  if (date instanceof Date) {
    return date;
  } // test for MS format.
  // FIXME: will fail on a Number


  var m = date.match(/\/Date\((-?\d+)([-\+]?\d{2})?(\d{2})?\)\//i);

  if (m) {
    var offset = m[2] ? 3600000 * m[2] + // hrs offset
    60000 * m[3] * (m[2] / Math.abs(m[2])) // mins offset
    : 0;
    return new Date(1 * m[1] + // ticks
    offset);
  } // failing that, try to parse whatever we've got.


  return Date.parse(date);
}; // timeline-locales.js
// Russian ===================================================


links.locales = {
  'ru': {
    'MONTHS': ["Ð¯Ð½Ð²Ð°ÑÑ", "Ð¤ÐµÐ²ÑÐ°Ð»Ñ", "ÐÐ°ÑÑ", "ÐÐ¿ÑÐµÐ»Ñ", "ÐÐ°Ð¹", "ÐÑÐ½Ñ", "ÐÑÐ»Ñ", "ÐÐ²Ð³ÑÑÑ", "Ð¡ÐµÐ½ÑÑÐ±ÑÑ", "ÐÐºÑÑÐ±ÑÑ", "ÐÐ¾ÑÐ±ÑÑ", "ÐÐµÐºÐ°Ð±ÑÑ"],
    'MONTHS_SHORT': ["Ð¯Ð½Ð²", "Ð¤ÐµÐ²", "ÐÐ°Ñ", "ÐÐ¿Ñ", "ÐÐ°Ð¹", "ÐÑÐ½", "ÐÑÐ»", "ÐÐ²Ð³", "Ð¡ÐµÐ½", "ÐÐºÑ", "ÐÐ¾Ñ", "ÐÐµÐº"],
    'DAYS': ["ÐÐ¾ÑÐºÑÐµÑÐµÐ½ÑÐµ", "ÐÐ¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº", "ÐÑÐ¾ÑÐ½Ð¸Ðº", "Ð¡ÑÐµÐ´Ð°", "Ð§ÐµÑÐ²ÐµÑÐ³", "ÐÑÑÐ½Ð¸ÑÐ°", "Ð¡ÑÐ±Ð±Ð¾ÑÐ°"],
    'DAYS_SHORT': ["ÐÐ¾Ñ", "ÐÐ¾Ð½", "ÐÑo", "Ð¡Ñe", "Ð§ÐµÑ", "ÐÑÑ", "Ð¡ÑÐ±"],
    'ZOOM_IN': "Ð£Ð²eÐ»Ð¸ÑÐ¸ÑÑ",
    'ZOOM_OUT': "Ð£Ð¼eÐ½ÑÑÐ¸ÑÑ",
    'MOVE_LEFT': "Ð¡Ð´Ð²Ð¸Ð½ÑÑÑ Ð½Ð°Ð»eÐ²Ð¾",
    'MOVE_RIGHT': "Ð¡Ð´Ð²Ð¸Ð½ÑÑÑ Ð½Ð°Ð¿ÑÐ°Ð²Ð¾",
    'NEW': "ÐÐ¾Ð²ÑÐ¹",
    'CREATE_NEW_EVENT': "Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð½Ð¾Ð²Ð¾e ÑÐ¾Ð±ÑÑÐ¸e"
  }
};
links.locales['ru_RU'] = links.locales['ru'];
links.version = '2.9.1';

if (typeof L.gmx === 'undefined') {
  L.gmx = {};
}

L.gmx.timeline = links;

var translate$1 = T.getText.bind(T);
T.addText('rus', {
  DateInterval: {
    title: 'ÐÑÐ¸Ð±Ð»Ð¸Ð·ÑÑÐµ ÐºÐ°ÑÑÑ Ð´Ð»Ñ Ð·Ð°Ð³ÑÑÐ·ÐºÐ¸ Ð½Ð° ÑÐ°Ð¹Ð¼Ð»Ð°Ð¹Ð½'
  }
});

var _DAY = 60 * 60 * 24;

var DateInterval = L$1.Control.extend({
  includes: L$1.Evented.prototype,
  options: {
    position: 'bottom',
    id: 'DateInterval',
    minZoom: 9,
    className: 'DateInterval'
  },
  initialize: function initialize(options) {
    this._activeTab = null;
    this._layers = {};
    this.options = _objectSpread2(_objectSpread2({}, this.options), options);
  },
  onAdd: function onAdd(map) {
    var _this = this;

    this._map = map;
    this._container = L$1.DomUtil.create('div', 'scanex-date-interval');
    L$1.DomEvent.disableScrollPropagation(this._container);
    L$1.DomEvent.disableClickPropagation(this._container);
    this._tabs = L$1.DomUtil.create('div', 'buttons', this._container);
    this._timelineNode = L$1.DomUtil.create('div', 'timeline', this._container);
    this._icon = L$1.DomUtil.create('div', 'icon', this._container);
    this._icon.innerHTML = translate$1('DateInterval.title');
    this._timeline = new links.Timeline(this._timelineNode, {
      locale: 'ru',
      width: '100%',
      height: '80px',
      axisOnTop: true,
      selectable: true,
      layout: 'dot',
      scale: links.Timeline.StepDate.SCALE.DAY
    });

    if (this._interval) {
      this._timeline.setVisibleChartRange(this._interval[0], this._interval[1]);
    }

    links.events.addListener(this._timeline, 'select', this._clickOnTimeline.bind(this));
    links.events.addListener(this._timeline, 'rangechanged', this._reSetDateInterval.bind(this)); // const stop = L.DomEvent.stopPropagation;
    // const prevent = L.DomEvent.preventDefault;
    // L.DomEvent
    // .on(this._timelineNode, 'keyup', stop)
    // .on(this._timelineNode, 'keyup', prevent)
    // .on(this._timelineNode, 'keyup', this._keydown, this);

    var chkZoom = function chkZoom() {
      _this.toggle(map.getZoom() >= _this.options.minZoom);
    };

    map.on('zoomend', chkZoom, this);
    chkZoom();

    this._chkTabs();

    return this._container;
  },
  onRemove: function onRemove(map) {
    map.off('moveend', this._setBounds, this);
    var layer = this._layers[this._activeTab];

    if (layer) {
      map.removeLayer(layer);

      layer._observer.deactivate();
    }

    this._timeline = null;
  },
  _toggleActive: function _toggleActive(node, utm) {
    var classList = node.classList;
    var layer = this._layers[this._activeTab];

    if (classList.contains('active')) {
      classList.remove('active');
      layer._showDates[utm] = false;
    } else {
      classList.add('active');
      layer._showDates[utm] = true;
    }

    layer.repaint();
  },
  // _keydown: function (ev) {
  // const layer = this._layers[this._activeTab];
  // if (layer && ev.target.classList.contains('scanex-forestry-map')) {
  // L.DomEvent.stopPropagation(ev);
  // const key = ev.key;
  // const ctrlKey = ev.ctrlKey);
  // if (key === 'ArrowLeft' || key === 'Left') {
  // i = ctrlKey ? 0 : (i > 1 ? i - 2 : (rollClicked ? len : 0));
  // } else if (key === 'ArrowRight' || key === 'Right') {
  // i = ctrlKey ? len : (i < len ? i: (rollClicked ? 0 : len));
  // } else if (key === 's') {
  // i = i === 0 ? 0 : i - 1;
  // }
  // console('sss', this._timeline);
  // }
  // },
  _clickOnTimeline: function _clickOnTimeline(ev) {
    var layer = this._layers[this._activeTab];

    if (ev && ev.date && layer && layer._showDates) {
      this._toggleActive(ev.originalEvent.target, Math.floor(ev.date.getTime() / 1000));
    }
  },
  _reSetDateInterval: function _reSetDateInterval() {
    var layer = this._layers[this._activeTab];

    if (layer) {
      layer._gmx.rawProperties.maxShownPeriod = null;

      var range = this._timeline.getVisibleChartRange();

      layer.setDateInterval(range.start, range.end);

      layer._observer.setDateInterval(range.start, range.end);
    }
  },
  _setBounds: function _setBounds() {
    var layer = this._layers[this._activeTab];

    if (layer) {
      layer._observer.setBounds(this._map.getBounds());
    }
  },
  _addObserver: function _addObserver(layer) {
    var tm = this._timeline;
    layer._gmx.rawProperties.maxShownPeriod = null;
    layer.options.minZoom = this.options.minZoom;
    var lprops = layer.getGmxProperties();
    var hpDm = layer.getDataManager();
    var tmpKeyNum = hpDm.tileAttributeIndexes[lprops.TemporalColumnName];
    layer._gmx.tmpKeyNum = tmpKeyNum;
    layer._showDates = null;
    layer.addLayerFilter(function (prp) {
      if (layer._showDates) {
        var utm = _DAY * Math.floor(Number(prp.properties[tmpKeyNum]) / _DAY);

        return layer._showDates[utm];
      } else {
        return true;
      }
    });
    var observer = hpDm.addObserver({
      type: 'resend',
      filters: ['clipFilter', 'userFilter_timeline', 'styleFilter'],
      active: false,
      needBbox: true,
      layerID: lprops.name,
      itemHook: function itemHook(it) {
        if (!this.cache) {
          this.cache = {};
        }

        var arr = it.properties;

        if (this.intersectsWithGeometry(arr[arr.length - 1])) {
          var utm = _DAY * Math.floor(Number(arr[tmpKeyNum]) / _DAY);

          this.cache[utm] = 1 + (this.cache[utm] || 0);
        }
      },
      callback: function callback() {
        var out = this.cache || {};
        this.cache = {};
        var maxUtm = 0;
        var data = Object.keys(out).map(function (tStamp) {
          maxUtm = Math.max(maxUtm, tStamp);
          return {
            start: new Date(tStamp * 1000),
            className: layer._showDates && layer._showDates[tStamp] ? 'active' : '',
            content: '',
            editable: true
          };
        });

        if (!layer._showDates && data.length) {
          layer._showDates = {};
          layer._showDates[maxUtm] = true;
          data[data.length - 1].className = 'active';
          layer.repaint();
        }

        tm.setData(data); // ÐÐµÑÐµÑÐ¸ÑÐ¾Ð²ÐºÐ° ÑÐ°Ð¹Ð¼Ð»Ð°Ð¹Ð½Ð°
      }
    });
    layer._observer = observer;
    this._interval = [new Date(1000 * (lprops.DateEndUTC - _DAY * 30)), new Date()];
    tm.setVisibleChartRange(this._interval[0], this._interval[1]);
    observer.setDateInterval(this._interval[0], this._interval[1]);
    layer.setDateInterval(this._interval[0], this._interval[1]);

    this._setBounds();

    this._map.on('moveend', this._setBounds, this); // this._reSetDateInterval();


    observer.activate();
    return observer;
  },
  _chkTabs: function _chkTabs() {
    if (Object.keys(this._layers).length === 0) {
      this._activeTab = null;

      this._container.classList.add('hidden');
    } else {
      this._container.classList.remove('hidden');
    }
  },
  toggle: function toggle(flag) {
    var layer = this._layers[this._activeTab];

    if (flag) {
      this._timelineNode.classList.remove('hidden');

      this._tabs.classList.remove('hidden');

      this._icon.classList.add('hidden');

      if (layer) {
        layer._observer.activate();
      }
    } else {
      this._timelineNode.classList.add('hidden');

      this._tabs.classList.add('hidden');

      this._icon.classList.remove('hidden');

      if (layer) {
        layer._observer.deactivate();
      }
    }

    this._chkTabs();
  },
  removeLayer: function removeLayer(layer) {
    var _layer$getGmxProperti = layer.getGmxProperties(),
        LayerID = _layer$getGmxProperti.LayerID;

    this.removeLayerByID(LayerID);
  },
  removeLayerByID: function removeLayerByID(LayerID) {
    var layer = this._layers[LayerID];

    if (layer) {
      if (this._activeTab === LayerID) {
        this.setTab();
      }

      if (layer._tabNode && layer._tabNode.parentNode) {
        layer._tabNode.parentNode.removeChild(layer._tabNode);
      }

      layer._tabNode = null;

      this._map.removeLayer(layer);

      delete this._layers[LayerID];
      var arr = Object.keys(this._layers);

      if (arr.length) {
        this.setTab(this._layers[arr[0]].getGmxProperties().LayerID);
      }
    }

    this._chkTabs();
  },
  addLayer: function addLayer(layer) {
    var _this2 = this;

    var _layer$getGmxProperti2 = layer.getGmxProperties(),
        LayerID = _layer$getGmxProperti2.LayerID,
        title = _layer$getGmxProperti2.title;

    if (!this._layers[LayerID]) {
      this._layers[LayerID] = layer;
      var tab = L$1.DomUtil.create('div', 'tab', this._tabs);
      tab.innerText = title;
      L$1.DomEvent.on(tab, 'click', function (e) {
        L$1.DomEvent.stopPropagation(e);

        _this2.setTab(LayerID);
      }, this);
      layer._tabNode = tab;
      this.setTab(LayerID);
    }

    this._chkTabs();
  },
  setTab: function setTab(layerID) {
    var layer;

    if (this._activeTab) {
      layer = this._layers[this._activeTab];
    }

    if (layer) {
      layer._observer.deactivate();

      layer._tabNode.classList.remove('active');

      this._activeTab = null;
    }

    layer = this._layers[layerID];

    if (layer) {
      this._addObserver(layer);

      var interval = layer.getDateInterval();

      this._timeline.setVisibleChartRange(interval.beginDate, interval.endDate);

      layer._observer.activate();

      layer._tabNode.classList.add('active');

      this._activeTab = layerID;

      this._setBounds();

      if (!layer._map) {
        this._map.addLayer(layer);
      }
    }
  }
});

T.addText('eng', {
  gmxLocation: {
    locationChange: 'Ð¡hange the map center:',
    locationTxt: 'Current center coordinates',
    coordFormatChange: 'Toggle coordinates format',
    scaleBarChange: 'Toggle scale bar format'
  },
  units: {
    km: 'km',
    m: 'm'
  }
});
T.addText('rus', {
  gmxLocation: {
    locationChange: 'ÐÐµÑÐµÐ¼ÐµÑÑÐ¸ÑÑ ÑÐµÐ½ÑÑ ÐºÐ°ÑÑÑ:',
    locationTxt: 'Ð¢ÐµÐºÑÑÐ¸Ðµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ ÑÐµÐ½ÑÑÐ° ÐºÐ°ÑÑÑ',
    coordFormatChange: 'Ð¡Ð¼ÐµÐ½Ð¸ÑÑ ÑÐ¾ÑÐ¼Ð°Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ',
    scaleBarChange: 'Ð¡Ð¼ÐµÐ½Ð¸ÑÑ ÑÐ¾ÑÐ¼Ð°Ñ Ð¼Ð°ÑÑÑÐ°Ð±Ð°'
  },
  units: {
    km: 'ÐºÐ¼',
    m: 'Ð¼'
  }
});
var _mzoom = ['M 1:500 000 000', //  0   156543.03392804
'M 1:300 000 000', //  1   78271.51696402
'M 1:150 000 000', //  2   39135.75848201
'M 1:80 000 000', //  3   19567.879241005
'M 1:40 000 000', //  4   9783.9396205025
'M 1:20 000 000', //  5   4891.96981025125
'M 1:10 000 000', //  6   2445.98490512563
'M 1:5 000 000', //  7   1222.99245256281
'M 1:2500 000', //  8   611.496226281406
'M 1:1 000 000', //  9   305.748113140703
'M 1:500 000', //  10  152.874056570352
'M 1:300 000', //  11  76.437028285176
'M 1:150 000', //  12  38.218514142588
'M 1:80 000', //  13  19.109257071294
'M 1:40 000', //  14  9.554628535647
'M 1:20 000', //  15  4.777314267823
'M 1:10 000', //  16  2.388657133912
'M 1:5 000', //  17  1.194328566956
'M 1:2 500', //  18  0.597164283478
'M 1:1 250', //  19  0.298582141739
'M 1:625' //  20  0.149291070869
];
var coordFormats = ['', '', ' (EPSG:3395)', ' (EPSG:3857)'];
L$1.Control.GmxLocation = L$1.Control.extend({
  includes: L$1.Evented ? L$1.Evented.prototype : L$1.Mixin.Events,
  options: {
    position: 'gmxbottomright',
    id: 'location',
    gmxPopup: 'internal',
    notHide: true,
    coordinatesFormat: 0,
    scaleFormat: 'bar' // or text

  },
  setScaleFormat: function setScaleFormat(type) {
    this.options.scaleFormat = type === 'bar' ? 'bar' : 'text';
    this.scaleBar.style.visibility = type === 'bar' ? 'visible' : 'hidden';

    this._checkPositionChanged();
  },
  onAdd: function onAdd(map) {
    var className = 'leaflet-gmx-location',
        container = L$1.DomUtil.create('div', className),
        utils = L$1.Control.GmxLocation.Utils,
        my = this;
    this._container = container;
    container._id = this.options.id;

    if (this.options.notHide) {
      container._notHide = true;
    }

    this.prevCoordinates = '';
    var corner = map._controlCorners[this.options.position];

    if (corner) {
      this._window = L$1.DomUtil.create('div', 'leaflet-gmx-location-window', container);
      this._window.style.display = 'none';
      var closeButton = L$1.DomUtil.create('div', 'closeButton', this._window);
      closeButton.innerHTML = '&#215;';
      L$1.DomEvent.disableClickPropagation(this._window);
      L$1.DomEvent.on(this._window, 'contextmenu', L$1.DomEvent.fakeStop || L$1.DomEvent._fakeStop);
      L$1.DomEvent.on(closeButton, 'click', function () {
        var style = my._window.style;
        style.display = style.display === 'none' ? 'block' : 'none';
      }, this);
      map.on('click', function () {
        my._window.style.display = 'none';
      }, this);
      this._windowContent = L$1.DomUtil.create('div', 'windowContent', this._window);
    }

    this.locationTxt = L$1.DomUtil.create('span', 'leaflet-gmx-locationTxt', container);
    this.locationTxt.title = T.getText('gmxLocation.locationTxt');
    this.coordFormatChange = L$1.DomUtil.create('span', 'leaflet-gmx-coordFormatChange', container);
    this.coordFormatChange.title = T.getText('gmxLocation.coordFormatChange');
    this.scaleBar = L$1.DomUtil.create('span', 'leaflet-gmx-scaleBar', container);
    this.scaleBarTxt = L$1.DomUtil.create('span', 'leaflet-gmx-scaleBarTxt', container);
    this.scaleBarTxt.title = this.scaleBar.title = T.getText('gmxLocation.scaleBarChange');
    this._map = map;
    var util = {
      coordFormat: this.options.coordinatesFormat || 0,
      len: coordFormats.length,
      setCoordinatesFormat: function setCoordinatesFormat(num) {
        num = num || this.coordFormat || 0;

        if (num < 0) {
          num = util.len - 1;
        } else if (num >= util.len) {
          num = 0;
        }

        this.coordFormat = num;
        var res = utils.getCoordinatesString(my._map.getCenter(), this.coordFormat);

        if (res && my.prevCoordinates !== res) {
          my.locationTxt.innerHTML = res;
        }

        my.prevCoordinates = res;

        if (this._redrawTimer) {
          clearTimeout(this._redrawTimer);
        }

        this._redrawTimer = setTimeout(function () {
          if (my._map) {
            my._map.fire('onChangeLocationSize', {
              locationSize: container.clientWidth
            });
          }
        }, 100);
        my.fire('coordinatesformatchange', {
          coordinatesFormat: this.coordFormat
        });
      },
      goTo: function goTo(value) {
        var coord = L$1.Control.gmxLocation.Utils.parseCoordinates(value);

        my._map.panTo(coord);
      },
      showCoordinates: function showCoordinates(ev) {
        //Ð¾ÐºÐ¾ÑÐºÐ¾ Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼Ð¸
        var oldText = utils.getCoordinatesString(my._map.getCenter(), this.coordFormat);

        if (my.options.onCoordinatesClick) {
          my.options.onCoordinatesClick(oldText, ev);
        } else if (L$1.control.gmxPopup) {
          var div = L$1.DomUtil.create('div', 'gmxLocation-popup'),
              span = L$1.DomUtil.create('div', '', div),
              input = L$1.DomUtil.create('input', 'gmxLocation-input', div),
              button = L$1.DomUtil.create('button', '', div);
          button.innerHTML = 'Ok';
          L$1.DomEvent.on(button, 'click', function () {
            util.goTo(input.value);
          });
          span.innerHTML = T.getText('gmxLocation.locationChange');
          input.value = oldText;
          L$1.DomEvent.on(input, 'keydown', function (ev) {
            if (ev.which === 13) {
              util.goTo(this.value);
            }
          });

          if (my.options.gmxPopup === 'internal' && my._window) {
            my._windowContent.innerHTML = '';

            my._windowContent.appendChild(div);

            var style = my._window.style;
            style.display = style.display === 'none' ? 'block' : 'none';
          } else {
            var opt = {};

            if (my.options.gmxPopup === 'tip') {
              var pos = my._map.mouseEventToContainerPoint(ev);

              opt = {
                tip: true,
                anchor: new L$1.Point(pos.x, pos.y - 5)
              };
            }

            L$1.control.gmxPopup(opt).setContent(div).openOn(my._map);
          }
        } else {
          //if (this.coordFormat > 2) { return; } // ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½ÑÑ ÑÐ¾ÑÐ¼Ð°ÑÐ¾Ð².
          var text = window.prompt(my.locationTxt.title + ':', oldText);

          if (text && text !== oldText) {
            var point = utils.parseCoordinates(text);

            if (point) {
              my._map.panTo(point);
            }
          }
        }
      },
      nextCoordinatesFormat: function nextCoordinatesFormat() {
        this.coordFormat += 1;
        this.setCoordinatesFormat(this.coordFormat || 0);
      }
    };

    this.getCoordinatesFormat = function () {
      return util.coordFormat;
    };

    this._checkPositionChanged = function () {
      var z = map.getZoom();

      if (z && !map._animatingZoom) {
        var attr = {
          txt: _mzoom[z],
          width: 0
        };

        if (this.options.scaleFormat === 'bar') {
          attr = utils.getScaleBarDistance(z, map.getCenter());
        }

        if (!attr || attr.txt === my._scaleBarText && attr.width === my._scaleBarWidth) {
          return;
        }

        my._scaleBarText = attr.txt;
        my._scaleBarWidth = attr.width;

        if (my._scaleBarText) {
          my.scaleBar.style.width = my._scaleBarWidth + 'px'; //, 4);

          my.scaleBarTxt.innerHTML = my._scaleBarText;
        }

        util.setCoordinatesFormat(util.coordFormat || 0);
      }
    };

    this._setCoordinatesFormat = function () {
      util.setCoordinatesFormat(util.coordFormat || 0);
    };

    this.setCoordinatesFormat = function (nm) {
      if (!map._animatingZoom) {
        if (nm === 0) {
          util.coordFormat = 0;
        }

        util.setCoordinatesFormat(nm);
      }
    };

    var toggleScaleFormat = function toggleScaleFormat() {
      this.setScaleFormat(this.options.scaleFormat === 'bar' ? 'text' : 'bar');
    };

    this._toggleHandlers = function (flag) {
      var op = flag ? 'on' : 'off',
          func = L$1.DomEvent[op],
          stop = L$1.DomEvent.stopPropagation;
      func(container, 'mousemove', stop);
      func(this.coordFormatChange, 'click', stop);
      func(this.coordFormatChange, 'click', util.nextCoordinatesFormat, util);
      func(this.locationTxt, 'click', stop);
      func(this.locationTxt, 'click', util.showCoordinates, util);
      func(this.scaleBarTxt, 'click', stop);
      func(this.scaleBarTxt, 'click', toggleScaleFormat, this);
      func(this.scaleBar, 'click', stop);
      func(this.scaleBar, 'click', toggleScaleFormat, this);

      if (!L$1.Browser.mobile && !L$1.Browser.ie) {
        func(this.coordFormatChange, 'dblclick', stop);
        func(this.scaleBarTxt, 'dblclick', stop);
        func(this.scaleBar, 'dblclick', stop);
      }

      map[op]('moveend', this._checkPositionChanged, this);
      map[op]('move', this._setCoordinatesFormat, this);
    };

    this._toggleHandlers(true);

    this.setScaleFormat(this.options.scaleFormat);

    this._checkPositionChanged();

    map.fire('controladd', this);

    if (map.gmxControlsManager) {
      map.gmxControlsManager.add(this);
    }

    return container;
  },
  onRemove: function onRemove(map) {
    if (map.gmxControlsManager) {
      map.gmxControlsManager.remove(this);
    }

    map.fire('controlremove', this);
    this.prevCoordinates = this._scaleBarText = null;

    this._toggleHandlers(false);
  }
});
var utils$1 = {
  getScaleBarDistance: function getScaleBarDistance(z, pos) {
    var merc = L$1.Projection.Mercator.project(pos),
        pos1 = L$1.Projection.Mercator.unproject(new L$1.Point(merc.x + 40, merc.y + 30)),
        metersPerPixel = Math.pow(2, -z) * 156543.033928041 * this.distVincenty(pos.lng, pos.lat, pos1.lng, pos1.lat) / 50;

    for (var i = 0; i < 30; i++) {
      var distance = [1, 2, 5][i % 3] * Math.pow(10, Math.floor(i / 3)),
          w = Math.floor(distance / metersPerPixel);

      if (w > 50) {
        return {
          txt: this.prettifyDistance(distance),
          width: w
        };
      }
    }

    return null;
  }
};

if (L$1.gmxUtil) {
  utils$1.getCoordinatesString = L$1.gmxUtil.getCoordinatesString;
  utils$1.prettifyDistance = L$1.gmxUtil.prettifyDistance;
  utils$1.formatDegrees = L$1.gmxUtil.formatDegrees;
  utils$1.pad2 = L$1.gmxUtil.pad2;
  utils$1.trunc = L$1.gmxUtil.trunc;
  utils$1.latLonFormatCoordinates = L$1.gmxUtil.latLonFormatCoordinates;
  utils$1.latLonFormatCoordinates2 = L$1.gmxUtil.latLonFormatCoordinates2;
  utils$1.degRad = L$1.gmxUtil.degRad;
  utils$1.distVincenty = L$1.gmxUtil.distVincenty;
  utils$1.parseCoordinates = L$1.gmxUtil.parseCoordinates;
} else {
  utils$1.prettifyDistance = function (length) {
    var type = '',
        //map.DistanceUnit
    txt = T.getText('units.km') || 'km',
        km = ' ' + txt;

    if (length < 2000 || type === 'm') {
      txt = T.getText('units.m') || 'm';
      return Math.round(length) + ' ' + txt;
    } else if (length < 200000) {
      return Math.round(length / 10) / 100 + km;
    }

    return Math.round(length / 1000) + km;
  };

  utils$1.formatDegrees = function (angle) {
    angle = Math.round(10000000 * angle) / 10000000 + 0.00000001;
    var a1 = Math.floor(angle),
        a2 = Math.floor(60 * (angle - a1)),
        a3 = this.pad2(3600 * (angle - a1 - a2 / 60)).substring(0, 2);
    return this.pad2(a1) + 'Â°' + this.pad2(a2) + '\'' + a3 + '"';
  };

  utils$1.pad2 = function (t) {
    return t < 10 ? '0' + t : '' + t;
  };

  utils$1.trunc = function (x) {
    return ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);
  };

  utils$1.latLonFormatCoordinates = function (x, y) {
    return this.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + this.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');
  };

  utils$1.latLonFormatCoordinates2 = function (x, y) {
    return this.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + this.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');
  };

  utils$1.degRad = function (ang) {
    return ang * (Math.PI / 180.0);
  };

  utils$1.distVincenty = function (lon1, lat1, lon2, lat2) {
    var p1 = {};
    var p2 = {};
    p1.lon = this.degRad(lon1);
    p1.lat = this.degRad(lat1);
    p2.lon = this.degRad(lon2);
    p2.lat = this.degRad(lat2);
    var a = 6378137,
        b = 6356752.3142,
        f = 1 / 298.257223563; // WGS-84 ellipsiod

    var L = p2.lon - p1.lon;
    var U1 = Math.atan((1 - f) * Math.tan(p1.lat));
    var U2 = Math.atan((1 - f) * Math.tan(p2.lat));
    var sinU1 = Math.sin(U1),
        cosU1 = Math.cos(U1);
    var sinU2 = Math.sin(U2),
        cosU2 = Math.cos(U2);
    var lambda = L,
        lambdaP = 2 * Math.PI;
    var iterLimit = 20;

    while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {
      var sinLambda = Math.sin(lambda),
          cosLambda = Math.cos(lambda);
      var sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));

      if (sinSigma === 0) {
        return 0;
      }

      var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      var sigma = Math.atan2(sinSigma, cosSigma);
      var sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
      var cosSqAlpha = 1 - sinAlpha * sinAlpha;
      var cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;

      if (isNaN(cos2SigmaM)) {
        cos2SigmaM = 0;
      }

      var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
      lambdaP = lambda;
      lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
    }

    if (iterLimit === 0) {
      return NaN;
    }

    var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
    var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    var s = b * A * (sigma - deltaSigma);
    s = s.toFixed(3);
    return s;
  };

  utils$1.parseCoordinates = function (text) {
    // should understand the following formats:
    // 55.74312, 37.61558
    // 55Â°44'35" N, 37Â°36'56" E
    // 4187347, 7472103
    // 4219783, 7407468 (EPSG:3395)
    // 4219783, 7442673 (EPSG:3857)
    var crs = null,
        regex = /\(EPSG:(\d+)\)/g,
        t = regex.exec(text);

    if (t) {
      crs = t[1];
      text = text.replace(regex, '');
    }

    if (text.match(/[Ð¹ÑÑÐºÐµÐ½Ð³ÑÑÐ·ÑÑÑÑÐ²Ð°Ð¿ÑÐ¾Ð»Ð´Ð¶ÑÑÑÑÐ¼Ð¸ÑÑÐ±ÑÐÐ¦Ð£ÐÐÐÐÐ¨Ð©ÐÐ¥ÐªÐ¤Ð«ÐÐÐÐ ÐÐÐÐÐ­Ð¯Ð§Ð¡ÐÐÐ¢Ð¬ÐÐ®qrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {
      return null;
    } //there should be a separator in the string (exclude strings like "11E11")


    if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {
      return null;
    }

    if (text.indexOf(' ') !== -1) {
      text = text.replace(/,/g, '.');
    }

    var results = [];
    regex = /(-?\d+(\.\d+)?)([^\d\-]*)/g;
    t = regex.exec(text);

    while (t) {
      results.push(t[1]);
      t = regex.exec(text);
    }

    if (results.length < 2) {
      return null;
    }

    var ii = Math.floor(results.length / 2),
        y = 0,
        mul = 1,
        i;

    for (i = 0; i < ii; i++) {
      y += parseFloat(results[i]) * mul;
      mul /= 60;
    }

    var x = 0;
    mul = 1;

    for (i = ii; i < results.length; i++) {
      x += parseFloat(results[i]) * mul;
      mul /= 60;
    }

    if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {
      t = x;
      x = y;
      y = t;
    }

    var pos;

    if (crs === '3857') {
      pos = L$1.Projection.SphericalMercator.unproject(new L$1.Point(y, x));
      x = pos.lng;
      y = pos.lat;
    }

    if (Math.abs(x) > 180 || Math.abs(y) > 180) {
      pos = L$1.Projection.Mercator.unproject(new L$1.Point(y, x));
      x = pos.lng;
      y = pos.lat;
    }

    if (text.indexOf('W') !== -1) {
      x = -x;
    }

    if (text.indexOf('S') !== -1) {
      y = -y;
    }

    return [y, x];
  };

  utils$1.getCoordinatesString = function (latlng, num) {
    var x = latlng.lng,
        y = latlng.lat,
        formats = coordFormats,
        len = formats.length,
        merc,
        out = '';
    num = num || 0;

    if (x > 180) {
      x -= 360;
    }

    if (x < -180) {
      x += 360;
    }

    if (num % len === 0) {
      out = utils$1.latLonFormatCoordinates2(x, y);
    } else if (num % len === 1) {
      out = utils$1.latLonFormatCoordinates(x, y);
    } else if (num % len === 2) {
      merc = L$1.Projection.Mercator.project(new L$1.LatLng(y, x));
      out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];
    } else {
      merc = L$1.CRS.EPSG3857.project(new L$1.LatLng(y, x));
      out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];
    }

    return out;
  };
}

L$1.Control.GmxLocation.Utils = utils$1;
L$1.Control.gmxLocation = L$1.Control.GmxLocation;

L$1.control.gmxLocation = function (options) {
  return new L$1.Control.GmxLocation(options);
};

var gmxLocation = L$1.Control.GmxLocation;

var Legend = L$1.Control.extend({
  includes: L$1.Evented.prototype,
  options: {
    position: 'topright'
  },
  initialize: function initialize() {
    this._components = {};
  },
  onAdd: function onAdd(map) {
    var _this = this;

    this._container = L$1.DomUtil.create('div', 'scanex-forestry-legend');
    L$1.DomEvent.disableScrollPropagation(this._container);
    L$1.DomEvent.disableClickPropagation(this._container);
    this._icon = L$1.DomUtil.create('div', 'scanex-legend-icon icon', this._container);
    this._panel = L$1.DomUtil.create('div', 'panel hidden', this._container);
    this._content = L$1.DomUtil.create('div', 'scrollable style-4', this._panel);
    L$1.DomEvent.on(this._icon, 'click', function (e) {
      L$1.DomEvent.stopPropagation(e);
      _this._active = !_this._active;

      _this.showPanel(_this._active);

      _this.fire('activate', {
        active: _this._active
      });
    });
    return this._container;
  },
  onRemove: function onRemove(map) {},
  showPanel: function showPanel(visible) {
    this._active = visible;

    if (this._active) {
      L$1.DomUtil.addClass(this._icon, 'active');
      L$1.DomUtil.removeClass(this._panel, 'hidden');
    } else {
      L$1.DomUtil.removeClass(this._icon, 'active');
      L$1.DomUtil.addClass(this._panel, 'hidden');
    }
  },
  enable: function enable(id) {
    var container = this._container.querySelector("[data-id=".concat(id, "]"));

    if (container) {
      var btn = container.querySelector('.toggle');
      L$1.DomUtil.addClass(btn, 'toggle-active');
      this.fire('click', {
        id: id,
        visible: true
      });
    }
  },
  disable: function disable(id) {
    var container = this._container.querySelector("[data-id=".concat(id, "]"));

    if (container) {
      var btn = container.querySelector('.toggle');
      L$1.DomUtil.removeClass(btn, 'toggle-active');
      this.fire('click', {
        id: id,
        visible: false
      });
    }
  },
  state: function state(id) {
    var container = this._container.querySelector("[data-id=".concat(id, "]"));

    if (container) {
      var btn = container.querySelector('.toggle');
      return L$1.DomUtil.hasClass(btn, 'toggle-active');
    } else {
      return false;
    }
  },
  toggle: function toggle(id) {
    var container = this._container.querySelector("[data-id=".concat(id, "]"));

    if (container) {
      var btn = container.querySelector('.toggle');
      var visible = !L$1.DomUtil.hasClass(btn, 'toggle-active');

      if (visible) {
        this.enable(id);
      } else {
        this.disable(id);
      }
    }
  },
  addComponent: function addComponent(id, title, parent) {
    var _this2 = this;

    var container = L$1.DomUtil.create('div', 'component', parent ? parent : this._content);
    container.setAttribute('data-id', id);
    L$1.DomUtil.create('i', null, container);
    L$1.DomUtil.create('label', 'title', container).innerText = title;
    L$1.DomUtil.create('div', 'toggle', container);
    L$1.DomEvent.on(container, 'click', function (e) {
      _this2.toggle(id);
    }, this);
    this._components[id] = container;
    return container;
  },
  addGroup: function addGroup(id, title) {
    var _this3 = this;

    var container = L$1.DomUtil.create('div', 'group', this._content);
    container.setAttribute('data-id', id);
    var header = L$1.DomUtil.create('div', 'header', container);
    var icon = L$1.DomUtil.create('i', 'scanex-legend-icon', header);
    L$1.DomUtil.addClass(icon, id);
    var label = L$1.DomUtil.create('label', 'title', header);
    label.innerText = title;
    var btn = L$1.DomUtil.create('div', 'toggle', header);
    var children = L$1.DomUtil.create('div', 'children hidden', container);

    var toggle = function toggle(e) {
      L$1.DomEvent.stopPropagation(e);

      if (L$1.DomUtil.hasClass(children, 'hidden')) {
        L$1.DomUtil.removeClass(children, 'hidden');
      } else {
        L$1.DomUtil.addClass(children, 'hidden');
      }
    };

    L$1.DomEvent.on(icon, 'click', toggle, this);
    L$1.DomEvent.on(label, 'click', toggle, this);
    L$1.DomEvent.on(btn, 'click', function (e) {
      var visible = !L$1.DomUtil.hasClass(btn, 'toggle-active');

      if (visible) {
        L$1.DomUtil.addClass(btn, 'toggle-active');
      } else {
        L$1.DomUtil.removeClass(btn, 'toggle-active');
      }

      var _iterator = _createForOfIteratorHelper(children.querySelectorAll('.component')),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;

          var _id = item.getAttribute('data-id');

          if (visible) {
            _this3.enable(_id);
          } else {
            _this3.disable(_id);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }, this);
    return children;
  }
});

var Zoom = L$1.Control.extend({
  options: {
    position: 'topright'
  },
  onAdd: function onAdd(map) {
    var container = L$1.DomUtil.create('div', 'scanex-forestry-zoom');
    L$1.DomEvent.disableScrollPropagation(container);
    L$1.DomEvent.disableClickPropagation(container);
    var plus = L$1.DomUtil.create('i', 'scanex-zoom-icon plus', container);
    L$1.DomEvent.on(plus, 'click', function () {
      return map.zoomIn(1);
    }, map);
    var middle = L$1.DomUtil.create('label', 'middle', container);
    middle.innerHTML = map.getZoom();
    var minus = L$1.DomUtil.create('i', 'scanex-zoom-icon minus', container);
    L$1.DomEvent.on(minus, 'click', function () {
      return map.zoomOut(1);
    }, map);
    map.on('zoomend', function (e) {
      if (middle) {
        middle.innerHTML = e.target._zoom;
      }
    });
    return container;
  },
  onRemove: function onRemove() {}
});

var translate$2 = T.getText.bind(T);

var Controller = /*#__PURE__*/function (_EventTarget) {
  _inherits(Controller, _EventTarget);

  var _super = _createSuper(Controller);

  function Controller(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications;

    _classCallCheck(this, Controller);

    _this = _super.call(this);
    _this._map = map;
    _this._content = content;
    _this._notifications = notifications;
    return _this;
  }

  _createClass(Controller, [{
    key: "_status",
    value: function _status(response) {
      switch (response.status) {
        case 200:
          return response.json();

        case 401:
          this._notifications.unAuthorized.open();

          return;

        case 403:
          this._notifications.forbidden.open();

          return;

        case 404:
          this._notifications.notFound.open();

          return;

        case 500:
          this._notifications.serverError.open();

          return;

        default:
          alert(response.status);
          return;
      }
    }
  }, {
    key: "httpPost",
    value: function httpPost(url, options) {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2._notifications.loading.open();

        fetch(url, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(options)
        }).then(_this2._status.bind(_this2)).then(function (data) {
          _this2._notifications.loading.close();

          resolve(data);
        }).catch(function (e) {
          _this2._notifications.loading.close();

          resolve();
        });
      });
    }
  }, {
    key: "httpGet",
    value: function httpGet(url) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve) {
        _this3._notifications.loading.open();

        var args = Object.keys(options);
        fetch("".concat(args.length > 0 ? "".concat(url, "?").concat(args.map(function (k) {
          return "".concat(k, "=").concat(options[k]);
        }).join('&')) : url), {
          method: 'GET',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          }
        }).then(_this3._status.bind(_this3)).then(function (data) {
          _this3._notifications.loading.close();

          resolve(data);
        }).catch(function (e) {
          _this3._notifications.loading.close();

          resolve();
        });
      });
    }
  }, {
    key: "sendForm",
    value: function sendForm(url, fd) {
      var _this4 = this;

      return new Promise(function (resolve) {
        _this4._notifications.loading.open();

        fetch(url, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          body: fd
        }).then(_this4._status.bind(_this4)).then(function (data) {
          _this4._notifications.loading.close();

          resolve(data);
        }).catch(function (e) {
          _this4._notifications.loading.close();

          resolve();
        });
      });
    }
  }, {
    key: "canClick",
    get: function get() {
      switch (this._content.getCurrentId()) {
        case 'edit-project':
          return false;

        default:
          return true;
      }
    }
  }]);

  return Controller;
}(EventTarget);

var LayerController = /*#__PURE__*/function (_Controller) {
  _inherits(LayerController, _Controller);

  var _super2 = _createSuper(LayerController);

  function LayerController(_ref2) {
    var _this5;

    var kind = _ref2.kind,
        map = _ref2.map,
        content = _ref2.content,
        notifications = _ref2.notifications,
        layer = _ref2.layer,
        legend = _ref2.legend;

    _classCallCheck(this, LayerController);

    _this5 = _super2.call(this, {
      map: map,
      content: content,
      notifications: notifications
    });
    _this5._kind = kind;
    _this5._layer = layer;
    _this5._legend = legend;

    _this5._layer.on('click', _this5._click, _assertThisInitialized(_this5));

    _this5._layer.setStyleHook(function (item) {
      var c = _this5._content.getCurrent();

      if (c) {
        return c.getStyleHook(_this5._kind, item);
      } else {
        return {};
      }
    });

    _this5._layer.setFilter(function (item) {
      var c = _this5._content.getCurrent();

      if (c) {
        return c.getFilter(_this5._kind, item);
      } else {
        return true;
      }
    });

    _this5._legend.addComponent(_this5._kind, translate$2("legend.".concat(_this5._kind)));

    _this5._legend.on('click', _this5._toggle, _assertThisInitialized(_this5));

    return _this5;
  }

  _createClass(LayerController, [{
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.canClick) {
                  L.DomEvent.stopPropagation(e);
                }

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _click(_x) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }, {
    key: "_toggle",
    value: function _toggle(e) {
      var id = e.id,
          visible = e.visible;

      if (id === this._kind) {
        if (visible) {
          this._map.addLayer(this._layer);
        } else {
          this._map.removeLayer(this._layer);
        }
      }
    }
  }]);

  return LayerController;
}(Controller);

var translate$3 = T.getText.bind(T);

var Borders = /*#__PURE__*/function (_Controller) {
  _inherits(Borders, _Controller);

  var _super = _createSuper(Borders);

  function Borders(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layers = _ref.layers,
        legend = _ref.legend;

    _classCallCheck(this, Borders);

    _this = _super.call(this, {
      map: map,
      content: content,
      notifications: notifications
    });
    _this._map = map;
    _this._layers = layers;
    _this._legend = legend;

    _this._legend.on('click', _this._toggle, _assertThisInitialized(_this));

    var p = _this._legend.addGroup('borders', translate$3("legend.borders"));

    if (_this._layers.regions) {
      _this._legend.addComponent('regions', translate$3('legend.regions'), p);
    }

    if (_this._layers.forestries) {
      _this._legend.addComponent('forestries', translate$3('legend.forestries'), p);
    }

    if (_this._layers.forestries_local) {
      _this._legend.addComponent('forestries_local', translate$3('legend.forestries_local'), p);
    }

    return _this;
  }

  _createClass(Borders, [{
    key: "_toggle",
    value: function _toggle(e) {
      var id = e.id,
          visible = e.visible;
      var layer = this._layers[id];

      if (layer) {
        if (visible) {
          this._map.addLayer(layer);
        } else {
          this._map.removeLayer(layer);
        }
      }
    }
  }]);

  return Borders;
}(Controller);

var s = {
  rus: {
    units: {
      pc: '%',
      cm: 'ÑÐ¼',
      m: 'Ð¼',
      ha: 'Ð³Ð°',
      m3: 'ÐºÑÐ±. Ð¼',
      m2: 'ÐºÐ². Ð¼'
    },
    legend: {
      quadrants: 'ÐÐµÑÐ¾ÑÐ¾Ð·ÑÐ¹ÑÑÐ²ÐµÐ½Ð½ÑÐµ ÐºÐ²Ð°ÑÑÐ°Ð»Ñ',
      stands: 'ÐÑÐ´ÐµÐ»Ñ',
      parks: 'ÐÐÐÐ¢',
      fires: 'ÐÐ¾Ð¶Ð°ÑÑ',
      declarations: 'ÐÐµÐºÐ»Ð°ÑÐ°ÑÐ¸Ð¸',
      incidents: 'ÐÐ¾ÑÐ¼Ð¸ÑÐµÑÐºÐ¸Ð¹ Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ¸Ð½Ð³',
      projects: 'ÐÑÐ¾ÐµÐºÑÑ ÑÑÐ°ÑÑÐºÐ¾Ð²',
      plots: 'ÐÑÐµÐ½Ð´Ð¾Ð²Ð°Ð½Ð½ÑÐµ ÑÑÐ°ÑÑÐºÐ¸',
      borders: 'ÐÐ´Ð¼Ð¸Ð½Ð¸ÑÑÑÐ°ÑÐ¸Ð²Ð½ÑÐµ Ð³ÑÐ°Ð½Ð¸ÑÑ',
      regions: 'Ð ÐµÐ³Ð¸Ð¾Ð½Ñ',
      roads: 'ÐÐ¾ÑÐ¾Ð³Ð¸',
      warehouses: 'ÐÑÐ½ÐºÑÑ Ð¿Ð¾Ð³ÑÑÐ·ÐºÐ¸',
      forestries: 'ÐÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð°',
      forestries_local: 'Ð£ÑÐ°ÑÑÐºÐ¾Ð²ÑÐµ Ð»ÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð°',
      burn: {
        unconfirmed: 'ÐÐ°ÑÑ Ð½ÐµÐ¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ',
        working: 'ÐÐ°ÑÑ (Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸)',
        faux: 'ÐÐ°ÑÑ Ð»Ð¾Ð¶Ð½Ð°Ñ',
        confirmed: 'ÐÐ°ÑÑ Ð¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ'
      },
      cut: {
        unconfirmed: 'Ð ÑÐ±ÐºÐ° Ð½ÐµÐ¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ',
        working: 'Ð ÑÐ±ÐºÐ° (Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸)',
        faux: 'Ð ÑÐ±ÐºÐ° Ð»Ð¾Ð¶Ð½Ð°Ñ',
        confirmed: 'Ð ÑÐ±ÐºÐ° Ð¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ'
      },
      windthrow: {
        unconfirmed: 'ÐÐµÑÑÐ¾Ð²Ð°Ð» Ð½ÐµÐ¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½ÑÐ¹',
        working: 'ÐÐµÑÑÐ¾Ð²Ð°Ð» (Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸)',
        faux: 'ÐÐµÑÑÐ¾Ð²Ð°Ð» Ð»Ð¾Ð¶Ð½ÑÐ¹',
        confirmed: 'ÐÐµÑÑÐ¾Ð²Ð°Ð» Ð¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½ÑÐ¹'
      },
      disease: {
        unconfirmed: 'ÐÐ°ÑÐ¾Ð»Ð¾Ð³Ð¸Ñ Ð½ÐµÐ¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ',
        working: 'ÐÐ°ÑÐ¾Ð»Ð¾Ð³Ð¸Ñ (Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸)',
        faux: 'ÐÐ°ÑÐ¾Ð»Ð¾Ð³Ð¸Ñ Ð»Ð¾Ð¶Ð½Ð°Ñ',
        confirmed: 'ÐÐ°ÑÐ¾Ð»Ð¾Ð³Ð¸Ñ Ð¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ'
      }
    }
  }
};

var View = /*#__PURE__*/function (_EventTarget) {
  _inherits(View, _EventTarget);

  var _super = _createSuper(View);

  function View(container) {
    var _this;

    var strings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, View);

    _this = _super.call(this);
    _this._target = container;
    _this._target.innerHTML = "<div class=\"container\"></div>\n        <i class=\"scanex-component-icon close\"></i>";
    _this._container = _this._target.querySelector('.container');
    var btn = container.querySelector('.scanex-component-icon');
    btn.addEventListener('click', function (e) {
      e.stopPropagation();

      _this.close();
    });
    L$1.DomEvent.disableScrollPropagation(_this._target);
    Object.keys(s).forEach(function (lang) {
      return T.addText(lang, s[lang]);
    });
    Object.keys(strings).forEach(function (lang) {
      return T.addText(lang, strings[lang]);
    });
    return _this;
  }

  _createClass(View, [{
    key: "getStyleHook",
    value: function getStyleHook() {
      return {};
    }
  }, {
    key: "getFilter",
    value: function getFilter() {
      return true;
    }
  }, {
    key: "open",
    value: function open() {
      var event = document.createEvent('Event');
      event.initEvent('open', false, false);
      this.dispatchEvent(event);
    }
  }, {
    key: "close",
    value: function close() {
      var event = document.createEvent('Event');
      event.initEvent('close', false, false);
      this.dispatchEvent(event);
    }
  }, {
    key: "toggle",
    value: function toggle(gmx_id) {
      if (this._gmx_id && this._gmx_id === gmx_id) {
        this._gmx_id = null;
      } else {
        this._gmx_id = gmx_id;
      }

      return this._gmx_id;
    }
  }, {
    key: "translate",
    value: function translate(key) {
      return T.getText(key);
    }
  }, {
    key: "m",
    value: function m$1(value) {
      return m(value);
    }
  }, {
    key: "rub",
    value: function rub$1(value) {
      return rub(value);
    }
  }, {
    key: "date",
    value: function date$1(value) {
      return date(value);
    }
  }, {
    key: "fmt",
    value: function fmt$1(value) {
      return fmt(value);
    }
  }, {
    key: "ha",
    value: function ha$1(value) {
      return ha(value);
    }
  }]);

  return View;
}(EventTarget);

var strings = {
  rus: {
    declaration: {
      title: 'ÐÐµÑÐ½Ð°Ñ Ð´ÐµÐºÐ»Ð°ÑÐ°ÑÐ¸Ñ â',
      federalSubject: 'ÐÐ°Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ±ÑÐµÐºÑÐ° Ð Ð¾ÑÑÐ¸Ð¹ÑÐºÐ¾Ð¹ Ð¤ÐµÐ´ÐµÑÐ°ÑÐ¸Ð¸',
      executive: 'ÐÑÐ³Ð°Ð½ Ð¸ÑÐ¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð¾Ð¹ Ð²Ð»Ð°ÑÑÐ¸',
      officer: 'ÐÑÐ²ÐµÑÑÑÐ²ÐµÐ½Ð½Ð¾Ðµ Ð»Ð¸ÑÐ¾',
      lessee: 'ÐÑÐµÐ½Ð´Ð°ÑÐ¾Ñ',
      contract: 'ÐÐ¾Ð³Ð¾Ð²Ð¾Ñ Ð°ÑÐµÐ½Ð´Ñ',
      purpose_of_forest: 'Ð¦ÐµÐ»ÐµÐ²Ð¾Ðµ Ð½Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð»ÐµÑÐ¾Ð²',
      protective_forest_category: 'ÐÐ°ÑÐµÐ³Ð¾ÑÐ¸Ñ Ð·Ð°ÑÐ¸ÑÐ½ÑÑ Ð»ÐµÑÐ¾Ð²',
      forestry_name: 'ÐÐ°Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð»ÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð° (Ð»ÐµÑÐ¾Ð¿Ð°ÑÐºÐ°)',
      local_forestry_name: 'ÐÐ°Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ°ÑÑÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð»ÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð°',
      tract_name: 'ÐÐ°Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾ÑÐ¸ÑÐ° (Ð¿ÑÐ¸ Ð½Ð°Ð»Ð¸ÑÐ¸Ð¸)',
      quadrant_number: 'ÐÐ¾Ð¼ÐµÑ Ð»ÐµÑÐ½Ð¾Ð³Ð¾ ÐºÐ²Ð°ÑÑÐ°Ð»Ð°',
      forest_inventory_unit_number: 'ÐÐ¾Ð¼ÐµÑ Ð»ÐµÑÐ¾ÑÐ°ÐºÑÐ°ÑÐ¸Ð¾Ð½Ð½Ð¾Ð³Ð¾ Ð²ÑÐ´ÐµÐ»Ð°',
      num: 'ÐÐ¾Ð¼ÐµÑ Ð»ÐµÑÐ¾ÑÐµÐºÐ¸',
      total_square: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ Ð»ÐµÑÐ¾ÑÐµÐºÐ¸ (Ð»ÐµÑÐ¾ÑÐ°ÐºÑÐ°ÑÐ¸Ð¾Ð½Ð½Ð¾Ð³Ð¾ Ð²ÑÐ´ÐµÐ»Ð°)',
      felling_form: 'Ð¤Ð¾ÑÐ¼Ð° ÑÑÐ±ÐºÐ¸',
      felling_type: 'ÐÐ¸Ð´ ÑÑÐ±ÐºÐ¸',
      farm: 'Ð¥Ð¾Ð·ÑÐ¹ÑÑÐ²Ð¾',
      species: 'ÐÑÑÑÐ±Ð°ÐµÐ¼Ð°Ñ Ð´ÑÐµÐ²ÐµÑÐ½Ð°Ñ Ð¿Ð¾ÑÐ¾Ð´Ð°',
      unit_of_measurement: 'ÐÐ´Ð¸Ð½Ð¸ÑÑ Ð¸Ð·Ð¼ÐµÑÐµÐ½Ð¸Ñ',
      stock: 'ÐÐ±ÑÐµÐ¼ Ð·Ð°Ð³Ð¾ÑÐ¾Ð²ÐºÐ¸',
      doc: 'ÐÐ¾ÐºÑÐ¼ÐµÐ½ÑÑ Ðº Ð´Ð¾Ð³Ð¾Ð²Ð¾ÑÑ Ð°ÑÐµÐ½Ð´Ñ'
    }
  }
};

var STYLES = {
  fillStyle: 'rgba(49, 243, 80, 0.25)',
  strokeStyle: '#61E9F1',
  lineWidth: 2
};

var Declaration = /*#__PURE__*/function (_BaseView) {
  _inherits(Declaration, _BaseView);

  var _super = _createSuper(Declaration);

  function Declaration(container) {
    var _this;

    _classCallCheck(this, Declaration);

    _this = _super.call(this, container, strings);

    _this._container.classList.add('scanex-forestry-declaration');

    _this._container.innerHTML = "<div class=\"header\">\n            <label>".concat(_this.translate('declaration.title'), "</label>            \n            <label class=\"number\"></label>\n        </div>\n        <div class=\"scrollable\">\n            <table cellspacing=\"0\" cellpadding=\"0\">\n                <tbody>\n                    <!--\n                    <tr>\n                        <td>").concat(_this.translate('declaration.federalSubject'), "</td>\n                        <td class=\"federal-subject\"></td>\n                    </tr>\n                    -->\n                    <tr>\n                        <td>").concat(_this.translate('declaration.executive'), "</td>\n                        <td class=\"executive\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.officer'), "</td>\n                        <td class=\"officer\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.lessee'), "</td>\n                        <td class=\"lessee\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.contract'), "</td>\n                        <td class=\"contract\"></td>\n                    </tr>\n                </tbody>\n            </table>\n            <div>\n                <i class=\"scanex-declaration-icon doc\"></i>\n                <button class=\"open-doc\">").concat(_this.translate('declaration.doc'), "</button>\n            </div>        \n            <table cellspacing=\"0\" cellpadding=\"0\">\n                <tbody>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.purpose_of_forest'), "</td>\n                        <td class=\"purpose_of_forest\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.protective_forest_category'), "</td>\n                        <td class=\"protective_forest_category\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.forestry_name'), "</td>\n                        <td class=\"forestry_name\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.local_forestry_name'), "</td>\n                        <td class=\"local_forestry_name\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.tract_name'), "</td>\n                        <td class=\"tract_name\"></td>\n                    </tr>                                \n                    <tr>\n                        <td>").concat(_this.translate('declaration.quadrant_number'), "</td>\n                        <td class=\"quadrant_number\"></td>\n                    </tr>\n                    <tr>\n                        <td>").concat(_this.translate('declaration.forest_inventory_unit_number'), "</td>\n                        <td class=\"forest_inventory_unit_number\"></td>\n                    </tr>\n                </tbody>\n            </table>\n            <div class=\"content\"></div>\n        </div>");
    return _this;
  }

  _createClass(Declaration, [{
    key: "open",
    value: function open(_ref) {
      var _this2 = this;

      var gmx_id = _ref.gmx_id,
          data = _objectWithoutProperties(_ref, ["gmx_id"]);

      _get(_getPrototypeOf(Declaration.prototype), "open", this).call(this);

      this._gmx_id = gmx_id;
      var DeclarationNumber = data.DeclarationNumber,
          ExecutiveAuthority = data.ExecutiveAuthority,
          ResponsiblePerson = data.ResponsiblePerson,
          Owner = data.Owner,
          DogovorNumber = data.DogovorNumber,
          CuttingAreas = data.CuttingAreas;
      this._container.querySelector('.number').innerText = DeclarationNumber || ''; // this._container.querySelector('.federal-subject').innerText = Region || '';

      this._container.querySelector('.executive').innerText = ExecutiveAuthority || '';
      this._container.querySelector('.officer').innerText = ResponsiblePerson || '';
      this._container.querySelector('.lessee').innerText = Owner || '';
      this._container.querySelector('.contract').innerText = DogovorNumber || '';

      var _ref2 = Array.isArray(CuttingAreas) && CuttingAreas.length ? CuttingAreas[0].volumes[0] : {},
          purpose_of_forest = _ref2.purpose_of_forest,
          protective_forest_category = _ref2.protective_forest_category,
          forestry_name = _ref2.forestry_name,
          local_forestry_name = _ref2.local_forestry_name,
          tract_name = _ref2.tract_name,
          quadrant_number = _ref2.quadrant_number,
          forest_inventory_unit_number = _ref2.forest_inventory_unit_number;

      this._container.querySelector('.purpose_of_forest').innerText = purpose_of_forest || '';
      this._container.querySelector('.protective_forest_category').innerText = protective_forest_category || '';
      this._container.querySelector('.forestry_name').innerText = forestry_name || '';
      this._container.querySelector('.local_forestry_name').innerText = local_forestry_name || '';
      this._container.querySelector('.tract_name').innerText = tract_name || '';
      this._container.querySelector('.quadrant_number').innerText = quadrant_number || '';
      this._container.querySelector('.forest_inventory_unit_number').innerText = forest_inventory_unit_number || '';
      this._container.querySelector('.content').innerHTML = "<table cellspacing=\"0\" cellpadding=\"0\">\n            <tbody>                \n                ".concat(Array.isArray(CuttingAreas) ? CuttingAreas.map(function (_ref3) {
        var num = _ref3.num,
            volumes = _ref3.volumes;
        return "<tr class=\"num\">\n                        <td>".concat(_this2.translate('declaration.num'), "</td>\n                        <td>").concat(num || '', "</td>\n                    </tr>\n                    ").concat(Array.isArray(volumes) ? volumes.map(function (_ref4) {
          var total_square = _ref4.total_square,
              felling_form = _ref4.felling_form,
              felling_type = _ref4.felling_type,
              farm = _ref4.farm,
              species = _ref4.species,
              unit_of_measurement = _ref4.unit_of_measurement,
              stock = _ref4.stock;
          return "<tr>\n                            <td>".concat(_this2.translate('declaration.total_square'), ", ").concat(_this2.translate('units.ha'), "</td>\n                            <td class=\"amount\">").concat(_this2.ha(total_square), "</td>\n                        </tr>\n                        <tr>\n                            <td>").concat(_this2.translate('declaration.felling_form'), "</td>\n                            <td class=\"amount\">").concat(felling_form || '', "</td>\n                        </tr>\n                        <tr>\n                            <td>").concat(_this2.translate('declaration.felling_type'), "</td>\n                            <td class=\"amount\">").concat(felling_type || '', "</td>\n                        </tr>\n                        <tr>\n                            <td>").concat(_this2.translate('declaration.farm'), "</td>\n                            <td class=\"amount\">").concat(farm || '', "</td>\n                        </tr>\n                        <tr>\n                            <td>").concat(_this2.translate('declaration.species'), "</td>\n                            <td class=\"amount\">").concat(species || '', "</td>\n                        </tr>                        \n                        <tr>\n                            <td>").concat(_this2.translate('declaration.stock'), ", ").concat(_this2.translate('units.m'), "<sup>3</sup></td>\n                            <td class=\"amount\">").concat(_this2.m(stock), "</td>\n                        </tr>");
        }).join('') : '');
      }).join('') : '', "              \n            </tbody>\n        </table>");
    }
  }, {
    key: "getStyleHook",
    value: function getStyleHook(kind, item) {
      if (kind === 'declarations') {
        return item.id === this._gmx_id ? STYLES : {};
      } else {
        return {};
      }
    }
  }, {
    key: "close",
    value: function close() {
      this._gmx_id = null;

      _get(_getPrototypeOf(Declaration.prototype), "close", this).call(this);
    }
  }]);

  return Declaration;
}(View);

var Declarations = /*#__PURE__*/function (_LayerController) {
  _inherits(Declarations, _LayerController);

  var _super = _createSuper(Declarations);

  function Declarations(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layer = _ref.layer,
        legend = _ref.legend,
        path = _ref.path;

    _classCallCheck(this, Declarations);

    _this = _super.call(this, {
      kind: 'declarations',
      map: map,
      content: content,
      notifications: notifications,
      layer: layer,
      legend: legend
    });
    _this._path = path;
    _this._view = _this._content.add(_this._kind, Declaration);

    _this._view.on('close', function () {
      _this._gmx_id = null;

      _this._layer.repaint();
    });

    return _this;
  }

  _createClass(Declarations, [{
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var _e$gmx, id, properties, gmx_id, data;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.canClick) {
                  _context.next = 12;
                  break;
                }

                L.DomEvent.stopPropagation(e);
                _e$gmx = e.gmx, id = _e$gmx.id, properties = _e$gmx.properties;
                gmx_id = this._view.toggle(id);

                if (!gmx_id) {
                  _context.next = 11;
                  break;
                }

                _context.next = 7;
                return this.httpGet("".concat(this._path, "/Forest/GetForestDeclarationInformation"), {
                  ForestDeclarationID: properties.id,
                  debug: true
                });

              case 7:
                data = _context.sent;

                if (data) {
                  this._view.open(_objectSpread2({
                    gmx_id: gmx_id
                  }, data));

                  this._layer.repaint();
                }

                _context.next = 12;
                break;

              case 11:
                this._view.close();

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _click(_x) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }]);

  return Declarations;
}(LayerController);

var strings$1 = {
  rus: {
    hotspot: {
      title: 'ÐÑÐ¸Ð±Ð»Ð¸Ð·ÑÑÐµ ÐºÐ°ÑÑÑ Ð´Ð»Ñ Ð·Ð°Ð³ÑÑÐ·ÐºÐ¸ Ð½Ð° ÑÐ°Ð¹Ð¼Ð»Ð°Ð¹Ð½',
      fire: 'ÐÐ¾Ð¶Ð°Ñ',
      date: 'ÐÐ°ÑÐ° Ð¾Ð±Ð½Ð°ÑÑÐ¶ÐµÐ½Ð¸Ñ',
      satelite: 'Ð¡Ð¿ÑÑÐ½Ð¸Ðº',
      from: 'ÐÑÑÐ¾ÑÐ½Ð¸Ðº',
      scanex: 'Ð¡ÐÐÐÐ­ÐÐ¡',
      confidence: 'ÐÐ¾ÑÑÐ¾Ð²ÐµÑÐ½Ð¾ÑÑÑ',
      brightness: 'Ð¢ÐµÐ¼Ð¿ÐµÑÐ°ÑÑÑÐ° (Ð)',
      frp: 'ÐÐ¾ÑÐ½Ð¾ÑÑÑ Ð¿Ð¾Ð¶Ð°ÑÐ°',
      coords: 'ÐÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ'
    }
  }
};

var Fires = /*#__PURE__*/function (_BaseView) {
  _inherits(Fires, _BaseView);

  var _super = _createSuper(Fires);

  function Fires(container) {
    _classCallCheck(this, Fires);

    return _super.call(this, container, strings$1);
  }

  _createClass(Fires, [{
    key: "open",
    value: function open(props) {
      _get(_getPrototypeOf(Fires.prototype), "open", this).call(this);

      this._container.innerHTML = "<table cellspacing=\"0\" cellpadding=\"0\">\n            <thead>\n                <tr>\n                    <th colspan=\"2\" class=\"title\">".concat(this.translate('hotspot.fire'), "</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td class=\"name\">").concat(this.translate('hotspot.date'), "</td>\n                    <td class=\"value\">").concat(this.date(props.Timestamp * 1000), "</td>\n                </tr>\n                <tr>\n                    <td class=\"name\">").concat(this.translate('hotspot.satelite'), "</td>\n                    <td class=\"value\">").concat(props.Satellite, "</td>\n                </tr>\n                <tr>\n                    <td class=\"name\">").concat(this.translate('hotspot.from'), "</td>\n                    <td class=\"value\">").concat(this.translate('hotspot.scanex'), "</td>\n                </tr>\n                <tr>\n                    <td class=\"name\">").concat(this.translate('hotspot.confidence'), "</td>\n                    <td class=\"value\">").concat(props.Confidence, " %</td>\n                </tr>\n                <tr>\n                    <td class=\"name\">").concat(this.translate('hotspot.brightness'), "</td>\n                    <td class=\"value\">").concat(props.Brightness, "</td>\n                </tr>\n                <tr>\n                    <td class=\"name\">").concat(this.translate('hotspot.frp'), "</td>\n                    <td class=\"value\">").concat(props.Frp, "</td>\n                </tr>\n                <tr>\n                    <td class=\"name\">").concat(this.translate('hotspot.coords'), "</td>\n                    <td class=\"value\">").concat(props.coords, "</td>\n                </tr>\n            </tbody>\n        </table>");
    }
  }]);

  return Fires;
}(View);

var translate$4 = T.getText.bind(T);
var hotSpotLayerID = '9DC30891452449DD8D551D0AA62FFF54';

var Fires$1 = /*#__PURE__*/function (_EventTarget) {
  _inherits(Fires$1, _EventTarget);

  var _super = _createSuper(Fires$1);

  function Fires$1(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layers = _ref.layers,
        legend = _ref.legend,
        dateInterval = _ref.dateInterval,
        permissions = _ref.permissions;

    _classCallCheck(this, Fires$1);

    _this = _super.call(this);
    _this._map = map;
    _this._content = content;
    _this._layers = layers;
    _this._legend = legend;
    _this._dateInterval = dateInterval;
    _this._permissions = permissions;

    _this._legend.addComponent('fires', translate$4('legend.fires'));

    _this._legend.on('click', _this._toggle, _assertThisInitialized(_this));

    _this._view = _this._content.add('fires', Fires);
    return _this;
  }

  _createClass(Fires$1, [{
    key: "_getHotspots",
    value: function () {
      var _getHotspots2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var arr, layer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._hotspotLayer) {
                  _context.next = 9;
                  break;
                }

                _context.next = 3;
                return L.gmx.loadLayers([{
                  mapID: '9746DBC72F3D438C99EB9C76855B5FBC',
                  // ÑÐ»Ð¾Ð¹ Ð»ÐµÐ¶Ð¸Ñ Ð² ÐºÐ°ÑÑÐµ "Forestry" Ð½Ð° maps.kosmosnimki.ru
                  layerID: hotSpotLayerID
                }], {});

              case 3:
                arr = _context.sent;
                layer = arr[0];
                this._hotspotLayer = layer;

                this._hotspotLayer.disablePopup();

                this._hotspotLayer.on('click', this._click, this);

                this._dateInterval.addLayer(this._hotspotLayer);

              case 9:
                return _context.abrupt("return", this._hotspotLayer);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _getHotspots() {
        return _getHotspots2.apply(this, arguments);
      }

      return _getHotspots;
    }()
  }, {
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(e) {
        var properties, latlng, coords;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.canClick) {
                  L.DomEvent.stopPropagation(e);
                  properties = e.gmx.properties, latlng = e.latlng;
                  coords = L.gmxUtil.formatCoordinates(latlng, 1);

                  this._view.open(_objectSpread2({
                    coords: coords
                  }, properties));
                }

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _click(_x) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }, {
    key: "_toggle",
    value: function () {
      var _toggle2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(e) {
        var id, visible, hsl, end, start;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                id = e.id, visible = e.visible;

                if (!(id === 'fires')) {
                  _context3.next = 10;
                  break;
                }

                if (!this._permissions.ForestFiresTimeLine) {
                  _context3.next = 9;
                  break;
                }

                _context3.next = 5;
                return this._getHotspots();

              case 5:
                hsl = _context3.sent;

                if (visible) {
                  this._dateInterval.addLayer(hsl);
                } else {
                  this._dateInterval.removeLayer(hsl);
                }

                _context3.next = 10;
                break;

              case 9:
                if (visible) {
                  end = new Date();
                  start = new Date(end.getTime() - 2 * 60 * 60 * 24 * 1000);

                  this._layers.fires.setDateInterval(start, end);

                  this._map.addLayer(this._layers.fires);
                } else {
                  this._map.removeLayer(this._layers.fires);
                }

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _toggle(_x2) {
        return _toggle2.apply(this, arguments);
      }

      return _toggle;
    }()
  }]);

  return Fires$1;
}(EventTarget);

var pikaday = createCommonjsModule(function (module, exports) {
  /*!
   * Pikaday
   *
   * Copyright Â© 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
   */
  (function (root, factory) {

    var moment$1;

    {
      // CommonJS module
      // Load moment.js as an optional dependency
      try {
        moment$1 = moment;
      } catch (e) {}

      module.exports = factory(moment$1);
    }
  })(commonjsGlobal, function (moment) {
    /**
     * feature detection and helper functions
     */

    var hasMoment = typeof moment === 'function',
        hasEventListeners = !!window.addEventListener,
        document = window.document,
        sto = window.setTimeout,
        addEvent = function addEvent(el, e, callback, capture) {
      if (hasEventListeners) {
        el.addEventListener(e, callback, !!capture);
      } else {
        el.attachEvent('on' + e, callback);
      }
    },
        removeEvent = function removeEvent(el, e, callback, capture) {
      if (hasEventListeners) {
        el.removeEventListener(e, callback, !!capture);
      } else {
        el.detachEvent('on' + e, callback);
      }
    },
        trim = function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    },
        hasClass = function hasClass(el, cn) {
      return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
    },
        addClass = function addClass(el, cn) {
      if (!hasClass(el, cn)) {
        el.className = el.className === '' ? cn : el.className + ' ' + cn;
      }
    },
        removeClass = function removeClass(el, cn) {
      el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
    },
        isArray = function isArray(obj) {
      return /Array/.test(Object.prototype.toString.call(obj));
    },
        isDate = function isDate(obj) {
      return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    },
        isWeekend = function isWeekend(date) {
      var day = date.getDay();
      return day === 0 || day === 6;
    },
        isLeapYear = function isLeapYear(year) {
      // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },
        getDaysInMonth = function getDaysInMonth(year, month) {
      return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },
        setToStartOfDay = function setToStartOfDay(date) {
      if (isDate(date)) date.setHours(0, 0, 0, 0);
    },
        compareDates = function compareDates(a, b) {
      // weak date comparison (use setToStartOfDay(date) to ensure correct result)
      return a.getTime() === b.getTime();
    },
        extend = function extend(to, from, overwrite) {
      var prop, hasProp;

      for (prop in from) {
        hasProp = to[prop] !== undefined;

        if (hasProp && _typeof(from[prop]) === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
          if (isDate(from[prop])) {
            if (overwrite) {
              to[prop] = new Date(from[prop].getTime());
            }
          } else if (isArray(from[prop])) {
            if (overwrite) {
              to[prop] = from[prop].slice(0);
            }
          } else {
            to[prop] = extend({}, from[prop], overwrite);
          }
        } else if (overwrite || !hasProp) {
          to[prop] = from[prop];
        }
      }

      return to;
    },
        fireEvent = function fireEvent(el, eventName, data) {
      var ev;

      if (document.createEvent) {
        ev = document.createEvent('HTMLEvents');
        ev.initEvent(eventName, true, false);
        ev = extend(ev, data);
        el.dispatchEvent(ev);
      } else if (document.createEventObject) {
        ev = document.createEventObject();
        ev = extend(ev, data);
        el.fireEvent('on' + eventName, ev);
      }
    },
        adjustCalendar = function adjustCalendar(calendar) {
      if (calendar.month < 0) {
        calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
        calendar.month += 12;
      }

      if (calendar.month > 11) {
        calendar.year += Math.floor(Math.abs(calendar.month) / 12);
        calendar.month -= 12;
      }

      return calendar;
    },

    /**
     * defaults and localisation
     */
    defaults = {
      // bind the picker to a form field
      field: null,
      // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
      bound: undefined,
      // data-attribute on the input field with an aria assistance tekst (only applied when `bound` is set)
      ariaLabel: 'Use the arrow keys to pick a date',
      // position of the datepicker, relative to the field (default to bottom & left)
      // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
      position: 'bottom left',
      // automatically fit in the viewport even if it means repositioning from the position option
      reposition: true,
      // the default output format for `.toString()` and `field` value
      format: 'YYYY-MM-DD',
      // the toString function which gets passed a current date object and format
      // and returns a string
      toString: null,
      // used to create date object from current input string
      parse: null,
      // the initial date to view when first opened
      defaultDate: null,
      // make the `defaultDate` the initial selected value
      setDefaultDate: false,
      // first day of week (0: Sunday, 1: Monday etc)
      firstDay: 0,
      // the default flag for moment's strict date parsing
      formatStrict: false,
      // the minimum/earliest date that can be selected
      minDate: null,
      // the maximum/latest date that can be selected
      maxDate: null,
      // number of years either side, or array of upper/lower range
      yearRange: 10,
      // show week numbers at head of row
      showWeekNumber: false,
      // Week picker mode
      pickWholeWeek: false,
      // used internally (don't config outside)
      minYear: 0,
      maxYear: 9999,
      minMonth: undefined,
      maxMonth: undefined,
      startRange: null,
      endRange: null,
      isRTL: false,
      // Additional text to append to the year in the calendar title
      yearSuffix: '',
      // Render the month after year in the calendar title
      showMonthAfterYear: false,
      // Render days of the calendar grid that fall in the next or previous month
      showDaysInNextAndPreviousMonths: false,
      // Allows user to select days that fall in the next or previous month
      enableSelectionDaysInNextAndPreviousMonths: false,
      // how many months are visible
      numberOfMonths: 1,
      // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
      // only used for the first display or when a selected date is not visible
      mainCalendar: 'left',
      // Specify a DOM element to render the calendar in
      container: undefined,
      // Blur field when date is selected
      blurFieldOnSelect: true,
      // internationalization
      i18n: {
        previousMonth: 'Previous Month',
        nextMonth: 'Next Month',
        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
      },
      // Theme Classname
      theme: null,
      // events array
      events: [],
      // callback function
      onSelect: null,
      onOpen: null,
      onClose: null,
      onDraw: null,
      // Enable keyboard input
      keyboardInput: true
    },

    /**
     * templating functions to abstract HTML rendering
     */
    renderDayName = function renderDayName(opts, day, abbr) {
      day += opts.firstDay;

      while (day >= 7) {
        day -= 7;
      }

      return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    },
        renderDay = function renderDay(opts) {
      var arr = [];
      var ariaSelected = 'false';

      if (opts.isEmpty) {
        if (opts.showDaysInNextAndPreviousMonths) {
          arr.push('is-outside-current-month');

          if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
            arr.push('is-selection-disabled');
          }
        } else {
          return '<td class="is-empty"></td>';
        }
      }

      if (opts.isDisabled) {
        arr.push('is-disabled');
      }

      if (opts.isToday) {
        arr.push('is-today');
      }

      if (opts.isSelected) {
        arr.push('is-selected');
        ariaSelected = 'true';
      }

      if (opts.hasEvent) {
        arr.push('has-event');
      }

      if (opts.isInRange) {
        arr.push('is-inrange');
      }

      if (opts.isStartRange) {
        arr.push('is-startrange');
      }

      if (opts.isEndRange) {
        arr.push('is-endrange');
      }

      return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' + '<button class="pika-button pika-day" type="button" ' + 'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + '</button>' + '</td>';
    },
        renderWeek = function renderWeek(d, m, y) {
      // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
      var onejan = new Date(y, 0, 1),
          weekNum = Math.ceil(((new Date(y, m, d) - onejan) / 86400000 + onejan.getDay() + 1) / 7);
      return '<td class="pika-week">' + weekNum + '</td>';
    },
        renderRow = function renderRow(days, isRTL, pickWholeWeek, isRowSelected) {
      return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
    },
        renderBody = function renderBody(rows) {
      return '<tbody>' + rows.join('') + '</tbody>';
    },
        renderHead = function renderHead(opts) {
      var i,
          arr = [];

      if (opts.showWeekNumber) {
        arr.push('<th></th>');
      }

      for (i = 0; i < 7; i++) {
        arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
      }

      return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
    },
        renderTitle = function renderTitle(instance, c, year, month, refYear, randId) {
      var i,
          j,
          arr,
          opts = instance._o,
          isMinYear = year === opts.minYear,
          isMaxYear = year === opts.maxYear,
          html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
          monthHtml,
          yearHtml,
          prev = true,
          next = true;

      for (arr = [], i = 0; i < 12; i++) {
        arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : '') + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? 'disabled="disabled"' : '') + '>' + opts.i18n.months[i] + '</option>');
      }

      monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

      if (isArray(opts.yearRange)) {
        i = opts.yearRange[0];
        j = opts.yearRange[1] + 1;
      } else {
        i = year - opts.yearRange;
        j = 1 + year + opts.yearRange;
      }

      for (arr = []; i < j && i <= opts.maxYear; i++) {
        if (i >= opts.minYear) {
          arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : '') + '>' + i + '</option>');
        }
      }

      yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

      if (opts.showMonthAfterYear) {
        html += yearHtml + monthHtml;
      } else {
        html += monthHtml + yearHtml;
      }

      if (isMinYear && (month === 0 || opts.minMonth >= month)) {
        prev = false;
      }

      if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
        next = false;
      }

      if (c === 0) {
        html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
      }

      if (c === instance._o.numberOfMonths - 1) {
        html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
      }

      return html += '</div>';
    },
        renderTable = function renderTable(opts, data, randId) {
      return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
    },

    /**
     * Pikaday constructor
     */
    Pikaday = function Pikaday(options) {
      var self = this,
          opts = self.config(options);

      self._onMouseDown = function (e) {
        if (!self._v) {
          return;
        }

        e = e || window.event;
        var target = e.target || e.srcElement;

        if (!target) {
          return;
        }

        if (!hasClass(target, 'is-disabled')) {
          if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
            self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));

            if (opts.bound) {
              sto(function () {
                self.hide();

                if (opts.blurFieldOnSelect && opts.field) {
                  opts.field.blur();
                }
              }, 100);
            }
          } else if (hasClass(target, 'pika-prev')) {
            self.prevMonth();
          } else if (hasClass(target, 'pika-next')) {
            self.nextMonth();
          }
        }

        if (!hasClass(target, 'pika-select')) {
          // if this is touch event prevent mouse events emulation
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
            return false;
          }
        } else {
          self._c = true;
        }
      };

      self._onChange = function (e) {
        e = e || window.event;
        var target = e.target || e.srcElement;

        if (!target) {
          return;
        }

        if (hasClass(target, 'pika-select-month')) {
          self.gotoMonth(target.value);
        } else if (hasClass(target, 'pika-select-year')) {
          self.gotoYear(target.value);
        }
      };

      self._onKeyChange = function (e) {
        e = e || window.event;

        if (self.isVisible()) {
          switch (e.keyCode) {
            case 13:
            case 27:
              if (opts.field) {
                opts.field.blur();
              }

              break;

            case 37:
              e.preventDefault();
              self.adjustDate('subtract', 1);
              break;

            case 38:
              self.adjustDate('subtract', 7);
              break;

            case 39:
              self.adjustDate('add', 1);
              break;

            case 40:
              self.adjustDate('add', 7);
              break;
          }
        }
      };

      self._onInputChange = function (e) {
        var date;

        if (e.firedBy === self) {
          return;
        }

        if (opts.parse) {
          date = opts.parse(opts.field.value, opts.format);
        } else if (hasMoment) {
          date = moment(opts.field.value, opts.format, opts.formatStrict);
          date = date && date.isValid() ? date.toDate() : null;
        } else {
          date = new Date(Date.parse(opts.field.value));
        }

        if (isDate(date)) {
          self.setDate(date);
        }

        if (!self._v) {
          self.show();
        }
      };

      self._onInputFocus = function () {
        self.show();
      };

      self._onInputClick = function () {
        self.show();
      };

      self._onInputBlur = function () {
        // IE allows pika div to gain focus; catch blur the input field
        var pEl = document.activeElement;

        do {
          if (hasClass(pEl, 'pika-single')) {
            return;
          }
        } while (pEl = pEl.parentNode);

        if (!self._c) {
          self._b = sto(function () {
            self.hide();
          }, 50);
        }

        self._c = false;
      };

      self._onClick = function (e) {
        e = e || window.event;
        var target = e.target || e.srcElement,
            pEl = target;

        if (!target) {
          return;
        }

        if (!hasEventListeners && hasClass(target, 'pika-select')) {
          if (!target.onchange) {
            target.setAttribute('onchange', 'return;');
            addEvent(target, 'change', self._onChange);
          }
        }

        do {
          if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
            return;
          }
        } while (pEl = pEl.parentNode);

        if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
          self.hide();
        }
      };

      self.el = document.createElement('div');
      self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');
      addEvent(self.el, 'mousedown', self._onMouseDown, true);
      addEvent(self.el, 'touchend', self._onMouseDown, true);
      addEvent(self.el, 'change', self._onChange);

      if (opts.keyboardInput) {
        addEvent(document, 'keydown', self._onKeyChange);
      }

      if (opts.field) {
        if (opts.container) {
          opts.container.appendChild(self.el);
        } else if (opts.bound) {
          document.body.appendChild(self.el);
        } else {
          opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
        }

        addEvent(opts.field, 'change', self._onInputChange);

        if (!opts.defaultDate) {
          if (hasMoment && opts.field.value) {
            opts.defaultDate = moment(opts.field.value, opts.format).toDate();
          } else {
            opts.defaultDate = new Date(Date.parse(opts.field.value));
          }

          opts.setDefaultDate = true;
        }
      }

      var defDate = opts.defaultDate;

      if (isDate(defDate)) {
        if (opts.setDefaultDate) {
          self.setDate(defDate, true);
        } else {
          self.gotoDate(defDate);
        }
      } else {
        self.gotoDate(new Date());
      }

      if (opts.bound) {
        this.hide();
        self.el.className += ' is-bound';
        addEvent(opts.trigger, 'click', self._onInputClick);
        addEvent(opts.trigger, 'focus', self._onInputFocus);
        addEvent(opts.trigger, 'blur', self._onInputBlur);
      } else {
        this.show();
      }
    };
    /**
     * public Pikaday API
     */


    Pikaday.prototype = {
      /**
       * configure functionality
       */
      config: function config(options) {
        if (!this._o) {
          this._o = extend({}, defaults, true);
        }

        var opts = extend(this._o, options, true);
        opts.isRTL = !!opts.isRTL;
        opts.field = opts.field && opts.field.nodeName ? opts.field : null;
        opts.theme = typeof opts.theme === 'string' && opts.theme ? opts.theme : null;
        opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);
        opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
        opts.disableWeekends = !!opts.disableWeekends;
        opts.disableDayFn = typeof opts.disableDayFn === 'function' ? opts.disableDayFn : null;
        var nom = parseInt(opts.numberOfMonths, 10) || 1;
        opts.numberOfMonths = nom > 4 ? 4 : nom;

        if (!isDate(opts.minDate)) {
          opts.minDate = false;
        }

        if (!isDate(opts.maxDate)) {
          opts.maxDate = false;
        }

        if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
          opts.maxDate = opts.minDate = false;
        }

        if (opts.minDate) {
          this.setMinDate(opts.minDate);
        }

        if (opts.maxDate) {
          this.setMaxDate(opts.maxDate);
        }

        if (isArray(opts.yearRange)) {
          var fallback = new Date().getFullYear() - 10;
          opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
          opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
        } else {
          opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;

          if (opts.yearRange > 100) {
            opts.yearRange = 100;
          }
        }

        return opts;
      },

      /**
       * return a formatted string of the current selection (using Moment.js if available)
       */
      toString: function toString(format) {
        format = format || this._o.format;

        if (!isDate(this._d)) {
          return '';
        }

        if (this._o.toString) {
          return this._o.toString(this._d, format);
        }

        if (hasMoment) {
          return moment(this._d).format(format);
        }

        return this._d.toDateString();
      },

      /**
       * return a Moment.js object of the current selection (if available)
       */
      getMoment: function getMoment() {
        return hasMoment ? moment(this._d) : null;
      },

      /**
       * set the current selection from a Moment.js object (if available)
       */
      setMoment: function setMoment(date, preventOnSelect) {
        if (hasMoment && moment.isMoment(date)) {
          this.setDate(date.toDate(), preventOnSelect);
        }
      },

      /**
       * return a Date object of the current selection
       */
      getDate: function getDate() {
        return isDate(this._d) ? new Date(this._d.getTime()) : null;
      },

      /**
       * set the current selection
       */
      setDate: function setDate(date, preventOnSelect) {
        if (!date) {
          this._d = null;

          if (this._o.field) {
            this._o.field.value = '';
            fireEvent(this._o.field, 'change', {
              firedBy: this
            });
          }

          return this.draw();
        }

        if (typeof date === 'string') {
          date = new Date(Date.parse(date));
        }

        if (!isDate(date)) {
          return;
        }

        var min = this._o.minDate,
            max = this._o.maxDate;

        if (isDate(min) && date < min) {
          date = min;
        } else if (isDate(max) && date > max) {
          date = max;
        }

        this._d = new Date(date.getTime());
        setToStartOfDay(this._d);
        this.gotoDate(this._d);

        if (this._o.field) {
          this._o.field.value = this.toString();
          fireEvent(this._o.field, 'change', {
            firedBy: this
          });
        }

        if (!preventOnSelect && typeof this._o.onSelect === 'function') {
          this._o.onSelect.call(this, this.getDate());
        }
      },

      /**
       * change view to a specific date
       */
      gotoDate: function gotoDate(date) {
        var newCalendar = true;

        if (!isDate(date)) {
          return;
        }

        if (this.calendars) {
          var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
              lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),
              visibleDate = date.getTime(); // get the end of the month

          lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
          lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
          newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
        }

        if (newCalendar) {
          this.calendars = [{
            month: date.getMonth(),
            year: date.getFullYear()
          }];

          if (this._o.mainCalendar === 'right') {
            this.calendars[0].month += 1 - this._o.numberOfMonths;
          }
        }

        this.adjustCalendars();
      },
      adjustDate: function adjustDate(sign, days) {
        var day = this.getDate() || new Date();
        var difference = parseInt(days) * 24 * 60 * 60 * 1000;
        var newDay;

        if (sign === 'add') {
          newDay = new Date(day.valueOf() + difference);
        } else if (sign === 'subtract') {
          newDay = new Date(day.valueOf() - difference);
        }

        this.setDate(newDay);
      },
      adjustCalendars: function adjustCalendars() {
        this.calendars[0] = adjustCalendar(this.calendars[0]);

        for (var c = 1; c < this._o.numberOfMonths; c++) {
          this.calendars[c] = adjustCalendar({
            month: this.calendars[0].month + c,
            year: this.calendars[0].year
          });
        }

        this.draw();
      },
      gotoToday: function gotoToday() {
        this.gotoDate(new Date());
      },

      /**
       * change view to a specific month (zero-index, e.g. 0: January)
       */
      gotoMonth: function gotoMonth(month) {
        if (!isNaN(month)) {
          this.calendars[0].month = parseInt(month, 10);
          this.adjustCalendars();
        }
      },
      nextMonth: function nextMonth() {
        this.calendars[0].month++;
        this.adjustCalendars();
      },
      prevMonth: function prevMonth() {
        this.calendars[0].month--;
        this.adjustCalendars();
      },

      /**
       * change view to a specific full year (e.g. "2012")
       */
      gotoYear: function gotoYear(year) {
        if (!isNaN(year)) {
          this.calendars[0].year = parseInt(year, 10);
          this.adjustCalendars();
        }
      },

      /**
       * change the minDate
       */
      setMinDate: function setMinDate(value) {
        if (value instanceof Date) {
          setToStartOfDay(value);
          this._o.minDate = value;
          this._o.minYear = value.getFullYear();
          this._o.minMonth = value.getMonth();
        } else {
          this._o.minDate = defaults.minDate;
          this._o.minYear = defaults.minYear;
          this._o.minMonth = defaults.minMonth;
          this._o.startRange = defaults.startRange;
        }

        this.draw();
      },

      /**
       * change the maxDate
       */
      setMaxDate: function setMaxDate(value) {
        if (value instanceof Date) {
          setToStartOfDay(value);
          this._o.maxDate = value;
          this._o.maxYear = value.getFullYear();
          this._o.maxMonth = value.getMonth();
        } else {
          this._o.maxDate = defaults.maxDate;
          this._o.maxYear = defaults.maxYear;
          this._o.maxMonth = defaults.maxMonth;
          this._o.endRange = defaults.endRange;
        }

        this.draw();
      },
      setStartRange: function setStartRange(value) {
        this._o.startRange = value;
      },
      setEndRange: function setEndRange(value) {
        this._o.endRange = value;
      },

      /**
       * refresh the HTML
       */
      draw: function draw(force) {
        if (!this._v && !force) {
          return;
        }

        var opts = this._o,
            minYear = opts.minYear,
            maxYear = opts.maxYear,
            minMonth = opts.minMonth,
            maxMonth = opts.maxMonth,
            html = '',
            randId;

        if (this._y <= minYear) {
          this._y = minYear;

          if (!isNaN(minMonth) && this._m < minMonth) {
            this._m = minMonth;
          }
        }

        if (this._y >= maxYear) {
          this._y = maxYear;

          if (!isNaN(maxMonth) && this._m > maxMonth) {
            this._m = maxMonth;
          }
        }

        randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

        for (var c = 0; c < opts.numberOfMonths; c++) {
          html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
        }

        this.el.innerHTML = html;

        if (opts.bound) {
          if (opts.field.type !== 'hidden') {
            sto(function () {
              opts.trigger.focus();
            }, 1);
          }
        }

        if (typeof this._o.onDraw === 'function') {
          this._o.onDraw(this);
        }

        if (opts.bound) {
          // let the screen reader user know to use arrow keys
          opts.field.setAttribute('aria-label', opts.ariaLabel);
        }
      },
      adjustPosition: function adjustPosition() {
        var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect, leftAligned, bottomAligned;
        if (this._o.container) return;
        this.el.style.position = 'absolute';
        field = this._o.trigger;
        pEl = field;
        width = this.el.offsetWidth;
        height = this.el.offsetHeight;
        viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
        leftAligned = true;
        bottomAligned = true;

        if (typeof field.getBoundingClientRect === 'function') {
          clientRect = field.getBoundingClientRect();
          left = clientRect.left + window.pageXOffset;
          top = clientRect.bottom + window.pageYOffset;
        } else {
          left = pEl.offsetLeft;
          top = pEl.offsetTop + pEl.offsetHeight;

          while (pEl = pEl.offsetParent) {
            left += pEl.offsetLeft;
            top += pEl.offsetTop;
          }
        } // default position is bottom & left


        if (this._o.reposition && left + width > viewportWidth || this._o.position.indexOf('right') > -1 && left - width + field.offsetWidth > 0) {
          left = left - width + field.offsetWidth;
          leftAligned = false;
        }

        if (this._o.reposition && top + height > viewportHeight + scrollTop || this._o.position.indexOf('top') > -1 && top - height - field.offsetHeight > 0) {
          top = top - height - field.offsetHeight;
          bottomAligned = false;
        }

        this.el.style.left = left + 'px';
        this.el.style.top = top + 'px';
        addClass(this.el, leftAligned ? 'left-aligned' : 'right-aligned');
        addClass(this.el, bottomAligned ? 'bottom-aligned' : 'top-aligned');
        removeClass(this.el, !leftAligned ? 'left-aligned' : 'right-aligned');
        removeClass(this.el, !bottomAligned ? 'bottom-aligned' : 'top-aligned');
      },

      /**
       * render HTML for a particular month
       */
      render: function render(year, month, randId) {
        var opts = this._o,
            now = new Date(),
            days = getDaysInMonth(year, month),
            before = new Date(year, month, 1).getDay(),
            data = [],
            row = [];
        setToStartOfDay(now);

        if (opts.firstDay > 0) {
          before -= opts.firstDay;

          if (before < 0) {
            before += 7;
          }
        }

        var previousMonth = month === 0 ? 11 : month - 1,
            nextMonth = month === 11 ? 0 : month + 1,
            yearOfPreviousMonth = month === 0 ? year - 1 : year,
            yearOfNextMonth = month === 11 ? year + 1 : year,
            daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
        var cells = days + before,
            after = cells;

        while (after > 7) {
          after -= 7;
        }

        cells += 7 - after;
        var isWeekSelected = false;

        for (var i = 0, r = 0; i < cells; i++) {
          var day = new Date(year, month, 1 + (i - before)),
              isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
              isToday = compareDates(day, now),
              hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
              isEmpty = i < before || i >= days + before,
              dayNumber = 1 + (i - before),
              monthNumber = month,
              yearNumber = year,
              isStartRange = opts.startRange && compareDates(opts.startRange, day),
              isEndRange = opts.endRange && compareDates(opts.endRange, day),
              isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
              isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);

          if (isEmpty) {
            if (i < before) {
              dayNumber = daysInPreviousMonth + dayNumber;
              monthNumber = previousMonth;
              yearNumber = yearOfPreviousMonth;
            } else {
              dayNumber = dayNumber - days;
              monthNumber = nextMonth;
              yearNumber = yearOfNextMonth;
            }
          }

          var dayConfig = {
            day: dayNumber,
            month: monthNumber,
            year: yearNumber,
            hasEvent: hasEvent,
            isSelected: isSelected,
            isToday: isToday,
            isDisabled: isDisabled,
            isEmpty: isEmpty,
            isStartRange: isStartRange,
            isEndRange: isEndRange,
            isInRange: isInRange,
            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
            enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
          };

          if (opts.pickWholeWeek && isSelected) {
            isWeekSelected = true;
          }

          row.push(renderDay(dayConfig));

          if (++r === 7) {
            if (opts.showWeekNumber) {
              row.unshift(renderWeek(i - before, month, year));
            }

            data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
            row = [];
            r = 0;
            isWeekSelected = false;
          }
        }

        return renderTable(opts, data, randId);
      },
      isVisible: function isVisible() {
        return this._v;
      },
      show: function show() {
        if (!this.isVisible()) {
          this._v = true;
          this.draw();
          removeClass(this.el, 'is-hidden');

          if (this._o.bound) {
            addEvent(document, 'click', this._onClick);
            this.adjustPosition();
          }

          if (typeof this._o.onOpen === 'function') {
            this._o.onOpen.call(this);
          }
        }
      },
      hide: function hide() {
        var v = this._v;

        if (v !== false) {
          if (this._o.bound) {
            removeEvent(document, 'click', this._onClick);
          }

          this.el.style.position = 'static'; // reset

          this.el.style.left = 'auto';
          this.el.style.top = 'auto';
          addClass(this.el, 'is-hidden');
          this._v = false;

          if (v !== undefined && typeof this._o.onClose === 'function') {
            this._o.onClose.call(this);
          }
        }
      },

      /**
       * GAME OVER
       */
      destroy: function destroy() {
        var opts = this._o;
        this.hide();
        removeEvent(this.el, 'mousedown', this._onMouseDown, true);
        removeEvent(this.el, 'touchend', this._onMouseDown, true);
        removeEvent(this.el, 'change', this._onChange);

        if (opts.keyboardInput) {
          removeEvent(document, 'keydown', this._onKeyChange);
        }

        if (opts.field) {
          removeEvent(opts.field, 'change', this._onInputChange);

          if (opts.bound) {
            removeEvent(opts.trigger, 'click', this._onInputClick);
            removeEvent(opts.trigger, 'focus', this._onInputFocus);
            removeEvent(opts.trigger, 'blur', this._onInputBlur);
          }
        }

        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
      }
    };
    return Pikaday;
  });
});

var strings$2 = {
  rus: {
    incident: {
      title: 'Ð ÑÐ±ÐºÐ°',
      titleFire: 'ÐÐ°ÑÑ',
      titleDisease: 'ÐÐ°ÑÐ¾Ð»Ð¾Ð³Ð¸Ñ',
      areaFire: 'ÐÑÐ¾Ð¹Ð´ÐµÐ½Ð½Ð°Ñ Ð¿Ð¾Ð¶Ð°ÑÐ¾Ð¼ Ð¿Ð»Ð¾ÑÐ°Ð´Ñ (ÐÐ°)',
      areaFire1: 'ÐÑÐ¾Ð¹Ð´ÐµÐ½Ð½Ð°Ñ Ð¿Ð¾Ð¶Ð°ÑÐ¾Ð¼ Ð¿Ð»Ð¾ÑÐ°Ð´Ñ Ð½Ð°ÑÐ°Ð¶Ð´ÐµÐ½Ð¸Ð¹, Ð¸Ð· ÐºÐ¾ÑÐ¾ÑÑÑ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð° ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð´ÑÐµÐ²ÐµÑÐ¸Ð½Ñ (ÐÐ°)',
      areaSpec: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ ÐºÑÐ»ÑÑÑÑ (ÐÐ°)',
      areaSpecNew: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ Ð¼Ð¾Ð»Ð¾Ð´Ð½ÑÐºÐ¾Ð² ÐµÑÑÐµÑÑÐ²ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¿ÑÐ¾Ð¸ÑÑÐ¾Ð¶Ð´ÐµÐ½Ð¸Ñ (ÐÐ°)',
      areaFireLast: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ Ð³Ð¾ÑÐµÐ»ÑÐ½Ð¸ÐºÐ¾Ð² Ð¿ÑÐ¾ÑÐ»ÑÑ Ð»ÐµÑ (ÐÐ°)',
      areaSpecNot: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ ÑÐµÐ´Ð¸Ð½ Ð¸ Ð½Ðµ Ð¿Ð¾ÐºÑÑÑÑÑ Ð»ÐµÑÐ¾Ð¼ Ð·ÐµÐ¼ÐµÐ»Ñ (ÐÐ°)',
      arend: 'ÐÑÐµÐ½Ð´Ð°ÑÐ¾Ñ',
      titleValue: 'ÐÐ±ÑÐµÐ¼ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹ Ð·Ð°Ð¿Ð°ÑÐ¾Ð² Ð´ÑÐµÐ²ÐµÑÐ¸Ð½Ñ',
      estimValue: 'Ð¿Ð¾ Ð¿ÑÐ¾Ð³Ð½Ð¾Ð·Ð°Ð¼ ÑÐ¸ÑÑÐµÐ¼Ñ',
      checkedValue: 'Ð¿Ð¾ Ð´Ð°Ð½Ð½ÑÐ¼ Ð½Ð°ÑÑÑÐ½Ð¾Ð¹ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸',
      Expert: 'ÐÑÐ²ÐµÑÑÑÐ²ÐµÐ½Ð½ÑÐ¹ ÑÐºÑÐ¿ÐµÑÑ',
      CheckingExpert: 'ÐÑÐ²ÐµÑÑÑÐ²ÐµÐ½Ð½ÑÐ¹ Ð·Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ Ð¸Ð½ÑÐ¸Ð´ÐµÐ½ÑÐ°',
      Probability: 'ÐÑÐ¾ÑÐµÐ½Ñ Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÐ¸ Ð¸Ð½ÑÐ¸Ð´ÐµÐ½ÑÐ°',
      Intensity: 'ÐÐ½ÑÐµÑÐ¸Ð²Ð½Ð¾ÑÑÑ',
      date: 'ÐÐ°ÑÐ° Ð¾Ð±Ð½Ð°ÑÑÐ¶ÐµÐ½Ð¸Ñ',
      dateInspect: 'ÐÐ°ÑÐ° Ð¾Ð±ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ñ',
      areaAll: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½Ð¸Ñ Ð²ÑÐµÐ³Ð¾ (ÐÐ°)',
      areaArenda: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½Ð¸Ñ Ð½Ð° Ð°ÑÐµÐ½Ð´Ð¾Ð²Ð°Ð½Ð½Ð¾Ð¹ ÑÐµÑÑÐ¸ÑÐ¾ÑÐ¸Ð¸ (ÐÐ°)',
      specialCommon: 'ÐÑÐµÐ¾Ð±Ð»Ð°Ð´Ð°ÑÑÐ°Ñ Ð¿ÑÐ¸ÑÐ¾Ð´Ð° Ð½Ð°ÑÐ°Ð¶Ð´ÐµÐ½Ð¸Ð¹',
      dateCheck: 'Ð¡ÑÐ¾Ðº Ð¿ÑÐ¾Ð²ÐµÐ²Ð´ÐµÐ½Ð¸Ñ Ð½Ð°ÑÑÑÐ½Ð¾Ð¹ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸',
      comment: 'ÐÐ¾Ð¼Ð¼ÐµÐ½ÑÐ°ÑÐ¸Ð¹',
      status: 'Ð¡ÑÐ°ÑÑÑ',
      bpla: 'Ð¡Ð½Ð¸Ð¼Ð¾Ðº Ñ ÐÐÐÐ',
      // bplaTitle: 'Ð¡Ð½Ð¸Ð¼Ð¾Ðº Ð·Ð¾Ð½Ñ Ð¸Ð½ÑÐ¸Ð´ÐµÐ½ÑÐ° Ñ ÐÐÐÐ.tiff',
      BplaView: 'ÐÑÐ¾ÑÐ¼Ð¾ÑÑ',
      BplaDownload: 'ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ',
      BplaRemove: 'Ð£Ð´Ð°Ð»Ð¸ÑÑ',
      docs: 'ÐÐ¾ÐºÑÐ¼ÐµÐ½ÑÑ',
      detail: 'ÐÐµÑÐ°Ð»Ð¸',
      editGeo: 'Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÐºÐ¾Ð½ÑÑÑ',
      saveGeo: 'Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ',
      downloadGeo: 'ÐÑÐ³ÑÑÐ·Ð¸ÑÑ ÐºÐ¾Ð½ÑÑÑ',
      verRastr: 'Ð Ð°ÑÑÑ Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÐ¸',
      maskWater: 'ÐÐ°ÑÐºÐ¸ Ð¾Ð±Ð»Ð°ÑÐ½Ð¾ÑÑÐ¸ Ð¸ Ð²Ð¾Ð´Ñ',
      IncidentCheck: 'ÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð½Ð° Ð¿ÑÐ¾Ð²ÐµÑÐºÑ',
      IncidentAccept: 'ÐÐ¾Ð´ÑÐ²ÐµÑÐ´Ð¸ÑÑ Ð¸Ð½ÑÐ¸Ð´ÐµÐ½Ñ',
      IncidentDecline: 'ÐÑÐºÐ»Ð¾Ð½Ð¸ÑÑ Ð¸Ð½ÑÐ¸Ð´ÐµÐ½Ñ'
    }
  }
};

// 2	"Ð² ÑÐ°Ð±Ð¾ÑÐµ"
// 3	"Ð»Ð¾Ð¶Ð½Ð°Ñ"
// 4	"Ð¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ"

var Incidents = /*#__PURE__*/function (_BaseView) {
  _inherits(Incidents, _BaseView);

  var _super = _createSuper(Incidents);

  function Incidents(container, _ref) {
    var _this;

    var permissions = _ref.permissions,
        layer = _ref.layer,
        path = _ref.path;

    _classCallCheck(this, Incidents);

    _this = _super.call(this, container, strings$2);
    _this._path = path;
    _this._layer = layer;
    _this._permission = permissions;
    _this._buttonsStr = '';

    if (_this._permission.IncidentDocuments) {
      _this._buttonsStr += "<button class=\"detailBtn button\">".concat(_this.translate('incident.detail'), "</button>");
    }

    if (_this._permission.IncidentEdit) {
      _this._buttonsStr += "<button class=\"editGeo button\">".concat(_this.translate('incident.editGeo'), "</button>");
    }

    if (_this._permission.IncidentSave) {
      _this._buttonsStr += "<button class=\"saveGeo button\">".concat(_this.translate('incident.saveGeo'), "</button>");
    }

    if (_this._permission.ContiurUnload) {
      _this._buttonsStr += "<button class=\"download button\">".concat(_this.translate('incident.downloadGeo'), "</button>");
    }

    if (_this._permission.ProbabilityRasterView) {
      _this._buttonsStr += "<button class=\"verRastr button\">".concat(_this.translate('incident.verRastr'), "</button>");
    }

    if (_this._permission.CloudMaskView) {
      _this._buttonsStr += "<button class=\"maskWater button\">".concat(_this.translate('incident.maskWater'), "</button>");
    }

    _this._container.classList.add('scanex-forestry-incident');

    return _this;
  }

  _createClass(Incidents, [{
    key: "_formatDate",
    value: function _formatDate(str) {
      return str && this.date(new Date(str)) || '';
    }
  }, {
    key: "_parseVyd",
    value: function _parseVyd(arr) {
      var _this2 = this;

      return arr.map(function (data) {
        if (Array.isArray(data.volumes) && data.volumes.length) {
          var str = data.volumes.map(function (it) {
            return "\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"species\">".concat(it.species, " (").concat(it.storey, ")</td>\n\t\t\t\t\t\t<td class=\"probable_volume\">").concat(_this2.m(it.probable_volume), " ").concat(_this2.translate('units.m'), "<sup>3</sup></td>\n\t\t\t\t\t\t<td class=\"confirmed_volume\"><span class=\"\"><input class=\"span-gray confirmed_vol\" id=\"").concat(it.wood_element_id, "\" type=\"text\" placeholder=\"\" value=\"").concat(_this2.m(it.confirmed_vol || 0), "\" />&nbsp;").concat(_this2.translate('units.m'), "<sup>3</sup></span></td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t");
          }).join('\n');
          return "\n\t\t\t\t<div class=\"vydel\">\n\t\t\t\t\t<div class=\"table2_row\">".concat(_this2.translate('incident.arend'), " <span>").concat(data.renter || '', "</span></div>\n\t\t\t\t\t<table cellspacing=\"0\" cellpadding=\"0\">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<th class=\"species\">").concat(_this2.translate('incident.titleValue'), "</th>\n\t\t\t\t\t\t\t\t<th class=\"probable_volume\">").concat(_this2.translate('incident.estimValue'), "</th>\n\t\t\t\t\t\t\t\t<th class=\"confirmed_volume\">").concat(_this2.translate('incident.checkedValue'), "</th>\n\t\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t").concat(str, "\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</div>");
        } else {
          return '';
        }
      }).join('\n');
    }
  }, {
    key: "_parseProps",
    value: function _parseProps(props) {
      return "\n\t\t\t<div class=\"table1_row\">".concat(this.translate('incident.status'), " <span>").concat(props.Status, "</span></div>\n\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.Expert'), " <span>").concat(props.Expert || '', "</span></div>\n\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.CheckingExpert'), " <span>").concat(props.CheckingExpert || '', "</span></div>\n\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.Probability'), " <span>").concat(this.fmt(Math.floor(10000 * (props.Probability || 0)) / 100), " %</span></div>\n\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.Intensity'), " <span>").concat(props.Intensity || 0, "</span></div>\n\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.date'), " <span>").concat(this._formatDate(props.Detected), "</span></div>\n\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.areaAll'), " <span>").concat(this.ha(props.Area || 0), "</span></div>\n\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.dateCheck'), " <input class=\"span-gray dateCheck\" type=\"text\" placeholder=\"\" value=").concat(this._formatDate(props.CheckDate), "></div>\n\t\t");
    }
  }, {
    key: "open",
    value: function open(data) {
      var _this3 = this;

      _get(_getPrototypeOf(Incidents.prototype), "open", this).call(this);

      var props = data.properties || {};
      var title = '';

      switch (props.class_id) {
        case 1:
          // Ð ÑÐ±ÐºÐ°
          title = "<div class=\"header1\">".concat(this.translate('incident.title'), "</div>");
          break;

        case 2:
          // Ð²ÐµÑÑÐ¾Ð²Ð°Ð»Ñ 
          title = "<div class=\"header1\">".concat(this.translate('incident.titleFire'), "</div>");
          break;

        case 3:
          // ÐÐ°ÑÐ¾Ð»Ð¾Ð³Ð¸Ñ
          title = "<div class=\"header1\">".concat(this.translate('incident.titleDisease'), "</div>");
          break;

        case 4:
          // ÐÐ°ÑÑ
          title = "<div class=\"header1\">".concat(this.translate('incident.titleFire'), "</div>");
          break;

        default:
          title = "<div class=\"header1\">".concat(this.translate('incident.title'), "</div>");
          break;
      }

      this._container.classList.add('minHeight');

      var str1 = this._parseVyd(data.ForestChange || []);

      var str2 = this._parseProps(data);

      this._container.innerHTML = "\n\t\t\t".concat(title, "\n\n\t\t\t<div class=\"inside\">\n\t\t\t\t<div class=\"inside_left\">\n\t\t\t\t\t<div class=\"table1\">\n\t\t\t\t\t\t").concat(str2, "\n\n\t\t\t\t\t\t<div class=\"table1_row\">").concat(this.translate('incident.comment'), "</div>\n\t\t\t\t\t\t\n\t\t\t\t\t\t<textarea class=\"usr-text-area\" ").concat(this._permission.IncidentEdit && data.Status === 'Ð² ÑÐ°Ð±Ð¾ÑÐµ' ? '' : 'disabled', ">").concat(data.Comment || '', "</textarea>\n\t\t\t\t\t\t<div class=\"table1_row \">").concat(this.translate('incident.bpla'), ":</div>\n\n\t\t\t\t\t\t<div class=\"table1_row \">\n\t\t\t\t\t\t\t<span>").concat(props.uav_date || '', "</span>\n\t\t\t\t\t\t\t<span>").concat(props.uav_description || '', "</span>\n\t\t\t\t\t\t\t<div class=\"group_buttons\">\n\t\t\t\t\t\t\t\t").concat(this._permission.BplaView && props.uav_raster_id ? "<div class=\"mini-green-but BplaView\">".concat(this.translate('incident.BplaView'), "</div>") : '', "\n\t\t\t\t\t\t\t\t").concat(this._permission.BplaDownload ? "<div class=\"mini-green-but BplaDownload\">".concat(this.translate('incident.BplaDownload'), "</div>") : '', "\n\t\t\t\t\t\t\t\t").concat(this._permission.BplaRemove && props.uav_raster_id ? "<div class=\"mini-green-but BplaRemove\">".concat(this.translate('incident.BplaRemove'), "</div>") : '', "\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t").concat(str1, "\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"rubka\">\n\t\t\t\t\t<div class=\"right-wrapper-top \">\n\t\t\t\t\t\t").concat(this._buttonsStr, "\n\t\t\t\t\t </div>\n\t\t\t\t\t<hr />\n\t\t\t\t\t <div class=\"right-wrapper-bottom \">\n\t\t\t\t\t\t").concat(this._permission.IncidentAccept && data.Status === 'Ð² ÑÐ°Ð±Ð¾ÑÐµ' ? "<button class=\"IncidentAccept button\">".concat(this.translate('incident.IncidentAccept'), "</button>") : '', "\n\t\t\t\t\t\t").concat(this._permission.IncidentCheck && data.Status === 'Ð½ÐµÐ¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ' ? "<button class=\"IncidentCheck button\">".concat(this.translate('incident.IncidentCheck'), "</button>") : '', "\n\t\t\t\t\t\t").concat(this._permission.IncidentDecline && (data.Status === 'Ð½ÐµÐ¿Ð¾Ð´ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð½Ð°Ñ' || data.Status === 'Ð² ÑÐ°Ð±Ð¾ÑÐµ') ? "<button class=\"IncidentDecline button\">".concat(this.translate('incident.IncidentDecline'), "</button>") : '', "\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>");

      var node = this._container.querySelector('.verRastr');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:verifyRaster', false, false);
          event.detail = _this3._rastId;

          _this3.dispatchEvent(event);
        });
      }

      node = this._container.querySelector('.download');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:download', false, false);
          event.detail = props.id;

          _this3.dispatchEvent(event);
        });
      }

      node = this._container.querySelector('.detailBtn');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:docs', false, false);
          event.detail = props.id;

          _this3.dispatchEvent(event);
        });

        if (data.Status !== 'Ð² ÑÐ°Ð±Ð¾ÑÐµ') {
          node.classList.add('hidden');
        }
      }

      node = this._container.querySelector('.editGeo');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:editGeo', false, false);

          _this3.dispatchEvent(event);
        });
      }

      node = this._container.querySelector('.saveGeo');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();

          _this3._saveItem(data);
        });
      }

      node = this._container.querySelector('.IncidentAccept');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:IncidentAccept', false, false);
          event.detail = {
            IncidentID: props.id,
            comment: _this3._commentNode ? _this3._commentNode.value : ''
          };

          _this3.dispatchEvent(event);
        });
        this._IncidentAcceptNode = node;
      }

      node = this._container.querySelector('.IncidentCheck');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:IncidentCheck', false, false);
          event.detail = {
            IncidentID: props.id,
            comment: _this3._commentNode ? _this3._commentNode.value : ''
          };

          _this3.dispatchEvent(event);
        });
        this._IncidentCheckNode = node;
      }

      node = this._container.querySelector('.IncidentDecline');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:IncidentDecline', false, false);
          event.detail = {
            IncidentID: props.id,
            comment: _this3._commentNode ? _this3._commentNode.value : ''
          };

          _this3.dispatchEvent(event);
        });
        this._IncidentDeclineNode = node;
      }

      node = this._container.querySelector('.usr-text-area');

      if (node) {
        this._commentNode = node;
      }

      node = this._container.querySelector('.BplaView');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:bplaRaster', false, false);
          event.detail = props.uav_raster_id;

          _this3.dispatchEvent(event);
        });
      }

      node = this._container.querySelector('.BplaDownload');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:bplaDownload', false, false);
          event.detail = props.id;

          _this3.dispatchEvent(event);
        });
      }

      node = this._container.querySelector('.BplaRemove');

      if (node) {
        node.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('incident:bplaRemove', false, false);
          event.detail = props.id;

          _this3.dispatchEvent(event);
        });
      }

      node = this._container.querySelector('.dateCheck');

      if (node) {
        if (!this._permission.IncidentEdit || data.Status !== 'Ð² ÑÐ°Ð±Ð¾ÑÐµ') {
          node.classList.add('white');
          node.disabled = true;
        }

        var i18n = {
          previousMonth: 'ÐÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ',
          nextMonth: 'Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ',
          months: ['Ð¯Ð½Ð²Ð°ÑÑ', 'Ð¤ÐµÐ²ÑÐ°Ð»Ñ', 'ÐÐ°ÑÑ', 'ÐÐ¿ÑÐµÐ»Ñ', 'ÐÐ°Ð¹', 'ÐÑÐ½Ñ', 'ÐÑÐ»Ñ', 'ÐÐ²Ð³ÑÑÑ', 'Ð¡ÐµÐ½ÑÑÐ±ÑÑ', 'ÐÐºÑÑÐ±ÑÑ', 'ÐÐ¾ÑÐ±ÑÑ', 'ÐÐµÐºÐ°Ð±ÑÑ'],
          weekdays: ['ÐÐ¾ÑÐºÑÐµÑÐµÐ½ÑÐµ', 'ÐÐ¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº', 'ÐÑÐ¾ÑÐ½Ð¸Ðº', 'Ð¡ÑÐµÐ´Ð°', 'Ð§ÐµÑÐ²ÐµÑÐ³', 'ÐÑÑÐ½Ð¸ÑÐ°', 'Ð¡ÑÐ±Ð±Ð¾ÑÐ°'],
          weekdaysShort: ['ÐÑ', 'ÐÐ½', 'ÐÑ', 'Ð¡Ñ', 'Ð§Ñ', 'ÐÑ', 'Ð¡Ð±']
        };
        this._dateCheck = new pikaday({
          field: node,
          format: 'DD.MM.YYYY',
          yearRange: 20,
          i18n: i18n
        });

        if (data.CheckDate) {
          this._dateCheck.setDate(new Date(data.CheckDate));
        }
      }

      if (!this._permission.IncidentEdit || data.Status !== 'Ð² ÑÐ°Ð±Ð¾ÑÐµ') {
        var confirmedNodes = this._container.getElementsByClassName('confirmed_vol');

        confirmedNodes.forEach(function (node) {
          node.classList.add('white');
          node.disabled = true;
        });
      }

      this._rastId = props.prob_raster_id;
    }
  }, {
    key: "_saveItem",
    value: function _saveItem(data) {
      var props = data.properties || {};
      var out = {
        "incidentID": props.id,
        "comment": this._commentNode ? this._commentNode.value : ''
      };

      var d1 = this._dateCheck.getDate();

      if (d1) {
        out.checkDate = d1.toLocaleDateString().split('.').reverse().join('-');
      }

      var confirmedNodes = this._container.getElementsByClassName('confirmed_vol');

      var confirmed_vol = {};
      confirmedNodes.forEach(function (node) {
        confirmed_vol[node.getAttribute('id')] = Number(node.value) || 0;
      });
      var arr = data.ForestChange;

      if (arr && arr.length) {
        out.forestChange = arr.map(function (it) {
          return {
            stand: it.stand_id,
            volumes: it.volumes.map(function (it1) {
              return {
                wood_element_id: it1.wood_element_id,
                confirmed_vol: confirmed_vol[it1.wood_element_id]
              };
            })
          };
        });
      }

      var event = document.createEvent('Event');
      event.initEvent('incident:saveItem', false, false);
      event.detail = out;
      this.dispatchEvent(event);
    }
  }]);

  return Incidents;
}(View);

var translate$5 = T.getText.bind(T);

var Incidents$1 = /*#__PURE__*/function (_Controller) {
  _inherits(Incidents$1, _Controller);

  var _super = _createSuper(Incidents$1);

  function Incidents$1(_ref) {
    var _this;

    var map = _ref.map,
        layer = _ref.layer,
        content = _ref.content,
        notifications = _ref.notifications,
        legend = _ref.legend,
        path = _ref.path,
        dateInterval = _ref.dateInterval,
        permissions = _ref.permissions;

    _classCallCheck(this, Incidents$1);

    _this = _super.call(this, {
      map: map,
      content: content,
      notifications: notifications
    });
    _this._cache = {};
    _this._kind = 'incidents';
    _this._layer = layer;

    _this._layer.on('click', _this._click, _assertThisInitialized(_this));

    _this._rasterPrefix = '/gis/TileSender.ashx?ModeKey=tile&ftc=osm&z={z}&x={x}&y={y}&srs=3857&LayerName=';
    _this._legend = legend;

    _this._map.addLayer(_this._layer);

    _this._layer.setStyleHook(_this.getStyleHook.bind(_assertThisInitialized(_this)));

    var _this$_layer$getGmxPr = _this._layer.getGmxProperties(),
        attributes = _this$_layer$getGmxPr.attributes,
        Temporal = _this$_layer$getGmxPr.Temporal;

    _this._isTemporal = !!Temporal;
    _this._cid = attributes.indexOf('class_id');

    if (_this._cid >= 0) {
      _this._cid += 1;
    }

    _this._sid = attributes.indexOf('status_id');

    if (_this._sid >= 0) {
      _this._sid += 1;
    }

    _this._path = path;
    _this._dateInterval = dateInterval;
    _this._permissions = permissions;

    _this._legend.on('click', _this._toggle, _assertThisInitialized(_this));

    var p = _this._legend.addGroup(_this._kind, translate$5('legend.incidents'));

    _this._legend.addComponent('cut-unconfirmed', translate$5('legend.cut.unconfirmed'), p);

    _this._legend.addComponent('cut-working', translate$5('legend.cut.working'), p);

    _this._legend.addComponent('cut-faux', translate$5('legend.cut.faux'), p);

    _this._legend.addComponent('cut-confirmed', translate$5('legend.cut.confirmed'), p); // this._legend.addComponent('windthrow-unconfirmed', translate('legend.windthrow.unconfirmed'), p);
    // this._legend.addComponent('windthrow-working', translate('legend.windthrow.working'), p);
    // this._legend.addComponent('windthrow-faux', translate('legend.windthrow.faux'), p);
    // this._legend.addComponent('windthrow-confirmed', translate('legend.windthrow.confirmed'), p);


    _this._legend.addComponent('disease-unconfirmed', translate$5('legend.disease.unconfirmed'), p);

    _this._legend.addComponent('disease-working', translate$5('legend.disease.working'), p);

    _this._legend.addComponent('disease-faux', translate$5('legend.disease.faux'), p);

    _this._legend.addComponent('disease-confirmed', translate$5('legend.disease.confirmed'), p);

    _this._legend.addComponent('burn-unconfirmed', translate$5('legend.burn.unconfirmed'), p);

    _this._legend.addComponent('burn-working', translate$5('legend.burn.working'), p);

    _this._legend.addComponent('burn-faux', translate$5('legend.burn.faux'), p);

    _this._legend.addComponent('burn-confirmed', translate$5('legend.burn.confirmed'), p);

    _this._view = _this._content.add(_this._kind, Incidents, {
      permissions: _this._permissions
    });

    _this._view.on('incident:docs', function (e) {
      var event = document.createEvent('Event');
      event.initEvent('incident:docs', false, false);
      event.detail = e.detail;

      _this.dispatchEvent(event);
    }).on('incident:verifyRaster', function (e) {
      var rastr = _this._layer.verifyRaster;

      if (!rastr) {
        rastr = _this._layer.verifyRaster = L.tileLayer(_this._rasterPrefix + e.detail, {});
      }

      _this._toggleRasterLayer(rastr);
    }).on('incident:bplaRaster', function (e) {
      var rastr = _this._layer.bplaRaster;

      if (!rastr) {
        rastr = _this._layer.bplaRaster = L.tileLayer(_this._rasterPrefix + e.detail, {});
      }

      _this._toggleRasterLayer(rastr);
    }).on('incident:bplaDownload', function (e) {
      console.log('_bplaDownload', e.detail);
    }).on('incident:bplaRemove', function (e) {
      console.log('_bplaRemove', e.detail);
    }).on('incident:download', function (e) {
      window.location = "".concat(_this._path, "/Monitoring/DownloadIncidentContour?IncidentID=").concat(e.detail, "&Format=Shape");
    }).on('incident:editGeo', function (e) {
      _this._editGeo();
    }).on('incident:saveItem', function (e) {
      _this._saveItem(e.detail);
    }).on('incident:IncidentCheck', function (e) {
      var response = fetch("".concat(_this._path, "/Monitoring/CheckIncident"), {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(e.detail)
      });
    }).on('incident:IncidentAccept', function (e) {
      var response = fetch("".concat(_this._path, "/Monitoring/ApproveIncident"), {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(e.detail)
      });
    }).on('incident:IncidentDecline', function (e) {
      var response = fetch("".concat(_this._path, "/Monitoring/DeclineIncident"), {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(e.detail)
      });
    }).on('close', function (e) {
      var map = _this._layer._map;
      var rastr = _this._layer.verifyRaster;

      if (rastr) {
        if (rastr._map) {
          map.removeLayer(rastr);
        }
      }

      if (_this._layer.bplaRaster && _this._layer.bplaRaster._map) {
        map.removeLayer(_this._layer.bplaRaster);
      }
    });

    return _this;
  }

  _createClass(Incidents$1, [{
    key: "_saveItem",
    value: function () {
      var _saveItem2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(out) {
        var response;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._drawingObj) {
                  out.wkbGeometry = JSON.stringify(this._drawingObj[0].toGeoJSON().geometry);

                  this._removeDrawing();
                }

                _context.next = 3;
                return fetch("".concat(this._path, "/Monitoring/SaveIncident"), {
                  method: 'POST',
                  credentials: 'include',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(out)
                });

              case 3:
                response = _context.sent;
                L.gmx.layersVersion.now();

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _saveItem(_x) {
        return _saveItem2.apply(this, arguments);
      }

      return _saveItem;
    }()
  }, {
    key: "_toggleRasterLayer",
    value: function _toggleRasterLayer(rastr) {
      var map = this._layer._map;

      if (rastr._map) {
        map.removeLayer(rastr);
      } else {
        map.addLayer(rastr);
      }
    }
  }, {
    key: "_removeDrawing",
    value: function _removeDrawing() {
      this._layer._map.gmxDrawing.remove(this._drawingObj[0]);

      this._drawingObj = null;
    }
  }, {
    key: "_editGeo",
    value: function _editGeo() {
      var map = this._layer._map;

      if (this._drawingObj) {
        this._removeDrawing();
      } else {
        L.gmxUtil.sendCrossDomainPostRequest('/gis/VectorLayer/Search.ashx', {
          layer: this._layer.getGmxProperties().LayerID,
          WrapStyle: 'message',
          page: 0,
          pagesize: 1,
          orderby: 'rec_id',
          geometry: true,
          query: '"rec_id"=' + this._gmx_id
        }, function (res) {
          if (res && res.Status === 'ok') {
            var prp = res.Result.values[0];
            var geom = L.gmxUtil.geometryToGeoJSON(prp[prp.length - 1], true);

            if (geom) {
              this._drawingObj = map.gmxDrawing.addGeoJSON(new L.GeoJSON(geom), {});
            }
          }
        }.bind(this));
      }
    }
  }, {
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(e) {
        var _e$gmx, id, properties, data;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.canClick) {
                  _context2.next = 8;
                  break;
                }

                L.DomEvent.stopPropagation(e);
                _e$gmx = e.gmx, id = _e$gmx.id, properties = _e$gmx.properties;
                _context2.next = 5;
                return this.httpGet("".concat(this._path, "/Monitoring/GetIncident"), {
                  IncidentID: properties.id
                });

              case 5:
                data = _context2.sent;

                if (data) {
                  this._gmx_id = id;

                  this._view.open(_objectSpread2({
                    gmx_id: this._gmx_id,
                    properties: properties
                  }, data));
                }

                this._layer.repaint();

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _click(_x2) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }, {
    key: "_toggle",
    value: function _toggle(e) {
      var id = e.id,
          visible = e.visible;

      switch (id) {
        case 'cut-unconfirmed':
        case 'cut-working':
        case 'cut-faux':
        case 'cut-confirmed':
        case 'windthrow-unconfirmed':
        case 'windthrow-working':
        case 'windthrow-faux':
        case 'windthrow-confirmed':
        case 'disease-unconfirmed':
        case 'disease-working':
        case 'disease-faux':
        case 'disease-confirmed':
        case 'burn-unconfirmed':
        case 'burn-working':
        case 'burn-faux':
        case 'burn-confirmed':
          if (visible) {
            this._cache[id] = true;
          } else {
            delete this._cache[id];
          }

          if (visible) {
            if (this._isTemporal) {
              this._dateInterval.addLayer(this._layer);
            } else {
              this._map.addLayer(this._layer);
            }
          } else if (Object.keys(this._cache).length === 0) {
            if (this._isTemporal) {
              this._dateInterval.removeLayer(this._layer);
            } else {
              this._map.removeLayer(this._layer);
            }
          }

          this._layer.repaint();

          break;
      }
    }
  }, {
    key: "getStyleHook",
    value: function getStyleHook(_ref2) {
      var properties = _ref2.properties;
      var c = properties[this._cid];
      var s = properties[this._sid];

      switch (c) {
        case 1:
          switch (s) {
            case 1:
              return this._cache['cut-unconfirmed'] ? {} : null;

            case 2:
              return this._cache['cut-working'] ? {} : null;

            case 3:
              return this._cache['cut-faux'] ? {} : null;

            case 4:
              return this._cache['cut-confirmed'] ? {} : null;

            default:
              return null;
          }

        case 2:
          switch (s) {
            case 1:
              return this._cache['windthrow-unconfirmed'] ? {} : null;

            case 2:
              return this._cache['windthrow-working'] ? {} : null;

            case 3:
              return this._cache['windthrow-faux'] ? {} : null;

            case 4:
              return this._cache['windthrow-confirmed'] ? {} : null;

            default:
              return null;
          }

        case 3:
          switch (s) {
            case 1:
              return this._cache['disease-unconfirmed'] ? {} : null;

            case 2:
              return this._cache['disease-working'] ? {} : null;

            case 3:
              return this._cache['disease-faux'] ? {} : null;

            case 4:
              return this._cache['disease-confirmed'] ? {} : null;

            default:
              return null;
          }

        case 4:
          switch (s) {
            case 1:
              return this._cache['burn-unconfirmed'] ? {} : null;

            case 2:
              return this._cache['burn-working'] ? {} : null;

            case 3:
              return this._cache['burn-faux'] ? {} : null;

            case 4:
              return this._cache['burn-confirmed'] ? {} : null;

            default:
              return null;
          }

        default:
          return null;
      }
    }
  }]);

  return Incidents$1;
}(Controller);

var Legend$1 = /*#__PURE__*/function (_EventTarget) {
  _inherits(Legend, _EventTarget);

  var _super = _createSuper(Legend);

  function Legend(_ref) {
    var _this;

    var map = _ref.map,
        legend = _ref.legend,
        _ref$tags = _ref.tags,
        tags = _ref$tags === void 0 ? [] : _ref$tags;

    _classCallCheck(this, Legend);

    _this = _super.call(this);
    _this._map = map;
    _this._legend = legend;
    _this._cache = {};

    _this._legend.on('click', _this._click, _assertThisInitialized(_this));

    _this._setVisible(tags);

    return _this;
  }

  _createClass(Legend, [{
    key: "_setVisible",
    value: function _setVisible(tags) {
      var ts = window.localStorage.getItem('tags');

      var _iterator = _createForOfIteratorHelper(ts && JSON.parse(ts) || tags),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var t = _step.value;

          this._legend.enable(t);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "_click",
    value: function _click(e) {
      var id = e.id,
          visible = e.visible;

      if (visible) {
        this._cache[id] = true;
      } else {
        delete this._cache[id];
      }

      window.localStorage.setItem('tags', JSON.stringify(Object.keys(this._cache)));
    }
  }]);

  return Legend;
}(EventTarget);

var strings$3 = {
  rus: {
    alert: {
      forbidden: 'ÐÐµÑ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ñ'
    }
  }
};

var Forbidden = /*#__PURE__*/function (_BaseView) {
  _inherits(Forbidden, _BaseView);

  var _super = _createSuper(Forbidden);

  function Forbidden(container) {
    var _this;

    _classCallCheck(this, Forbidden);

    _this = _super.call(this, container, strings$3);

    _this._container.classList.add('scanex-forestry-forbidden');

    _this._container.innerHTML = "<div>".concat(_this.translate('alert.forbidden'), "</div>");
    return _this;
  }

  return Forbidden;
}(View);

var strings$4 = {
  rus: {
    alert: {
      loading: 'ÐÑÐ¿Ð¾Ð»Ð½ÑÐµÑÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ ...'
    }
  }
};

var Loading = /*#__PURE__*/function (_BaseView) {
  _inherits(Loading, _BaseView);

  var _super = _createSuper(Loading);

  function Loading(container) {
    var _this;

    _classCallCheck(this, Loading);

    _this = _super.call(this, container, strings$4);

    _this._container.classList.add('scanex-forestry-loading');

    _this._container.innerHTML = "<div>".concat(_this.translate('alert.loading'), "</div>");
    return _this;
  }

  return Loading;
}(View);

var strings$5 = {
  rus: {
    alert: {
      notAvailable: 'ÐÐµÐ´ÑÑÑÑ Ð¿Ð¾Ð´Ð³Ð¾ÑÐ¾Ð²ÐºÐ° Ð´Ð°Ð½Ð½ÑÑ...'
    }
  }
};

var STYLES$1 = {
  fillStyle: document.createElement('canvas').getContext('2d').createPattern(L.gmxUtil.getPatternIcon(null, {
    type: '',
    color: parseInt('FFD700', 16),
    opacity: 1,
    weight: 1,
    fillOpacity: 1,
    fillPattern: {
      style: 'diagonal1',
      width: 8,
      step: 0,
      colors: [parseInt('FFD700', 16), 0]
    },
    common: true
  }).canvas, 'repeat'),
  strokeStyle: '#FFD700',
  lineWidth: 2
};

var NotAvailable = /*#__PURE__*/function (_BaseView) {
  _inherits(NotAvailable, _BaseView);

  var _super = _createSuper(NotAvailable);

  function NotAvailable(container) {
    var _this;

    _classCallCheck(this, NotAvailable);

    _this = _super.call(this, container, strings$5);

    _this._container.classList.add('scanex-forestry-not-available');

    _this._container.innerHTML = "<div>".concat(_this.translate('alert.notAvailable'), "</div>");
    return _this;
  }

  _createClass(NotAvailable, [{
    key: "getStyleHook",
    value: function getStyleHook(kind, item) {
      if (kind === 'quadrants') {
        return item.id === this._gmx_id ? STYLES$1 : {};
      } else {
        return {};
      }
    }
  }]);

  return NotAvailable;
}(View);

var strings$6 = {
  rus: {
    alert: {
      notFound: 'ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾'
    }
  }
};

var NotFound = /*#__PURE__*/function (_BaseView) {
  _inherits(NotFound, _BaseView);

  var _super = _createSuper(NotFound);

  function NotFound(container) {
    var _this;

    _classCallCheck(this, NotFound);

    _this = _super.call(this, container, strings$6);

    _this._container.classList.add('scanex-forestry-not-found');

    _this._container.innerHTML = "<div>".concat(_this.translate('alert.notFound'), "</div>");
    return _this;
  }

  return NotFound;
}(View);

var strings$7 = {
  rus: {
    alert: {
      serverError: 'ÐÑÐ¸Ð±ÐºÐ° ÑÐµÑÐ²ÐµÑÐ°'
    }
  }
};

var ServerError = /*#__PURE__*/function (_BaseView) {
  _inherits(ServerError, _BaseView);

  var _super = _createSuper(ServerError);

  function ServerError(container) {
    var _this;

    _classCallCheck(this, ServerError);

    _this = _super.call(this, container, strings$7);

    _this._container.classList.add('scanex-forestry-server-error');

    _this._container.innerHTML = "<div>".concat(_this.translate('alert.serverError'), "</div>");
    return _this;
  }

  return ServerError;
}(View);

var strings$8 = {
  rus: {
    alert: {
      unAuthorized: 'ÐÑ Ð½Ðµ Ð²Ð¾ÑÐ»Ð¸ Ð² ÑÐ¸ÑÑÐµÐ¼Ñ'
    }
  }
};

var UnAuthorized = /*#__PURE__*/function (_BaseView) {
  _inherits(UnAuthorized, _BaseView);

  var _super = _createSuper(UnAuthorized);

  function UnAuthorized(container) {
    var _this;

    _classCallCheck(this, UnAuthorized);

    _this = _super.call(this, container, strings$8);

    _this._container.classList.add('scanex-forestry-unauthorized');

    _this._container.innerHTML = "<div>".concat(_this.translate('alert.unAuthorized'), "</div>");
    return _this;
  }

  return UnAuthorized;
}(View);

var strings$9 = {
  rus: {
    park: {
      title: 'ÐÐÐÐ¢',
      name: 'ÐÐ°Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ',
      type: 'ÐÐ°ÑÐµÐ³Ð¾ÑÐ¸Ñ ÐÐÐÐ¢',
      year: 'ÐÐ¾ÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ',
      prov: 'Ð£ÑÐ¾Ð²ÐµÐ½Ñ Ð·Ð°ÑÐ¸ÑÑ',
      area: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ'
    }
  }
};

var Parks = /*#__PURE__*/function (_BaseView) {
  _inherits(Parks, _BaseView);

  var _super = _createSuper(Parks);

  function Parks(container) {
    var _this;

    _classCallCheck(this, Parks);

    _this = _super.call(this, container, strings$9);

    _this._container.classList.add('scanex-forestry-naturalpark');

    return _this;
  }

  _createClass(Parks, [{
    key: "open",
    value: function open(_ref) {
      var properties = _ref.properties;

      _get(_getPrototypeOf(Parks.prototype), "open", this).call(this);

      var NAME_R = properties.NAME_R,
          TYPE_NL = properties.TYPE_NL,
          YEAR_ = properties.YEAR_,
          PROV_NL = properties.PROV_NL,
          AREA_DOC = properties.AREA_DOC;
      this._container.innerHTML = "<div class=\"header\">".concat(this.translate('park.title'), ": ").concat(NAME_R, "</div>\n\t\t\t<table cellspacing=\"0\" cellpadding=\"0\">\t\t\t\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"name title\">").concat(this.translate('park.name'), "</td>\n\t\t\t\t\t<td class=\"name value\">").concat(NAME_R, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"type title\">").concat(this.translate('park.type'), "</td>\n\t\t\t\t\t<td class=\"type value\">").concat(TYPE_NL, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"year title\">").concat(this.translate('park.year'), "</td>\n\t\t\t\t\t<td class=\"year value\">").concat(YEAR_, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"prov title\">").concat(this.translate('park.prov'), "</td>\n\t\t\t\t\t<td class=\"prov value\">").concat(PROV_NL, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"area title\">").concat(this.translate('park.area'), ", ").concat(this.translate('units.m'), "<sup>2</sup></td>\n\t\t\t\t\t<td class=\"area value\">").concat(this.m(AREA_DOC), "</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>");
    }
  }]);

  return Parks;
}(View);

var Parks$1 = /*#__PURE__*/function (_LayerController) {
  _inherits(Parks$1, _LayerController);

  var _super = _createSuper(Parks$1);

  function Parks$1(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layer = _ref.layer,
        legend = _ref.legend;

    _classCallCheck(this, Parks$1);

    _this = _super.call(this, {
      kind: 'parks',
      map: map,
      content: content,
      notifications: notifications,
      layer: layer,
      legend: legend
    });
    _this._view = _this._content.add('parks', Parks);
    return _this;
  }

  _createClass(Parks$1, [{
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var properties;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.canClick) {
                  L.DomEvent.stopPropagation(e);
                  properties = e.gmx.properties;

                  this._view.open({
                    properties: properties
                  });
                }

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _click(_x) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }]);

  return Parks$1;
}(LayerController);

var log$3 = Math.log;
var LOG10E = Math.LOG10E;

// `Math.log10` method
// https://tc39.github.io/ecma262/#sec-math.log10
_export({ target: 'Math', stat: true }, {
  log10: function log10(x) {
    return log$3(x) * LOG10E;
  }
});

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
_export({ target: 'Object', stat: true, sham: !descriptors }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
var functionBind = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction$1(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.github.io/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED$a = NEW_TARGET_BUG || ARGS_BUG;

_export({ target: 'Reflect', stat: true, forced: FORCED$a, sham: FORCED$a }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction$1(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (functionBind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.github.io/ecma262/#sec-createhtml
var createHtml = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
var stringHtmlForced = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};

// `String.prototype.fixed` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fixed
_export({ target: 'String', proto: true, forced: stringHtmlForced('fixed') }, {
  fixed: function fixed() {
    return createHtml(this, 'tt', '', '');
  }
});

var apexcharts_common = createCommonjsModule(function (module, exports) {

  function t(e) {
    return (t = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
      return _typeof(t);
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
    })(e);
  }

  function e(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }

  function i(t, e) {
    for (var i = 0; i < e.length; i++) {
      var a = e[i];
      a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a);
    }
  }

  function a(t, e, a) {
    return e && i(t.prototype, e), a && i(t, a), t;
  }

  function s(t, e, i) {
    return e in t ? Object.defineProperty(t, e, {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : t[e] = i, t;
  }

  function r(t, e) {
    var i = Object.keys(t);

    if (Object.getOwnPropertySymbols) {
      var a = Object.getOwnPropertySymbols(t);
      e && (a = a.filter(function (e) {
        return Object.getOwnPropertyDescriptor(t, e).enumerable;
      })), i.push.apply(i, a);
    }

    return i;
  }

  function n(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = null != arguments[e] ? arguments[e] : {};
      e % 2 ? r(Object(i), !0).forEach(function (e) {
        s(t, e, i[e]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach(function (e) {
        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));
      });
    }

    return t;
  }

  function o(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), e && h(t, e);
  }

  function l(t) {
    return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    })(t);
  }

  function h(t, e) {
    return (h = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t;
    })(t, e);
  }

  function c(t, e) {
    return !e || "object" != _typeof(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t;
    }(t) : e;
  }

  function d(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;

      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;
      } catch (t) {
        return !1;
      }
    }();

    return function () {
      var i,
          a = l(t);

      if (e) {
        var s = l(this).constructor;
        i = Reflect.construct(a, arguments, s);
      } else i = a.apply(this, arguments);

      return c(this, i);
    };
  }

  function g(t) {
    return function (t) {
      if (Array.isArray(t)) return u(t);
    }(t) || function (t) {
      if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);
    }(t) || function (t, e) {
      if (!t) return;
      if ("string" == typeof t) return u(t, e);
      var i = Object.prototype.toString.call(t).slice(8, -1);
      "Object" === i && t.constructor && (i = t.constructor.name);
      if ("Map" === i || "Set" === i) return Array.from(t);
      if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return u(t, e);
    }(t) || function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }

  function u(t, e) {
    (null == e || e > t.length) && (e = t.length);

    for (var i = 0, a = new Array(e); i < e; i++) {
      a[i] = t[i];
    }

    return a;
  }

  var f = function () {
    function i() {
      e(this, i);
    }

    return a(i, [{
      key: "shadeRGBColor",
      value: function value(t, e) {
        var i = e.split(","),
            a = t < 0 ? 0 : 255,
            s = t < 0 ? -1 * t : t,
            r = parseInt(i[0].slice(4), 10),
            n = parseInt(i[1], 10),
            o = parseInt(i[2], 10);
        return "rgb(" + (Math.round((a - r) * s) + r) + "," + (Math.round((a - n) * s) + n) + "," + (Math.round((a - o) * s) + o) + ")";
      }
    }, {
      key: "shadeHexColor",
      value: function value(t, e) {
        var i = parseInt(e.slice(1), 16),
            a = t < 0 ? 0 : 255,
            s = t < 0 ? -1 * t : t,
            r = i >> 16,
            n = i >> 8 & 255,
            o = 255 & i;
        return "#" + (16777216 + 65536 * (Math.round((a - r) * s) + r) + 256 * (Math.round((a - n) * s) + n) + (Math.round((a - o) * s) + o)).toString(16).slice(1);
      }
    }, {
      key: "shadeColor",
      value: function value(t, e) {
        return i.isColorHex(e) ? this.shadeHexColor(t, e) : this.shadeRGBColor(t, e);
      }
    }], [{
      key: "bind",
      value: function value(t, e) {
        return function () {
          return t.apply(e, arguments);
        };
      }
    }, {
      key: "isObject",
      value: function value(e) {
        return e && "object" === t(e) && !Array.isArray(e) && null != e;
      }
    }, {
      key: "listToArray",
      value: function value(t) {
        var e,
            i = [];

        for (e = 0; e < t.length; e++) {
          i[e] = t[e];
        }

        return i;
      }
    }, {
      key: "extend",
      value: function value(t, e) {
        var i = this;
        "function" != typeof Object.assign && (Object.assign = function (t) {
          if (null == t) throw new TypeError("Cannot convert undefined or null to object");

          for (var e = Object(t), i = 1; i < arguments.length; i++) {
            var a = arguments[i];
            if (null != a) for (var s in a) {
              a.hasOwnProperty(s) && (e[s] = a[s]);
            }
          }

          return e;
        });
        var a = Object.assign({}, t);
        return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach(function (r) {
          i.isObject(e[r]) && r in t ? a[r] = i.extend(t[r], e[r]) : Object.assign(a, s({}, r, e[r]));
        }), a;
      }
    }, {
      key: "extendArray",
      value: function value(t, e) {
        var a = [];
        return t.map(function (t) {
          a.push(i.extend(e, t));
        }), t = a;
      }
    }, {
      key: "monthMod",
      value: function value(t) {
        return t % 12;
      }
    }, {
      key: "clone",
      value: function value(e) {
        if ("[object Array]" === Object.prototype.toString.call(e)) {
          for (var i = [], a = 0; a < e.length; a++) {
            i[a] = this.clone(e[a]);
          }

          return i;
        }

        if ("[object Null]" === Object.prototype.toString.call(e)) return null;
        if ("[object Date]" === Object.prototype.toString.call(e)) return e;

        if ("object" === t(e)) {
          var s = {};

          for (var r in e) {
            e.hasOwnProperty(r) && (s[r] = this.clone(e[r]));
          }

          return s;
        }

        return e;
      }
    }, {
      key: "log10",
      value: function value(t) {
        return Math.log(t) / Math.LN10;
      }
    }, {
      key: "roundToBase10",
      value: function value(t) {
        return Math.pow(10, Math.floor(Math.log10(t)));
      }
    }, {
      key: "roundToBase",
      value: function value(t, e) {
        return Math.pow(e, Math.floor(Math.log(t) / Math.log(e)));
      }
    }, {
      key: "parseNumber",
      value: function value(t) {
        return null === t ? t : parseFloat(t);
      }
    }, {
      key: "randomId",
      value: function value() {
        return (Math.random() + 1).toString(36).substring(4);
      }
    }, {
      key: "noExponents",
      value: function value(t) {
        var e = String(t).split(/[eE]/);
        if (1 === e.length) return e[0];
        var i = "",
            a = t < 0 ? "-" : "",
            s = e[0].replace(".", ""),
            r = Number(e[1]) + 1;

        if (r < 0) {
          for (i = a + "0."; r++;) {
            i += "0";
          }

          return i + s.replace(/^-/, "");
        }

        for (r -= s.length; r--;) {
          i += "0";
        }

        return s + i;
      }
    }, {
      key: "getDimensions",
      value: function value(t) {
        var e = getComputedStyle(t),
            i = [],
            a = t.clientHeight,
            s = t.clientWidth;
        return a -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), s -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i.push(s), i.push(a), i;
      }
    }, {
      key: "getBoundingClientRect",
      value: function value(t) {
        var e = t.getBoundingClientRect();
        return {
          top: e.top,
          right: e.right,
          bottom: e.bottom,
          left: e.left,
          width: t.clientWidth,
          height: t.clientHeight,
          x: e.left,
          y: e.top
        };
      }
    }, {
      key: "getLargestStringFromArr",
      value: function value(t) {
        return t.reduce(function (t, e) {
          return Array.isArray(e) && (e = e.reduce(function (t, e) {
            return t.length > e.length ? t : e;
          })), t.length > e.length ? t : e;
        }, 0);
      }
    }, {
      key: "hexToRgba",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999",
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
        "#" !== t.substring(0, 1) && (t = "#999999");
        var i = t.replace("#", "");
        i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));

        for (var a = 0; a < i.length; a++) {
          i[a] = parseInt(1 === i[a].length ? i[a] + i[a] : i[a], 16);
        }

        return void 0 !== e && i.push(e), "rgba(" + i.join(",") + ")";
      }
    }, {
      key: "getOpacityFromRGBA",
      value: function value(t) {
        return parseFloat(t.replace(/^.*,(.+)\)/, "$1"));
      }
    }, {
      key: "rgb2hex",
      value: function value(t) {
        return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t.length ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : "";
      }
    }, {
      key: "isColorHex",
      value: function value(t) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t);
      }
    }, {
      key: "polarToCartesian",
      value: function value(t, e, i, a) {
        var s = (a - 90) * Math.PI / 180;
        return {
          x: t + i * Math.cos(s),
          y: e + i * Math.sin(s)
        };
      }
    }, {
      key: "escapeString",
      value: function value(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x",
            i = t.toString().slice();
        return i = i.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e);
      }
    }, {
      key: "negToZero",
      value: function value(t) {
        return t < 0 ? 0 : t;
      }
    }, {
      key: "moveIndexInArray",
      value: function value(t, e, i) {
        if (i >= t.length) for (var a = i - t.length + 1; a--;) {
          t.push(void 0);
        }
        return t.splice(i, 0, t.splice(e, 1)[0]), t;
      }
    }, {
      key: "extractNumber",
      value: function value(t) {
        return parseFloat(t.replace(/[^\d.]*/g, ""));
      }
    }, {
      key: "findAncestor",
      value: function value(t, e) {
        for (; (t = t.parentElement) && !t.classList.contains(e);) {
        }

        return t;
      }
    }, {
      key: "setELstyles",
      value: function value(t, e) {
        for (var i in e) {
          e.hasOwnProperty(i) && (t.style.key = e[i]);
        }
      }
    }, {
      key: "isNumber",
      value: function value(t) {
        return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10));
      }
    }, {
      key: "isFloat",
      value: function value(t) {
        return Number(t) === t && t % 1 != 0;
      }
    }, {
      key: "isSafari",
      value: function value() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      }
    }, {
      key: "isFirefox",
      value: function value() {
        return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
      }
    }, {
      key: "isIE11",
      value: function value() {
        if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return !0;
      }
    }, {
      key: "isIE",
      value: function value() {
        var t = window.navigator.userAgent,
            e = t.indexOf("MSIE ");
        if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);

        if (t.indexOf("Trident/") > 0) {
          var i = t.indexOf("rv:");
          return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10);
        }

        var a = t.indexOf("Edge/");
        return a > 0 && parseInt(t.substring(a + 5, t.indexOf(".", a)), 10);
      }
    }]), i;
  }(),
      p = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "getDefaultFilter",
      value: function value(t, e) {
        var i = this.w;
        t.unfilter(!0), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i.config.states.normal.filter ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e);
      }
    }, {
      key: "addNormalFilter",
      value: function value(t, e) {
        var i = this.w;
        i.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, i.config.chart.dropShadow, e);
      }
    }, {
      key: "addLightenFilter",
      value: function value(t, e, i) {
        var a = this,
            s = this.w,
            r = i.intensity;

        if (!f.isFirefox()) {
          t.unfilter(!0);
          new window.SVG.Filter();
          t.filter(function (t) {
            var i = s.config.chart.dropShadow;
            (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({
              rgb: {
                type: "linear",
                slope: 1.5,
                intercept: r
              }
            });
          }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
        }
      }
    }, {
      key: "addDarkenFilter",
      value: function value(t, e, i) {
        var a = this,
            s = this.w,
            r = i.intensity;

        if (!f.isFirefox()) {
          t.unfilter(!0);
          new window.SVG.Filter();
          t.filter(function (t) {
            var i = s.config.chart.dropShadow;
            (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({
              rgb: {
                type: "linear",
                slope: r
              }
            });
          }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
        }
      }
    }, {
      key: "applyFilter",
      value: function value(t, e, i) {
        var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;

        switch (i) {
          case "none":
            this.addNormalFilter(t, e);
            break;

          case "lighten":
            this.addLightenFilter(t, e, {
              intensity: a
            });
            break;

          case "darken":
            this.addDarkenFilter(t, e, {
              intensity: a
            });
        }
      }
    }, {
      key: "addShadow",
      value: function value(t, e, i) {
        var a = i.blur,
            s = i.top,
            r = i.left,
            n = i.color,
            o = i.opacity,
            l = t.flood(Array.isArray(n) ? n[e] : n, o).composite(t.sourceAlpha, "in").offset(r, s).gaussianBlur(a).merge(t.source);
        return t.blend(t.source, l);
      }
    }, {
      key: "dropShadow",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
            a = e.top,
            s = e.left,
            r = e.blur,
            n = e.color,
            o = e.opacity,
            l = e.noUserSpaceOnUse,
            h = this.w;
        return t.unfilter(!0), f.isIE() && "radialBar" === h.config.chart.type || (n = Array.isArray(n) ? n[i] : n, t.filter(function (t) {
          var e = null;
          e = f.isSafari() || f.isFirefox() || f.isIE() ? t.flood(n, o).composite(t.sourceAlpha, "in").offset(s, a).gaussianBlur(r) : t.flood(n, o).composite(t.sourceAlpha, "in").offset(s, a).gaussianBlur(r).merge(t.source), t.blend(t.source, e);
        }), l || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t;
      }
    }, {
      key: "setSelectionFilter",
      value: function value(t, e, i) {
        var a = this.w;

        if (void 0 !== a.globals.selectedDataPoints[e] && a.globals.selectedDataPoints[e].indexOf(i) > -1) {
          t.node.setAttribute("selected", !0);
          var s = a.config.states.active.filter;
          "none" !== s && this.applyFilter(t, e, s.type, s.value);
        }
      }
    }, {
      key: "_scaleFilterSize",
      value: function value(t) {
        !function (e) {
          for (var i in e) {
            e.hasOwnProperty(i) && t.setAttribute(i, e[i]);
          }
        }({
          width: "200%",
          height: "200%",
          x: "-50%",
          y: "-50%"
        });
      }
    }]), t;
  }(),
      x = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.setEasingFunctions();
    }

    return a(t, [{
      key: "setEasingFunctions",
      value: function value() {
        var t;

        if (!this.w.globals.easing) {
          switch (this.w.config.chart.animations.easing) {
            case "linear":
              t = "-";
              break;

            case "easein":
              t = "<";
              break;

            case "easeout":
              t = ">";
              break;

            case "easeinout":
              t = "<>";
              break;

            case "swing":
              t = function t(_t) {
                var e = 1.70158;
                return (_t -= 1) * _t * ((e + 1) * _t + e) + 1;
              };

              break;

            case "bounce":
              t = function t(_t2) {
                return _t2 < 1 / 2.75 ? 7.5625 * _t2 * _t2 : _t2 < 2 / 2.75 ? 7.5625 * (_t2 -= 1.5 / 2.75) * _t2 + .75 : _t2 < 2.5 / 2.75 ? 7.5625 * (_t2 -= 2.25 / 2.75) * _t2 + .9375 : 7.5625 * (_t2 -= 2.625 / 2.75) * _t2 + .984375;
              };

              break;

            case "elastic":
              t = function t(_t3) {
                return _t3 === !!_t3 ? _t3 : Math.pow(2, -10 * _t3) * Math.sin((_t3 - .075) * (2 * Math.PI) / .3) + 1;
              };

              break;

            default:
              t = "<>";
          }

          this.w.globals.easing = t;
        }
      }
    }, {
      key: "animateLine",
      value: function value(t, e, i, a) {
        t.attr(e).animate(a).attr(i);
      }
    }, {
      key: "animateCircleRadius",
      value: function value(t, e, i, a, s, r) {
        e || (e = 0), t.attr({
          r: e
        }).animate(a, s).attr({
          r: i
        }).afterAll(function () {
          r();
        });
      }
    }, {
      key: "animateCircle",
      value: function value(t, e, i, a, s) {
        t.attr({
          r: e.r,
          cx: e.cx,
          cy: e.cy
        }).animate(a, s).attr({
          r: i.r,
          cx: i.cx,
          cy: i.cy
        });
      }
    }, {
      key: "animateRect",
      value: function value(t, e, i, a, s) {
        t.attr(e).animate(a).attr(i).afterAll(function () {
          return s();
        });
      }
    }, {
      key: "animatePathsGradually",
      value: function value(t) {
        var e = t.el,
            i = t.realIndex,
            a = t.j,
            s = t.fill,
            r = t.pathFrom,
            n = t.pathTo,
            o = t.speed,
            l = t.delay,
            h = this.w,
            c = 0;
        h.config.chart.animations.animateGradually.enabled && (c = h.config.chart.animations.animateGradually.delay), h.config.chart.animations.dynamicAnimation.enabled && h.globals.dataChanged && "bar" !== h.config.chart.type && (c = 0), this.morphSVG(e, i, a, "line" !== h.config.chart.type || h.globals.comboCharts ? s : "stroke", r, n, o, l * c);
      }
    }, {
      key: "showDelayedElements",
      value: function value() {
        this.w.globals.delayedElements.forEach(function (t) {
          t.el.classList.remove("apexcharts-element-hidden");
        });
      }
    }, {
      key: "animationCompleted",
      value: function value(t) {
        var e = this.w;
        e.globals.animationEnded || (e.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e.config.chart.events.animationEnd && e.config.chart.events.animationEnd(this.ctx, {
          el: t,
          w: e
        }));
      }
    }, {
      key: "morphSVG",
      value: function value(t, e, i, a, s, r, n, o) {
        var l = this,
            h = this.w;
        s || (s = t.attr("pathFrom")), r || (r = t.attr("pathTo"));

        var c = function c(t) {
          return "radar" === h.config.chart.type && (n = 1), "M 0 ".concat(h.globals.gridHeight);
        };

        (!s || s.indexOf("undefined") > -1 || s.indexOf("NaN") > -1) && (s = c()), (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = c()), h.globals.shouldAnimate || (n = 1), t.plot(s).animate(1, h.globals.easing, o).plot(s).animate(n, h.globals.easing, o).plot(r).afterAll(function () {
          f.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && l.animationCompleted(t) : "none" !== a && h.globals.shouldAnimate && (!h.globals.comboCharts && e === h.globals.series.length - 1 || h.globals.comboCharts) && l.animationCompleted(t), l.showDelayedElements();
        });
      }
    }]), t;
  }(),
      b = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "drawLine",
      value: function value(t, e, i, a) {
        var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
            r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
            n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
            o = this.w,
            l = o.globals.dom.Paper.line().attr({
          x1: t,
          y1: e,
          x2: i,
          y2: a,
          stroke: s,
          "stroke-dasharray": r,
          "stroke-width": n
        });
        return l;
      }
    }, {
      key: "drawRect",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
            s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
            r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
            n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
            o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
            l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
            h = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
            c = this.w,
            d = c.globals.dom.Paper.rect();
        return d.attr({
          x: t,
          y: e,
          width: i > 0 ? i : 0,
          height: a > 0 ? a : 0,
          rx: s,
          ry: s,
          opacity: n,
          "stroke-width": null !== o ? o : 0,
          stroke: null !== l ? l : "none",
          "stroke-dasharray": h
        }), d.node.setAttribute("fill", r), d;
      }
    }, {
      key: "drawPolygon",
      value: function value(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none",
            s = this.w,
            r = s.globals.dom.Paper.polygon(t).attr({
          fill: a,
          stroke: e,
          "stroke-width": i
        });
        return r;
      }
    }, {
      key: "drawCircle",
      value: function value(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
            i = this.w,
            a = i.globals.dom.Paper.circle(2 * t);
        return null !== e && a.attr(e), a;
      }
    }, {
      key: "drawPath",
      value: function value(t) {
        var e = t.d,
            i = void 0 === e ? "" : e,
            a = t.stroke,
            s = void 0 === a ? "#a8a8a8" : a,
            r = t.strokeWidth,
            n = void 0 === r ? 1 : r,
            o = t.fill,
            l = t.fillOpacity,
            h = void 0 === l ? 1 : l,
            c = t.strokeOpacity,
            d = void 0 === c ? 1 : c,
            g = t.classes,
            u = t.strokeLinecap,
            f = void 0 === u ? null : u,
            p = t.strokeDashArray,
            x = void 0 === p ? 0 : p,
            b = this.w;
        return null === f && (f = b.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(b.globals.gridHeight)), b.globals.dom.Paper.path(i).attr({
          fill: o,
          "fill-opacity": h,
          stroke: s,
          "stroke-opacity": d,
          "stroke-linecap": f,
          "stroke-width": n,
          "stroke-dasharray": x,
          class: g
        });
      }
    }, {
      key: "group",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
            e = this.w,
            i = e.globals.dom.Paper.group();
        return null !== t && i.attr(t), i;
      }
    }, {
      key: "move",
      value: function value(t, e) {
        var i = ["M", t, e].join(" ");
        return i;
      }
    }, {
      key: "line",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
            a = null;
        return null === i ? a = ["L", t, e].join(" ") : "H" === i ? a = ["H", t].join(" ") : "V" === i && (a = ["V", e].join(" ")), a;
      }
    }, {
      key: "curve",
      value: function value(t, e, i, a, s, r) {
        var n = ["C", t, e, i, a, s, r].join(" ");
        return n;
      }
    }, {
      key: "quadraticCurve",
      value: function value(t, e, i, a) {
        return ["Q", t, e, i, a].join(" ");
      }
    }, {
      key: "arc",
      value: function value(t, e, i, a, s, r, n) {
        var o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7],
            l = "A";
        o && (l = "a");
        var h = [l, t, e, i, a, s, r, n].join(" ");
        return h;
      }
    }, {
      key: "renderPaths",
      value: function value(t) {
        var e,
            i = t.j,
            a = t.realIndex,
            s = t.pathFrom,
            r = t.pathTo,
            o = t.stroke,
            l = t.strokeWidth,
            h = t.strokeLinecap,
            c = t.fill,
            d = t.animationDelay,
            g = t.initialSpeed,
            u = t.dataChangeSpeed,
            f = t.className,
            b = t.shouldClipToGrid,
            m = void 0 === b || b,
            v = t.bindEventsOnPaths,
            y = void 0 === v || v,
            w = t.drawShadow,
            k = void 0 === w || w,
            A = this.w,
            S = new p(this.ctx),
            C = new x(this.ctx),
            L = this.w.config.chart.animations.enabled,
            P = L && this.w.config.chart.animations.dynamicAnimation.enabled,
            T = !!(L && !A.globals.resized || P && A.globals.dataChanged && A.globals.shouldAnimate);
        T ? e = s : (e = r, A.globals.animationEnded = !0);
        var z = A.config.stroke.dashArray,
            I = 0;
        I = Array.isArray(z) ? z[a] : A.config.stroke.dashArray;
        var M = this.drawPath({
          d: e,
          stroke: o,
          strokeWidth: l,
          fill: c,
          fillOpacity: 1,
          classes: f,
          strokeLinecap: h,
          strokeDashArray: I
        });
        if (M.attr("index", a), m && M.attr({
          "clip-path": "url(#gridRectMask".concat(A.globals.cuid, ")")
        }), "none" !== A.config.states.normal.filter.type) S.getDefaultFilter(M, a);else if (A.config.chart.dropShadow.enabled && k && (!A.config.chart.dropShadow.enabledOnSeries || A.config.chart.dropShadow.enabledOnSeries && -1 !== A.config.chart.dropShadow.enabledOnSeries.indexOf(a))) {
          var E = A.config.chart.dropShadow;
          S.dropShadow(M, E, a);
        }
        y && (M.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, M)), M.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, M)), M.node.addEventListener("mousedown", this.pathMouseDown.bind(this, M))), M.attr({
          pathTo: r,
          pathFrom: s
        });
        var X = {
          el: M,
          j: i,
          realIndex: a,
          pathFrom: s,
          pathTo: r,
          fill: c,
          strokeWidth: l,
          delay: d
        };
        return !L || A.globals.resized || A.globals.dataChanged ? !A.globals.resized && A.globals.dataChanged || C.showDelayedElements() : C.animatePathsGradually(n(n({}, X), {}, {
          speed: g
        })), A.globals.dataChanged && P && T && C.animatePathsGradually(n(n({}, X), {}, {
          speed: u
        })), M;
      }
    }, {
      key: "drawPattern",
      value: function value(t, e, i) {
        var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
            s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
            r = this.w,
            n = r.globals.dom.Paper.pattern(e, i, function (r) {
          "horizontalLines" === t ? r.line(0, 0, i, 0).stroke({
            color: a,
            width: s + 1
          }) : "verticalLines" === t ? r.line(0, 0, 0, e).stroke({
            color: a,
            width: s + 1
          }) : "slantedLines" === t ? r.line(0, 0, e, i).stroke({
            color: a,
            width: s
          }) : "squares" === t ? r.rect(e, i).fill("none").stroke({
            color: a,
            width: s
          }) : "circles" === t && r.circle(e).fill("none").stroke({
            color: a,
            width: s
          });
        });
        return n;
      }
    }, {
      key: "drawGradient",
      value: function value(t, e, i, a, s) {
        var r,
            n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
            o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
            l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
            h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
            c = this.w;
        e.length < 9 && 0 === e.indexOf("#") && (e = f.hexToRgba(e, a)), i.length < 9 && 0 === i.indexOf("#") && (i = f.hexToRgba(i, s));
        var d = 0,
            g = 1,
            u = 1,
            p = null;
        null !== o && (d = void 0 !== o[0] ? o[0] / 100 : 0, g = void 0 !== o[1] ? o[1] / 100 : 1, u = void 0 !== o[2] ? o[2] / 100 : 1, p = void 0 !== o[3] ? o[3] / 100 : null);
        var x = !("donut" !== c.config.chart.type && "pie" !== c.config.chart.type && "polarArea" !== c.config.chart.type && "bubble" !== c.config.chart.type);

        if (r = null === l || 0 === l.length ? c.globals.dom.Paper.gradient(x ? "radial" : "linear", function (t) {
          t.at(d, e, a), t.at(g, i, s), t.at(u, i, s), null !== p && t.at(p, e, a);
        }) : c.globals.dom.Paper.gradient(x ? "radial" : "linear", function (t) {
          (Array.isArray(l[h]) ? l[h] : l).forEach(function (e) {
            t.at(e.offset / 100, e.color, e.opacity);
          });
        }), x) {
          var b = c.globals.gridWidth / 2,
              m = c.globals.gridHeight / 2;
          "bubble" !== c.config.chart.type ? r.attr({
            gradientUnits: "userSpaceOnUse",
            cx: b,
            cy: m,
            r: n
          }) : r.attr({
            cx: .5,
            cy: .5,
            r: .8,
            fx: .2,
            fy: .2
          });
        } else "vertical" === t ? r.from(0, 0).to(0, 1) : "diagonal" === t ? r.from(0, 0).to(1, 1) : "horizontal" === t ? r.from(0, 1).to(1, 1) : "diagonal2" === t && r.from(1, 0).to(0, 1);

        return r;
      }
    }, {
      key: "drawText",
      value: function value(t) {
        var e,
            i = t.x,
            a = t.y,
            s = t.text,
            r = t.textAnchor,
            n = t.fontSize,
            o = t.fontFamily,
            l = t.fontWeight,
            h = t.foreColor,
            c = t.opacity,
            d = t.cssClass,
            g = void 0 === d ? "" : d,
            u = t.isPlainText,
            f = void 0 === u || u,
            p = this.w;
        return void 0 === s && (s = ""), r || (r = "start"), h && h.length || (h = p.config.chart.foreColor), o = o || p.config.chart.fontFamily, l = l || "regular", (e = Array.isArray(s) ? p.globals.dom.Paper.text(function (t) {
          for (var e = 0; e < s.length; e++) {
            0 === e ? t.tspan(s[e]) : t.tspan(s[e]).newLine();
          }
        }) : f ? p.globals.dom.Paper.plain(s) : p.globals.dom.Paper.text(function (t) {
          return t.tspan(s);
        })).attr({
          x: i,
          y: a,
          "text-anchor": r,
          "dominant-baseline": "auto",
          "font-size": n,
          "font-family": o,
          "font-weight": l,
          fill: h,
          class: "apexcharts-text " + g
        }), e.node.style.fontFamily = o, e.node.style.opacity = c, e;
      }
    }, {
      key: "drawMarker",
      value: function value(t, e, i) {
        t = t || 0;
        var a = i.pSize || 0,
            s = null;

        if ("square" === i.shape) {
          var r = void 0 === i.pRadius ? a / 2 : i.pRadius;
          null !== e && a || (a = 0, r = 0);
          var n = 1.2 * a + r,
              o = this.drawRect(n, n, n, n, r);
          o.attr({
            x: t - n / 2,
            y: e - n / 2,
            cx: t,
            cy: e,
            class: i.class ? i.class : "",
            fill: i.pointFillColor,
            "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
            stroke: i.pointStrokeColor,
            "stroke-width": i.pWidth ? i.pWidth : 0,
            "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
          }), s = o;
        } else "circle" !== i.shape && i.shape || (f.isNumber(e) || (a = 0, e = 0), s = this.drawCircle(a, {
          cx: t,
          cy: e,
          class: i.class ? i.class : "",
          stroke: i.pointStrokeColor,
          fill: i.pointFillColor,
          "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
          "stroke-width": i.pWidth ? i.pWidth : 0,
          "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
        }));

        return s;
      }
    }, {
      key: "pathMouseEnter",
      value: function value(t, e) {
        var i = this.w,
            a = new p(this.ctx),
            s = parseInt(t.node.getAttribute("index"), 10),
            r = parseInt(t.node.getAttribute("j"), 10);

        if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(e, this.ctx, {
          seriesIndex: s,
          dataPointIndex: r,
          w: i
        }), this.ctx.events.fireEvent("dataPointMouseEnter", [e, this.ctx, {
          seriesIndex: s,
          dataPointIndex: r,
          w: i
        }]), ("none" === i.config.states.active.filter.type || "true" !== t.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && "none" !== i.config.states.active.filter.type && !i.globals.isTouchDevice) {
          var n = i.config.states.hover.filter;
          a.applyFilter(t, s, n.type, n.value);
        }
      }
    }, {
      key: "pathMouseLeave",
      value: function value(t, e) {
        var i = this.w,
            a = new p(this.ctx),
            s = parseInt(t.node.getAttribute("index"), 10),
            r = parseInt(t.node.getAttribute("j"), 10);
        "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(e, this.ctx, {
          seriesIndex: s,
          dataPointIndex: r,
          w: i
        }), this.ctx.events.fireEvent("dataPointMouseLeave", [e, this.ctx, {
          seriesIndex: s,
          dataPointIndex: r,
          w: i
        }]), "none" !== i.config.states.active.filter.type && "true" === t.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && a.getDefaultFilter(t, s);
      }
    }, {
      key: "pathMouseDown",
      value: function value(t, e) {
        var i = this.w,
            a = new p(this.ctx),
            s = parseInt(t.node.getAttribute("index"), 10),
            r = parseInt(t.node.getAttribute("j"), 10),
            n = "false";

        if ("true" === t.node.getAttribute("selected")) {
          if (t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[s].indexOf(r) > -1) {
            var o = i.globals.selectedDataPoints[s].indexOf(r);
            i.globals.selectedDataPoints[s].splice(o, 1);
          }
        } else {
          if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
            i.globals.selectedDataPoints = [];

            var l = i.globals.dom.Paper.select(".apexcharts-series path").members,
                h = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
                c = function c(t) {
              Array.prototype.forEach.call(t, function (t) {
                t.node.setAttribute("selected", "false"), a.getDefaultFilter(t, s);
              });
            };

            c(l), c(h);
          }

          t.node.setAttribute("selected", "true"), n = "true", void 0 === i.globals.selectedDataPoints[s] && (i.globals.selectedDataPoints[s] = []), i.globals.selectedDataPoints[s].push(r);
        }

        if ("true" === n) {
          var d = i.config.states.active.filter;
          "none" !== d && a.applyFilter(t, s, d.type, d.value);
        } else "none" !== i.config.states.active.filter.type && a.getDefaultFilter(t, s);

        "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(e, this.ctx, {
          selectedDataPoints: i.globals.selectedDataPoints,
          seriesIndex: s,
          dataPointIndex: r,
          w: i
        }), e && this.ctx.events.fireEvent("dataPointSelection", [e, this.ctx, {
          selectedDataPoints: i.globals.selectedDataPoints,
          seriesIndex: s,
          dataPointIndex: r,
          w: i
        }]);
      }
    }, {
      key: "rotateAroundCenter",
      value: function value(t) {
        var e = t.getBBox();
        return {
          x: e.x + e.width / 2,
          y: e.y + e.height / 2
        };
      }
    }, {
      key: "getTextRects",
      value: function value(t, e, i, a) {
        var s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
            r = this.w,
            n = this.drawText({
          x: -200,
          y: -200,
          text: t,
          textAnchor: "start",
          fontSize: e,
          fontFamily: i,
          foreColor: "#fff",
          opacity: 0
        });
        a && n.attr("transform", a), r.globals.dom.Paper.add(n);
        var o = n.bbox();
        return s || (o = n.node.getBoundingClientRect()), n.remove(), {
          width: o.width,
          height: o.height
        };
      }
    }, {
      key: "placeTextWithEllipsis",
      value: function value(t, e, i) {
        if ("function" == typeof t.getComputedTextLength && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= i / .8)) {
          for (var a = e.length - 3; a > 0; a -= 3) {
            if (t.getSubStringLength(0, a) <= i / .8) return void (t.textContent = e.substring(0, a) + "...");
          }

          t.textContent = ".";
        }
      }
    }], [{
      key: "setAttrs",
      value: function value(t, e) {
        for (var i in e) {
          e.hasOwnProperty(i) && t.setAttribute(i, e[i]);
        }
      }
    }]), t;
  }(),
      m = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.annoCtx = i;
    }

    return a(t, [{
      key: "setOrientations",
      value: function value(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
            i = this.w;

        if ("vertical" === t.label.orientation) {
          var a = null !== e ? e : 0,
              s = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a, "']"));

          if (null !== s) {
            var r = s.getBoundingClientRect();
            s.setAttribute("x", parseFloat(s.getAttribute("x")) - r.height + 4), "top" === t.label.position ? s.setAttribute("y", parseFloat(s.getAttribute("y")) + r.width) : s.setAttribute("y", parseFloat(s.getAttribute("y")) - r.width);
            var n = this.annoCtx.graphics.rotateAroundCenter(s),
                o = n.x,
                l = n.y;
            s.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(l, ")"));
          }
        }
      }
    }, {
      key: "addBackgroundToAnno",
      value: function value(t, e) {
        var i = this.w;
        if (!e.label.text || e.label.text && !e.label.text.trim()) return null;
        var a = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
            s = t.getBoundingClientRect(),
            r = e.label.style.padding.left,
            n = e.label.style.padding.right,
            o = e.label.style.padding.top,
            l = e.label.style.padding.bottom;
        "vertical" === e.label.orientation && (o = e.label.style.padding.left, l = e.label.style.padding.right, r = e.label.style.padding.top, n = e.label.style.padding.bottom);
        var h = s.left - a.left - r,
            c = s.top - a.top - o,
            d = this.annoCtx.graphics.drawRect(h - i.globals.barPadForNumericAxis, c, s.width + r + n, s.height + o + l, e.label.borderRadius, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0);
        return e.id && d.node.classList.add(e.id), d;
      }
    }, {
      key: "annotationsBackground",
      value: function value() {
        var t = this,
            e = this.w,
            i = function i(_i, a, s) {
          var r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(a, "']"));

          if (r) {
            var n = r.parentNode,
                o = t.addBackgroundToAnno(r, _i);
            o && n.insertBefore(o.node, r);
          }
        };

        e.config.annotations.xaxis.map(function (t, e) {
          i(t, e, "xaxis");
        }), e.config.annotations.yaxis.map(function (t, e) {
          i(t, e, "yaxis");
        }), e.config.annotations.points.map(function (t, e) {
          i(t, e, "point");
        });
      }
    }, {
      key: "getStringX",
      value: function value(t) {
        var e = this.w,
            i = t;
        e.config.xaxis.convertedCatToNumeric && e.globals.categoryLabels.length && (t = e.globals.categoryLabels.indexOf(t) + 1);
        var a = e.globals.labels.indexOf(t),
            s = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a + 1) + ")");
        return s && (i = parseFloat(s.getAttribute("x"))), i;
      }
    }]), t;
  }(),
      v = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.annoCtx = i, this.invertAxis = this.annoCtx.invertAxis;
    }

    return a(t, [{
      key: "addXaxisAnnotation",
      value: function value(t, e, i) {
        var a = this.w,
            s = this.invertAxis ? a.globals.minY : a.globals.minX,
            r = this.invertAxis ? a.globals.maxY : a.globals.maxX,
            n = this.invertAxis ? a.globals.yRange[0] : a.globals.xRange,
            o = (t.x - s) / (n / a.globals.gridWidth);
        this.annoCtx.inversedReversedAxis && (o = (r - t.x) / (n / a.globals.gridWidth));
        var l = t.label.text;
        "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (o = this.annoCtx.helpers.getStringX(t.x));
        var h = t.strokeDashArray;

        if (f.isNumber(o)) {
          if (null === t.x2 || void 0 === t.x2) {
            var c = this.annoCtx.graphics.drawLine(o + t.offsetX, 0 + t.offsetY, o + t.offsetX, a.globals.gridHeight + t.offsetY, t.borderColor, h, t.borderWidth);
            e.appendChild(c.node), t.id && c.node.classList.add(t.id);
          } else {
            var d = (t.x2 - s) / (n / a.globals.gridWidth);

            if (this.annoCtx.inversedReversedAxis && (d = (r - t.x2) / (n / a.globals.gridWidth)), "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (d = this.annoCtx.helpers.getStringX(t.x2)), d < o) {
              var g = o;
              o = d, d = g;
            }

            var u = this.annoCtx.graphics.drawRect(o + t.offsetX, 0 + t.offsetY, d - o, a.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, h);
            u.node.classList.add("apexcharts-annotation-rect"), u.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")), e.appendChild(u.node), t.id && u.node.classList.add(t.id);
          }

          var p = "top" === t.label.position ? 4 : a.globals.gridHeight,
              x = this.annoCtx.graphics.getTextRects(l, parseFloat(t.label.style.fontSize)),
              b = this.annoCtx.graphics.drawText({
            x: o + t.label.offsetX,
            y: p + t.label.offsetY - ("vertical" === t.label.orientation ? "top" === t.label.position ? x.width / 2 - 12 : -x.width / 2 : 0),
            text: l,
            textAnchor: t.label.textAnchor,
            fontSize: t.label.style.fontSize,
            fontFamily: t.label.style.fontFamily,
            fontWeight: t.label.style.fontWeight,
            foreColor: t.label.style.color,
            cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
          });
          b.attr({
            rel: i
          }), e.appendChild(b.node), this.annoCtx.helpers.setOrientations(t, i);
        }
      }
    }, {
      key: "drawXAxisAnnotations",
      value: function value() {
        var t = this,
            e = this.w,
            i = this.annoCtx.graphics.group({
          class: "apexcharts-xaxis-annotations"
        });
        return e.config.annotations.xaxis.map(function (e, a) {
          t.addXaxisAnnotation(e, i.node, a);
        }), i;
      }
    }]), t;
  }(),
      y = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "getStackedSeriesTotals",
      value: function value() {
        var t = this.w,
            e = [];
        if (0 === t.globals.series.length) return e;

        for (var i = 0; i < t.globals.series[t.globals.maxValsInArrayIndex].length; i++) {
          for (var a = 0, s = 0; s < t.globals.series.length; s++) {
            void 0 !== t.globals.series[s][i] && (a += t.globals.series[s][i]);
          }

          e.push(a);
        }

        return t.globals.stackedSeriesTotals = e, e;
      }
    }, {
      key: "getSeriesTotalByIndex",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return null === t ? this.w.config.series.reduce(function (t, e) {
          return t + e;
        }, 0) : this.w.globals.series[t].reduce(function (t, e) {
          return t + e;
        }, 0);
      }
    }, {
      key: "isSeriesNull",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return 0 === (null === t ? this.w.config.series.filter(function (t) {
          return null !== t;
        }) : this.w.config.series[t].data.filter(function (t) {
          return null !== t;
        })).length;
      }
    }, {
      key: "seriesHaveSameValues",
      value: function value(t) {
        return this.w.globals.series[t].every(function (t, e, i) {
          return t === i[0];
        });
      }
    }, {
      key: "getCategoryLabels",
      value: function value(t) {
        var e = this.w,
            i = t.slice();
        return e.config.xaxis.convertedCatToNumeric && (i = t.map(function (t) {
          return e.config.xaxis.labels.formatter(t - e.globals.minX + 1);
        })), i;
      }
    }, {
      key: "getLargestSeries",
      value: function value() {
        var t = this.w;
        t.globals.maxValsInArrayIndex = t.globals.series.map(function (t) {
          return t.length;
        }).indexOf(Math.max.apply(Math, t.globals.series.map(function (t) {
          return t.length;
        })));
      }
    }, {
      key: "getLargestMarkerSize",
      value: function value() {
        var t = this.w,
            e = 0;
        return t.globals.markers.size.forEach(function (t) {
          e = Math.max(e, t);
        }), t.globals.markers.largestSize = e, e;
      }
    }, {
      key: "getSeriesTotals",
      value: function value() {
        var t = this.w;
        t.globals.seriesTotals = t.globals.series.map(function (t, e) {
          var i = 0;
          if (Array.isArray(t)) for (var a = 0; a < t.length; a++) {
            i += t[a];
          } else i += t;
          return i;
        });
      }
    }, {
      key: "getSeriesTotalsXRange",
      value: function value(t, e) {
        var i = this.w;
        return i.globals.series.map(function (a, s) {
          for (var r = 0, n = 0; n < a.length; n++) {
            i.globals.seriesX[s][n] > t && i.globals.seriesX[s][n] < e && (r += a[n]);
          }

          return r;
        });
      }
    }, {
      key: "getPercentSeries",
      value: function value() {
        var t = this.w;
        t.globals.seriesPercent = t.globals.series.map(function (e, i) {
          var a = [];
          if (Array.isArray(e)) for (var s = 0; s < e.length; s++) {
            var r = t.globals.stackedSeriesTotals[s],
                n = 0;
            r && (n = 100 * e[s] / r), a.push(n);
          } else {
            var o = 100 * e / t.globals.seriesTotals.reduce(function (t, e) {
              return t + e;
            }, 0);
            a.push(o);
          }
          return a;
        });
      }
    }, {
      key: "getCalculatedRatios",
      value: function value() {
        var t,
            e,
            i,
            a,
            s = this.w.globals,
            r = [],
            n = 0,
            o = [],
            l = .1,
            h = 0;
        if (s.yRange = [], s.isMultipleYAxis) for (var c = 0; c < s.minYArr.length; c++) {
          s.yRange.push(Math.abs(s.minYArr[c] - s.maxYArr[c])), o.push(0);
        } else s.yRange.push(Math.abs(s.minY - s.maxY));
        s.xRange = Math.abs(s.maxX - s.minX), s.zRange = Math.abs(s.maxZ - s.minZ);

        for (var d = 0; d < s.yRange.length; d++) {
          r.push(s.yRange[d] / s.gridHeight);
        }

        if (e = s.xRange / s.gridWidth, i = Math.abs(s.initialMaxX - s.initialMinX) / s.gridWidth, t = s.yRange / s.gridWidth, a = s.xRange / s.gridHeight, (n = s.zRange / s.gridHeight * 16) || (n = 1), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (s.hasNegs = !0), s.isMultipleYAxis) {
          o = [];

          for (var g = 0; g < r.length; g++) {
            o.push(-s.minYArr[g] / r[g]);
          }
        } else o.push(-s.minY / r[0]), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (l = -s.minY / t, h = s.minX / e);

        return {
          yRatio: r,
          invertedYRatio: t,
          zRatio: n,
          xRatio: e,
          initialXRatio: i,
          invertedXRatio: a,
          baseLineInvertedY: l,
          baseLineY: o,
          baseLineX: h
        };
      }
    }, {
      key: "getLogSeries",
      value: function value(t) {
        var e = this,
            i = this.w;
        return i.globals.seriesLog = t.map(function (t, a) {
          return i.config.yaxis[a] && i.config.yaxis[a].logarithmic ? t.map(function (t) {
            return null === t ? null : e.getLogVal(t, a);
          }) : t;
        }), i.globals.invalidLogScale ? t : i.globals.seriesLog;
      }
    }, {
      key: "getLogVal",
      value: function value(t, e) {
        var i = this.w;
        return (Math.log(t) - Math.log(i.globals.minYArr[e])) / (Math.log(i.globals.maxYArr[e]) - Math.log(i.globals.minYArr[e]));
      }
    }, {
      key: "getLogYRatios",
      value: function value(t) {
        var e = this,
            i = this.w,
            a = this.w.globals;
        return a.yLogRatio = t.slice(), a.logYRange = a.yRange.map(function (t, s) {
          if (i.config.yaxis[s] && e.w.config.yaxis[s].logarithmic) {
            var r,
                n = -Number.MAX_VALUE,
                o = Number.MIN_VALUE;
            return a.seriesLog.forEach(function (t, e) {
              t.forEach(function (t) {
                i.config.yaxis[e] && i.config.yaxis[e].logarithmic && (n = Math.max(t, n), o = Math.min(t, o));
              });
            }), r = Math.pow(a.yRange[s], Math.abs(o - n) / a.yRange[s]), a.yLogRatio[s] = r / a.gridHeight, r;
          }
        }), a.invalidLogScale ? t.slice() : a.yLogRatio;
      }
    }], [{
      key: "checkComboSeries",
      value: function value(t) {
        var e = !1,
            i = 0;
        return t.length && void 0 !== t[0].type && (e = !0, t.forEach(function (t) {
          "bar" !== t.type && "column" !== t.type && "candlestick" !== t.type || i++;
        })), {
          comboBarCount: i,
          comboCharts: e
        };
      }
    }, {
      key: "extendArrayProps",
      value: function value(t, e, i) {
        return e.yaxis && (e = t.extendYAxis(e, i)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e;
      }
    }]), t;
  }(),
      w = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.annoCtx = i;
    }

    return a(t, [{
      key: "addYaxisAnnotation",
      value: function value(t, e, i) {
        var a,
            s = this.w,
            r = t.strokeDashArray,
            n = this._getY1Y2("y1", t),
            o = t.label.text;

        if (null === t.y2 || void 0 === t.y2) {
          var l = this.annoCtx.graphics.drawLine(0 + t.offsetX, n + t.offsetY, s.globals.gridWidth + t.offsetX, n + t.offsetY, t.borderColor, r, t.borderWidth);
          e.appendChild(l.node), t.id && l.node.classList.add(t.id);
        } else {
          if ((a = this._getY1Y2("y2", t)) > n) {
            var h = n;
            n = a, a = h;
          }

          var c = this.annoCtx.graphics.drawRect(0 + t.offsetX, a + t.offsetY, s.globals.gridWidth + t.offsetX, n - a, 0, t.fillColor, t.opacity, 1, t.borderColor, r);
          c.node.classList.add("apexcharts-annotation-rect"), c.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")), e.appendChild(c.node), t.id && c.node.classList.add(t.id);
        }

        var d = "right" === t.label.position ? s.globals.gridWidth : 0,
            g = this.annoCtx.graphics.drawText({
          x: d + t.label.offsetX,
          y: (a || n) + t.label.offsetY - 3,
          text: o,
          textAnchor: t.label.textAnchor,
          fontSize: t.label.style.fontSize,
          fontFamily: t.label.style.fontFamily,
          fontWeight: t.label.style.fontWeight,
          foreColor: t.label.style.color,
          cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
        });
        g.attr({
          rel: i
        }), e.appendChild(g.node);
      }
    }, {
      key: "_getY1Y2",
      value: function value(t, e) {
        var i,
            a = "y1" === t ? e.y : e.y2,
            s = this.w;

        if (this.annoCtx.invertAxis) {
          var r = s.globals.labels.indexOf(a);
          s.config.xaxis.convertedCatToNumeric && (r = s.globals.categoryLabels.indexOf(a));
          var n = s.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
          n && (i = parseFloat(n.getAttribute("y")));
        } else {
          var o;
          if (s.config.yaxis[e.yAxisIndex].logarithmic) o = (a = new y(this.annoCtx.ctx).getLogVal(a, e.yAxisIndex)) / s.globals.yLogRatio[e.yAxisIndex];else o = (a - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight);
          i = s.globals.gridHeight - o, s.config.yaxis[e.yAxisIndex] && s.config.yaxis[e.yAxisIndex].reversed && (i = o);
        }

        return i;
      }
    }, {
      key: "drawYAxisAnnotations",
      value: function value() {
        var t = this,
            e = this.w,
            i = this.annoCtx.graphics.group({
          class: "apexcharts-yaxis-annotations"
        });
        return e.config.annotations.yaxis.map(function (e, a) {
          t.addYaxisAnnotation(e, i.node, a);
        }), i;
      }
    }]), t;
  }(),
      k = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.annoCtx = i;
    }

    return a(t, [{
      key: "addPointAnnotation",
      value: function value(t, e, i) {
        var a = this.w,
            s = 0,
            r = 0,
            n = 0;
        this.annoCtx.invertAxis && console.warn("Point annotation is not supported in horizontal bar charts.");
        var o,
            l = parseFloat(t.y);

        if ("string" == typeof t.x) {
          var h = a.globals.labels.indexOf(t.x);
          a.config.xaxis.convertedCatToNumeric && (h = a.globals.categoryLabels.indexOf(t.x)), s = this.annoCtx.helpers.getStringX(t.x), null === t.y && (l = a.globals.series[t.seriesIndex][h]);
        } else s = (t.x - a.globals.minX) / (a.globals.xRange / a.globals.gridWidth);

        a.config.yaxis[t.yAxisIndex].logarithmic ? o = (l = new y(this.annoCtx.ctx).getLogVal(l, t.yAxisIndex)) / a.globals.yLogRatio[t.yAxisIndex] : o = (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight);

        if (r = a.globals.gridHeight - o - parseFloat(t.label.style.fontSize) - t.marker.size, n = a.globals.gridHeight - o, a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (r = o + parseFloat(t.label.style.fontSize) + t.marker.size, n = o), f.isNumber(s)) {
          var c = {
            pSize: t.marker.size,
            pWidth: t.marker.strokeWidth,
            pointFillColor: t.marker.fillColor,
            pointStrokeColor: t.marker.strokeColor,
            shape: t.marker.shape,
            pRadius: t.marker.radius,
            class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "")
          },
              d = this.annoCtx.graphics.drawMarker(s + t.marker.offsetX, n + t.marker.offsetY, c);
          e.appendChild(d.node);
          var g = t.label.text ? t.label.text : "",
              u = this.annoCtx.graphics.drawText({
            x: s + t.label.offsetX,
            y: r + t.label.offsetY,
            text: g,
            textAnchor: t.label.textAnchor,
            fontSize: t.label.style.fontSize,
            fontFamily: t.label.style.fontFamily,
            fontWeight: t.label.style.fontWeight,
            foreColor: t.label.style.color,
            cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
          });

          if (u.attr({
            rel: i
          }), e.appendChild(u.node), t.customSVG.SVG) {
            var p = this.annoCtx.graphics.group({
              class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass
            });
            p.attr({
              transform: "translate(".concat(s + t.customSVG.offsetX, ", ").concat(r + t.customSVG.offsetY, ")")
            }), p.node.innerHTML = t.customSVG.SVG, e.appendChild(p.node);
          }

          if (t.image.path) {
            var x = t.image.width ? t.image.width : 20,
                b = t.image.height ? t.image.height : 20;
            this.annoCtx.addImage({
              x: s + t.image.offsetX - x / 2,
              y: r + t.image.offsetY - b / 2,
              width: x,
              height: b,
              path: t.image.path,
              appendTo: ".apexcharts-point-annotations"
            });
          }
        }
      }
    }, {
      key: "drawPointAnnotations",
      value: function value() {
        var t = this,
            e = this.w,
            i = this.annoCtx.graphics.group({
          class: "apexcharts-point-annotations"
        });
        return e.config.annotations.points.map(function (e, a) {
          t.addPointAnnotation(e, i.node, a);
        }), i;
      }
    }]), t;
  }();

  var A,
      S,
      C = {
    name: "en",
    options: {
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      toolbar: {
        exportToSVG: "Download SVG",
        exportToPNG: "Download PNG",
        exportToCSV: "Download CSV",
        menu: "Menu",
        selection: "Selection",
        selectionZoom: "Selection Zoom",
        zoomIn: "Zoom In",
        zoomOut: "Zoom Out",
        pan: "Panning",
        reset: "Reset Zoom"
      }
    }
  },
      L = function () {
    function t() {
      e(this, t), this.yAxis = {
        show: !0,
        showAlways: !1,
        showForNullSeries: !0,
        seriesName: void 0,
        opposite: !1,
        reversed: !1,
        logarithmic: !1,
        tickAmount: void 0,
        forceNiceScale: !1,
        max: void 0,
        min: void 0,
        floating: !1,
        decimalsInFloat: void 0,
        labels: {
          show: !0,
          minWidth: 0,
          maxWidth: 160,
          offsetX: 0,
          offsetY: 0,
          align: void 0,
          rotate: 0,
          padding: 20,
          style: {
            colors: [],
            fontSize: "11px",
            fontWeight: 400,
            fontFamily: void 0,
            cssClass: ""
          },
          formatter: void 0
        },
        axisBorder: {
          show: !1,
          color: "#e0e0e0",
          width: 1,
          offsetX: 0,
          offsetY: 0
        },
        axisTicks: {
          show: !1,
          color: "#e0e0e0",
          width: 6,
          offsetX: 0,
          offsetY: 0
        },
        title: {
          text: void 0,
          rotate: -90,
          offsetY: 0,
          offsetX: 0,
          style: {
            color: void 0,
            fontSize: "11px",
            fontWeight: 900,
            fontFamily: void 0,
            cssClass: ""
          }
        },
        tooltip: {
          enabled: !1,
          offsetX: 0
        },
        crosshairs: {
          show: !0,
          position: "front",
          stroke: {
            color: "#b6b6b6",
            width: 1,
            dashArray: 0
          }
        }
      }, this.pointAnnotation = {
        x: 0,
        y: null,
        yAxisIndex: 0,
        seriesIndex: 0,
        marker: {
          size: 4,
          fillColor: "#fff",
          strokeWidth: 2,
          strokeColor: "#333",
          shape: "circle",
          offsetX: 0,
          offsetY: 0,
          radius: 2,
          cssClass: ""
        },
        label: {
          borderColor: "#c2c2c2",
          borderWidth: 1,
          borderRadius: 2,
          text: void 0,
          textAnchor: "middle",
          offsetX: 0,
          offsetY: 0,
          style: {
            background: "#fff",
            color: void 0,
            fontSize: "11px",
            fontFamily: void 0,
            fontWeight: 400,
            cssClass: "",
            padding: {
              left: 5,
              right: 5,
              top: 2,
              bottom: 2
            }
          }
        },
        customSVG: {
          SVG: void 0,
          cssClass: void 0,
          offsetX: 0,
          offsetY: 0
        },
        image: {
          path: void 0,
          width: 20,
          height: 20,
          offsetX: 0,
          offsetY: 0
        }
      }, this.yAxisAnnotation = {
        y: 0,
        y2: null,
        strokeDashArray: 1,
        fillColor: "#c2c2c2",
        borderColor: "#c2c2c2",
        borderWidth: 1,
        opacity: .3,
        offsetX: 0,
        offsetY: 0,
        yAxisIndex: 0,
        label: {
          borderColor: "#c2c2c2",
          borderWidth: 1,
          borderRadius: 2,
          text: void 0,
          textAnchor: "end",
          position: "right",
          offsetX: 0,
          offsetY: -3,
          style: {
            background: "#fff",
            color: void 0,
            fontSize: "11px",
            fontFamily: void 0,
            fontWeight: 400,
            cssClass: "",
            padding: {
              left: 5,
              right: 5,
              top: 2,
              bottom: 2
            }
          }
        }
      }, this.xAxisAnnotation = {
        x: 0,
        x2: null,
        strokeDashArray: 1,
        fillColor: "#c2c2c2",
        borderColor: "#c2c2c2",
        borderWidth: 1,
        opacity: .3,
        offsetX: 0,
        offsetY: 0,
        label: {
          borderColor: "#c2c2c2",
          borderWidth: 1,
          borderRadius: 2,
          text: void 0,
          textAnchor: "middle",
          orientation: "vertical",
          position: "top",
          offsetX: 0,
          offsetY: 0,
          style: {
            background: "#fff",
            color: void 0,
            fontSize: "11px",
            fontFamily: void 0,
            fontWeight: 400,
            cssClass: "",
            padding: {
              left: 5,
              right: 5,
              top: 2,
              bottom: 2
            }
          }
        }
      }, this.text = {
        x: 0,
        y: 0,
        text: "",
        textAnchor: "start",
        foreColor: void 0,
        fontSize: "13px",
        fontFamily: void 0,
        fontWeight: 400,
        appendTo: ".apexcharts-annotations",
        backgroundColor: "transparent",
        borderColor: "#c2c2c2",
        borderRadius: 0,
        borderWidth: 0,
        paddingLeft: 4,
        paddingRight: 4,
        paddingTop: 2,
        paddingBottom: 2
      };
    }

    return a(t, [{
      key: "init",
      value: function value() {
        return {
          annotations: {
            position: "front",
            yaxis: [this.yAxisAnnotation],
            xaxis: [this.xAxisAnnotation],
            points: [this.pointAnnotation],
            texts: [],
            images: [],
            shapes: []
          },
          chart: {
            animations: {
              enabled: !0,
              easing: "easeinout",
              speed: 800,
              animateGradually: {
                delay: 150,
                enabled: !0
              },
              dynamicAnimation: {
                enabled: !0,
                speed: 350
              }
            },
            background: "transparent",
            locales: [C],
            defaultLocale: "en",
            dropShadow: {
              enabled: !1,
              enabledOnSeries: void 0,
              top: 2,
              left: 2,
              blur: 4,
              color: "#000",
              opacity: .35
            },
            events: {
              animationEnd: void 0,
              beforeMount: void 0,
              mounted: void 0,
              updated: void 0,
              click: void 0,
              mouseMove: void 0,
              legendClick: void 0,
              markerClick: void 0,
              selection: void 0,
              dataPointSelection: void 0,
              dataPointMouseEnter: void 0,
              dataPointMouseLeave: void 0,
              beforeZoom: void 0,
              zoomed: void 0,
              scrolled: void 0
            },
            foreColor: "#373d3f",
            fontFamily: "Helvetica, Arial, sans-serif",
            height: "auto",
            parentHeightOffset: 15,
            redrawOnParentResize: !0,
            id: void 0,
            group: void 0,
            offsetX: 0,
            offsetY: 0,
            selection: {
              enabled: !1,
              type: "x",
              fill: {
                color: "#24292e",
                opacity: .1
              },
              stroke: {
                width: 1,
                color: "#24292e",
                opacity: .4,
                dashArray: 3
              },
              xaxis: {
                min: void 0,
                max: void 0
              },
              yaxis: {
                min: void 0,
                max: void 0
              }
            },
            sparkline: {
              enabled: !1
            },
            brush: {
              enabled: !1,
              autoScaleYaxis: !0,
              target: void 0
            },
            stacked: !1,
            stackType: "normal",
            toolbar: {
              show: !0,
              offsetX: 0,
              offsetY: 0,
              tools: {
                download: !0,
                selection: !0,
                zoom: !0,
                zoomin: !0,
                zoomout: !0,
                pan: !0,
                reset: !0,
                customIcons: []
              },
              export: {
                csv: {
                  filename: void 0,
                  columnDelimiter: ",",
                  headerCategory: "category",
                  headerValue: "value",
                  dateFormatter: function dateFormatter(t) {
                    return new Date(t).toDateString();
                  }
                }
              },
              autoSelected: "zoom"
            },
            type: "line",
            width: "100%",
            zoom: {
              enabled: !0,
              type: "x",
              autoScaleYaxis: !1,
              zoomedArea: {
                fill: {
                  color: "#90CAF9",
                  opacity: .4
                },
                stroke: {
                  color: "#0D47A1",
                  opacity: .4,
                  width: 1
                }
              }
            }
          },
          plotOptions: {
            area: {
              fillTo: "origin"
            },
            bar: {
              horizontal: !1,
              columnWidth: "70%",
              barHeight: "70%",
              distributed: !1,
              startingShape: "flat",
              endingShape: "flat",
              rangeBarOverlap: !0,
              colors: {
                ranges: [],
                backgroundBarColors: [],
                backgroundBarOpacity: 1,
                backgroundBarRadius: 0
              },
              dataLabels: {
                position: "top",
                maxItems: 100,
                hideOverflowingLabels: !0,
                orientation: "horizontal"
              }
            },
            bubble: {
              minBubbleRadius: void 0,
              maxBubbleRadius: void 0
            },
            candlestick: {
              colors: {
                upward: "#00B746",
                downward: "#EF403C"
              },
              wick: {
                useFillColor: !0
              }
            },
            heatmap: {
              radius: 2,
              enableShades: !0,
              shadeIntensity: .5,
              reverseNegativeShade: !1,
              distributed: !1,
              useFillColorAsStroke: !1,
              colorScale: {
                inverse: !1,
                ranges: [],
                min: void 0,
                max: void 0
              }
            },
            radialBar: {
              inverseOrder: !1,
              startAngle: 0,
              endAngle: 360,
              offsetX: 0,
              offsetY: 0,
              hollow: {
                margin: 5,
                size: "50%",
                background: "transparent",
                image: void 0,
                imageWidth: 150,
                imageHeight: 150,
                imageOffsetX: 0,
                imageOffsetY: 0,
                imageClipped: !0,
                position: "front",
                dropShadow: {
                  enabled: !1,
                  top: 0,
                  left: 0,
                  blur: 3,
                  color: "#000",
                  opacity: .5
                }
              },
              track: {
                show: !0,
                startAngle: void 0,
                endAngle: void 0,
                background: "#f2f2f2",
                strokeWidth: "97%",
                opacity: 1,
                margin: 5,
                dropShadow: {
                  enabled: !1,
                  top: 0,
                  left: 0,
                  blur: 3,
                  color: "#000",
                  opacity: .5
                }
              },
              dataLabels: {
                show: !0,
                name: {
                  show: !0,
                  fontSize: "16px",
                  fontFamily: void 0,
                  fontWeight: 600,
                  color: void 0,
                  offsetY: 0,
                  formatter: function formatter(t) {
                    return t;
                  }
                },
                value: {
                  show: !0,
                  fontSize: "14px",
                  fontFamily: void 0,
                  fontWeight: 400,
                  color: void 0,
                  offsetY: 16,
                  formatter: function formatter(t) {
                    return t + "%";
                  }
                },
                total: {
                  show: !1,
                  label: "Total",
                  fontSize: "16px",
                  fontWeight: 600,
                  fontFamily: void 0,
                  color: void 0,
                  formatter: function formatter(t) {
                    return t.globals.seriesTotals.reduce(function (t, e) {
                      return t + e;
                    }, 0) / t.globals.series.length + "%";
                  }
                }
              }
            },
            pie: {
              customScale: 1,
              offsetX: 0,
              offsetY: 0,
              startAngle: 0,
              expandOnClick: !0,
              dataLabels: {
                offset: 0,
                minAngleToShowLabel: 10
              },
              donut: {
                size: "65%",
                background: "transparent",
                labels: {
                  show: !1,
                  name: {
                    show: !0,
                    fontSize: "16px",
                    fontFamily: void 0,
                    fontWeight: 600,
                    color: void 0,
                    offsetY: -10,
                    formatter: function formatter(t) {
                      return t;
                    }
                  },
                  value: {
                    show: !0,
                    fontSize: "20px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    color: void 0,
                    offsetY: 10,
                    formatter: function formatter(t) {
                      return t;
                    }
                  },
                  total: {
                    show: !1,
                    showAlways: !1,
                    label: "Total",
                    fontSize: "16px",
                    fontWeight: 400,
                    fontFamily: void 0,
                    color: void 0,
                    formatter: function formatter(t) {
                      return t.globals.seriesTotals.reduce(function (t, e) {
                        return t + e;
                      }, 0);
                    }
                  }
                }
              }
            },
            polarArea: {
              rings: {
                strokeWidth: 1,
                strokeColor: "#e8e8e8"
              }
            },
            radar: {
              size: void 0,
              offsetX: 0,
              offsetY: 0,
              polygons: {
                strokeWidth: 1,
                strokeColors: "#e8e8e8",
                connectorColors: "#e8e8e8",
                fill: {
                  colors: void 0
                }
              }
            }
          },
          colors: void 0,
          dataLabels: {
            enabled: !0,
            enabledOnSeries: void 0,
            formatter: function formatter(t) {
              return null !== t ? t : "";
            },
            textAnchor: "middle",
            distributed: !1,
            offsetX: 0,
            offsetY: 0,
            style: {
              fontSize: "12px",
              fontFamily: void 0,
              fontWeight: 600,
              colors: void 0
            },
            background: {
              enabled: !0,
              foreColor: "#fff",
              borderRadius: 2,
              padding: 4,
              opacity: .9,
              borderWidth: 1,
              borderColor: "#fff",
              dropShadow: {
                enabled: !1,
                top: 1,
                left: 1,
                blur: 1,
                color: "#000",
                opacity: .45
              }
            },
            dropShadow: {
              enabled: !1,
              top: 1,
              left: 1,
              blur: 1,
              color: "#000",
              opacity: .45
            }
          },
          fill: {
            type: "solid",
            colors: void 0,
            opacity: .85,
            gradient: {
              shade: "dark",
              type: "horizontal",
              shadeIntensity: .5,
              gradientToColors: void 0,
              inverseColors: !0,
              opacityFrom: 1,
              opacityTo: 1,
              stops: [0, 50, 100],
              colorStops: []
            },
            image: {
              src: [],
              width: void 0,
              height: void 0
            },
            pattern: {
              style: "squares",
              width: 6,
              height: 6,
              strokeWidth: 2
            }
          },
          grid: {
            show: !0,
            borderColor: "#e0e0e0",
            strokeDashArray: 0,
            position: "back",
            xaxis: {
              lines: {
                show: !1
              }
            },
            yaxis: {
              lines: {
                show: !0
              }
            },
            row: {
              colors: void 0,
              opacity: .5
            },
            column: {
              colors: void 0,
              opacity: .5
            },
            padding: {
              top: 0,
              right: 10,
              bottom: 0,
              left: 12
            }
          },
          labels: [],
          legend: {
            show: !0,
            showForSingleSeries: !1,
            showForNullSeries: !0,
            showForZeroSeries: !0,
            floating: !1,
            position: "bottom",
            horizontalAlign: "center",
            inverseOrder: !1,
            fontSize: "12px",
            fontFamily: void 0,
            fontWeight: 400,
            width: void 0,
            height: void 0,
            formatter: void 0,
            tooltipHoverFormatter: void 0,
            offsetX: -20,
            offsetY: 4,
            labels: {
              colors: void 0,
              useSeriesColors: !1
            },
            markers: {
              width: 12,
              height: 12,
              strokeWidth: 0,
              fillColors: void 0,
              strokeColor: "#fff",
              radius: 12,
              customHTML: void 0,
              offsetX: 0,
              offsetY: 0,
              onClick: void 0
            },
            itemMargin: {
              horizontal: 5,
              vertical: 2
            },
            onItemClick: {
              toggleDataSeries: !0
            },
            onItemHover: {
              highlightDataSeries: !0
            }
          },
          markers: {
            discrete: [],
            size: 0,
            colors: void 0,
            strokeColors: "#fff",
            strokeWidth: 2,
            strokeOpacity: .9,
            strokeDashArray: 0,
            fillOpacity: 1,
            shape: "circle",
            radius: 2,
            offsetX: 0,
            offsetY: 0,
            onClick: void 0,
            onDblClick: void 0,
            showNullDataPoints: !0,
            hover: {
              size: void 0,
              sizeOffset: 3
            }
          },
          noData: {
            text: void 0,
            align: "center",
            verticalAlign: "middle",
            offsetX: 0,
            offsetY: 0,
            style: {
              color: void 0,
              fontSize: "14px",
              fontFamily: void 0
            }
          },
          responsive: [],
          series: void 0,
          states: {
            normal: {
              filter: {
                type: "none",
                value: 0
              }
            },
            hover: {
              filter: {
                type: "lighten",
                value: .15
              }
            },
            active: {
              allowMultipleDataPointsSelection: !1,
              filter: {
                type: "darken",
                value: .65
              }
            }
          },
          title: {
            text: void 0,
            align: "left",
            margin: 5,
            offsetX: 0,
            offsetY: 0,
            floating: !1,
            style: {
              fontSize: "14px",
              fontWeight: 900,
              fontFamily: void 0,
              color: void 0
            }
          },
          subtitle: {
            text: void 0,
            align: "left",
            margin: 5,
            offsetX: 0,
            offsetY: 30,
            floating: !1,
            style: {
              fontSize: "12px",
              fontWeight: 400,
              fontFamily: void 0,
              color: void 0
            }
          },
          stroke: {
            show: !0,
            curve: "smooth",
            lineCap: "butt",
            width: 2,
            colors: void 0,
            dashArray: 0
          },
          tooltip: {
            enabled: !0,
            enabledOnSeries: void 0,
            shared: !0,
            followCursor: !1,
            intersect: !1,
            inverseOrder: !1,
            custom: void 0,
            fillSeriesColor: !1,
            theme: "light",
            style: {
              fontSize: "12px",
              fontFamily: void 0
            },
            onDatasetHover: {
              highlightDataSeries: !1
            },
            x: {
              show: !0,
              format: "dd MMM",
              formatter: void 0
            },
            y: {
              formatter: void 0,
              title: {
                formatter: function formatter(t) {
                  return t + ": ";
                }
              }
            },
            z: {
              formatter: void 0,
              title: "Size: "
            },
            marker: {
              show: !0,
              fillColors: void 0
            },
            items: {
              display: "flex"
            },
            fixed: {
              enabled: !1,
              position: "topRight",
              offsetX: 0,
              offsetY: 0
            }
          },
          xaxis: {
            type: "category",
            categories: [],
            convertedCatToNumeric: !1,
            sorted: !1,
            offsetX: 0,
            offsetY: 0,
            labels: {
              show: !0,
              rotate: -45,
              rotateAlways: !1,
              hideOverlappingLabels: !0,
              trim: !1,
              minHeight: void 0,
              maxHeight: 120,
              showDuplicates: !0,
              style: {
                colors: [],
                fontSize: "12px",
                fontWeight: 400,
                fontFamily: void 0,
                cssClass: ""
              },
              offsetX: 0,
              offsetY: 0,
              format: void 0,
              formatter: void 0,
              datetimeUTC: !0,
              datetimeFormatter: {
                year: "yyyy",
                month: "MMM 'yy",
                day: "dd MMM",
                hour: "HH:mm",
                minute: "HH:mm:ss"
              }
            },
            axisBorder: {
              show: !0,
              color: "#e0e0e0",
              width: "100%",
              height: 1,
              offsetX: 0,
              offsetY: 0
            },
            axisTicks: {
              show: !0,
              color: "#e0e0e0",
              height: 6,
              offsetX: 0,
              offsetY: 0
            },
            tickAmount: void 0,
            tickPlacement: "on",
            min: void 0,
            max: void 0,
            range: void 0,
            floating: !1,
            position: "bottom",
            title: {
              text: void 0,
              offsetX: 0,
              offsetY: 0,
              style: {
                color: void 0,
                fontSize: "12px",
                fontWeight: 900,
                fontFamily: void 0,
                cssClass: ""
              }
            },
            crosshairs: {
              show: !0,
              width: 1,
              position: "back",
              opacity: .9,
              stroke: {
                color: "#b6b6b6",
                width: 1,
                dashArray: 3
              },
              fill: {
                type: "solid",
                color: "#B1B9C4",
                gradient: {
                  colorFrom: "#D8E3F0",
                  colorTo: "#BED1E6",
                  stops: [0, 100],
                  opacityFrom: .4,
                  opacityTo: .5
                }
              },
              dropShadow: {
                enabled: !1,
                left: 0,
                top: 0,
                blur: 1,
                opacity: .4
              }
            },
            tooltip: {
              enabled: !0,
              offsetY: 0,
              formatter: void 0,
              style: {
                fontSize: "12px",
                fontFamily: void 0
              }
            }
          },
          yaxis: this.yAxis,
          theme: {
            mode: "light",
            palette: "palette1",
            monochrome: {
              enabled: !1,
              color: "#008FFB",
              shadeTo: "light",
              shadeIntensity: .65
            }
          }
        };
      }
    }]), t;
  }(),
      P = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.graphics = new b(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new m(this), this.xAxisAnnotations = new v(this), this.yAxisAnnotations = new w(this), this.pointsAnnotations = new k(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }

    return a(t, [{
      key: "drawAxesAnnotations",
      value: function value() {
        var t = this.w;

        if (t.globals.axisCharts) {
          for (var e = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a = this.pointsAnnotations.drawPointAnnotations(), s = t.config.chart.animations.enabled, r = [e, i, a], n = [i.node, e.node, a.node], o = 0; o < 3; o++) {
            t.globals.dom.elGraphical.add(r[o]), !s || t.globals.resized || t.globals.dataChanged || "scatter" !== t.config.chart.type && "bubble" !== t.config.chart.type && t.globals.dataPoints > 1 && n[o].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({
              el: n[o],
              index: 0
            });
          }

          this.helpers.annotationsBackground();
        }
      }
    }, {
      key: "drawImageAnnos",
      value: function value() {
        var t = this;
        this.w.config.annotations.images.map(function (e, i) {
          t.addImage(e, i);
        });
      }
    }, {
      key: "drawTextAnnos",
      value: function value() {
        var t = this;
        this.w.config.annotations.texts.map(function (e, i) {
          t.addText(e, i);
        });
      }
    }, {
      key: "addXaxisAnnotation",
      value: function value(t, e, i) {
        this.xAxisAnnotations.addXaxisAnnotation(t, e, i);
      }
    }, {
      key: "addYaxisAnnotation",
      value: function value(t, e, i) {
        this.yAxisAnnotations.addYaxisAnnotation(t, e, i);
      }
    }, {
      key: "addPointAnnotation",
      value: function value(t, e, i) {
        this.pointsAnnotations.addPointAnnotation(t, e, i);
      }
    }, {
      key: "addText",
      value: function value(t, e) {
        var i = t.x,
            a = t.y,
            s = t.text,
            r = t.textAnchor,
            n = t.foreColor,
            o = t.fontSize,
            l = t.fontFamily,
            h = t.fontWeight,
            c = t.cssClass,
            d = t.backgroundColor,
            g = t.borderWidth,
            u = t.strokeDashArray,
            f = t.borderRadius,
            p = t.borderColor,
            x = t.appendTo,
            b = void 0 === x ? ".apexcharts-annotations" : x,
            m = t.paddingLeft,
            v = void 0 === m ? 4 : m,
            y = t.paddingRight,
            w = void 0 === y ? 4 : y,
            k = t.paddingBottom,
            A = void 0 === k ? 2 : k,
            S = t.paddingTop,
            C = void 0 === S ? 2 : S,
            L = this.w,
            P = this.graphics.drawText({
          x: i,
          y: a,
          text: s,
          textAnchor: r || "start",
          fontSize: o || "12px",
          fontWeight: h || "regular",
          fontFamily: l || L.config.chart.fontFamily,
          foreColor: n || L.config.chart.foreColor,
          cssClass: c
        }),
            T = L.globals.dom.baseEl.querySelector(b);
        T && T.appendChild(P.node);
        var z = P.bbox();

        if (s) {
          var I = this.graphics.drawRect(z.x - v, z.y - C, z.width + v + w, z.height + A + C, f, d || "transparent", 1, g, p, u);
          T.insertBefore(I.node, P.node);
        }
      }
    }, {
      key: "addImage",
      value: function value(t, e) {
        var i = this.w,
            a = t.path,
            s = t.x,
            r = void 0 === s ? 0 : s,
            n = t.y,
            o = void 0 === n ? 0 : n,
            l = t.width,
            h = void 0 === l ? 20 : l,
            c = t.height,
            d = void 0 === c ? 20 : c,
            g = t.appendTo,
            u = void 0 === g ? ".apexcharts-annotations" : g,
            f = i.globals.dom.Paper.image(a);
        f.size(h, d).move(r, o);
        var p = i.globals.dom.baseEl.querySelector(u);
        p && p.appendChild(f.node);
      }
    }, {
      key: "addXaxisAnnotationExternal",
      value: function value(t, e, i) {
        return this.addAnnotationExternal({
          params: t,
          pushToMemory: e,
          context: i,
          type: "xaxis",
          contextMethod: i.addXaxisAnnotation
        }), i;
      }
    }, {
      key: "addYaxisAnnotationExternal",
      value: function value(t, e, i) {
        return this.addAnnotationExternal({
          params: t,
          pushToMemory: e,
          context: i,
          type: "yaxis",
          contextMethod: i.addYaxisAnnotation
        }), i;
      }
    }, {
      key: "addPointAnnotationExternal",
      value: function value(t, e, i) {
        return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
          params: t,
          pushToMemory: e,
          context: i,
          type: "point",
          contextMethod: i.addPointAnnotation
        }), i;
      }
    }, {
      key: "addAnnotationExternal",
      value: function value(t) {
        var e = t.params,
            i = t.pushToMemory,
            a = t.context,
            s = t.type,
            r = t.contextMethod,
            n = a,
            o = n.w,
            l = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations")),
            h = l.childNodes.length + 1,
            c = new L(),
            d = Object.assign({}, "xaxis" === s ? c.xAxisAnnotation : "yaxis" === s ? c.yAxisAnnotation : c.pointAnnotation),
            g = f.extend(d, e);

        switch (s) {
          case "xaxis":
            this.addXaxisAnnotation(g, l, h);
            break;

          case "yaxis":
            this.addYaxisAnnotation(g, l, h);
            break;

          case "point":
            this.addPointAnnotation(g, l, h);
        }

        var u = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(h, "']")),
            p = this.helpers.addBackgroundToAnno(u, g);
        return p && l.insertBefore(p.node, u), i && o.globals.memory.methodsToExec.push({
          context: n,
          id: g.id ? g.id : f.randomId(),
          method: r,
          label: "addAnnotation",
          params: e
        }), a;
      }
    }, {
      key: "clearAnnotations",
      value: function value(t) {
        var e = t.w,
            i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
        e.globals.memory.methodsToExec.map(function (t, i) {
          "addText" !== t.label && "addAnnotation" !== t.label || e.globals.memory.methodsToExec.splice(i, 1);
        }), i = f.listToArray(i), Array.prototype.forEach.call(i, function (t) {
          for (; t.firstChild;) {
            t.removeChild(t.firstChild);
          }
        });
      }
    }, {
      key: "removeAnnotation",
      value: function value(t, e) {
        var i = t.w,
            a = i.globals.dom.baseEl.querySelectorAll(".".concat(e));
        a && (i.globals.memory.methodsToExec.map(function (t, a) {
          t.id === e && i.globals.memory.methodsToExec.splice(a, 1);
        }), Array.prototype.forEach.call(a, function (t) {
          t.parentElement.removeChild(t);
        }));
      }
    }]), t;
  }(),
      T = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.opts = null, this.seriesIndex = 0;
    }

    return a(t, [{
      key: "clippedImgArea",
      value: function value(t) {
        var e = this.w,
            i = e.config,
            a = parseInt(e.globals.gridWidth, 10),
            s = parseInt(e.globals.gridHeight, 10),
            r = a > s ? a : s,
            n = t.image,
            o = 0,
            l = 0;
        void 0 === t.width && void 0 === t.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1, l = i.fill.image.height) : (o = r + 1, l = r) : (o = t.width, l = t.height);
        var h = document.createElementNS(e.globals.SVGNS, "pattern");
        b.setAttrs(h, {
          id: t.patternID,
          patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse",
          width: o + "px",
          height: l + "px"
        });
        var c = document.createElementNS(e.globals.SVGNS, "image");
        h.appendChild(c), c.setAttributeNS(window.SVG.xlink, "href", n), b.setAttrs(c, {
          x: 0,
          y: 0,
          preserveAspectRatio: "none",
          width: o + "px",
          height: l + "px"
        }), c.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(h);
      }
    }, {
      key: "getSeriesIndex",
      value: function value(t) {
        var e = this.w;
        return ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || "heatmap" === e.config.chart.type ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % e.globals.series.length, this.seriesIndex;
      }
    }, {
      key: "fillPath",
      value: function value(t) {
        var e = this.w;
        this.opts = t;
        var i,
            a,
            s,
            r = this.w.config;
        this.seriesIndex = this.getSeriesIndex(t);
        var n = this.getFillColors()[this.seriesIndex];
        void 0 !== e.globals.seriesColors[this.seriesIndex] && (n = e.globals.seriesColors[this.seriesIndex]), "function" == typeof n && (n = n({
          seriesIndex: this.seriesIndex,
          dataPointIndex: t.dataPointIndex,
          value: t.value,
          w: e
        }));
        var o = this.getFillType(this.seriesIndex),
            l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity,
            h = n;

        if (t.color && (n = t.color), -1 === n.indexOf("rgb") ? n.length < 9 && (h = f.hexToRgba(n, l)) : n.indexOf("rgba") > -1 && (l = f.getOpacityFromRGBA(n)), t.opacity && (l = t.opacity), "pattern" === o && (a = this.handlePatternFill(a, n, l, h)), "gradient" === o && (s = this.handleGradientFill(n, l, this.seriesIndex)), "image" === o) {
          var c = r.fill.image.src,
              d = t.patternID ? t.patternID : "";
          this.clippedImgArea({
            opacity: l,
            image: Array.isArray(c) ? t.seriesNumber < c.length ? c[t.seriesNumber] : c[0] : c,
            width: t.width ? t.width : void 0,
            height: t.height ? t.height : void 0,
            patternUnits: t.patternUnits,
            patternID: "pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d)
          }), i = "url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d, ")");
        } else i = "gradient" === o ? s : "pattern" === o ? a : h;

        return t.solid && (i = h), i;
      }
    }, {
      key: "getFillType",
      value: function value(t) {
        var e = this.w;
        return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type;
      }
    }, {
      key: "getFillColors",
      value: function value() {
        var t = this.w,
            e = t.config,
            i = this.opts,
            a = [];
        return t.globals.comboCharts ? "line" === t.config.series[this.seriesIndex].type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors) : "line" === e.chart.type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors), void 0 !== i.fillColors && (a = [], Array.isArray(i.fillColors) ? a = i.fillColors.slice() : a.push(i.fillColors)), a;
      }
    }, {
      key: "handlePatternFill",
      value: function value(t, e, i, a) {
        var s = this.w.config,
            r = this.opts,
            n = new b(this.ctx),
            o = void 0 === s.fill.pattern.strokeWidth ? Array.isArray(s.stroke.width) ? s.stroke.width[this.seriesIndex] : s.stroke.width : Array.isArray(s.fill.pattern.strokeWidth) ? s.fill.pattern.strokeWidth[this.seriesIndex] : s.fill.pattern.strokeWidth,
            l = e;
        Array.isArray(s.fill.pattern.style) ? t = void 0 !== s.fill.pattern.style[r.seriesNumber] ? n.drawPattern(s.fill.pattern.style[r.seriesNumber], s.fill.pattern.width, s.fill.pattern.height, l, o, i) : a : t = n.drawPattern(s.fill.pattern.style, s.fill.pattern.width, s.fill.pattern.height, l, o, i);
        return t;
      }
    }, {
      key: "handleGradientFill",
      value: function value(t, e, i) {
        var a,
            s = this.w.config,
            r = this.opts,
            n = new b(this.ctx),
            o = new f(),
            l = s.fill.gradient.type,
            h = t,
            c = void 0 === s.fill.gradient.opacityFrom ? e : Array.isArray(s.fill.gradient.opacityFrom) ? s.fill.gradient.opacityFrom[i] : s.fill.gradient.opacityFrom;
        h.indexOf("rgba") > -1 && (c = f.getOpacityFromRGBA(h));
        var d = void 0 === s.fill.gradient.opacityTo ? e : Array.isArray(s.fill.gradient.opacityTo) ? s.fill.gradient.opacityTo[i] : s.fill.gradient.opacityTo;
        if (void 0 === s.fill.gradient.gradientToColors || 0 === s.fill.gradient.gradientToColors.length) a = "dark" === s.fill.gradient.shade ? o.shadeColor(-1 * parseFloat(s.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? f.rgb2hex(t) : t) : o.shadeColor(parseFloat(s.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? f.rgb2hex(t) : t);else {
          var g = s.fill.gradient.gradientToColors[r.seriesNumber];
          a = g, g.indexOf("rgba") > -1 && (d = f.getOpacityFromRGBA(g));
        }

        if (s.fill.gradient.inverseColors) {
          var u = h;
          h = a, a = u;
        }

        return h.indexOf("rgb") > -1 && (h = f.rgb2hex(h)), a.indexOf("rgb") > -1 && (a = f.rgb2hex(a)), n.drawGradient(l, h, a, c, d, r.size, s.fill.gradient.stops, s.fill.gradient.colorStops, i);
      }
    }]), t;
  }(),
      z = function () {
    function t(i, a) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "setGlobalMarkerSize",
      value: function value() {
        var t = this.w;

        if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
          if (t.globals.markers.size.length < t.globals.series.length + 1) for (var e = 0; e <= t.globals.series.length; e++) {
            void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0]);
          }
        } else t.globals.markers.size = t.config.series.map(function (e) {
          return t.config.markers.size;
        });
      }
    }, {
      key: "plotChartMarkers",
      value: function value(t, e, i, a) {
        var s,
            r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
            n = this.w,
            o = e,
            l = t,
            h = null,
            c = new b(this.ctx);
        if ((n.globals.markers.size[e] > 0 || r) && (h = c.group({
          class: r ? "" : "apexcharts-series-markers"
        })).attr("clip-path", "url(#gridRectMarkerMask".concat(n.globals.cuid, ")")), Array.isArray(l.x)) for (var d = 0; d < l.x.length; d++) {
          var g = i;
          1 === i && 0 === d && (g = 0), 1 === i && 1 === d && (g = 1);
          var u = "apexcharts-marker";
          "line" !== n.config.chart.type && "area" !== n.config.chart.type || n.globals.comboCharts || n.config.tooltip.intersect || (u += " no-pointer-events");
          var x = Array.isArray(n.config.markers.size) ? n.globals.markers.size[e] > 0 : n.config.markers.size > 0;

          if (x || r) {
            f.isNumber(l.y[d]) ? u += " w".concat(f.randomId()) : u = "apexcharts-nullpoint";
            var m = this.getMarkerConfig(u, e, g);
            n.config.series[o].data[g] && (n.config.series[o].data[g].fillColor && (m.pointFillColor = n.config.series[o].data[g].fillColor), n.config.series[o].data[g].strokeColor && (m.pointStrokeColor = n.config.series[o].data[g].strokeColor)), a && (m.pSize = a), (s = c.drawMarker(l.x[d], l.y[d], m)).attr("rel", g), s.attr("j", g), s.attr("index", e), s.node.setAttribute("default-marker-size", m.pSize);
            var v = new p(this.ctx);
            v.setSelectionFilter(s, e, g), this.addEvents(s), h && h.add(s);
          } else void 0 === n.globals.pointsArray[e] && (n.globals.pointsArray[e] = []), n.globals.pointsArray[e].push([l.x[d], l.y[d]]);
        }
        return h;
      }
    }, {
      key: "getMarkerConfig",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
            a = this.w,
            s = this.getMarkerStyle(e),
            r = a.globals.markers.size[e],
            n = a.config.markers;
        return null !== i && n.discrete.length && n.discrete.map(function (t) {
          t.seriesIndex === e && t.dataPointIndex === i && (s.pointStrokeColor = t.strokeColor, s.pointFillColor = t.fillColor, r = t.size);
        }), {
          pSize: r,
          pRadius: n.radius,
          pWidth: Array.isArray(n.strokeWidth) ? n.strokeWidth[e] : n.strokeWidth,
          pointStrokeColor: s.pointStrokeColor,
          pointFillColor: s.pointFillColor,
          shape: Array.isArray(n.shape) ? n.shape[e] : n.shape,
          class: t,
          pointStrokeOpacity: Array.isArray(n.strokeOpacity) ? n.strokeOpacity[e] : n.strokeOpacity,
          pointStrokeDashArray: Array.isArray(n.strokeDashArray) ? n.strokeDashArray[e] : n.strokeDashArray,
          pointFillOpacity: Array.isArray(n.fillOpacity) ? n.fillOpacity[e] : n.fillOpacity,
          seriesIndex: e
        };
      }
    }, {
      key: "addEvents",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx);
        t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", e.config.markers.onClick), t.node.addEventListener("dblclick", e.config.markers.onDblClick), t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), {
          passive: !0
        });
      }
    }, {
      key: "getMarkerStyle",
      value: function value(t) {
        var e = this.w,
            i = e.globals.markers.colors,
            a = e.config.markers.strokeColor || e.config.markers.strokeColors;
        return {
          pointStrokeColor: Array.isArray(a) ? a[t] : a,
          pointFillColor: Array.isArray(i) ? i[t] : i
        };
      }
    }]), t;
  }(),
      I = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }

    return a(t, [{
      key: "draw",
      value: function value(t, e, i) {
        var a = this.w,
            s = new b(this.ctx),
            r = i.realIndex,
            n = i.pointsPos,
            o = i.zRatio,
            l = i.elParent,
            h = s.group({
          class: "apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)
        });
        if (h.attr("clip-path", "url(#gridRectMarkerMask".concat(a.globals.cuid, ")")), Array.isArray(n.x)) for (var c = 0; c < n.x.length; c++) {
          var d = e + 1,
              g = !0;
          0 === e && 0 === c && (d = 0), 0 === e && 1 === c && (d = 1);
          var u = 0,
              f = a.globals.markers.size[r];

          if (o !== 1 / 0) {
            f = a.globals.seriesZ[r][d] / o;
            var p = a.config.plotOptions.bubble;
            p.minBubbleRadius && f < p.minBubbleRadius && (f = p.minBubbleRadius), p.maxBubbleRadius && f > p.maxBubbleRadius && (f = p.maxBubbleRadius);
          }

          a.config.chart.animations.enabled || (u = f);
          var x = n.x[c],
              m = n.y[c];

          if (u = u || 0, null !== m && void 0 !== a.globals.series[r][d] || (g = !1), g) {
            var v = this.drawPoint(x, m, u, f, r, d, e);
            h.add(v);
          }

          l.add(h);
        }
      }
    }, {
      key: "drawPoint",
      value: function value(t, e, i, a, s, r, n) {
        var o = this.w,
            l = s,
            h = new x(this.ctx),
            c = new p(this.ctx),
            d = new T(this.ctx),
            g = new z(this.ctx),
            u = new b(this.ctx),
            f = g.getMarkerConfig("apexcharts-marker", l),
            m = d.fillPath({
          seriesNumber: s,
          dataPointIndex: r,
          patternUnits: "objectBoundingBox",
          value: o.globals.series[s][n]
        }),
            v = u.drawCircle(i);

        if (o.config.series[l].data[r] && o.config.series[l].data[r].fillColor && (m = o.config.series[l].data[r].fillColor), v.attr({
          cx: t,
          cy: e,
          fill: m,
          stroke: f.pointStrokeColor,
          r: a,
          "stroke-width": f.pWidth,
          "stroke-dasharray": f.pointStrokeDashArray,
          "stroke-opacity": f.pointStrokeOpacity
        }), o.config.chart.dropShadow.enabled) {
          var y = o.config.chart.dropShadow;
          c.dropShadow(v, y, s);
        }

        if (this.initialAnim && !o.globals.dataChanged && !o.globals.resized) {
          var w = o.config.chart.animations.speed;
          h.animateCircleRadius(v, 0, a, w, o.globals.easing, function () {
            window.setTimeout(function () {
              h.animationCompleted(v);
            }, 100);
          });
        }

        if (o.globals.dataChanged) if (this.dynamicAnim) {
          var k,
              A,
              S,
              C,
              L = o.config.chart.animations.dynamicAnimation.speed;
          null != (C = o.globals.previousPaths[s] && o.globals.previousPaths[s][n]) && (k = C.x, A = C.y, S = void 0 !== C.r ? C.r : a);

          for (var P = 0; P < o.globals.collapsedSeries.length; P++) {
            o.globals.collapsedSeries[P].index === s && (L = 1, a = 0);
          }

          0 === t && 0 === e && (a = 0), h.animateCircle(v, {
            cx: k,
            cy: A,
            r: S
          }, {
            cx: t,
            cy: e,
            r: a
          }, L, o.globals.easing);
        } else v.attr({
          r: a
        });
        return v.attr({
          rel: r,
          j: r,
          index: s,
          "default-marker-size": a
        }), c.setSelectionFilter(v, s, r), g.addEvents(v), v.node.classList.add("apexcharts-marker"), v;
      }
    }, {
      key: "centerTextInBubble",
      value: function value(t) {
        var e = this.w;
        return {
          y: t += parseInt(e.config.dataLabels.style.fontSize, 10) / 4
        };
      }
    }]), t;
  }(),
      M = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "dataLabelsCorrection",
      value: function value(t, e, i, a, s, r, n) {
        var o = this.w,
            l = !1,
            h = new b(this.ctx).getTextRects(i, n),
            c = h.width,
            d = h.height;
        void 0 === o.globals.dataLabelsRects[a] && (o.globals.dataLabelsRects[a] = []), o.globals.dataLabelsRects[a].push({
          x: t,
          y: e,
          width: c,
          height: d
        });
        var g = o.globals.dataLabelsRects[a].length - 2,
            u = void 0 !== o.globals.lastDrawnDataLabelsIndexes[a] ? o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length - 1] : 0;

        if (void 0 !== o.globals.dataLabelsRects[a][g]) {
          var f = o.globals.dataLabelsRects[a][u];
          (t > f.x + f.width + 2 || e > f.y + f.height + 2 || t + c < f.x) && (l = !0);
        }

        return (0 === s || r) && (l = !0), {
          x: t,
          y: e,
          textRects: h,
          drawnextLabel: l
        };
      }
    }, {
      key: "drawDataLabel",
      value: function value(t, e, i) {
        var a = this,
            s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2,
            r = this.w,
            n = new b(this.ctx),
            o = r.config.dataLabels,
            l = 0,
            h = 0,
            c = i,
            d = null;
        if (!o.enabled || !Array.isArray(t.x)) return d;
        d = n.group({
          class: "apexcharts-data-labels"
        });

        for (var g = 0; g < t.x.length; g++) {
          if (l = t.x[g] + o.offsetX, h = t.y[g] + o.offsetY + s, !isNaN(l)) {
            1 === i && 0 === g && (c = 0), 1 === i && 1 === g && (c = 1);

            var u = r.globals.series[e][c],
                f = "",
                p = function p(t) {
              return r.config.dataLabels.formatter(t, {
                ctx: a.ctx,
                seriesIndex: e,
                dataPointIndex: c,
                w: r
              });
            };

            if ("bubble" === r.config.chart.type) {
              f = p(u = r.globals.seriesZ[e][c]), h = t.y[g];
              var x = new I(this.ctx),
                  m = x.centerTextInBubble(h, e, c);
              h = m.y;
            } else void 0 !== u && (f = p(u));

            this.plotDataLabelsText({
              x: l,
              y: h,
              text: f,
              i: e,
              j: c,
              parent: d,
              offsetCorrection: !0,
              dataLabelsConfig: r.config.dataLabels
            });
          }
        }

        return d;
      }
    }, {
      key: "plotDataLabelsText",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = t.x,
            s = t.y,
            r = t.i,
            n = t.j,
            o = t.text,
            l = t.textAnchor,
            h = t.parent,
            c = t.dataLabelsConfig,
            d = t.color,
            g = t.alwaysDrawDataLabel,
            u = t.offsetCorrection;

        if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
          var f = {
            x: a,
            y: s,
            drawnextLabel: !0
          };
          u && (f = this.dataLabelsCorrection(a, s, o, r, n, g, parseInt(c.style.fontSize, 10))), e.globals.zoomed || (a = f.x, s = f.y), f.textRects && (a + f.textRects.width < -20 || a > e.globals.gridWidth + 20) && (o = "");
          var x = e.globals.dataLabels.style.colors[r];
          (("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || e.config.dataLabels.distributed) && (x = e.globals.dataLabels.style.colors[n]), d && (x = d);
          var m = c.offsetX,
              v = c.offsetY;

          if ("bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || (m = 0, v = 0), f.drawnextLabel) {
            var y = i.drawText({
              width: 100,
              height: parseInt(c.style.fontSize, 10),
              x: a + m,
              y: s + v,
              foreColor: x,
              textAnchor: l || c.textAnchor,
              text: o,
              fontSize: c.style.fontSize,
              fontFamily: c.style.fontFamily,
              fontWeight: c.style.fontWeight || "normal"
            });

            if (y.attr({
              class: "apexcharts-datalabel",
              cx: a,
              cy: s
            }), c.dropShadow.enabled) {
              var w = c.dropShadow;
              new p(this.ctx).dropShadow(y, w);
            }

            h.add(y), void 0 === e.globals.lastDrawnDataLabelsIndexes[r] && (e.globals.lastDrawnDataLabelsIndexes[r] = []), e.globals.lastDrawnDataLabelsIndexes[r].push(n);
          }
        }
      }
    }, {
      key: "addBackgroundToDataLabel",
      value: function value(t, e) {
        var i = this.w,
            a = i.config.dataLabels.background,
            s = a.padding,
            r = a.padding / 2,
            n = e.width,
            o = e.height,
            l = new b(this.ctx).drawRect(e.x - s, e.y - r / 2, n + 2 * s, o + r, a.borderRadius, "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, a.opacity, a.borderWidth, a.borderColor);
        a.dropShadow.enabled && new p(this.ctx).dropShadow(l, a.dropShadow);
        return l;
      }
    }, {
      key: "dataLabelsBackground",
      value: function value() {
        var t = this.w;
        if ("bubble" !== t.config.chart.type) for (var e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < e.length; i++) {
          var a = e[i],
              s = a.getBBox(),
              r = null;

          if (s.width && s.height && (r = this.addBackgroundToDataLabel(a, s)), r) {
            a.parentNode.insertBefore(r.node, a);
            var n = a.getAttribute("fill");
            t.config.chart.animations.enabled && !t.globals.resized && !t.globals.dataChanged ? r.animate().attr({
              fill: n
            }) : r.attr({
              fill: n
            }), a.setAttribute("fill", t.config.dataLabels.background.foreColor);
          }
        }
      }
    }, {
      key: "bringForward",
      value: function value() {
        for (var t = this.w, e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a = 0; a < e.length; a++) {
          i && i.insertBefore(e[a], i.nextSibling);
        }
      }
    }]), t;
  }(),
      E = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.barCtx = i;
    }

    return a(t, [{
      key: "handleBarDataLabels",
      value: function value(t) {
        var e = t.x,
            i = t.y,
            a = t.y1,
            s = t.y2,
            r = t.i,
            n = t.j,
            o = t.realIndex,
            l = t.series,
            h = t.barHeight,
            c = t.barWidth,
            d = t.barYPosition,
            g = t.visibleSeries,
            u = t.renderedPath,
            f = this.w,
            p = new b(this.barCtx.ctx),
            x = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth,
            m = e + parseFloat(c * g),
            v = i + parseFloat(h * g);
        f.globals.isXNumeric && !f.globals.isBarHorizontal && (m = e + parseFloat(c * (g + 1)), v = i + parseFloat(h * (g + 1)) - x);
        var y = e,
            w = i,
            k = {},
            A = f.config.dataLabels,
            S = this.barCtx.barOptions.dataLabels;
        void 0 !== d && this.barCtx.isTimelineBar && (v = d, w = d);
        var C = A.offsetX,
            L = A.offsetY,
            P = {
          width: 0,
          height: 0
        };

        if (f.config.dataLabels.enabled) {
          var T = String(f.globals.minY).length > String(f.globals.maxY).length ? f.globals.minY : f.globals.maxY;
          P = p.getTextRects(f.globals.yLabelFormatters[0](T), parseFloat(A.style.fontSize));
        }

        var z = {
          x: e,
          y: i,
          i: r,
          j: n,
          renderedPath: u,
          bcx: m,
          bcy: v,
          barHeight: h,
          barWidth: c,
          textRects: P,
          strokeWidth: x,
          dataLabelsX: y,
          dataLabelsY: w,
          barDataLabelsConfig: S,
          offX: C,
          offY: L
        };
        return k = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(z) : this.calculateColumnsDataLabelsPosition(z), u.attr({
          cy: k.bcy,
          cx: k.bcx,
          j: n,
          val: l[r][n],
          barHeight: h,
          barWidth: c
        }), this.drawCalculatedDataLabels({
          x: k.dataLabelsX,
          y: k.dataLabelsY,
          val: this.barCtx.isTimelineBar ? [a, s] : l[r][n],
          i: o,
          j: n,
          barWidth: c,
          barHeight: h,
          textRects: P,
          dataLabelsConfig: A
        });
      }
    }, {
      key: "calculateColumnsDataLabelsPosition",
      value: function value(t) {
        var e,
            i = this.w,
            a = t.i,
            s = t.j,
            r = t.y,
            n = t.bcx,
            o = t.barWidth,
            l = t.barHeight,
            h = t.textRects,
            c = t.dataLabelsY,
            d = t.barDataLabelsConfig,
            g = t.strokeWidth,
            u = t.offX,
            f = t.offY;
        l = Math.abs(l);
        var p = "vertical" === i.config.plotOptions.bar.dataLabels.orientation;
        n -= g / 2;
        var x = i.globals.gridWidth / i.globals.dataPoints;

        if (e = i.globals.isXNumeric ? n - o / 2 + u : n - x + o / 2 + u, p) {
          e = e + h.height / 2 - g / 2 - 2;
        }

        var b = this.barCtx.series[a][s] < 0,
            m = r;

        switch (this.barCtx.isReversed && (m = r - l + (b ? 2 * l : 0), r -= l), d.position) {
          case "center":
            c = p ? b ? m + l / 2 + f : m + l / 2 - f : b ? m - l / 2 + h.height / 2 + f : m + l / 2 + h.height / 2 - f;
            break;

          case "bottom":
            c = p ? b ? m + l + f : m + l - f : b ? m - l + h.height + g + f : m + l - h.height / 2 + g - f;
            break;

          case "top":
            c = p ? b ? m + f : m - f : b ? m - h.height / 2 - f : m + h.height + f;
        }

        return i.config.chart.stacked || (c < 0 ? c = 0 + g : c + h.height / 3 > i.globals.gridHeight && (c = i.globals.gridHeight - g)), {
          bcx: n,
          bcy: r,
          dataLabelsX: e,
          dataLabelsY: c
        };
      }
    }, {
      key: "calculateBarsDataLabelsPosition",
      value: function value(t) {
        var e = this.w,
            i = t.x,
            a = t.i,
            s = t.j,
            r = t.bcy,
            n = t.barHeight,
            o = t.barWidth,
            l = t.textRects,
            h = t.dataLabelsX,
            c = t.strokeWidth,
            d = t.barDataLabelsConfig,
            g = t.offX,
            u = t.offY,
            f = e.globals.gridHeight / e.globals.dataPoints;
        o = Math.abs(o);
        var p = r - (this.barCtx.isTimelineBar ? 0 : f) + n / 2 + l.height / 2 + u - 3,
            x = this.barCtx.series[a][s] < 0,
            b = i;

        switch (this.barCtx.isReversed && (b = i + o - (x ? 2 * o : 0), i = e.globals.gridWidth - o), d.position) {
          case "center":
            h = x ? b + o / 2 - g : b - o / 2 + g;
            break;

          case "bottom":
            h = x ? b + o - c - Math.round(l.width / 2) - g : b - o + c + Math.round(l.width / 2) + g;
            break;

          case "top":
            h = x ? b - c + Math.round(l.width / 2) - g : b - c - Math.round(l.width / 2) + g;
        }

        return e.config.chart.stacked || (h < 0 ? h = h + l.width + c : h + l.width / 2 > e.globals.gridWidth && (h = e.globals.gridWidth - l.width - c)), {
          bcx: i,
          bcy: r,
          dataLabelsX: h,
          dataLabelsY: p
        };
      }
    }, {
      key: "drawCalculatedDataLabels",
      value: function value(t) {
        var e = t.x,
            i = t.y,
            a = t.val,
            s = t.i,
            r = t.j,
            o = t.textRects,
            l = t.barHeight,
            h = t.barWidth,
            c = t.dataLabelsConfig,
            d = this.w,
            g = "rotate(0)";
        "vertical" === d.config.plotOptions.bar.dataLabels.orientation && (g = "rotate(-90, ".concat(e, ", ").concat(i, ")"));
        var u = new M(this.barCtx.ctx),
            f = new b(this.barCtx.ctx),
            p = c.formatter,
            x = null,
            m = d.globals.collapsedSeriesIndices.indexOf(s) > -1;

        if (c.enabled && !m) {
          x = f.group({
            class: "apexcharts-data-labels",
            transform: g
          });
          var v = "";
          void 0 !== a && (v = p(a, {
            seriesIndex: s,
            dataPointIndex: r,
            w: d
          })), 0 === a && d.config.chart.stacked && (v = "");
          var y = d.globals.series[s][r] <= 0,
              w = d.config.plotOptions.bar.dataLabels.position;
          if ("vertical" === d.config.plotOptions.bar.dataLabels.orientation && ("top" === w && (c.textAnchor = y ? "end" : "start"), "center" === w && (c.textAnchor = "middle"), "bottom" === w && (c.textAnchor = y ? "end" : "start")), this.barCtx.isTimelineBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) h < f.getTextRects(v, parseFloat(c.style.fontSize)).width && (v = "");
          d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? ((h = Math.abs(d.globals.series[s][r]) / this.barCtx.invertedYRatio[this.barCtx.yaxisIndex]) > 0 && o.width / 1.6 > h || h < 0 && o.width / 1.6 < h) && (v = "") : (l = Math.abs(d.globals.series[s][r]) / this.barCtx.yRatio[this.barCtx.yaxisIndex], o.height / 1.6 > l && (v = "")));
          var k = n({}, c);
          this.barCtx.isHorizontal && a < 0 && ("start" === c.textAnchor ? k.textAnchor = "end" : "end" === c.textAnchor && (k.textAnchor = "start")), u.plotDataLabelsText({
            x: e,
            y: i,
            text: v,
            i: s,
            j: r,
            parent: x,
            dataLabelsConfig: k,
            alwaysDrawDataLabel: !0,
            offsetCorrection: !0
          });
        }

        return x;
      }
    }]), t;
  }(),
      X = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }

    return a(t, [{
      key: "getAllSeriesEls",
      value: function value() {
        return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
      }
    }, {
      key: "getSeriesByName",
      value: function value(t) {
        return this.w.globals.dom.baseEl.querySelector("[seriesName='".concat(f.escapeString(t), "']"));
      }
    }, {
      key: "isSeriesHidden",
      value: function value(t) {
        var e = this.getSeriesByName(t),
            i = parseInt(e.getAttribute("data:realIndex"), 10);
        return {
          isHidden: e.classList.contains("apexcharts-series-collapsed"),
          realIndex: i
        };
      }
    }, {
      key: "addCollapsedClassToSeries",
      value: function value(t, e) {
        var i = this.w;

        function a(i) {
          for (var a = 0; a < i.length; a++) {
            i[a].index === e && t.node.classList.add("apexcharts-series-collapsed");
          }
        }

        a(i.globals.collapsedSeries), a(i.globals.ancillaryCollapsedSeries);
      }
    }, {
      key: "toggleSeries",
      value: function value(t) {
        var e = this.isSeriesHidden(t);
        return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden;
      }
    }, {
      key: "showSeries",
      value: function value(t) {
        var e = this.isSeriesHidden(t);
        e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0);
      }
    }, {
      key: "hideSeries",
      value: function value(t) {
        var e = this.isSeriesHidden(t);
        e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1);
      }
    }, {
      key: "resetSeries",
      value: function value() {
        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
            e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            a = this.w,
            s = f.clone(a.globals.initialSeries);
        a.globals.previousPaths = [], i ? (a.globals.collapsedSeries = [], a.globals.ancillaryCollapsedSeries = [], a.globals.collapsedSeriesIndices = [], a.globals.ancillaryCollapsedSeriesIndices = []) : s = this.emptyCollapsedSeries(s), a.config.series = s, t && (e && (a.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled));
      }
    }, {
      key: "emptyCollapsedSeries",
      value: function value(t) {
        for (var e = this.w, i = 0; i < t.length; i++) {
          e.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
        }

        return t;
      }
    }, {
      key: "toggleSeriesOnHover",
      value: function value(t, e) {
        var i = this.w,
            a = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");

        if ("mousemove" === t.type) {
          var s = parseInt(e.getAttribute("rel"), 10) - 1,
              r = null,
              n = null;
          i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (r = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")), n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s, "']"))) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']")) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path"));

          for (var o = 0; o < a.length; o++) {
            a[o].classList.add(this.legendInactiveClass);
          }

          null !== r && (i.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass), r.classList.remove(this.legendInactiveClass), null !== n && n.classList.remove(this.legendInactiveClass));
        } else if ("mouseout" === t.type) for (var l = 0; l < a.length; l++) {
          a[l].classList.remove(this.legendInactiveClass);
        }
      }
    }, {
      key: "highlightRangeInSeries",
      value: function value(t, e) {
        var i = this,
            a = this.w,
            s = a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
            r = function r(t) {
          for (var e = 0; e < s.length; e++) {
            s[e].classList[t](i.legendInactiveClass);
          }
        };

        if ("mousemove" === t.type) {
          var n = parseInt(e.getAttribute("rel"), 10) - 1;
          r("add"), function (t) {
            for (var e = 0; e < s.length; e++) {
              var a = parseInt(s[e].getAttribute("val"), 10);
              a >= t.from && a <= t.to && s[e].classList.remove(i.legendInactiveClass);
            }
          }(a.config.plotOptions.heatmap.colorScale.ranges[n]);
        } else "mouseout" === t.type && r("remove");
      }
    }, {
      key: "getActiveConfigSeriesIndex",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
            e = this.w,
            i = 0;
        if (e.config.series.length > 1) for (var a = e.config.series.map(function (i, a) {
          var s = !1;
          return t && (s = "bar" === e.config.series[a].type || "column" === e.config.series[a].type), i.data && i.data.length > 0 && !s ? a : -1;
        }), s = 0; s < a.length; s++) {
          if (-1 !== a[s]) {
            i = a[s];
            break;
          }
        }
        return i;
      }
    }, {
      key: "getPreviousPaths",
      value: function value() {
        var t = this.w;

        function e(e, i, a) {
          for (var s = e[i].childNodes, r = {
            type: a,
            paths: [],
            realIndex: e[i].getAttribute("data:realIndex")
          }, n = 0; n < s.length; n++) {
            if (s[n].hasAttribute("pathTo")) {
              var o = s[n].getAttribute("pathTo");
              r.paths.push({
                d: o
              });
            }
          }

          t.globals.previousPaths.push(r);
        }

        t.globals.previousPaths = [];
        ["line", "area", "bar", "candlestick", "radar"].forEach(function (i) {
          for (var a, s = (a = i, t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a, "-series .apexcharts-series"))), r = 0; r < s.length; r++) {
            e(s, r, i);
          }
        }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
        var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series");
        if (i.length > 0) for (var a = 0; a < i.length; a++) {
          for (var s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series[data\\:realIndex='".concat(a, "'] rect")), r = [], n = 0; n < s.length; n++) {
            r.push({
              color: s[n].getAttribute("color")
            });
          }

          t.globals.previousPaths.push(r);
        }
        t.globals.axisCharts || (t.globals.previousPaths = t.globals.series);
      }
    }, {
      key: "handlePrevBubbleScatterPaths",
      value: function value(t) {
        var e = this.w,
            i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
        if (i.length > 0) for (var a = 0; a < i.length; a++) {
          for (var s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(a, "'] circle")), r = [], n = 0; n < s.length; n++) {
            r.push({
              x: s[n].getAttribute("cx"),
              y: s[n].getAttribute("cy"),
              r: s[n].getAttribute("r")
            });
          }

          e.globals.previousPaths.push(r);
        }
      }
    }, {
      key: "clearPreviousPaths",
      value: function value() {
        var t = this.w;
        t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1;
      }
    }, {
      key: "handleNoData",
      value: function value() {
        var t = this.w,
            e = t.config.noData,
            i = new b(this.ctx),
            a = t.globals.svgWidth / 2,
            s = t.globals.svgHeight / 2,
            r = "middle";

        if (t.globals.noData = !0, t.globals.animationEnded = !0, "left" === e.align ? (a = 10, r = "start") : "right" === e.align && (a = t.globals.svgWidth - 10, r = "end"), "top" === e.verticalAlign ? s = 50 : "bottom" === e.verticalAlign && (s = t.globals.svgHeight - 50), a += e.offsetX, s = s + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && "" !== e.text) {
          var n = i.drawText({
            x: a,
            y: s,
            text: e.text,
            textAnchor: r,
            fontSize: e.style.fontSize,
            fontFamily: e.style.fontFamily,
            foreColor: e.style.color,
            opacity: 1,
            class: "apexcharts-text-nodata"
          });
          t.globals.dom.Paper.add(n);
        }
      }
    }, {
      key: "setNullSeriesToZeroValues",
      value: function value(t) {
        for (var e = this.w, i = 0; i < t.length; i++) {
          if (0 === t[i].length) for (var a = 0; a < t[e.globals.maxValsInArrayIndex].length; a++) {
            t[i].push(0);
          }
        }

        return t;
      }
    }, {
      key: "hasAllSeriesEqualX",
      value: function value() {
        for (var t = !0, e = this.w, i = this.filteredSeriesX(), a = 0; a < i.length - 1; a++) {
          if (i[a][0] !== i[a + 1][0]) {
            t = !1;
            break;
          }
        }

        return e.globals.allSeriesHasEqualX = t, t;
      }
    }, {
      key: "filteredSeriesX",
      value: function value() {
        var t = this.w.globals.seriesX.map(function (t) {
          return t.length > 0 ? t : [];
        });
        return t;
      }
    }]), t;
  }(),
      Y = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.barCtx = i;
    }

    return a(t, [{
      key: "initVariables",
      value: function value(t) {
        var e = this.w;
        this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;

        for (var i = 0; i < t.length; i++) {
          if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), e.globals.isXNumeric) for (var a = 0; a < t[i].length; a++) {
            e.globals.seriesX[i][a] > e.globals.minX && e.globals.seriesX[i][a] < e.globals.maxX && this.barCtx.visibleItems++;
          } else this.barCtx.visibleItems = e.globals.dataPoints;
        }

        0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1);
      }
    }, {
      key: "initialPositions",
      value: function value() {
        var t,
            e,
            i,
            a,
            s,
            r,
            n,
            o,
            l = this.w,
            h = l.globals.dataPoints;
        if (this.barCtx.isTimelineBar && (h = l.globals.labels.length), this.barCtx.isHorizontal) s = (i = l.globals.gridHeight / h) / this.barCtx.seriesLen, l.globals.isXNumeric && (s = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s = s * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, o = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e = (i - s * this.barCtx.seriesLen) / 2;else {
          if (a = l.globals.gridWidth / this.barCtx.visibleItems, l.config.xaxis.convertedCatToNumeric && (a = l.globals.gridWidth / l.globals.dataPoints), r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric) {
            var c = this.barCtx.xRatio;
            l.config.xaxis.convertedCatToNumeric && (c = this.barCtx.initialXRatio), l.globals.minXDiff && .5 !== l.globals.minXDiff && l.globals.minXDiff / c > 0 && (a = l.globals.minXDiff / c), (r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1);
          }

          n = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = l.globals.padHorizontal + (a - r * this.barCtx.seriesLen) / 2;
        }
        return {
          x: t,
          y: e,
          yDivision: i,
          xDivision: a,
          barHeight: s,
          barWidth: r,
          zeroH: n,
          zeroW: o
        };
      }
    }, {
      key: "getPathFillColor",
      value: function value(t, e, i, a) {
        var s = this.w,
            r = new T(this.barCtx.ctx),
            n = null,
            o = this.barCtx.barOptions.distributed ? i : e;
        this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function (a) {
          t[e][i] >= a.from && t[e][i] <= a.to && (n = a.color);
        });
        return s.config.series[e].data[i] && s.config.series[e].data[i].fillColor && (n = s.config.series[e].data[i].fillColor), r.fillPath({
          seriesNumber: this.barCtx.barOptions.distributed ? o : a,
          dataPointIndex: i,
          color: n,
          value: t[e][i]
        });
      }
    }, {
      key: "getStrokeWidth",
      value: function value(t, e, i) {
        var a = 0,
            s = this.w;
        return void 0 === this.barCtx.series[t][e] || null === this.barCtx.series[t][e] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s.config.stroke.show && (this.barCtx.isNullValue || (a = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), a;
      }
    }, {
      key: "barBackground",
      value: function value(t) {
        var e = t.j,
            i = t.i,
            a = t.x1,
            s = t.x2,
            r = t.y1,
            n = t.y2,
            o = t.elSeries,
            l = this.w,
            h = new b(this.barCtx.ctx),
            c = new X(this.barCtx.ctx).getActiveConfigSeriesIndex();

        if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c === i) {
          e >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e -= this.barCtx.barOptions.colors.backgroundBarColors.length);
          var d = this.barCtx.barOptions.colors.backgroundBarColors[e],
              g = h.drawRect(void 0 !== a ? a : 0, void 0 !== r ? r : 0, void 0 !== s ? s : l.globals.gridWidth, void 0 !== n ? n : l.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d, this.barCtx.barOptions.colors.backgroundBarOpacity);
          o.add(g), g.node.classList.add("apexcharts-backgroundBar");
        }
      }
    }, {
      key: "getColumnPaths",
      value: function value(t) {
        var e = t.barWidth,
            i = t.barXPosition,
            a = t.yRatio,
            s = t.y1,
            r = t.y2,
            n = t.strokeWidth,
            o = t.series,
            l = t.realIndex,
            h = t.i,
            c = t.j,
            d = t.w,
            g = new b(this.barCtx.ctx);
        (n = Array.isArray(n) ? n[l] : n) || (n = 0);
        var u = {
          barWidth: e,
          strokeWidth: n,
          yRatio: a,
          barXPosition: i,
          y1: s,
          y2: r
        },
            f = this.getRoundedBars(d, u, o, h, c),
            p = i,
            x = i + e,
            m = g.move(p, f.y1),
            v = g.move(p, f.y1);
        return d.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(l, c, !1)), {
          pathTo: m = m + g.line(p, f.y2) + f.endingPath + g.line(x - n, f.y2) + g.line(x - n, f.y1) + f.startingPath + "z",
          pathFrom: v = v + g.line(p, s) + g.line(x - n, s) + g.line(x - n, s) + g.line(x - n, s) + g.line(p, s)
        };
      }
    }, {
      key: "getBarpaths",
      value: function value(t) {
        var e = t.barYPosition,
            i = t.barHeight,
            a = t.x1,
            s = t.x2,
            r = t.strokeWidth,
            n = t.series,
            o = t.realIndex,
            l = t.i,
            h = t.j,
            c = t.w,
            d = new b(this.barCtx.ctx);
        (r = Array.isArray(r) ? r[o] : r) || (r = 0);
        var g = {
          barHeight: i,
          strokeWidth: r,
          barYPosition: e,
          x2: s,
          x1: a
        },
            u = this.getRoundedBars(c, g, n, l, h),
            f = d.move(u.x1, e),
            p = d.move(u.x1, e);
        c.globals.previousPaths.length > 0 && (p = this.barCtx.getPreviousPath(o, h, !1));
        var x = e,
            m = e + i;
        return {
          pathTo: f = f + d.line(u.x2, x) + u.endingPath + d.line(u.x2, m - r) + d.line(u.x1, m - r) + u.startingPath + "z",
          pathFrom: p = p + d.line(a, x) + d.line(a, m - r) + d.line(a, m - r) + d.line(a, m - r) + d.line(a, x)
        };
      }
    }, {
      key: "getRoundedBars",
      value: function value(t, e, i, a, s) {
        var r = new b(this.barCtx.ctx),
            n = Array.isArray(e.strokeWidth) ? e.strokeWidth[a] : e.strokeWidth;

        if (n || (n = 0), this.barCtx.isHorizontal) {
          var o = null,
              l = "",
              h = e.x2,
              c = e.x1;

          if (void 0 !== i[a][s] || null !== i[a][s]) {
            var d = i[a][s] < 0,
                g = e.barHeight / 2 - n;

            switch (d && (g = -e.barHeight / 2 - n), g > Math.abs(h - c) && (g = Math.abs(h - c)), "rounded" === this.barCtx.barOptions.endingShape && (h = e.x2 - g / 2), "rounded" === this.barCtx.barOptions.startingShape && (c = e.x1 + g / 2), this.barCtx.barOptions.endingShape) {
              case "flat":
                o = r.line(h, e.barYPosition + e.barHeight - n);
                break;

              case "rounded":
                o = r.quadraticCurve(h + g, e.barYPosition + (e.barHeight - n) / 2, h, e.barYPosition + e.barHeight - n);
            }

            switch (this.barCtx.barOptions.startingShape) {
              case "flat":
                l = r.line(c, e.barYPosition + e.barHeight - n);
                break;

              case "rounded":
                l = r.quadraticCurve(c - g, e.barYPosition + e.barHeight / 2, c, e.barYPosition);
            }
          }

          return {
            endingPath: o,
            startingPath: l,
            x2: h,
            x1: c
          };
        }

        var u = null,
            f = "",
            p = e.y2,
            x = e.y1;

        if (void 0 !== i[a][s] || null !== i[a][s]) {
          var m = i[a][s] < 0,
              v = e.barWidth / 2 - n;

          switch (m && (v = -e.barWidth / 2 - n), v > Math.abs(p - x) && (v = Math.abs(p - x)), "rounded" === this.barCtx.barOptions.endingShape && (p += v / 2), "rounded" === this.barCtx.barOptions.startingShape && (x -= v / 2), this.barCtx.barOptions.endingShape) {
            case "flat":
              u = r.line(e.barXPosition + e.barWidth - n, p);
              break;

            case "rounded":
              u = r.quadraticCurve(e.barXPosition + (e.barWidth - n) / 2, p - v, e.barXPosition + e.barWidth - n, p);
          }

          switch (this.barCtx.barOptions.startingShape) {
            case "flat":
              f = r.line(e.barXPosition + e.barWidth - n, x);
              break;

            case "rounded":
              f = r.quadraticCurve(e.barXPosition + (e.barWidth - n) / 2, x + v, e.barXPosition, x);
          }
        }

        return {
          endingPath: u,
          startingPath: f,
          y2: p,
          y1: x
        };
      }
    }]), t;
  }(),
      F = function () {
    function t(i, a) {
      e(this, t), this.ctx = i, this.w = i.w;
      var s = this.w;
      this.barOptions = s.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s.config.stroke.width, this.isNullValue = !1, this.isTimelineBar = "datetime" === s.config.xaxis.type && s.globals.seriesRangeBarTimeline.length, this.xyRatios = a, null !== this.xyRatios && (this.xRatio = a.xRatio, this.initialXRatio = a.initialXRatio, this.yRatio = a.yRatio, this.invertedXRatio = a.invertedXRatio, this.invertedYRatio = a.invertedYRatio, this.baseLineY = a.baseLineY, this.baseLineInvertedY = a.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new Y(this);
    }

    return a(t, [{
      key: "draw",
      value: function value(t, e) {
        var i = this.w,
            a = new b(this.ctx),
            s = new y(this.ctx, i);
        t = s.getLogSeries(t), this.series = t, this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
        var r = a.group({
          class: "apexcharts-bar-series apexcharts-plot-series"
        });
        i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");

        for (var o = 0, l = 0; o < t.length; o++, l++) {
          var h,
              c,
              d,
              g,
              u = void 0,
              p = void 0,
              x = [],
              m = [],
              v = i.globals.comboCharts ? e[o] : o,
              w = a.group({
            class: "apexcharts-series",
            rel: o + 1,
            seriesName: f.escapeString(i.globals.seriesNames[v]),
            "data:realIndex": v
          });
          this.ctx.series.addCollapsedClassToSeries(w, v), t[o].length > 0 && (this.visibleI = this.visibleI + 1);
          var k = 0,
              A = 0;
          this.yRatio.length > 1 && (this.yaxisIndex = v), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
          var S = this.barHelpers.initialPositions();
          p = S.y, k = S.barHeight, c = S.yDivision, g = S.zeroW, u = S.x, A = S.barWidth, h = S.xDivision, d = S.zeroH, this.horizontal || m.push(u + A / 2);

          for (var C = a.group({
            class: "apexcharts-datalabels",
            "data:realIndex": v
          }), L = 0; L < i.globals.dataPoints; L++) {
            var P = this.barHelpers.getStrokeWidth(o, L, v),
                T = null,
                z = {
              indexes: {
                i: o,
                j: L,
                realIndex: v,
                bc: l
              },
              x: u,
              y: p,
              strokeWidth: P,
              elSeries: w
            };
            this.isHorizontal ? (T = this.drawBarPaths(n(n({}, z), {}, {
              barHeight: k,
              zeroW: g,
              yDivision: c
            })), A = this.series[o][L] / this.invertedYRatio) : (T = this.drawColumnPaths(n(n({}, z), {}, {
              xDivision: h,
              barWidth: A,
              zeroH: d
            })), k = this.series[o][L] / this.yRatio[this.yaxisIndex]), p = T.y, u = T.x, L > 0 && m.push(u + A / 2), x.push(p);
            var I = this.barHelpers.getPathFillColor(t, o, L, v);
            this.renderSeries({
              realIndex: v,
              pathFill: I,
              j: L,
              i: o,
              pathFrom: T.pathFrom,
              pathTo: T.pathTo,
              strokeWidth: P,
              elSeries: w,
              x: u,
              y: p,
              series: t,
              barHeight: k,
              barWidth: A,
              elDataLabelsWrap: C,
              visibleSeries: this.visibleI,
              type: "bar"
            });
          }

          i.globals.seriesXvalues[v] = m, i.globals.seriesYvalues[v] = x, r.add(w);
        }

        return r;
      }
    }, {
      key: "renderSeries",
      value: function value(t) {
        var e = t.realIndex,
            i = t.pathFill,
            a = t.lineFill,
            s = t.j,
            r = t.i,
            n = t.pathFrom,
            o = t.pathTo,
            l = t.strokeWidth,
            h = t.elSeries,
            c = t.x,
            d = t.y,
            g = t.y1,
            u = t.y2,
            f = t.series,
            x = t.barHeight,
            m = t.barWidth,
            v = t.barYPosition,
            y = t.elDataLabelsWrap,
            w = t.visibleSeries,
            k = t.type,
            A = this.w,
            S = new b(this.ctx);
        a || (a = this.barOptions.distributed ? A.globals.stroke.colors[s] : A.globals.stroke.colors[e]), A.config.series[r].data[s] && A.config.series[r].data[s].strokeColor && (a = A.config.series[r].data[s].strokeColor), this.isNullValue && (i = "none");
        var C = s / A.config.chart.animations.animateGradually.delay * (A.config.chart.animations.speed / A.globals.dataPoints) / 2.4,
            L = S.renderPaths({
          i: r,
          j: s,
          realIndex: e,
          pathFrom: n,
          pathTo: o,
          stroke: a,
          strokeWidth: l,
          strokeLineCap: A.config.stroke.lineCap,
          fill: i,
          animationDelay: C,
          initialSpeed: A.config.chart.animations.speed,
          dataChangeSpeed: A.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-".concat(k, "-area")
        });
        L.attr("clip-path", "url(#gridRectMask".concat(A.globals.cuid, ")")), void 0 !== g && void 0 !== u && (L.attr("data-range-y1", g), L.attr("data-range-y2", u)), new p(this.ctx).setSelectionFilter(L, e, s), h.add(L);
        var P = new E(this).handleBarDataLabels({
          x: c,
          y: d,
          y1: g,
          y2: u,
          i: r,
          j: s,
          series: f,
          realIndex: e,
          barHeight: x,
          barWidth: m,
          barYPosition: v,
          renderedPath: L,
          visibleSeries: w
        });
        return null !== P && y.add(P), h.add(y), h;
      }
    }, {
      key: "drawBarPaths",
      value: function value(t) {
        var e = t.indexes,
            i = t.barHeight,
            a = t.strokeWidth,
            s = t.zeroW,
            r = t.x,
            n = t.y,
            o = t.yDivision,
            l = t.elSeries,
            h = this.w,
            c = e.i,
            d = e.j;
        h.globals.isXNumeric && (n = (h.globals.seriesX[c][d] - h.globals.minX) / this.invertedXRatio - i);
        var g = n + i * this.visibleI;
        r = void 0 === this.series[c][d] || null === this.series[c][d] ? s : s + this.series[c][d] / this.invertedYRatio - 2 * (this.isReversed ? this.series[c][d] / this.invertedYRatio : 0);
        var u = this.barHelpers.getBarpaths({
          barYPosition: g,
          barHeight: i,
          x1: s,
          x2: r,
          strokeWidth: a,
          series: this.series,
          realIndex: e.realIndex,
          i: c,
          j: d,
          w: h
        });
        return h.globals.isXNumeric || (n += o), this.barHelpers.barBackground({
          j: d,
          i: c,
          y1: g - i * this.visibleI,
          y2: i * this.seriesLen,
          elSeries: l
        }), {
          pathTo: u.pathTo,
          pathFrom: u.pathFrom,
          x: r,
          y: n,
          barYPosition: g
        };
      }
    }, {
      key: "drawColumnPaths",
      value: function value(t) {
        var e = t.indexes,
            i = t.x,
            a = t.y,
            s = t.xDivision,
            r = t.barWidth,
            n = t.zeroH,
            o = t.strokeWidth,
            l = t.elSeries,
            h = this.w,
            c = e.i,
            d = e.j,
            g = e.bc;

        if (h.globals.isXNumeric) {
          var u = c;
          h.globals.seriesX[c].length || (u = h.globals.maxValsInArrayIndex), i = (h.globals.seriesX[u][d] - h.globals.minX) / this.xRatio - r * this.seriesLen / 2;
        }

        var f = i + r * this.visibleI;
        a = void 0 === this.series[c][d] || null === this.series[c][d] ? n : n - this.series[c][d] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[c][d] / this.yRatio[this.yaxisIndex] : 0);
        var p = this.barHelpers.getColumnPaths({
          barXPosition: f,
          barWidth: r,
          y1: n,
          y2: a,
          strokeWidth: o,
          series: this.series,
          realIndex: e.realIndex,
          i: c,
          j: d,
          w: h
        });
        return h.globals.isXNumeric || (i += s), this.barHelpers.barBackground({
          bc: g,
          j: d,
          i: c,
          x1: f - o / 2 - r * this.visibleI,
          x2: r * this.seriesLen + o / 2,
          elSeries: l
        }), {
          pathTo: p.pathTo,
          pathFrom: p.pathFrom,
          x: i,
          y: a,
          barXPosition: f
        };
      }
    }, {
      key: "getPreviousPath",
      value: function value(t, e) {
        for (var i, a = this.w, s = 0; s < a.globals.previousPaths.length; s++) {
          var r = a.globals.previousPaths[s];
          r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(t, 10) && void 0 !== a.globals.previousPaths[s].paths[e] && (i = a.globals.previousPaths[s].paths[e].d);
        }

        return i;
      }
    }]), t;
  }(),
      D = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }

    return a(t, [{
      key: "isValidDate",
      value: function value(t) {
        return !isNaN(this.parseDate(t));
      }
    }, {
      key: "getTimeStamp",
      value: function value(t) {
        return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t;
      }
    }, {
      key: "getDate",
      value: function value(t) {
        return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t);
      }
    }, {
      key: "parseDate",
      value: function value(t) {
        var e = Date.parse(t);
        if (!isNaN(e)) return this.getTimeStamp(t);
        var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
        return i = this.getTimeStamp(i);
      }
    }, {
      key: "parseDateWithTimezone",
      value: function value(t) {
        return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      }
    }, {
      key: "formatDate",
      value: function value(t, e) {
        var i = this.w.globals.locale,
            a = this.w.config.xaxis.labels.datetimeUTC,
            s = ["\0"].concat(g(i.months)),
            r = ["\x01"].concat(g(i.shortMonths)),
            n = ["\x02"].concat(g(i.days)),
            o = ["\x03"].concat(g(i.shortDays));

        function l(t, e) {
          var i = t + "";

          for (e = e || 2; i.length < e;) {
            i = "0" + i;
          }

          return i;
        }

        var h = a ? t.getUTCFullYear() : t.getFullYear();
        e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + h)).replace(/(^|[^\\])yy/g, "$1" + h.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h);
        var c = (a ? t.getUTCMonth() : t.getMonth()) + 1;
        e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + s[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + l(c))).replace(/(^|[^\\])M/g, "$1" + c);
        var d = a ? t.getUTCDate() : t.getDate();
        e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + n[0])).replace(/(^|[^\\])ddd/g, "$1" + o[0])).replace(/(^|[^\\])dd/g, "$1" + l(d))).replace(/(^|[^\\])d/g, "$1" + d);
        var u = a ? t.getUTCHours() : t.getHours(),
            f = u > 12 ? u - 12 : 0 === u ? 12 : u;
        e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + l(u))).replace(/(^|[^\\])H/g, "$1" + u)).replace(/(^|[^\\])hh+/g, "$1" + l(f))).replace(/(^|[^\\])h/g, "$1" + f);
        var p = a ? t.getUTCMinutes() : t.getMinutes();
        e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + l(p))).replace(/(^|[^\\])m/g, "$1" + p);
        var x = a ? t.getUTCSeconds() : t.getSeconds();
        e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + l(x))).replace(/(^|[^\\])s/g, "$1" + x);
        var b = a ? t.getUTCMilliseconds() : t.getMilliseconds();
        e = e.replace(/(^|[^\\])fff+/g, "$1" + l(b, 3)), b = Math.round(b / 10), e = e.replace(/(^|[^\\])ff/g, "$1" + l(b)), b = Math.round(b / 10);
        var m = u < 12 ? "AM" : "PM";
        e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + b)).replace(/(^|[^\\])TT+/g, "$1" + m)).replace(/(^|[^\\])T/g, "$1" + m.charAt(0));
        var v = m.toLowerCase();
        e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + v)).replace(/(^|[^\\])t/g, "$1" + v.charAt(0));
        var y = -t.getTimezoneOffset(),
            w = a || !y ? "Z" : y > 0 ? "+" : "-";

        if (!a) {
          var k = (y = Math.abs(y)) % 60;
          w += l(Math.floor(y / 60)) + ":" + l(k);
        }

        e = e.replace(/(^|[^\\])K/g, "$1" + w);
        var A = (a ? t.getUTCDay() : t.getDay()) + 1;
        return e = (e = (e = (e = (e = e.replace(new RegExp(n[0], "g"), n[A])).replace(new RegExp(o[0], "g"), o[A])).replace(new RegExp(s[0], "g"), s[c])).replace(new RegExp(r[0], "g"), r[c])).replace(/\\(.)/g, "$1");
      }
    }, {
      key: "getTimeUnitsfromTimestamp",
      value: function value(t, e, i) {
        var a = this.w;
        void 0 !== a.config.xaxis.min && (t = a.config.xaxis.min), void 0 !== a.config.xaxis.max && (e = a.config.xaxis.max);
        var s = this.getDate(t),
            r = this.getDate(e),
            n = this.formatDate(s, "yyyy MM dd HH mm").split(" "),
            o = this.formatDate(r, "yyyy MM dd HH mm").split(" ");
        return {
          minMinute: parseInt(n[4], 10),
          maxMinute: parseInt(o[4], 10),
          minHour: parseInt(n[3], 10),
          maxHour: parseInt(o[3], 10),
          minDate: parseInt(n[2], 10),
          maxDate: parseInt(o[2], 10),
          minMonth: parseInt(n[1], 10) - 1,
          maxMonth: parseInt(o[1], 10) - 1,
          minYear: parseInt(n[0], 10),
          maxYear: parseInt(o[0], 10)
        };
      }
    }, {
      key: "isLeapYear",
      value: function value(t) {
        return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
      }
    }, {
      key: "calculcateLastDaysOfMonth",
      value: function value(t, e, i) {
        return this.determineDaysOfMonths(t, e) - i;
      }
    }, {
      key: "determineDaysOfYear",
      value: function value(t) {
        var e = 365;
        return this.isLeapYear(t) && (e = 366), e;
      }
    }, {
      key: "determineRemainingDaysOfYear",
      value: function value(t, e, i) {
        var a = this.daysCntOfYear[e] + i;
        return e > 1 && this.isLeapYear() && a++, a;
      }
    }, {
      key: "determineDaysOfMonths",
      value: function value(t, e) {
        var i = 30;

        switch (t = f.monthMod(t), !0) {
          case this.months30.indexOf(t) > -1:
            2 === t && (i = this.isLeapYear(e) ? 29 : 28);
            break;

          case this.months31.indexOf(t) > -1:
          default:
            i = 31;
        }

        return i;
      }
    }]), t;
  }(),
      R = function (t) {
    o(s, F);
    var i = d(s);

    function s() {
      return e(this, s), i.apply(this, arguments);
    }

    return a(s, [{
      key: "draw",
      value: function value(t, e) {
        var i = this.w,
            a = new b(this.ctx);
        this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(t);

        for (var s = a.group({
          class: "apexcharts-rangebar-series apexcharts-plot-series"
        }), r = 0; r < t.length; r++) {
          var o,
              l,
              h,
              c = void 0,
              d = void 0,
              g = void 0,
              u = i.globals.comboCharts ? e[r] : r,
              p = a.group({
            class: "apexcharts-series",
            seriesName: f.escapeString(i.globals.seriesNames[u]),
            rel: r + 1,
            "data:realIndex": u
          });
          t[r].length > 0 && (this.visibleI = this.visibleI + 1);
          var x = 0,
              m = 0;
          this.yRatio.length > 1 && (this.yaxisIndex = u);
          var v = this.barHelpers.initialPositions();
          d = v.y, h = v.zeroW, c = v.x, m = v.barWidth, o = v.xDivision, l = v.zeroH;

          for (var y = a.group({
            class: "apexcharts-datalabels",
            "data:realIndex": u
          }), w = 0; w < i.globals.dataPoints; w++) {
            var k = this.barHelpers.getStrokeWidth(r, w, u),
                A = this.seriesRangeStart[r][w],
                S = this.seriesRangeEnd[r][w],
                C = null,
                L = null,
                P = {
              x: c,
              y: d,
              strokeWidth: k,
              elSeries: p
            };

            if (g = v.yDivision, x = v.barHeight, this.isHorizontal) {
              L = d + x * this.visibleI;
              var T = (g - x * this.seriesLen) / 2;
              if (void 0 === i.config.series[r].data[w]) break;

              if (this.isTimelineBar && i.config.series[r].data[w].x) {
                var z = this.detectOverlappingBars({
                  i: r,
                  j: w,
                  barYPosition: L,
                  srty: T,
                  barHeight: x,
                  yDivision: g,
                  initPositions: v
                });
                x = z.barHeight, L = z.barYPosition;
              }

              m = (C = this.drawRangeBarPaths(n({
                indexes: {
                  i: r,
                  j: w,
                  realIndex: u
                },
                barHeight: x,
                barYPosition: L,
                zeroW: h,
                yDivision: g,
                y1: A,
                y2: S
              }, P))).barWidth;
            } else x = (C = this.drawRangeColumnPaths(n({
              indexes: {
                i: r,
                j: w,
                realIndex: u
              },
              zeroH: l,
              barWidth: m,
              xDivision: o
            }, P))).barHeight;

            d = C.y, c = C.x;
            var I = this.barHelpers.getPathFillColor(t, r, w, u),
                M = i.globals.stroke.colors[u];
            this.renderSeries({
              realIndex: u,
              pathFill: I,
              lineFill: M,
              j: w,
              i: r,
              x: c,
              y: d,
              y1: A,
              y2: S,
              pathFrom: C.pathFrom,
              pathTo: C.pathTo,
              strokeWidth: k,
              elSeries: p,
              series: t,
              barHeight: x,
              barYPosition: L,
              barWidth: m,
              elDataLabelsWrap: y,
              visibleSeries: this.visibleI,
              type: "rangebar"
            });
          }

          s.add(p);
        }

        return s;
      }
    }, {
      key: "detectOverlappingBars",
      value: function value(t) {
        var e = t.i,
            i = t.j,
            a = t.barYPosition,
            s = t.srty,
            r = t.barHeight,
            n = t.yDivision,
            o = t.initPositions,
            l = this.w,
            h = [],
            c = l.config.series[e].data[i].rangeName,
            d = l.config.series[e].data[i].x,
            g = l.globals.labels.indexOf(d),
            u = l.globals.seriesRangeBarTimeline[e].findIndex(function (t) {
          return t.x === d && t.overlaps.length > 0;
        });
        return a = s + r * this.visibleI + n * g, u > -1 && !l.config.plotOptions.bar.rangeBarOverlap && (h = l.globals.seriesRangeBarTimeline[e][u].overlaps).indexOf(c) > -1 && (a = (r = o.barHeight / h.length) * this.visibleI + n * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r * (this.visibleI + h.indexOf(c)) + n * g), {
          barYPosition: a,
          barHeight: r
        };
      }
    }, {
      key: "drawRangeColumnPaths",
      value: function value(t) {
        var e = t.indexes,
            i = t.x,
            a = (t.strokeWidth, t.xDivision),
            s = t.barWidth,
            r = t.zeroH,
            n = this.w,
            o = e.i,
            l = e.j,
            h = this.yRatio[this.yaxisIndex],
            c = e.realIndex,
            d = this.getRangeValue(c, l),
            g = Math.min(d.start, d.end),
            u = Math.max(d.start, d.end);
        n.globals.isXNumeric && (i = (n.globals.seriesX[o][l] - n.globals.minX) / this.xRatio - s / 2);
        var f = i + s * this.visibleI;
        void 0 === this.series[o][l] || null === this.series[o][l] ? g = r : (g = r - g / h, u = r - u / h);
        var p = Math.abs(u - g),
            x = this.barHelpers.getColumnPaths({
          barXPosition: f,
          barWidth: s,
          y1: g,
          y2: u,
          strokeWidth: this.strokeWidth,
          series: this.seriesRangeEnd,
          i: c,
          j: l,
          w: n
        });
        return n.globals.isXNumeric || (i += a), {
          pathTo: x.pathTo,
          pathFrom: x.pathFrom,
          barHeight: p,
          x: i,
          y: u,
          barXPosition: f
        };
      }
    }, {
      key: "drawRangeBarPaths",
      value: function value(t) {
        var e = t.indexes,
            i = t.y,
            a = t.y1,
            s = t.y2,
            r = t.yDivision,
            n = t.barHeight,
            o = t.barYPosition,
            l = t.zeroW,
            h = this.w,
            c = l + a / this.invertedYRatio,
            d = l + s / this.invertedYRatio,
            g = Math.abs(d - c),
            u = this.barHelpers.getBarpaths({
          barYPosition: o,
          barHeight: n,
          x1: c,
          x2: d,
          strokeWidth: this.strokeWidth,
          series: this.seriesRangeEnd,
          i: e.realIndex,
          j: e.j,
          w: h
        });
        return h.globals.isXNumeric || (i += r), {
          pathTo: u.pathTo,
          pathFrom: u.pathFrom,
          barWidth: g,
          x: d,
          y: i
        };
      }
    }, {
      key: "getRangeValue",
      value: function value(t, e) {
        var i = this.w;
        return {
          start: i.globals.seriesRangeStart[t][e],
          end: i.globals.seriesRangeEnd[t][e]
        };
      }
    }, {
      key: "getTooltipValues",
      value: function value(t) {
        var e = t.ctx,
            i = t.seriesIndex,
            a = t.dataPointIndex,
            s = t.y1,
            r = t.y2,
            n = t.w,
            o = n.globals.seriesRangeStart[i][a],
            l = n.globals.seriesRangeEnd[i][a],
            h = n.globals.labels[a],
            c = n.config.series[i].name,
            d = n.config.tooltip.y.formatter,
            g = n.config.tooltip.y.title.formatter,
            u = {
          w: n,
          seriesIndex: i,
          dataPointIndex: a
        };
        "function" == typeof g && (c = g(c, u)), s && r && (o = s, l = r, n.config.series[i].data[a].x && (h = n.config.series[i].data[a].x + ":"), "function" == typeof d && (h = d(h, u)));
        var f = "",
            p = "",
            x = n.globals.colors[i];
        if (void 0 === n.config.tooltip.x.formatter) {
          if ("datetime" === n.config.xaxis.type) {
            var b = new D(e);
            f = b.formatDate(b.getDate(o), n.config.tooltip.x.format), p = b.formatDate(b.getDate(l), n.config.tooltip.x.format);
          } else f = o, p = l;
        } else f = n.config.tooltip.x.formatter(o), p = n.config.tooltip.x.formatter(l);
        return {
          start: o,
          end: l,
          startVal: f,
          endVal: p,
          ylabel: h,
          color: x,
          seriesName: c
        };
      }
    }, {
      key: "buildCustomTooltipHTML",
      value: function value(t) {
        var e = t.color,
            i = t.seriesName;
        return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e + '">' + (i || "") + '</span></div><div> <span class="category">' + t.ylabel + ' </span> <span class="value start-value">' + t.start + '</span> <span class="separator">-</span> <span class="value end-value">' + t.end + "</span></div></div>";
      }
    }]), s;
  }(),
      H = function () {
    function t(i) {
      e(this, t), this.opts = i;
    }

    return a(t, [{
      key: "line",
      value: function value() {
        return {
          chart: {
            animations: {
              easing: "swing"
            }
          },
          dataLabels: {
            enabled: !1
          },
          stroke: {
            width: 5,
            curve: "straight"
          },
          markers: {
            size: 0,
            hover: {
              sizeOffset: 6
            }
          },
          xaxis: {
            crosshairs: {
              width: 1
            }
          }
        };
      }
    }, {
      key: "sparkline",
      value: function value(t) {
        this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
        return f.extend(t, {
          grid: {
            show: !1,
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          },
          legend: {
            show: !1
          },
          xaxis: {
            labels: {
              show: !1
            },
            tooltip: {
              enabled: !1
            },
            axisBorder: {
              show: !1
            },
            axisTicks: {
              show: !1
            }
          },
          chart: {
            toolbar: {
              show: !1
            },
            zoom: {
              enabled: !1
            }
          },
          dataLabels: {
            enabled: !1
          }
        });
      }
    }, {
      key: "bar",
      value: function value() {
        return {
          chart: {
            stacked: !1,
            animations: {
              easing: "swing"
            }
          },
          plotOptions: {
            bar: {
              dataLabels: {
                position: "center"
              }
            }
          },
          dataLabels: {
            style: {
              colors: ["#fff"]
            },
            background: {
              enabled: !1
            }
          },
          stroke: {
            width: 0,
            lineCap: "square"
          },
          fill: {
            opacity: .85
          },
          legend: {
            markers: {
              shape: "square",
              radius: 2,
              size: 8
            }
          },
          tooltip: {
            shared: !1
          },
          xaxis: {
            tooltip: {
              enabled: !1
            },
            tickPlacement: "between",
            crosshairs: {
              width: "barWidth",
              position: "back",
              fill: {
                type: "gradient"
              },
              dropShadow: {
                enabled: !1
              },
              stroke: {
                width: 0
              }
            }
          }
        };
      }
    }, {
      key: "candlestick",
      value: function value() {
        return {
          stroke: {
            width: 1,
            colors: ["#333"]
          },
          fill: {
            opacity: 1
          },
          dataLabels: {
            enabled: !1
          },
          tooltip: {
            shared: !0,
            custom: function custom(t) {
              var e = t.seriesIndex,
                  i = t.dataPointIndex,
                  a = t.w;
              return '<div class="apexcharts-tooltip-candlestick"><div>Open: <span class="value">' + a.globals.seriesCandleO[e][i] + '</span></div><div>High: <span class="value">' + a.globals.seriesCandleH[e][i] + '</span></div><div>Low: <span class="value">' + a.globals.seriesCandleL[e][i] + '</span></div><div>Close: <span class="value">' + a.globals.seriesCandleC[e][i] + "</span></div></div>";
            }
          },
          states: {
            active: {
              filter: {
                type: "none"
              }
            }
          },
          xaxis: {
            crosshairs: {
              width: 1
            }
          }
        };
      }
    }, {
      key: "rangeBar",
      value: function value() {
        return {
          stroke: {
            width: 0,
            lineCap: "square"
          },
          plotOptions: {
            bar: {
              dataLabels: {
                position: "center"
              }
            }
          },
          dataLabels: {
            enabled: !1,
            formatter: function formatter(t, e) {
              e.ctx;
              var i = e.seriesIndex,
                  a = e.dataPointIndex,
                  s = e.w,
                  r = s.globals.seriesRangeStart[i][a];
              return s.globals.seriesRangeEnd[i][a] - r;
            },
            background: {
              enabled: !1
            },
            style: {
              colors: ["#fff"]
            }
          },
          tooltip: {
            shared: !1,
            followCursor: !0,
            custom: function custom(t) {
              return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function (t) {
                var e = new R(t.ctx, null),
                    i = e.getTooltipValues(t),
                    a = i.color,
                    s = i.seriesName,
                    r = i.ylabel,
                    n = i.startVal,
                    o = i.endVal;
                return e.buildCustomTooltipHTML({
                  color: a,
                  seriesName: s,
                  ylabel: r,
                  start: n,
                  end: o
                });
              }(t) : function (t) {
                var e = new R(t.ctx, null),
                    i = e.getTooltipValues(t),
                    a = i.color,
                    s = i.seriesName,
                    r = i.ylabel,
                    n = i.start,
                    o = i.end;
                return e.buildCustomTooltipHTML({
                  color: a,
                  seriesName: s,
                  ylabel: r,
                  start: n,
                  end: o
                });
              }(t);
            }
          },
          xaxis: {
            tickPlacement: "between",
            tooltip: {
              enabled: !1
            },
            crosshairs: {
              stroke: {
                width: 0
              }
            }
          }
        };
      }
    }, {
      key: "area",
      value: function value() {
        return {
          stroke: {
            width: 4
          },
          fill: {
            type: "gradient",
            gradient: {
              inverseColors: !1,
              shade: "light",
              type: "vertical",
              opacityFrom: .65,
              opacityTo: .5,
              stops: [0, 100, 100]
            }
          },
          markers: {
            size: 0,
            hover: {
              sizeOffset: 6
            }
          },
          tooltip: {
            followCursor: !1
          }
        };
      }
    }, {
      key: "brush",
      value: function value(t) {
        return f.extend(t, {
          chart: {
            toolbar: {
              autoSelected: "selection",
              show: !1
            },
            zoom: {
              enabled: !1
            }
          },
          dataLabels: {
            enabled: !1
          },
          stroke: {
            width: 1
          },
          tooltip: {
            enabled: !1
          },
          xaxis: {
            tooltip: {
              enabled: !1
            }
          }
        });
      }
    }, {
      key: "stacked100",
      value: function value(t) {
        t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
        var e = t.dataLabels.formatter;
        return t.yaxis.forEach(function (e, i) {
          t.yaxis[i].min = 0, t.yaxis[i].max = 100;
        }), "bar" === t.chart.type && (t.dataLabels.formatter = e || function (t) {
          return "number" == typeof t && t ? t.toFixed(0) + "%" : t;
        }), t;
      }
    }, {
      key: "convertCatToNumeric",
      value: function value(t) {
        return t.xaxis.convertedCatToNumeric = !0, t;
      }
    }, {
      key: "convertCatToNumericXaxis",
      value: function value(t, e, i) {
        t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function (t) {
          return f.isNumber(t) ? Math.floor(t) : t;
        };
        var a = t.xaxis.labels.formatter,
            s = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
        return i && i.length && (s = i.map(function (t) {
          return t.toString();
        })), s && s.length && (t.xaxis.labels.formatter = function (t) {
          return f.isNumber(t) ? a(s[Math.floor(t) - 1]) : a(t);
        }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t;
      }
    }, {
      key: "bubble",
      value: function value() {
        return {
          dataLabels: {
            style: {
              colors: ["#fff"]
            }
          },
          tooltip: {
            shared: !1,
            intersect: !0
          },
          xaxis: {
            crosshairs: {
              width: 0
            }
          },
          fill: {
            type: "solid",
            gradient: {
              shade: "light",
              inverse: !0,
              shadeIntensity: .55,
              opacityFrom: .4,
              opacityTo: .8
            }
          }
        };
      }
    }, {
      key: "scatter",
      value: function value() {
        return {
          dataLabels: {
            enabled: !1
          },
          tooltip: {
            shared: !1,
            intersect: !0
          },
          markers: {
            size: 6,
            strokeWidth: 1,
            hover: {
              sizeOffset: 2
            }
          }
        };
      }
    }, {
      key: "heatmap",
      value: function value() {
        return {
          chart: {
            stacked: !1
          },
          fill: {
            opacity: 1
          },
          dataLabels: {
            style: {
              colors: ["#fff"]
            }
          },
          stroke: {
            colors: ["#fff"]
          },
          tooltip: {
            followCursor: !0,
            marker: {
              show: !1
            },
            x: {
              show: !1
            }
          },
          legend: {
            position: "top",
            markers: {
              shape: "square",
              size: 10,
              offsetY: 2
            }
          },
          grid: {
            padding: {
              right: 20
            }
          }
        };
      }
    }, {
      key: "pie",
      value: function value() {
        return {
          chart: {
            toolbar: {
              show: !1
            }
          },
          plotOptions: {
            pie: {
              donut: {
                labels: {
                  show: !1
                }
              }
            }
          },
          dataLabels: {
            formatter: function formatter(t) {
              return t.toFixed(1) + "%";
            },
            style: {
              colors: ["#fff"]
            },
            background: {
              enabled: !1
            },
            dropShadow: {
              enabled: !0
            }
          },
          stroke: {
            colors: ["#fff"]
          },
          fill: {
            opacity: 1,
            gradient: {
              shade: "light",
              stops: [0, 100]
            }
          },
          tooltip: {
            theme: "dark",
            fillSeriesColor: !0
          },
          legend: {
            position: "right"
          }
        };
      }
    }, {
      key: "donut",
      value: function value() {
        return {
          chart: {
            toolbar: {
              show: !1
            }
          },
          dataLabels: {
            formatter: function formatter(t) {
              return t.toFixed(1) + "%";
            },
            style: {
              colors: ["#fff"]
            },
            background: {
              enabled: !1
            },
            dropShadow: {
              enabled: !0
            }
          },
          stroke: {
            colors: ["#fff"]
          },
          fill: {
            opacity: 1,
            gradient: {
              shade: "light",
              shadeIntensity: .35,
              stops: [80, 100],
              opacityFrom: 1,
              opacityTo: 1
            }
          },
          tooltip: {
            theme: "dark",
            fillSeriesColor: !0
          },
          legend: {
            position: "right"
          }
        };
      }
    }, {
      key: "polarArea",
      value: function value() {
        return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
          chart: {
            toolbar: {
              show: !1
            }
          },
          dataLabels: {
            formatter: function formatter(t) {
              return t.toFixed(1) + "%";
            },
            enabled: !1
          },
          stroke: {
            show: !0,
            width: 2
          },
          fill: {
            opacity: .7
          },
          tooltip: {
            theme: "dark",
            fillSeriesColor: !0
          },
          legend: {
            position: "right"
          }
        };
      }
    }, {
      key: "radar",
      value: function value() {
        return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
          dataLabels: {
            enabled: !1,
            style: {
              fontSize: "11px"
            }
          },
          stroke: {
            width: 2
          },
          markers: {
            size: 3,
            strokeWidth: 1,
            strokeOpacity: 1
          },
          fill: {
            opacity: .2
          },
          tooltip: {
            shared: !1,
            intersect: !0,
            followCursor: !0
          },
          grid: {
            show: !1
          },
          xaxis: {
            labels: {
              formatter: function formatter(t) {
                return t;
              },
              style: {
                colors: ["#a8a8a8"],
                fontSize: "11px"
              }
            },
            tooltip: {
              enabled: !1
            },
            crosshairs: {
              show: !1
            }
          }
        };
      }
    }, {
      key: "radialBar",
      value: function value() {
        return {
          chart: {
            animations: {
              dynamicAnimation: {
                enabled: !0,
                speed: 800
              }
            },
            toolbar: {
              show: !1
            }
          },
          fill: {
            gradient: {
              shade: "dark",
              shadeIntensity: .4,
              inverseColors: !1,
              type: "diagonal2",
              opacityFrom: 1,
              opacityTo: 1,
              stops: [70, 98, 100]
            }
          },
          legend: {
            show: !1,
            position: "right"
          },
          tooltip: {
            enabled: !1,
            fillSeriesColor: !0
          }
        };
      }
    }]), t;
  }(),
      N = function () {
    function i(t) {
      e(this, i), this.opts = t;
    }

    return a(i, [{
      key: "init",
      value: function value(e) {
        var i = e.responsiveOverride,
            a = this.opts,
            s = new L(),
            r = new H(a);
        this.chartType = a.chart.type, "histogram" === this.chartType && (a.chart.type = "bar", a = f.extend({
          plotOptions: {
            bar: {
              columnWidth: "99.99%"
            }
          }
        }, a)), a = this.extendYAxis(a), a = this.extendAnnotations(a);
        var n = s.init(),
            o = {};

        if (a && "object" === t(a)) {
          var l = {};
          l = -1 !== ["line", "area", "bar", "candlestick", "rangeBar", "histogram", "bubble", "scatter", "heatmap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a.chart.type) ? r[a.chart.type]() : r.line(), a.chart.brush && a.chart.brush.enabled && (l = r.brush(l)), a.chart.stacked && "100%" === a.chart.stackType && (a = r.stacked100(a)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a), a.xaxis = a.xaxis || window.Apex.xaxis || {}, i || (a.xaxis.convertedCatToNumeric = !1), ((a = this.checkForCatToNumericXAxis(this.chartType, l, a)).chart.sparkline && a.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l = r.sparkline(l)), o = f.extend(n, l);
        }

        var h = f.extend(o, window.Apex);
        return n = f.extend(h, a), n = this.handleUserInputErrors(n);
      }
    }, {
      key: "checkForCatToNumericXAxis",
      value: function value(t, e, i) {
        var a = new H(i),
            s = "bar" === t && i.plotOptions && i.plotOptions.bar && i.plotOptions.bar.horizontal,
            r = "pie" === t || "polarArea" === t || "donut" === t || "radar" === t || "radialBar" === t || "heatmap" === t,
            n = "datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type,
            o = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement;
        return s || r || !n || "between" === o || (i = a.convertCatToNumeric(i)), i;
      }
    }, {
      key: "extendYAxis",
      value: function value(t, e) {
        var i = new L();
        (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && 0 === t.yaxis.length) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = f.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [f.extend(i.yAxis, t.yaxis)] : t.yaxis = f.extendArray(t.yaxis, i.yAxis);
        var a = !1;
        t.yaxis.forEach(function (t) {
          t.logarithmic && (a = !0);
        });
        var s = t.series;
        return e && !s && (s = e.config.series), a && s.length !== t.yaxis.length && s.length && (t.yaxis = s.map(function (e, a) {
          if (e.name || (s[a].name = "series-".concat(a + 1)), t.yaxis[a]) return t.yaxis[a].seriesName = s[a].name, t.yaxis[a];
          var r = f.extend(i.yAxis, t.yaxis[0]);
          return r.show = !1, r;
        })), a && s.length > 1 && s.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t;
      }
    }, {
      key: "extendAnnotations",
      value: function value(t) {
        return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), t = this.extendPointAnnotations(t);
      }
    }, {
      key: "extendYAxisAnnotations",
      value: function value(t) {
        var e = new L();
        return t.annotations.yaxis = f.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t;
      }
    }, {
      key: "extendXAxisAnnotations",
      value: function value(t) {
        var e = new L();
        return t.annotations.xaxis = f.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t;
      }
    }, {
      key: "extendPointAnnotations",
      value: function value(t) {
        var e = new L();
        return t.annotations.points = f.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t;
      }
    }, {
      key: "checkForDarkTheme",
      value: function value(t) {
        t.theme && "dark" === t.theme.mode && (t.tooltip || (t.tooltip = {}), "light" !== t.tooltip.theme && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"));
      }
    }, {
      key: "handleUserInputErrors",
      value: function value(t) {
        var e = t;
        if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");

        if (("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal) {
          if (e.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
          e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1;
        }

        return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && ("barWidth" === e.xaxis.crosshairs.width && e.series.length > 1 && (console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'), e.xaxis.crosshairs.width = "tickWidth"), e.plotOptions.bar.horizontal && (e.states.hover.type = "none", e.tooltip.shared = !1), e.tooltip.followCursor || (console.warn("followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true", "color: blue;"), e.tooltip.followCursor = !0)), "candlestick" === e.chart.type && e.yaxis[0].reversed && (console.warn("Reversed y-axis in candlestick chart is not supported."), e.yaxis[0].reversed = !1), e.chart.group && 0 === e.yaxis[0].labels.minWidth && console.warn("It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour."), Array.isArray(e.stroke.width) && "line" !== e.chart.type && "area" !== e.chart.type && (console.warn("stroke.width option accepts array only for line and area charts. Reverted back to Number"), e.stroke.width = e.stroke.width[0]), e;
      }
    }]), i;
  }(),
      O = function () {
    function t() {
      e(this, t);
    }

    return a(t, [{
      key: "initGlobalVars",
      value: function value(t) {
        t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRangeBarTimeline = [], t.seriesPercent = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.xaxisLabelsCount = 0, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0;
      }
    }, {
      key: "globalVars",
      value: function value(t) {
        return {
          chartID: null,
          cuid: null,
          events: {
            beforeMount: [],
            mounted: [],
            updated: [],
            clicked: [],
            selection: [],
            dataPointSelection: [],
            zoomed: [],
            scrolled: []
          },
          colors: [],
          clientX: null,
          clientY: null,
          fill: {
            colors: []
          },
          stroke: {
            colors: []
          },
          dataLabels: {
            style: {
              colors: []
            }
          },
          radarPolygons: {
            fill: {
              colors: []
            }
          },
          markers: {
            colors: [],
            size: t.markers.size,
            largestSize: 0
          },
          animationEnded: !1,
          isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
          isDirty: !1,
          isExecCalled: !1,
          initialConfig: null,
          initialSeries: [],
          lastXAxis: [],
          lastYAxis: [],
          columnSeries: null,
          labels: [],
          timescaleLabels: [],
          noLabelsProvided: !1,
          allSeriesCollapsed: !1,
          collapsedSeries: [],
          collapsedSeriesIndices: [],
          ancillaryCollapsedSeries: [],
          ancillaryCollapsedSeriesIndices: [],
          risingSeries: [],
          dataFormatXNumeric: !1,
          capturedSeriesIndex: -1,
          capturedDataPointIndex: -1,
          selectedDataPoints: [],
          goldenPadding: 35,
          invalidLogScale: !1,
          ignoreYAxisIndexes: [],
          yAxisSameScaleIndices: [],
          maxValsInArrayIndex: 0,
          radialSize: 0,
          selection: void 0,
          zoomEnabled: "zoom" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
          panEnabled: "pan" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.pan,
          selectionEnabled: "selection" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.selection,
          yaxis: null,
          mousedown: !1,
          lastClientPosition: {},
          visibleXRange: void 0,
          yValueDecimal: 0,
          total: 0,
          SVGNS: "http://www.w3.org/2000/svg",
          svgWidth: 0,
          svgHeight: 0,
          noData: !1,
          locale: {},
          dom: {},
          memory: {
            methodsToExec: []
          },
          shouldAnimate: !0,
          skipLastTimelinelabel: !1,
          skipFirstTimelinelabel: !1,
          delayedElements: [],
          axisCharts: !0,
          isDataXYZ: !1,
          resized: !1,
          resizeTimer: null,
          comboCharts: !1,
          dataChanged: !1,
          previousPaths: [],
          allSeriesHasEqualX: !0,
          pointsArray: [],
          dataLabelsRects: [],
          lastDrawnDataLabelsIndexes: [],
          hasNullValues: !1,
          easing: null,
          zoomed: !1,
          gridWidth: 0,
          gridHeight: 0,
          rotateXLabels: !1,
          defaultLabels: !1,
          xLabelFormatter: void 0,
          yLabelFormatters: [],
          xaxisTooltipFormatter: void 0,
          ttKeyFormatter: void 0,
          ttVal: void 0,
          ttZFormatter: void 0,
          LINE_HEIGHT_RATIO: 1.618,
          xAxisLabelsHeight: 0,
          xAxisLabelsWidth: 0,
          yAxisLabelsWidth: 0,
          scaleX: 1,
          scaleY: 1,
          translateX: 0,
          translateY: 0,
          translateYAxisX: [],
          yAxisWidths: [],
          translateXAxisY: 0,
          translateXAxisX: 0,
          tooltip: null
        };
      }
    }, {
      key: "init",
      value: function value(t) {
        var e = this.globalVars(t);
        return this.initGlobalVars(e), e.initialConfig = f.extend({}, t), e.initialSeries = f.clone(t.series), e.lastXAxis = f.clone(e.initialConfig.xaxis), e.lastYAxis = f.clone(e.initialConfig.yaxis), e;
      }
    }]), t;
  }(),
      W = function () {
    function t(i) {
      e(this, t), this.opts = i;
    }

    return a(t, [{
      key: "init",
      value: function value() {
        var t = new N(this.opts).init({
          responsiveOverride: !1
        });
        return {
          config: t,
          globals: new O().init(t)
        };
      }
    }]), t;
  }(),
      B = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.coreUtils = new y(this.ctx);
    }

    return a(t, [{
      key: "isMultiFormat",
      value: function value() {
        return this.isFormatXY() || this.isFormat2DArray();
      }
    }, {
      key: "isFormatXY",
      value: function value() {
        var t = this.w.config.series.slice(),
            e = new X(this.ctx);
        if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null !== t[this.activeSeriesIndex].data[0] && void 0 !== t[this.activeSeriesIndex].data[0].x && null !== t[this.activeSeriesIndex].data[0]) return !0;
      }
    }, {
      key: "isFormat2DArray",
      value: function value() {
        var t = this.w.config.series.slice(),
            e = new X(this.ctx);
        if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && void 0 !== t[this.activeSeriesIndex].data[0] && null !== t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0].constructor === Array) return !0;
      }
    }, {
      key: "handleFormat2DArray",
      value: function value(t, e) {
        var i = this.w.config,
            a = this.w.globals;
        i.xaxis.sorted && ("datetime" === i.xaxis.type ? t[e].data.sort(function (t, e) {
          return new Date(t[0]).getTime() - new Date(e[0]).getTime();
        }) : "numeric" === i.xaxis.type && t[e].data.sort(function (t, e) {
          return t[0] - e[0];
        }));

        for (var s = 0; s < t[e].data.length; s++) {
          if (void 0 !== t[e].data[s][1] && (Array.isArray(t[e].data[s][1]) && 4 === t[e].data[s][1].length ? this.twoDSeries.push(f.parseNumber(t[e].data[s][1][3])) : 5 === t[e].data[s].length ? this.twoDSeries.push(f.parseNumber(t[e].data[s][4])) : this.twoDSeries.push(f.parseNumber(t[e].data[s][1])), a.dataFormatXNumeric = !0), "datetime" === i.xaxis.type) {
            var r = new Date(t[e].data[s][0]);
            r = new Date(r).getTime(), this.twoDSeriesX.push(r);
          } else this.twoDSeriesX.push(t[e].data[s][0]);
        }

        for (var n = 0; n < t[e].data.length; n++) {
          void 0 !== t[e].data[n][2] && (this.threeDSeries.push(t[e].data[n][2]), a.isDataXYZ = !0);
        }
      }
    }, {
      key: "handleFormatXY",
      value: function value(t, e) {
        var i = this.w.config,
            a = this.w.globals,
            s = new D(this.ctx),
            r = e;
        a.collapsedSeriesIndices.indexOf(e) > -1 && (r = this.activeSeriesIndex), i.xaxis.sorted && ("datetime" === i.xaxis.type ? t[e].data.sort(function (t, e) {
          return new Date(t.x).getTime() - new Date(e.x).getTime();
        }) : "numeric" === i.xaxis.type && t[e].data.sort(function (t, e) {
          return t.x - e.x;
        }));

        for (var n = 0; n < t[e].data.length; n++) {
          void 0 !== t[e].data[n].y && (Array.isArray(t[e].data[n].y) ? this.twoDSeries.push(f.parseNumber(t[e].data[n].y[t[e].data[n].y.length - 1])) : this.twoDSeries.push(f.parseNumber(t[e].data[n].y)));
        }

        for (var o = 0; o < t[r].data.length; o++) {
          var l = "string" == typeof t[r].data[o].x,
              h = Array.isArray(t[r].data[o].x),
              c = !h && !!s.isValidDate(t[r].data[o].x.toString());
          if (l || c) {
            if (l || i.xaxis.convertedCatToNumeric) {
              var d = a.isBarHorizontal && a.isRangeData;
              "datetime" !== i.xaxis.type || d ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : this.twoDSeriesX.push(s.parseDate(t[r].data[o].x));
            } else "datetime" === i.xaxis.type ? this.twoDSeriesX.push(s.parseDate(t[r].data[o].x.toString())) : (a.dataFormatXNumeric = !0, a.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[r].data[o].x)));
          } else h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[o].x)) : (a.isXNumeric = !0, a.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[r].data[o].x));
        }

        if (t[e].data[0] && void 0 !== t[e].data[0].z) {
          for (var g = 0; g < t[e].data.length; g++) {
            this.threeDSeries.push(t[e].data[g].z);
          }

          a.isDataXYZ = !0;
        }
      }
    }, {
      key: "handleRangeData",
      value: function value(t, e) {
        var i = this.w.config,
            a = this.w.globals,
            s = {};
        return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", t, e) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", t, e)), a.seriesRangeStart.push(s.start), a.seriesRangeEnd.push(s.end), "datetime" === i.xaxis.type && a.seriesRangeBarTimeline.push(s.rangeUniques), a.seriesRangeBarTimeline.forEach(function (t, e) {
          t && t.forEach(function (t, e) {
            t.y.forEach(function (e, i) {
              for (var a = 0; a < t.y.length; a++) {
                if (i !== a) {
                  var s = e.y1,
                      r = e.y2,
                      n = t.y[a].y1;
                  s <= t.y[a].y2 && n <= r && (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName), t.overlaps.indexOf(t.y[a].rangeName) < 0 && t.overlaps.push(t.y[a].rangeName));
                }
              }
            });
          });
        }), s;
      }
    }, {
      key: "handleCandleStickData",
      value: function value(t, e) {
        var i = this.w.globals,
            a = {};
        return this.isFormat2DArray() ? a = this.handleCandleStickDataFormat("array", t, e) : this.isFormatXY() && (a = this.handleCandleStickDataFormat("xy", t, e)), i.seriesCandleO[e] = a.o, i.seriesCandleH[e] = a.h, i.seriesCandleL[e] = a.l, i.seriesCandleC[e] = a.c, a;
      }
    }, {
      key: "handleRangeDataFormat",
      value: function value(t, e, i) {
        var a = [],
            s = [],
            r = e[i].data.filter(function (t, e, i) {
          return e === i.findIndex(function (e) {
            return e.x === t.x;
          });
        }).map(function (t, e) {
          return {
            x: t.x,
            overlaps: [],
            y: []
          };
        }),
            n = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts",
            o = new X(this.ctx).getActiveConfigSeriesIndex();

        if ("array" === t) {
          if (2 !== e[o].data[0][1].length) throw new Error(n);

          for (var l = 0; l < e[i].data.length; l++) {
            a.push(e[i].data[l][1][0]), s.push(e[i].data[l][1][1]);
          }
        } else if ("xy" === t) {
          if (2 !== e[o].data[0].y.length) throw new Error(n);

          for (var h = function h(t) {
            var n = f.randomId(),
                o = e[i].data[t].x,
                l = {
              y1: e[i].data[t].y[0],
              y2: e[i].data[t].y[1],
              rangeName: n
            };
            e[i].data[t].rangeName = n;
            var h = r.findIndex(function (t) {
              return t.x === o;
            });
            r[h].y.push(l), a.push(l.y1), s.push(l.y2);
          }, c = 0; c < e[i].data.length; c++) {
            h(c);
          }
        }

        return {
          start: a,
          end: s,
          rangeUniques: r
        };
      }
    }, {
      key: "handleCandleStickDataFormat",
      value: function value(t, e, i) {
        var a = [],
            s = [],
            r = [],
            n = [],
            o = "Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick";

        if ("array" === t) {
          if (!Array.isArray(e[i].data[0][1]) && 5 !== e[i].data[0].length || Array.isArray(e[i].data[0][1]) && 4 !== e[i].data[0][1].length) throw new Error(o);
          if (5 === e[i].data[0].length) for (var l = 0; l < e[i].data.length; l++) {
            a.push(e[i].data[l][1]), s.push(e[i].data[l][2]), r.push(e[i].data[l][3]), n.push(e[i].data[l][4]);
          } else for (var h = 0; h < e[i].data.length; h++) {
            a.push(e[i].data[h][1][0]), s.push(e[i].data[h][1][1]), r.push(e[i].data[h][1][2]), n.push(e[i].data[h][1][3]);
          }
        } else if ("xy" === t) {
          if (4 !== e[i].data[0].y.length) throw new Error(o);

          for (var c = 0; c < e[i].data.length; c++) {
            a.push(e[i].data[c].y[0]), s.push(e[i].data[c].y[1]), r.push(e[i].data[c].y[2]), n.push(e[i].data[c].y[3]);
          }
        }

        return {
          o: a,
          h: s,
          l: r,
          c: n
        };
      }
    }, {
      key: "parseDataAxisCharts",
      value: function value(t) {
        for (var e = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a = this.w.config, s = this.w.globals, r = new D(i), n = a.labels.length > 0 ? a.labels.slice() : a.xaxis.categories.slice(), o = function o() {
          for (var t = 0; t < n.length; t++) {
            if ("string" == typeof n[t]) {
              if (!r.isValidDate(n[t])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
              e.twoDSeriesX.push(r.parseDate(n[t]));
            } else e.twoDSeriesX.push(n[t]);
          }
        }, l = 0; l < t.length; l++) {
          if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[l].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
          if ("rangeBar" !== a.chart.type && "rangeArea" !== a.chart.type && "rangeBar" !== t[l].type && "rangeArea" !== t[l].type || (s.isRangeData = !0, this.handleRangeData(t, l)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, l) : this.isFormatXY() && this.handleFormatXY(t, l), "candlestick" !== a.chart.type && "candlestick" !== t[l].type || this.handleCandleStickData(t, l), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), l !== this.activeSeriesIndex || this.fallbackToCategory || (s.isXNumeric = !0);else {
            "datetime" === a.xaxis.type ? (s.isXNumeric = !0, o(), s.seriesX.push(this.twoDSeriesX)) : "numeric" === a.xaxis.type && (s.isXNumeric = !0, n.length > 0 && (this.twoDSeriesX = n, s.seriesX.push(this.twoDSeriesX))), s.labels.push(this.twoDSeriesX);
            var h = t[l].data.map(function (t) {
              return f.parseNumber(t);
            });
            s.series.push(h);
          }
          s.seriesZ.push(this.threeDSeries), void 0 !== t[l].name ? s.seriesNames.push(t[l].name) : s.seriesNames.push("series-" + parseInt(l + 1, 10)), void 0 !== t[l].color ? s.seriesColors.push(t[l].color) : s.seriesColors.push(void 0);
        }

        return this.w;
      }
    }, {
      key: "parseDataNonAxisCharts",
      value: function value(t) {
        var e = this.w.globals,
            i = this.w.config;
        e.series = t.slice(), e.seriesNames = i.labels.slice();

        for (var a = 0; a < e.series.length; a++) {
          void 0 === e.seriesNames[a] && e.seriesNames.push("series-" + (a + 1));
        }

        return this.w;
      }
    }, {
      key: "handleExternalLabelsData",
      value: function value(t) {
        var e = this.w.config,
            i = this.w.globals;
        if (e.xaxis.categories.length > 0) i.labels = e.xaxis.categories;else if (e.labels.length > 0) i.labels = e.labels.slice();else if (this.fallbackToCategory) {
          if (i.labels = i.labels[0], i.seriesRangeBarTimeline.length && (i.seriesRangeBarTimeline.map(function (t) {
            t.forEach(function (t) {
              i.labels.indexOf(t.x) < 0 && t.x && i.labels.push(t.x);
            });
          }), i.labels = i.labels.filter(function (t, e, i) {
            return i.indexOf(t) === e;
          })), e.xaxis.convertedCatToNumeric) new H(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t);
        } else this._generateExternalLabels(t);
      }
    }, {
      key: "_generateExternalLabels",
      value: function value(t) {
        var e = this.w.globals,
            i = this.w.config,
            a = [];

        if (e.axisCharts) {
          if (e.series.length > 0) for (var s = 0; s < e.series[e.maxValsInArrayIndex].length; s++) {
            a.push(s + 1);
          }
          e.seriesX = [];

          for (var r = 0; r < t.length; r++) {
            e.seriesX.push(a);
          }

          e.isXNumeric = !0;
        }

        if (0 === a.length) {
          a = e.axisCharts ? [] : e.series.map(function (t, e) {
            return e + 1;
          });

          for (var n = 0; n < t.length; n++) {
            e.seriesX.push(a);
          }
        }

        e.labels = a, i.xaxis.convertedCatToNumeric && (e.categoryLabels = a.map(function (t) {
          return i.xaxis.labels.formatter(t);
        })), e.noLabelsProvided = !0;
      }
    }, {
      key: "parseData",
      value: function value(t) {
        var e = this.w,
            i = e.config,
            a = e.globals;

        if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a.axisCharts ? this.parseDataAxisCharts(t) : this.parseDataNonAxisCharts(t), this.coreUtils.getLargestSeries(), "bar" === i.chart.type && i.chart.stacked) {
          var s = new X(this.ctx);
          a.series = s.setNullSeriesToZeroValues(a.series);
        }

        this.coreUtils.getSeriesTotals(), a.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a.dataFormatXNumeric || a.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(t);

        for (var r = this.coreUtils.getCategoryLabels(a.labels), n = 0; n < r.length; n++) {
          if (Array.isArray(r[n])) {
            a.isMultiLineX = !0;
            break;
          }
        }
      }
    }, {
      key: "excludeCollapsedSeriesInYAxis",
      value: function value() {
        var t = this,
            e = this.w;
        e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map(function (i, a) {
          if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return i.index;
        });
      }
    }]), t;
  }(),
      V = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.tooltipKeyFormat = "dd MMM";
    }

    return a(t, [{
      key: "xLabelFormat",
      value: function value(t, e, i) {
        var a = this.w;

        if ("datetime" === a.config.xaxis.type && void 0 === a.config.xaxis.labels.formatter && void 0 === a.config.tooltip.x.formatter) {
          var s = new D(this.ctx);
          return s.formatDate(s.getDate(e), a.config.tooltip.x.format);
        }

        return t(e, i);
      }
    }, {
      key: "defaultGeneralFormatter",
      value: function value(t) {
        return Array.isArray(t) ? t.map(function (t) {
          return t;
        }) : t;
      }
    }, {
      key: "defaultYFormatter",
      value: function value(t, e, i) {
        var a = this.w;
        return f.isNumber(t) && (t = 0 !== a.globals.yValueDecimal ? t.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : a.globals.yValueDecimal) : a.globals.maxYArr[i] - a.globals.minYArr[i] < 10 ? t.toFixed(1) : t.toFixed(0)), t;
      }
    }, {
      key: "setLabelFormatters",
      value: function value() {
        var t = this,
            e = this.w;
        return e.globals.xLabelFormatter = function (e) {
          return t.defaultGeneralFormatter(e);
        }, e.globals.xaxisTooltipFormatter = function (e) {
          return t.defaultGeneralFormatter(e);
        }, e.globals.ttKeyFormatter = function (e) {
          return t.defaultGeneralFormatter(e);
        }, e.globals.ttZFormatter = function (t) {
          return t;
        }, e.globals.legendFormatter = function (e) {
          return t.defaultGeneralFormatter(e);
        }, void 0 !== e.config.xaxis.labels.formatter ? e.globals.xLabelFormatter = e.config.xaxis.labels.formatter : e.globals.xLabelFormatter = function (t) {
          if (f.isNumber(t)) {
            if (!e.config.xaxis.convertedCatToNumeric && "numeric" === e.config.xaxis.type && e.globals.dataPoints < 50) return t.toFixed(1);
            if (e.globals.isBarHorizontal) if (e.globals.maxY - e.globals.minYArr < 4) return t.toFixed(1);
            return t.toFixed(0);
          }

          return t;
        }, "function" == typeof e.config.tooltip.x.formatter ? e.globals.ttKeyFormatter = e.config.tooltip.x.formatter : e.globals.ttKeyFormatter = e.globals.xLabelFormatter, "function" == typeof e.config.xaxis.tooltip.formatter && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), (Array.isArray(e.config.tooltip.y) || void 0 !== e.config.tooltip.y.formatter) && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach(function (i, a) {
          void 0 !== i.labels.formatter ? e.globals.yLabelFormatters[a] = i.labels.formatter : e.globals.yLabelFormatters[a] = function (s) {
            return e.globals.xyCharts ? Array.isArray(s) ? s.map(function (e) {
              return t.defaultYFormatter(e, i, a);
            }) : t.defaultYFormatter(s, i, a) : s;
          };
        }), e.globals;
      }
    }, {
      key: "heatmapLabelFormatters",
      value: function value() {
        var t = this.w;

        if ("heatmap" === t.config.chart.type) {
          t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
          var e = t.globals.seriesNames.reduce(function (t, e) {
            return t.length > e.length ? t : e;
          }, 0);
          t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e;
        }
      }
    }]), t;
  }(),
      G = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "getLabel",
      value: function value(t, e, i, a) {
        var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [],
            r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px",
            n = this.w,
            o = void 0 === t[a] ? "" : t[a],
            l = o,
            h = n.globals.xLabelFormatter,
            c = n.config.xaxis.labels.formatter,
            d = !1,
            g = new V(this.ctx),
            u = o;
        l = g.xLabelFormat(h, o, u), void 0 !== c && (l = c(o, t[a], a));

        var f = function f(t) {
          var i = null;
          return e.forEach(function (t) {
            "month" === t.unit ? i = "year" : "day" === t.unit ? i = "month" : "hour" === t.unit ? i = "day" : "minute" === t.unit && (i = "hour");
          }), i === t;
        };

        e.length > 0 ? (d = f(e[a].unit), i = e[a].position, l = e[a].value) : "datetime" === n.config.xaxis.type && void 0 === c && (l = ""), void 0 === l && (l = ""), l = Array.isArray(l) ? l : l.toString();
        var p = new b(this.ctx),
            x = {};
        return x = n.globals.rotateXLabels ? p.getTextRects(l, parseInt(r, 10), null, "rotate(".concat(n.config.xaxis.labels.rotate, " 0 0)"), !1) : p.getTextRects(l, parseInt(r, 10)), !Array.isArray(l) && (0 === l.indexOf("NaN") || 0 === l.toLowerCase().indexOf("invalid") || l.toLowerCase().indexOf("infinity") >= 0 || s.indexOf(l) >= 0 && !n.config.xaxis.labels.showDuplicates && "hours" !== this.ctx.timeScale.tickInterval && "minutes" !== this.ctx.timeScale.tickInterval) && (l = ""), {
          x: i,
          text: l,
          textRect: x,
          isBold: d
        };
      }
    }, {
      key: "checkForOverflowingLabels",
      value: function value(t, e, i, a, s) {
        var r = this.w;

        if (0 === t && r.globals.skipFirstTimelinelabel && (e.text = ""), t === i - 1 && r.globals.skipLastTimelinelabel && (e.text = ""), r.config.xaxis.labels.hideOverlappingLabels && a.length > 0) {
          var n = s[s.length - 1];
          e.x < n.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + n.x && (e.text = "");
        }

        return e;
      }
    }, {
      key: "checkForReversedLabels",
      value: function value(t, e) {
        var i = this.w;
        return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e;
      }
    }, {
      key: "isYAxisHidden",
      value: function value(t) {
        var e = this.w,
            i = new y(this.ctx);
        return !e.config.yaxis[t].show || !e.config.yaxis[t].showForNullSeries && i.isSeriesNull(t) && -1 === e.globals.collapsedSeriesIndices.indexOf(t);
      }
    }, {
      key: "drawYAxisTicks",
      value: function value(t, e, i, a, s, r, n) {
        var o = this.w,
            l = new b(this.ctx),
            h = o.globals.translateY;

        if (a.show && e > 0) {
          !0 === o.config.yaxis[s].opposite && (t += a.width);

          for (var c = e; c >= 0; c--) {
            var d = h + e / 10 + o.config.yaxis[s].labels.offsetY - 1;
            o.globals.isBarHorizontal && (d = r * c), "heatmap" === o.config.chart.type && (d += r / 2);
            var g = l.drawLine(t + i.offsetX - a.width + a.offsetX, d + a.offsetY, t + i.offsetX + a.offsetX, d + a.offsetY, a.color);
            n.add(g), h += r;
          }
        }
      }
    }]), t;
  }(),
      _ = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "fixSvgStringForIe11",
      value: function value(t) {
        if (!f.isIE11()) return t;
        var e = 0,
            i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function (t) {
          return 2 === ++e ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"' : t;
        });
        return i = (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
      }
    }, {
      key: "getSvgString",
      value: function value() {
        var t = this.w.globals.dom.Paper.svg();
        return this.fixSvgStringForIe11(t);
      }
    }, {
      key: "cleanup",
      value: function value() {
        var t = this.w,
            e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
            i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
            a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
        Array.prototype.forEach.call(a, function (t) {
          t.setAttribute("width", 0);
        }), e && e[0] && (e[0].setAttribute("x", -500), e[0].setAttribute("x1", -500), e[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100));
      }
    }, {
      key: "svgUrl",
      value: function value() {
        this.cleanup();
        var t = this.getSvgString(),
            e = new Blob([t], {
          type: "image/svg+xml;charset=utf-8"
        });
        return URL.createObjectURL(e);
      }
    }, {
      key: "dataURI",
      value: function value() {
        var t = this;
        return new Promise(function (e) {
          var i = t.w;
          t.cleanup();
          var a = document.createElement("canvas");
          a.width = i.globals.svgWidth, a.height = parseInt(i.globals.dom.elWrap.style.height, 10);
          var s = "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background,
              r = a.getContext("2d");
          r.fillStyle = s, r.fillRect(0, 0, a.width, a.height);
          var n = t.getSvgString();

          if (window.canvg && f.isIE11()) {
            var o = window.canvg.Canvg.fromString(r, n, {
              ignoreClear: !0,
              ignoreDimensions: !0
            });
            o.start();
            var l = a.msToBlob();
            o.stop(), e({
              blob: l
            });
          } else {
            var h = "data:image/svg+xml," + encodeURIComponent(n),
                c = new Image();
            c.crossOrigin = "anonymous", c.onload = function () {
              if (r.drawImage(c, 0, 0), a.msToBlob) {
                var t = a.msToBlob();
                e({
                  blob: t
                });
              } else {
                var i = a.toDataURL("image/png");
                e({
                  imgURI: i
                });
              }
            }, c.src = h;
          }
        });
      }
    }, {
      key: "exportToSVG",
      value: function value() {
        this.triggerDownload(this.svgUrl(), null, ".svg");
      }
    }, {
      key: "exportToPng",
      value: function value() {
        var t = this;
        this.dataURI().then(function (e) {
          var i = e.imgURI,
              a = e.blob;
          a ? navigator.msSaveOrOpenBlob(a, t.w.globals.chartID + ".png") : t.triggerDownload(i, null, ".png");
        });
      }
    }, {
      key: "exportToCSV",
      value: function value(t) {
        var e = this,
            i = t.series,
            a = t.columnDelimiter,
            s = t.lineDelimiter,
            r = void 0 === s ? "\n" : s,
            n = this.w,
            o = [],
            l = [],
            h = "data:text/csv;charset=utf-8,",
            c = new B(this.ctx),
            d = new G(this.ctx),
            g = function g(t) {
          var i = "";

          if (n.globals.axisCharts) {
            if ("category" === n.config.xaxis.type || n.config.xaxis.convertedCatToNumeric) if (n.globals.isBarHorizontal) {
              var a = n.globals.yLabelFormatters[0],
                  s = new X(e.ctx).getActiveConfigSeriesIndex();
              i = a(n.globals.labels[t], {
                seriesIndex: s,
                dataPointIndex: t,
                w: n
              });
            } else i = d.getLabel(n.globals.labels, n.globals.timescaleLabels, 0, t).text;
            "datetime" === n.config.xaxis.type && (n.config.xaxis.categories.length ? i = n.config.xaxis.categories[t] : n.config.labels.length && (i = n.config.labels[t]));
          } else i = n.config.labels[t];

          return i;
        };

        o.push(n.config.chart.toolbar.export.csv.headerCategory), i.map(function (t, e) {
          n.globals.axisCharts && o.push(t.name ? t.name : "series-".concat(e));
        }), n.globals.axisCharts || (o.push(n.config.chart.toolbar.export.csv.headerValue), l.push(o.join(a))), i.map(function (t, e) {
          n.globals.axisCharts ? function (t, e) {
            if (o.length && 0 === e && l.push(o.join(a)), t.data && t.data.length) for (var s = 0; s < t.data.length; s++) {
              o = [];
              var r = g(s);

              if (r || (c.isFormatXY() ? r = i[e].data[s].x : c.isFormat2DArray() && (r = i[e].data[s] ? i[e].data[s][0] : "")), 0 === e) {
                o.push((d = r, "datetime" === n.config.xaxis.type && String(d).length >= 10 ? n.config.chart.toolbar.export.csv.dateFormatter(r) : r));

                for (var h = 0; h < n.globals.series.length; h++) {
                  o.push(n.globals.series[h][s]);
                }
              }

              ("candlestick" === n.config.chart.type || t.type && "candlestick" === t.type) && (o.pop(), o.push(n.globals.seriesCandleO[e][s]), o.push(n.globals.seriesCandleH[e][s]), o.push(n.globals.seriesCandleL[e][s]), o.push(n.globals.seriesCandleC[e][s])), "rangeBar" === n.config.chart.type && (o.pop(), o.push(n.globals.seriesRangeStart[e][s]), o.push(n.globals.seriesRangeEnd[e][s])), o.length && l.push(o.join(a));
            }
            var d;
          }(t, e) : ((o = []).push(n.globals.labels[e]), o.push(n.globals.series[e]), l.push(o.join(a)));
        }), h += l.join(r), this.triggerDownload(encodeURI(h), n.config.chart.toolbar.export.csv.filename, ".csv");
      }
    }, {
      key: "triggerDownload",
      value: function value(t, e, i) {
        var a = document.createElement("a");
        a.href = t, a.download = (e || this.w.globals.chartID) + i, document.body.appendChild(a), a.click(), document.body.removeChild(a);
      }
    }]), t;
  }(),
      j = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
      var a = this.w;
      this.axesUtils = new G(i), this.xaxisLabels = a.globals.labels.slice(), a.globals.timescaleLabels.length > 0 && !a.globals.isBarHorizontal && (this.xaxisLabels = a.globals.timescaleLabels.slice()), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === a.config.xaxis.position ? this.offY = 0 : this.offY = a.globals.gridHeight + 1, this.offY = this.offY + a.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === a.config.chart.type && a.config.plotOptions.bar.horizontal, this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.xaxisBorderWidth = a.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = a.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = a.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = a.config.xaxis.axisBorder.height, this.yaxis = a.config.yaxis[0];
    }

    return a(t, [{
      key: "drawXaxis",
      value: function value() {
        var t,
            e = this,
            i = this.w,
            a = new b(this.ctx),
            s = a.group({
          class: "apexcharts-xaxis",
          transform: "translate(".concat(i.config.xaxis.offsetX, ", ").concat(i.config.xaxis.offsetY, ")")
        }),
            r = a.group({
          class: "apexcharts-xaxis-texts-g",
          transform: "translate(".concat(i.globals.translateXAxisX, ", ").concat(i.globals.translateXAxisY, ")")
        });
        s.add(r);

        for (var n = i.globals.padHorizontal, o = [], l = 0; l < this.xaxisLabels.length; l++) {
          o.push(this.xaxisLabels[l]);
        }

        var h = o.length;

        if (i.globals.isXNumeric) {
          var c = h > 1 ? h - 1 : h;
          t = i.globals.gridWidth / c, n = n + t / 2 + i.config.xaxis.labels.offsetX;
        } else t = i.globals.gridWidth / o.length, n = n + t + i.config.xaxis.labels.offsetX;

        if (i.config.xaxis.labels.show) for (var d = function d(s) {
          var l = n - t / 2 + i.config.xaxis.labels.offsetX;
          0 === s && 1 === h && t / 2 === n && 1 === i.globals.dataPoints && (l = i.globals.gridWidth / 2);
          var c = e.axesUtils.getLabel(o, i.globals.timescaleLabels, l, s, e.drawnLabels, e.xaxisFontSize),
              d = 28;
          i.globals.rotateXLabels && (d = 22);
          (c = e.axesUtils.checkForOverflowingLabels(s, c, h, e.drawnLabels, e.drawnLabelsRects)).text && i.globals.xaxisLabelsCount++;
          var g = a.drawText({
            x: c.x,
            y: e.offY + i.config.xaxis.labels.offsetY + d - ("top" === i.config.xaxis.position ? i.globals.xAxisHeight + i.config.xaxis.axisTicks.height - 2 : 0),
            text: c.text,
            textAnchor: "middle",
            fontWeight: c.isBold ? 600 : i.config.xaxis.labels.style.fontWeight,
            fontSize: e.xaxisFontSize,
            fontFamily: e.xaxisFontFamily,
            foreColor: Array.isArray(e.xaxisForeColors) ? i.config.xaxis.convertedCatToNumeric ? e.xaxisForeColors[i.globals.minX + s - 1] : e.xaxisForeColors[s] : e.xaxisForeColors,
            isPlainText: !1,
            cssClass: "apexcharts-xaxis-label " + i.config.xaxis.labels.style.cssClass
          });
          r.add(g);
          var u = document.createElementNS(i.globals.SVGNS, "title");
          u.textContent = Array.isArray(c.text) ? c.text.join(" ") : c.text, g.node.appendChild(u), "" !== c.text && (e.drawnLabels.push(c.text), e.drawnLabelsRects.push(c)), n += t;
        }, g = 0; g <= h - 1; g++) {
          d(g);
        }

        if (void 0 !== i.config.xaxis.title.text) {
          var u = a.group({
            class: "apexcharts-xaxis-title"
          }),
              f = a.drawText({
            x: i.globals.gridWidth / 2 + i.config.xaxis.title.offsetX,
            y: this.offY - parseFloat(this.xaxisFontSize) + i.globals.xAxisLabelsHeight + i.config.xaxis.title.offsetY,
            text: i.config.xaxis.title.text,
            textAnchor: "middle",
            fontSize: i.config.xaxis.title.style.fontSize,
            fontFamily: i.config.xaxis.title.style.fontFamily,
            fontWeight: i.config.xaxis.title.style.fontWeight,
            foreColor: i.config.xaxis.title.style.color,
            cssClass: "apexcharts-xaxis-title-text " + i.config.xaxis.title.style.cssClass
          });
          u.add(f), s.add(u);
        }

        if (i.config.xaxis.axisBorder.show) {
          var p = i.globals.barPadForNumericAxis,
              x = a.drawLine(i.globals.padHorizontal + i.config.xaxis.axisBorder.offsetX - p, this.offY, this.xaxisBorderWidth + p, this.offY, i.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
          s.add(x);
        }

        return s;
      }
    }, {
      key: "drawXaxisInversed",
      value: function value(t) {
        var e,
            i,
            a = this.w,
            s = new b(this.ctx),
            r = a.config.yaxis[0].opposite ? a.globals.translateYAxisX[t] : 0,
            n = s.group({
          class: "apexcharts-yaxis apexcharts-xaxis-inversed",
          rel: t
        }),
            o = s.group({
          class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
          transform: "translate(" + r + ", 0)"
        });
        n.add(o);
        var l = [];
        if (a.config.yaxis[t].show) for (var h = 0; h < this.xaxisLabels.length; h++) {
          l.push(this.xaxisLabels[h]);
        }
        i = -(e = a.globals.gridHeight / l.length) / 2.2;
        var c = a.globals.yLabelFormatters[0],
            d = a.config.yaxis[0].labels;
        if (d.show) for (var g = 0; g <= l.length - 1; g++) {
          var u = void 0 === l[g] ? "" : l[g];
          u = c(u, {
            seriesIndex: t,
            dataPointIndex: g,
            w: a
          });
          var f = 0;
          Array.isArray(u) && (f = u.length / 2 * parseInt(d.style.fontSize, 10));
          var p = s.drawText({
            x: d.offsetX - 15,
            y: i + e + d.offsetY - f,
            text: u,
            textAnchor: this.yaxis.opposite ? "start" : "end",
            foreColor: Array.isArray(d.style.colors) ? d.style.colors[g] : d.style.colors,
            fontSize: d.style.fontSize,
            fontFamily: d.style.fontFamily,
            fontWeight: d.style.fontWeight,
            isPlainText: !1,
            cssClass: "apexcharts-yaxis-label " + d.style.cssClass
          });
          o.add(p);
          var x = document.createElementNS(a.globals.SVGNS, "title");

          if (x.textContent = u.text, p.node.appendChild(x), 0 !== a.config.yaxis[t].labels.rotate) {
            var m = s.rotateAroundCenter(p.node);
            p.node.setAttribute("transform", "rotate(".concat(a.config.yaxis[t].labels.rotate, " 0 ").concat(m.y, ")"));
          }

          i += e;
        }

        if (void 0 !== a.config.yaxis[0].title.text) {
          var v = s.group({
            class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
            transform: "translate(" + r + ", 0)"
          }),
              y = s.drawText({
            x: 0,
            y: a.globals.gridHeight / 2,
            text: a.config.yaxis[0].title.text,
            textAnchor: "middle",
            foreColor: a.config.yaxis[0].title.style.color,
            fontSize: a.config.yaxis[0].title.style.fontSize,
            fontWeight: a.config.yaxis[0].title.style.fontWeight,
            fontFamily: a.config.yaxis[0].title.style.fontFamily,
            cssClass: "apexcharts-yaxis-title-text " + a.config.yaxis[0].title.style.cssClass
          });
          v.add(y), n.add(v);
        }

        var w = 0;
        this.isCategoryBarHorizontal && a.config.yaxis[0].opposite && (w = a.globals.gridWidth);
        var k = a.config.xaxis.axisBorder;

        if (k.show) {
          var A = s.drawLine(a.globals.padHorizontal + k.offsetX + w, 1 + k.offsetY, a.globals.padHorizontal + k.offsetX + w, a.globals.gridHeight + k.offsetY, k.color, 0);
          n.add(A);
        }

        return a.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(w, l.length, a.config.yaxis[0].axisBorder, a.config.yaxis[0].axisTicks, 0, e, n), n;
      }
    }, {
      key: "drawXaxisTicks",
      value: function value(t, e) {
        var i = this.w,
            a = t;

        if (!(t < 0 || t - 2 > i.globals.gridWidth)) {
          var s = this.offY + i.config.xaxis.axisTicks.offsetY,
              r = s + i.config.xaxis.axisTicks.height;

          if ("top" === i.config.xaxis.position && (r = s - i.config.xaxis.axisTicks.height), i.config.xaxis.axisTicks.show) {
            var n = new b(this.ctx).drawLine(t + i.config.xaxis.axisTicks.offsetX, s + i.config.xaxis.offsetY, a + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color);
            e.add(n), n.node.classList.add("apexcharts-xaxis-tick");
          }
        }
      }
    }, {
      key: "getXAxisTicksPositions",
      value: function value() {
        var t = this.w,
            e = [],
            i = this.xaxisLabels.length,
            a = t.globals.padHorizontal;
        if (t.globals.timescaleLabels.length > 0) for (var s = 0; s < i; s++) {
          a = this.xaxisLabels[s].position, e.push(a);
        } else for (var r = i, n = 0; n < r; n++) {
          var o = r;
          t.globals.isXNumeric && "bar" !== t.config.chart.type && (o -= 1), a += t.globals.gridWidth / o, e.push(a);
        }
        return e;
      }
    }, {
      key: "xAxisLabelCorrections",
      value: function value() {
        var t = this.w,
            e = new b(this.ctx),
            i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
            a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text"),
            s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
            r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
        if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways) for (var n = 0; n < a.length; n++) {
          var o = e.rotateAroundCenter(a[n]);
          o.y = o.y - 1, o.x = o.x + 1, a[n].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")), a[n].setAttribute("text-anchor", "end");
          i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
          var l = a[n].childNodes;
          t.config.xaxis.labels.trim && Array.prototype.forEach.call(l, function (i) {
            e.placeTextWithEllipsis(i, i.textContent, t.config.xaxis.labels.maxHeight - ("bottom" === t.config.legend.position ? 20 : 10));
          });
        } else !function () {
          for (var i = t.globals.gridWidth / (t.globals.labels.length + 1), s = 0; s < a.length; s++) {
            var r = a[s].childNodes;
            t.config.xaxis.labels.trim && "datetime" !== t.config.xaxis.type && Array.prototype.forEach.call(r, function (t) {
              e.placeTextWithEllipsis(t, t.textContent, i);
            });
          }
        }();

        if (s.length > 0) {
          var h = s[s.length - 1].getBBox(),
              c = s[0].getBBox();
          h.x < -20 && s[s.length - 1].parentNode.removeChild(s[s.length - 1]), c.x + c.width > t.globals.gridWidth && !t.globals.isBarHorizontal && s[0].parentNode.removeChild(s[0]);

          for (var d = 0; d < r.length; d++) {
            e.placeTextWithEllipsis(r[d], r[d].textContent, t.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) - 20);
          }
        }
      }
    }]), t;
  }(),
      U = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
      var a = this.w;
      this.xaxisLabels = a.globals.labels.slice(), this.axesUtils = new G(i), this.isTimelineBar = "datetime" === a.config.xaxis.type && a.globals.seriesRangeBarTimeline.length, a.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a.globals.timescaleLabels.slice());
    }

    return a(t, [{
      key: "drawGridArea",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
            e = this.w,
            i = new b(this.ctx);
        null === t && (t = i.group({
          class: "apexcharts-grid"
        }));
        var a = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, "transparent"),
            s = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, "transparent");
        return t.add(s), t.add(a), t;
      }
    }, {
      key: "drawGrid",
      value: function value() {
        var t = null;
        return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t;
      }
    }, {
      key: "createGridMask",
      value: function value() {
        var t = this.w,
            e = t.globals,
            i = new b(this.ctx),
            a = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;

        if (Array.isArray(t.config.stroke.width)) {
          var s = 0;
          t.config.stroke.width.forEach(function (t) {
            s = Math.max(s, t);
          }), a = s;
        }

        e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid));
        var r = t.config.chart.type,
            n = 0,
            o = 0;
        ("bar" === r || "rangeBar" === r || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (n = t.config.grid.padding.left, o = t.config.grid.padding.right, e.barPadForNumericAxis > n && (n = e.barPadForNumericAxis, o = e.barPadForNumericAxis)), e.dom.elGridRect = i.drawRect(-a / 2 - n - 2, -a / 2, e.gridWidth + a + o + n + 4, e.gridHeight + a, 0, "#fff"), new y(this).getLargestMarkerSize();
        var l = t.globals.markers.largestSize + 1;
        e.dom.elGridRectMarker = i.drawRect(2 * -l, 2 * -l, e.gridWidth + 4 * l, e.gridHeight + 4 * l, 0, "#fff"), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
        var h = e.dom.baseEl.querySelector("defs");
        h.appendChild(e.dom.elGridRectMask), h.appendChild(e.dom.elGridRectMarkerMask);
      }
    }, {
      key: "_drawGridLines",
      value: function value(t) {
        var e = t.i,
            i = t.x1,
            a = t.y1,
            s = t.x2,
            r = t.y2,
            n = t.xCount,
            o = t.parent,
            l = this.w;
        0 === e && l.globals.skipFirstTimelinelabel || e === n - 1 && l.globals.skipLastTimelinelabel && !l.config.xaxis.labels.formatter || "radar" === l.config.chart.type || (l.config.grid.xaxis.lines.show && this._drawGridLine({
          x1: i,
          y1: a,
          x2: s,
          y2: r,
          parent: o
        }), new j(this.ctx).drawXaxisTicks(i, this.elg));
      }
    }, {
      key: "_drawGridLine",
      value: function value(t) {
        var e = t.x1,
            i = t.y1,
            a = t.x2,
            s = t.y2,
            r = t.parent,
            n = this.w,
            o = r.node.classList.contains("apexcharts-gridlines-horizontal"),
            l = n.config.grid.strokeDashArray,
            h = n.globals.barPadForNumericAxis,
            c = new b(this).drawLine(e - (o ? h : 0), i, a + (o ? h : 0), s, n.config.grid.borderColor, l);
        c.node.classList.add("apexcharts-gridline"), r.add(c);
      }
    }, {
      key: "_drawGridBandRect",
      value: function value(t) {
        var e = t.c,
            i = t.x1,
            a = t.y1,
            s = t.x2,
            r = t.y2,
            n = t.type,
            o = this.w,
            l = new b(this.ctx),
            h = o.globals.barPadForNumericAxis;

        if ("column" !== n || "datetime" !== o.config.xaxis.type) {
          var c = o.config.grid[n].colors[e],
              d = l.drawRect(i - ("row" === n ? h : 0), a, s + ("row" === n ? 2 * h : 0), r, 0, c, o.config.grid[n].opacity);
          this.elg.add(d), d.attr("clip-path", "url(#gridRectMask".concat(o.globals.cuid, ")")), d.node.classList.add("apexcharts-grid-".concat(n));
        }
      }
    }, {
      key: "_drawXYLines",
      value: function value(t) {
        var e = this,
            i = t.xCount,
            a = t.tickAmount,
            s = this.w;

        if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show) {
          var r = s.globals.padHorizontal,
              n = s.globals.gridHeight;
          s.globals.timescaleLabels.length ? function (t) {
            for (var a = t.xC, s = t.x1, r = t.y1, n = t.x2, o = t.y2, l = 0; l < a; l++) {
              s = e.xaxisLabels[l].position, n = e.xaxisLabels[l].position, e._drawGridLines({
                i: l,
                x1: s,
                y1: r,
                x2: n,
                y2: o,
                xCount: i,
                parent: e.elgridLinesV
              });
            }
          }({
            xC: i,
            x1: r,
            y1: 0,
            x2: void 0,
            y2: n
          }) : (s.globals.isXNumeric && (i = s.globals.xAxisScale.result.length), s.config.xaxis.convertedCatToNumeric && (i = s.globals.xaxisLabelsCount), function (t) {
            for (var a = t.xC, r = t.x1, n = t.y1, o = t.x2, l = t.y2, h = 0; h < a + (s.globals.isXNumeric ? 0 : 1); h++) {
              0 === h && 1 === a && 1 === s.globals.dataPoints && (o = r = s.globals.gridWidth / 2), e._drawGridLines({
                i: h,
                x1: r,
                y1: n,
                x2: o,
                y2: l,
                xCount: i,
                parent: e.elgridLinesV
              }), o = r += s.globals.gridWidth / (s.globals.isXNumeric ? a - 1 : a);
            }
          }({
            xC: i,
            x1: r,
            y1: 0,
            x2: void 0,
            y2: n
          }));
        }

        if (s.config.grid.yaxis.lines.show) {
          var o = 0,
              l = 0,
              h = s.globals.gridWidth,
              c = a + 1;
          this.isTimelineBar && (c = s.globals.labels.length);

          for (var d = 0; d < c + (this.isTimelineBar ? 1 : 0); d++) {
            this._drawGridLine({
              x1: 0,
              y1: o,
              x2: h,
              y2: l,
              parent: this.elgridLinesH
            }), l = o += s.globals.gridHeight / (this.isTimelineBar ? c : a);
          }
        }
      }
    }, {
      key: "_drawInvertedXYLines",
      value: function value(t) {
        var e = t.xCount,
            i = this.w;
        if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) for (var a, s = i.globals.padHorizontal, r = i.globals.gridHeight, n = 0; n < e + 1; n++) {
          i.config.grid.xaxis.lines.show && this._drawGridLine({
            x1: s,
            y1: 0,
            x2: a,
            y2: r,
            parent: this.elgridLinesV
          }), new j(this.ctx).drawXaxisTicks(s, this.elg), a = s = s + i.globals.gridWidth / e + .3;
        }
        if (i.config.grid.yaxis.lines.show) for (var o = 0, l = 0, h = i.globals.gridWidth, c = 0; c < i.globals.dataPoints + 1; c++) {
          this._drawGridLine({
            x1: 0,
            y1: o,
            x2: h,
            y2: l,
            parent: this.elgridLinesH
          }), l = o += i.globals.gridHeight / i.globals.dataPoints;
        }
      }
    }, {
      key: "renderGrid",
      value: function value() {
        var t = this.w,
            e = new b(this.ctx);
        this.elg = e.group({
          class: "apexcharts-grid"
        }), this.elgridLinesH = e.group({
          class: "apexcharts-gridlines-horizontal"
        }), this.elgridLinesV = e.group({
          class: "apexcharts-gridlines-vertical"
        }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide());

        for (var i, a = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, s = 0; s < t.globals.series.length && (void 0 !== t.globals.yAxisScale[s] && (a = t.globals.yAxisScale[s].result.length - 1), !(a > 2)); s++) {
        }

        return !t.globals.isBarHorizontal || this.isTimelineBar ? (i = this.xaxisLabels.length, this.isTimelineBar && (a = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (i = t.config.xaxis.tickAmount)), this._drawXYLines({
          xCount: i,
          tickAmount: a
        })) : (i = a, a = t.globals.xTickAmount, this._drawInvertedXYLines({
          xCount: i,
          tickAmount: a
        })), this.drawGridBands(i, a), {
          el: this.elg,
          xAxisTickWidth: t.globals.gridWidth / i
        };
      }
    }, {
      key: "drawGridBands",
      value: function value(t, e) {
        var i = this.w;
        if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0) for (var a = 0, s = i.globals.gridHeight / e, r = i.globals.gridWidth, n = 0, o = 0; n < e; n++, o++) {
          o >= i.config.grid.row.colors.length && (o = 0), this._drawGridBandRect({
            c: o,
            x1: 0,
            y1: a,
            x2: r,
            y2: s,
            type: "row"
          }), a += i.globals.gridHeight / e;
        }
        if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0) for (var l = i.globals.isBarHorizontal || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? t : t - 1, h = i.globals.padHorizontal, c = i.globals.padHorizontal + i.globals.gridWidth / l, d = i.globals.gridHeight, g = 0, u = 0; g < t; g++, u++) {
          u >= i.config.grid.column.colors.length && (u = 0), this._drawGridBandRect({
            c: u,
            x1: h,
            y1: 0,
            x2: c,
            y2: d,
            type: "column"
          }), h += i.globals.gridWidth / l;
        }
      }
    }]), t;
  }(),
      q = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "niceScale",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
            s = arguments.length > 4 ? arguments[4] : void 0,
            r = this.w;

        if ("dataPoints" === i && (i = r.globals.dataPoints - 1), t === Number.MIN_VALUE && 0 === e || !f.isNumber(t) && !f.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) {
          t = 0, e = i;
          var n = this.linearScale(t, e, i);
          return n;
        }

        t > e ? (console.warn("axis.min cannot be greater than axis.max"), e = t + .1) : t === e && (t = 0 === t ? 0 : t - .5, e = 0 === e ? 2 : e + .5);
        var o = [],
            l = Math.abs(e - t);
        l < 1 && s && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[a].type || r.globals.isRangeData) && (e *= 1.01);
        var h = i + 1;
        h < 2 ? h = 2 : h > 2 && (h -= 2);
        var c = l / h,
            d = Math.floor(f.log10(c)),
            g = Math.pow(10, d),
            u = Math.round(c / g);
        u < 1 && (u = 1);
        var p = u * g,
            x = p * Math.floor(t / p),
            b = p * Math.ceil(e / p),
            m = x;

        if (s && l > 2) {
          for (; o.push(m), !((m += p) > b);) {
          }

          return {
            result: o,
            niceMin: o[0],
            niceMax: o[o.length - 1]
          };
        }

        var v = t;
        (o = []).push(v);

        for (var y = Math.abs(e - t) / i, w = 0; w <= i; w++) {
          v += y, o.push(v);
        }

        return o[o.length - 2] >= e && o.pop(), {
          result: o,
          niceMin: o[0],
          niceMax: o[o.length - 1]
        };
      }
    }, {
      key: "linearScale",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
            a = Math.abs(e - t),
            s = a / i;
        i === Number.MAX_VALUE && (i = 10, s = 1);

        for (var r = [], n = t; i >= 0;) {
          r.push(n), n += s, i -= 1;
        }

        return {
          result: r,
          niceMin: r[0],
          niceMax: r[r.length - 1]
        };
      }
    }, {
      key: "logarithmicScale",
      value: function value(t, e, i, a) {
        (e <= 0 || e === Number.MIN_VALUE) && (e = .01);

        for (var s = Math.log(e) / Math.log(10), r = Math.log(i) / Math.log(10), n = Math.abs(i - e) / a, o = [], l = e; a >= 0;) {
          o.push(l), l += n, a -= 1;
        }

        var h = o.map(function (t, a) {
          t <= 0 && (t = .01);
          var n = (r - s) / (i - e),
              o = Math.pow(10, s + n * (t - s));
          return Math.round(o / f.roundToBase(o, 10)) * f.roundToBase(o, 10);
        });
        return 0 === h[0] && (h[0] = 1), {
          result: h,
          niceMin: h[0],
          niceMax: h[h.length - 1]
        };
      }
    }, {
      key: "setYScaleForIndex",
      value: function value(t, e, i) {
        var a = this.w.globals,
            s = this.w.config,
            r = a.isBarHorizontal ? s.xaxis : s.yaxis[t];
        void 0 === a.yAxisScale[t] && (a.yAxisScale[t] = []);
        var n = Math.abs(i - e);
        if (r.logarithmic && n <= 5 && (a.invalidLogScale = !0), r.logarithmic && n > 5) a.allSeriesCollapsed = !1, a.yAxisScale[t] = this.logarithmicScale(t, e, i, r.tickAmount ? r.tickAmount : Math.floor(Math.log10(i)));else if (i !== -Number.MAX_VALUE && f.isNumber(i)) {
          if (a.allSeriesCollapsed = !1, void 0 === r.min && void 0 === r.max || r.forceNiceScale) {
            var o = void 0 === s.yaxis[t].max && void 0 === s.yaxis[t].min || s.yaxis[t].forceNiceScale;
            a.yAxisScale[t] = this.niceScale(e, i, r.tickAmount ? r.tickAmount : n < 5 && n > 1 ? n + 1 : 5, t, o);
          } else a.yAxisScale[t] = this.linearScale(e, i, r.tickAmount);
        } else a.yAxisScale[t] = this.linearScale(0, 5, 5);
      }
    }, {
      key: "setXScale",
      value: function value(t, e) {
        var i = this.w,
            a = i.globals,
            s = i.config.xaxis,
            r = Math.abs(e - t);
        return e !== -Number.MAX_VALUE && f.isNumber(e) ? a.xAxisScale = this.niceScale(t, e, s.tickAmount ? s.tickAmount : r < 5 && r > 1 ? r + 1 : 5, 0) : a.xAxisScale = this.linearScale(0, 5, 5), a.xAxisScale;
      }
    }, {
      key: "setMultipleYScales",
      value: function value() {
        var t = this,
            e = this.w.globals,
            i = this.w.config,
            a = e.minYArr.concat([]),
            s = e.maxYArr.concat([]),
            r = [];
        i.yaxis.forEach(function (e, n) {
          var o = n;
          i.series.forEach(function (t, i) {
            t.name === e.seriesName && (o = i, n !== i ? r.push({
              index: i,
              similarIndex: n,
              alreadyExists: !0
            }) : r.push({
              index: i
            }));
          });
          var l = a[o],
              h = s[o];
          t.setYScaleForIndex(n, l, h);
        }), this.sameScaleInMultipleAxes(a, s, r);
      }
    }, {
      key: "sameScaleInMultipleAxes",
      value: function value(t, e, i) {
        var a = this,
            s = this.w.config,
            r = this.w.globals,
            n = [];
        i.forEach(function (t) {
          t.alreadyExists && (void 0 === n[t.index] && (n[t.index] = []), n[t.index].push(t.index), n[t.index].push(t.similarIndex));
        }), r.yAxisSameScaleIndices = n, n.forEach(function (t, e) {
          n.forEach(function (i, a) {
            var s, r;
            e !== a && (s = t, r = i, s.filter(function (t) {
              return -1 !== r.indexOf(t);
            })).length > 0 && (n[e] = n[e].concat(n[a]));
          });
        });
        var o = n.map(function (t) {
          return t.filter(function (e, i) {
            return t.indexOf(e) === i;
          });
        }).map(function (t) {
          return t.sort();
        });
        n = n.filter(function (t) {
          return !!t;
        });
        var l = o.slice(),
            h = l.map(function (t) {
          return JSON.stringify(t);
        });
        l = l.filter(function (t, e) {
          return h.indexOf(JSON.stringify(t)) === e;
        });
        var c = [],
            d = [];
        t.forEach(function (t, i) {
          l.forEach(function (a, s) {
            a.indexOf(i) > -1 && (void 0 === c[s] && (c[s] = [], d[s] = []), c[s].push({
              key: i,
              value: t
            }), d[s].push({
              key: i,
              value: e[i]
            }));
          });
        });
        var g = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
            u = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
        c.forEach(function (t, e) {
          t.forEach(function (t, i) {
            g[e] = Math.min(t.value, g[e]);
          });
        }), d.forEach(function (t, e) {
          t.forEach(function (t, i) {
            u[e] = Math.max(t.value, u[e]);
          });
        }), t.forEach(function (t, e) {
          d.forEach(function (t, i) {
            var n = g[i],
                o = u[i];
            s.chart.stacked && (o = 0, t.forEach(function (t, e) {
              t.value !== -Number.MAX_VALUE && (o += t.value), n !== Number.MIN_VALUE && (n += c[i][e].value);
            })), t.forEach(function (i, l) {
              t[l].key === e && (void 0 !== s.yaxis[e].min && (n = "function" == typeof s.yaxis[e].min ? s.yaxis[e].min(r.minY) : s.yaxis[e].min), void 0 !== s.yaxis[e].max && (o = "function" == typeof s.yaxis[e].max ? s.yaxis[e].max(r.maxY) : s.yaxis[e].max), a.setYScaleForIndex(e, n, o));
            });
          });
        });
      }
    }, {
      key: "autoScaleY",
      value: function value(t, e, i) {
        t || (t = this);
        var a = t.w;
        if (a.globals.isMultipleYAxis || a.globals.collapsedSeries.length) return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e;
        var s = a.globals.seriesX[0],
            r = a.config.chart.stacked;
        return e.forEach(function (t, n) {
          for (var o = 0, l = 0; l < s.length; l++) {
            if (s[l] >= i.xaxis.min) {
              o = l;
              break;
            }
          }

          var h,
              c,
              d = a.globals.minYArr[n],
              g = a.globals.maxYArr[n],
              u = a.globals.stackedSeriesTotals;
          a.globals.series.forEach(function (n, l) {
            var f = n[o];
            r ? (f = u[o], h = c = f, u.forEach(function (t, e) {
              s[e] <= i.xaxis.max && s[e] >= i.xaxis.min && (t > c && null !== t && (c = t), n[e] < h && null !== n[e] && (h = n[e]));
            })) : (h = c = f, n.forEach(function (t, e) {
              if (s[e] <= i.xaxis.max && s[e] >= i.xaxis.min) {
                var r = t,
                    n = t;
                a.globals.series.forEach(function (i, a) {
                  null !== t && (r = Math.min(i[e], r), n = Math.max(i[e], n));
                }), n > c && null !== n && (c = n), r < h && null !== r && (h = r);
              }
            })), void 0 === h && void 0 === c && (h = d, c = g), (c *= c < 0 ? .9 : 1.1) < 0 && c < g && (c = g), (h *= h < 0 ? 1.1 : .9) < 0 && h > d && (h = d), e.length > 1 ? (e[l].min = void 0 === t.min ? h : t.min, e[l].max = void 0 === t.max ? c : t.max) : (e[0].min = void 0 === t.min ? h : t.min, e[0].max = void 0 === t.max ? c : t.max);
          });
        }), e;
      }
    }]), t;
  }(),
      Z = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.scales = new q(i);
    }

    return a(t, [{
      key: "init",
      value: function value() {
        this.setYRange(), this.setXRange(), this.setZRange();
      }
    }, {
      key: "getMinYMaxY",
      value: function value(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
            s = this.w.config,
            r = this.w.globals,
            n = -Number.MAX_VALUE,
            o = Number.MIN_VALUE;
        null === a && (a = t + 1);
        var l = r.series,
            h = l,
            c = l;
        "candlestick" === s.chart.type ? (h = r.seriesCandleL, c = r.seriesCandleH) : r.isRangeData && (h = r.seriesRangeStart, c = r.seriesRangeEnd);

        for (var d = t; d < a; d++) {
          r.dataPoints = Math.max(r.dataPoints, l[d].length);

          for (var g = 0; g < r.series[d].length; g++) {
            var u = l[d][g];
            null !== u && f.isNumber(u) ? (n = Math.max(n, c[d][g]), e = Math.min(e, h[d][g]), i = Math.max(i, h[d][g]), "candlestick" === this.w.config.chart.type && (n = Math.max(n, r.seriesCandleO[d][g]), n = Math.max(n, r.seriesCandleH[d][g]), n = Math.max(n, r.seriesCandleL[d][g]), i = n = Math.max(n, r.seriesCandleC[d][g])), f.isFloat(u) && (u = f.noExponents(u), r.yValueDecimal = Math.max(r.yValueDecimal, u.toString().split(".")[1].length)), o > h[d][g] && h[d][g] < 0 && (o = h[d][g])) : r.hasNullValues = !0;
          }
        }

        return "rangeBar" === s.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && "datetime" === s.xaxis.type && (o = e), "bar" === s.chart.type && (o < 0 && n < 0 && (n = 0), o === Number.MIN_VALUE && (o = 0)), {
          minY: o,
          maxY: n,
          lowestY: e,
          highestY: i
        };
      }
    }, {
      key: "setYRange",
      value: function value() {
        var t = this.w.globals,
            e = this.w.config;
        t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
        var i = Number.MAX_VALUE;
        if (t.isMultipleYAxis) for (var a = 0; a < t.series.length; a++) {
          var s = this.getMinYMaxY(a, i, null, a + 1);
          t.minYArr.push(s.minY), t.maxYArr.push(s.maxY), i = s.lowestY;
        }
        var r = this.getMinYMaxY(0, i, null, t.series.length);

        if (t.minY = r.minY, t.maxY = r.maxY, i = r.lowestY, e.chart.stacked && this._setStackedMinMax(), ("line" === e.chart.type || "area" === e.chart.type || "candlestick" === e.chart.type || "rangeBar" === e.chart.type && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) {
          var n = t.maxY - i;
          i >= 0 && i <= 10 && (n = 0), t.minY = i - 5 * n / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * n / 100;
        }

        if (e.yaxis.forEach(function (e, i) {
          void 0 !== e.max && ("number" == typeof e.max ? t.maxYArr[i] = e.max : "function" == typeof e.max && (t.maxYArr[i] = e.max(t.maxY)), t.maxY = t.maxYArr[i]), void 0 !== e.min && ("number" == typeof e.min ? t.minYArr[i] = e.min : "function" == typeof e.min && (t.minYArr[i] = e.min(t.minY)), t.minY = t.minYArr[i]);
        }), t.isBarHorizontal) {
          ["min", "max"].forEach(function (i) {
            void 0 !== e.xaxis[i] && "number" == typeof e.xaxis[i] && ("min" === i ? t.minY = e.xaxis[i] : t.maxY = e.xaxis[i]);
          });
        }

        return t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(function (e, i) {
          t.minYArr[i] = e.niceMin, t.maxYArr[i] = e.niceMax;
        })) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
          minY: t.minY,
          maxY: t.maxY,
          minYArr: t.minYArr,
          maxYArr: t.maxYArr
        };
      }
    }, {
      key: "setXRange",
      value: function value() {
        var t = this.w.globals,
            e = this.w.config,
            i = "numeric" === e.xaxis.type || "datetime" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;

        if (t.isXNumeric && function () {
          for (var e = 0; e < t.series.length; e++) {
            if (t.labels[e]) for (var i = 0; i < t.labels[e].length; i++) {
              null !== t.labels[e][i] && f.isNumber(t.labels[e][i]) && (t.maxX = Math.max(t.maxX, t.labels[e][i]), t.initialMaxX = Math.max(t.maxX, t.labels[e][i]), t.minX = Math.min(t.minX, t.labels[e][i]), t.initialMinX = Math.min(t.minX, t.labels[e][i]));
            }
          }
        }(), t.noLabelsProvided && 0 === e.xaxis.categories.length && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
          var a;
          if (void 0 === e.xaxis.tickAmount ? (a = Math.round(t.svgWidth / 150), "numeric" === e.xaxis.type && t.dataPoints < 30 && (a = t.dataPoints - 1), a > t.dataPoints && 0 !== t.dataPoints && (a = t.dataPoints - 1)) : "dataPoints" === e.xaxis.tickAmount ? (t.series.length > 1 && (a = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (a = t.maxX - t.minX - 1)) : a = e.xaxis.tickAmount, t.xTickAmount = a, void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE) {
            if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
              for (var s = [], r = t.minX - 1; r < t.maxX; r++) {
                s.push(r + 1);
              }

              t.xAxisScale = {
                result: s,
                niceMin: s[0],
                niceMax: s[s.length - 1]
              };
            } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
          } else t.xAxisScale = this.scales.linearScale(1, a, a), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, a - 1), t.seriesX = t.labels.slice());
          i && (t.labels = t.xAxisScale.result.slice());
        }

        return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
          minX: t.minX,
          maxX: t.maxX
        };
      }
    }, {
      key: "setZRange",
      value: function value() {
        var t = this.w.globals;
        if (t.isDataXYZ) for (var e = 0; e < t.series.length; e++) {
          if (void 0 !== t.seriesZ[e]) for (var i = 0; i < t.seriesZ[e].length; i++) {
            null !== t.seriesZ[e][i] && f.isNumber(t.seriesZ[e][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i]), t.minZ = Math.min(t.minZ, t.seriesZ[e][i]));
          }
        }
      }
    }, {
      key: "_handleSingleDataPoint",
      value: function value() {
        var t = this.w.globals,
            e = this.w.config;

        if (t.minX === t.maxX) {
          var i = new D(this.ctx);

          if ("datetime" === e.xaxis.type) {
            var a = i.getDate(t.minX);
            a.setUTCDate(a.getDate() - 2), t.minX = new Date(a).getTime();
            var s = i.getDate(t.maxX);
            s.setUTCDate(s.getDate() + 2), t.maxX = new Date(s).getTime();
          } else ("numeric" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX);
        }
      }
    }, {
      key: "_getMinXDiff",
      value: function value() {
        var t = this.w.globals;
        t.isXNumeric && t.seriesX.forEach(function (e, i) {
          1 === e.length && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
          var a = e.slice();
          a.sort(function (t, e) {
            return t - e;
          }), a.forEach(function (e, a) {
            if (a > 0) {
              var s = e - t.seriesX[i][a - 1];
              s > 0 && (t.minXDiff = Math.min(s, t.minXDiff));
            }
          }), 1 === t.dataPoints && t.minXDiff === Number.MAX_VALUE && (t.minXDiff = .5);
        });
      }
    }, {
      key: "_setStackedMinMax",
      value: function value() {
        var t = this.w.globals,
            e = [],
            i = [];
        if (t.series.length) for (var a = 0; a < t.series[t.maxValsInArrayIndex].length; a++) {
          for (var s = 0, r = 0, n = 0; n < t.series.length; n++) {
            null !== t.series[n][a] && f.isNumber(t.series[n][a]) && (t.series[n][a] > 0 ? s = s + parseFloat(t.series[n][a]) + 1e-4 : r += parseFloat(t.series[n][a])), n === t.series.length - 1 && (e.push(s), i.push(r));
          }
        }

        for (var o = 0; o < e.length; o++) {
          t.maxY = Math.max(t.maxY, e[o]), t.minY = Math.min(t.minY, i[o]);
        }
      }
    }]), t;
  }(),
      $ = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
      var a = this.w;
      this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.axisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === a.config.chart.type && a.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === a.config.xaxis.position && (this.xAxisoffX = a.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new G(i);
    }

    return a(t, [{
      key: "drawYaxis",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = e.config.yaxis[t].labels.style,
            s = a.fontSize,
            r = a.fontFamily,
            n = a.fontWeight,
            o = i.group({
          class: "apexcharts-yaxis",
          rel: t,
          transform: "translate(" + e.globals.translateYAxisX[t] + ", 0)"
        });
        if (this.axesUtils.isYAxisHidden(t)) return o;
        var l = i.group({
          class: "apexcharts-yaxis-texts-g"
        });
        o.add(l);
        var h = e.globals.yAxisScale[t].result.length - 1,
            c = e.globals.gridHeight / h,
            d = e.globals.translateY,
            g = e.globals.yLabelFormatters[t],
            u = e.globals.yAxisScale[t].result.slice();
        u = this.axesUtils.checkForReversedLabels(t, u);
        var f = "";
        if (e.config.yaxis[t].labels.show) for (var p = function p(o) {
          var p = u[o];
          p = g(p, o);
          var x = e.config.yaxis[t].labels.padding;
          e.config.yaxis[t].opposite && 0 !== e.config.yaxis.length && (x *= -1);
          var b = i.drawText({
            x: x,
            y: d + h / 10 + e.config.yaxis[t].labels.offsetY + 1,
            text: p,
            textAnchor: e.config.yaxis[t].opposite ? "start" : "end",
            fontSize: s,
            fontFamily: r,
            fontWeight: n,
            foreColor: Array.isArray(a.colors) ? a.colors[o] : a.colors,
            isPlainText: !1,
            cssClass: "apexcharts-yaxis-label " + a.cssClass
          });

          if (o === h && (f = b), l.add(b), 0 !== e.config.yaxis[t].labels.rotate) {
            var m = i.rotateAroundCenter(f.node),
                v = i.rotateAroundCenter(b.node);
            b.node.setAttribute("transform", "rotate(".concat(e.config.yaxis[t].labels.rotate, " ").concat(m.x, " ").concat(v.y, ")"));
          }

          d += c;
        }, x = h; x >= 0; x--) {
          p(x);
        }

        if (void 0 !== e.config.yaxis[t].title.text) {
          var m = i.group({
            class: "apexcharts-yaxis-title"
          }),
              v = 0;
          e.config.yaxis[t].opposite && (v = e.globals.translateYAxisX[t]);
          var y = i.drawText({
            x: v,
            y: e.globals.gridHeight / 2 + e.globals.translateY + e.config.yaxis[t].title.offsetY,
            text: e.config.yaxis[t].title.text,
            textAnchor: "end",
            foreColor: e.config.yaxis[t].title.style.color,
            fontSize: e.config.yaxis[t].title.style.fontSize,
            fontWeight: e.config.yaxis[t].title.style.fontWeight,
            fontFamily: e.config.yaxis[t].title.style.fontFamily,
            cssClass: "apexcharts-yaxis-title-text " + e.config.yaxis[t].title.style.cssClass
          });
          m.add(y), o.add(m);
        }

        var w = e.config.yaxis[t].axisBorder,
            k = 31 + w.offsetX;

        if (e.config.yaxis[t].opposite && (k = -31 - w.offsetX), w.show) {
          var A = i.drawLine(k, e.globals.translateY + w.offsetY - 2, k, e.globals.gridHeight + e.globals.translateY + w.offsetY + 2, w.color, 0, w.width);
          o.add(A);
        }

        return e.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(k, h, w, e.config.yaxis[t].axisTicks, t, c, o), o;
      }
    }, {
      key: "drawYaxisInversed",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = i.group({
          class: "apexcharts-xaxis apexcharts-yaxis-inversed"
        }),
            s = i.group({
          class: "apexcharts-xaxis-texts-g",
          transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
        });
        a.add(s);
        var r = e.globals.yAxisScale[t].result.length - 1,
            n = e.globals.gridWidth / r + .1,
            o = n + e.config.xaxis.labels.offsetX,
            l = e.globals.xLabelFormatter,
            h = e.globals.yAxisScale[t].result.slice(),
            c = e.globals.timescaleLabels;
        c.length > 0 && (this.xaxisLabels = c.slice(), r = (h = c.slice()).length), h = this.axesUtils.checkForReversedLabels(t, h);
        var d = c.length;
        if (e.config.xaxis.labels.show) for (var g = d ? 0 : r; d ? g < d : g >= 0; d ? g++ : g--) {
          var u = h[g];
          u = l(u, g);
          var f = e.globals.gridWidth + e.globals.padHorizontal - (o - n + e.config.xaxis.labels.offsetX);

          if (c.length) {
            var p = this.axesUtils.getLabel(h, c, f, g, this.drawnLabels, this.xaxisFontSize);
            f = p.x, u = p.text, this.drawnLabels.push(p.text), 0 === g && e.globals.skipFirstTimelinelabel && (u = ""), g === h.length - 1 && e.globals.skipLastTimelinelabel && (u = "");
          }

          var x = i.drawText({
            x: f,
            y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30 - ("top" === e.config.xaxis.position ? e.globals.xAxisHeight + e.config.xaxis.axisTicks.height - 2 : 0),
            text: u,
            textAnchor: "middle",
            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors,
            fontSize: this.xaxisFontSize,
            fontFamily: this.xaxisFontFamily,
            fontWeight: e.config.xaxis.labels.style.fontWeight,
            isPlainText: !1,
            cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass
          });
          s.add(x), x.tspan(u);
          var m = document.createElementNS(e.globals.SVGNS, "title");
          m.textContent = u, x.node.appendChild(m), o += n;
        }
        return this.inversedYAxisTitleText(a), this.inversedYAxisBorder(a), a;
      }
    }, {
      key: "inversedYAxisBorder",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = e.config.xaxis.axisBorder;

        if (a.show) {
          var s = 0;
          "bar" === e.config.chart.type && e.globals.isXNumeric && (s -= 15);
          var r = i.drawLine(e.globals.padHorizontal + s + a.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height);
          t.add(r);
        }
      }
    }, {
      key: "inversedYAxisTitleText",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx);

        if (void 0 !== e.config.xaxis.title.text) {
          var a = i.group({
            class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
          }),
              s = i.drawText({
            x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
            y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + e.config.xaxis.title.offsetY + 20,
            text: e.config.xaxis.title.text,
            textAnchor: "middle",
            fontSize: e.config.xaxis.title.style.fontSize,
            fontFamily: e.config.xaxis.title.style.fontFamily,
            fontWeight: e.config.xaxis.title.style.fontWeight,
            cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
          });
          a.add(s), t.add(a);
        }
      }
    }, {
      key: "yAxisTitleRotate",
      value: function value(t, e) {
        var i = this.w,
            a = new b(this.ctx),
            s = {
          width: 0,
          height: 0
        },
            r = {
          width: 0,
          height: 0
        },
            n = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
        null !== n && (s = n.getBoundingClientRect());
        var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));

        if (null !== o && (r = o.getBoundingClientRect()), null !== o) {
          var l = this.xPaddingForYAxisTitle(t, s, r, e);
          o.setAttribute("x", l.xPos - (e ? 10 : 0));
        }

        if (null !== o) {
          var h = a.rotateAroundCenter(o);
          o.setAttribute("transform", "rotate(".concat(e ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ").concat(h.x, " ").concat(h.y, ")"));
        }
      }
    }, {
      key: "xPaddingForYAxisTitle",
      value: function value(t, e, i, a) {
        var s = this.w,
            r = 0,
            n = 0,
            o = 10;
        return void 0 === s.config.yaxis[t].title.text || t < 0 ? {
          xPos: n,
          padd: 0
        } : (a ? (n = e.width + s.config.yaxis[t].title.offsetX + i.width / 2 + o / 2, 0 === (r += 1) && (n -= o / 2)) : (n = -1 * e.width + s.config.yaxis[t].title.offsetX + o / 2 + i.width / 2, s.globals.isBarHorizontal && (o = 25, n = -1 * e.width - s.config.yaxis[t].title.offsetX - o)), {
          xPos: n,
          padd: o
        });
      }
    }, {
      key: "setYAxisXPosition",
      value: function value(t, e) {
        var i = this.w,
            a = 0,
            s = 0,
            r = 18,
            n = 1;
        i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(function (o, l) {
          var h = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || 0 === t[l].width,
              c = t[l].width + e[l].width;
          o.opposite ? i.globals.isBarHorizontal ? (s = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[l] = s - o.labels.offsetX) : (s = i.globals.gridWidth + i.globals.translateX + n, h || (n = n + c + 20), i.globals.translateYAxisX[l] = s - o.labels.offsetX + 20) : (a = i.globals.translateX - r, h || (r = r + c + 20), i.globals.translateYAxisX[l] = a + o.labels.offsetX);
        });
      }
    }, {
      key: "setYAxisTextAlignments",
      value: function value() {
        var t = this.w,
            e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
        (e = f.listToArray(e)).forEach(function (e, i) {
          var a = t.config.yaxis[i];

          if (void 0 !== a.labels.align) {
            var s = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")),
                r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"));
            r = f.listToArray(r);
            var n = s.getBoundingClientRect();
            "left" === a.labels.align ? (r.forEach(function (t, e) {
              t.setAttribute("text-anchor", "start");
            }), a.opposite || s.setAttribute("transform", "translate(-".concat(n.width, ", 0)"))) : "center" === a.labels.align ? (r.forEach(function (t, e) {
              t.setAttribute("text-anchor", "middle");
            }), s.setAttribute("transform", "translate(".concat(n.width / 2 * (a.opposite ? 1 : -1), ", 0)"))) : "right" === a.labels.align && (r.forEach(function (t, e) {
              t.setAttribute("text-anchor", "end");
            }), a.opposite && s.setAttribute("transform", "translate(".concat(n.width, ", 0)")));
          }
        });
      }
    }]), t;
  }(),
      J = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.documentEvent = f.bind(this.documentEvent, this);
    }

    return a(t, [{
      key: "addEventListener",
      value: function value(t, e) {
        var i = this.w;
        i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : i.globals.events[t] = [e];
      }
    }, {
      key: "removeEventListener",
      value: function value(t, e) {
        var i = this.w;

        if (i.globals.events.hasOwnProperty(t)) {
          var a = i.globals.events[t].indexOf(e);
          -1 !== a && i.globals.events[t].splice(a, 1);
        }
      }
    }, {
      key: "fireEvent",
      value: function value(t, e) {
        var i = this.w;

        if (i.globals.events.hasOwnProperty(t)) {
          e && e.length || (e = []);

          for (var a = i.globals.events[t], s = a.length, r = 0; r < s; r++) {
            a[r].apply(null, e);
          }
        }
      }
    }, {
      key: "setupEventHandlers",
      value: function value() {
        var t = this,
            e = this.w,
            i = this.ctx,
            a = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
        this.ctx.eventList.forEach(function (t) {
          a.addEventListener(t, function (t) {
            var a = Object.assign({}, e, {
              seriesIndex: e.globals.capturedSeriesIndex,
              dataPointIndex: e.globals.capturedDataPointIndex
            });
            "mousemove" === t.type || "touchmove" === t.type ? "function" == typeof e.config.chart.events.mouseMove && e.config.chart.events.mouseMove(t, i, a) : ("mouseup" === t.type && 1 === t.which || "touchend" === t.type) && ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(t, i, a), i.ctx.events.fireEvent("click", [t, i, a]));
          }, {
            capture: !1,
            passive: !0
          });
        }), this.ctx.eventList.forEach(function (i) {
          e.globals.dom.baseEl.addEventListener(i, t.documentEvent);
        }), this.ctx.core.setupBrushHandler();
      }
    }, {
      key: "documentEvent",
      value: function value(t) {
        var e = this.w,
            i = t.target.className;

        if ("click" === t.type) {
          var a = e.globals.dom.baseEl.querySelector(".apexcharts-menu");
          a && a.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && a.classList.remove("apexcharts-menu-open");
        }

        e.globals.clientX = "touchmove" === t.type ? t.touches[0].clientX : t.clientX, e.globals.clientY = "touchmove" === t.type ? t.touches[0].clientY : t.clientY;
      }
    }]), t;
  }(),
      Q = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "setCurrentLocaleValues",
      value: function value(t) {
        var e = this.w.config.chart.locales;
        window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
        var i = e.filter(function (e) {
          return e.name === t;
        })[0];
        if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
        var a = f.extend(C, i);
        this.w.globals.locale = a.options;
      }
    }]), t;
  }(),
      K = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "drawAxis",
      value: function value(t, e) {
        var i,
            a,
            s = this.w.globals,
            r = this.w.config,
            n = new j(this.ctx),
            o = new $(this.ctx);
        s.axisCharts && "radar" !== t && (s.isBarHorizontal ? (a = o.drawYaxisInversed(0), i = n.drawXaxisInversed(0), s.dom.elGraphical.add(i), s.dom.elGraphical.add(a)) : (i = n.drawXaxis(), s.dom.elGraphical.add(i), r.yaxis.map(function (t, e) {
          -1 === s.ignoreYAxisIndexes.indexOf(e) && (a = o.drawYaxis(e), s.dom.Paper.add(a));
        })));
        r.yaxis.map(function (t, e) {
          -1 === s.ignoreYAxisIndexes.indexOf(e) && o.yAxisTitleRotate(e, t.opposite);
        });
      }
    }]), t;
  }(),
      tt = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "drawXCrosshairs",
      value: function value() {
        var t = this.w,
            e = new b(this.ctx),
            i = new p(this.ctx),
            a = t.config.xaxis.crosshairs.fill.gradient,
            s = t.config.xaxis.crosshairs.dropShadow,
            r = t.config.xaxis.crosshairs.fill.type,
            n = a.colorFrom,
            o = a.colorTo,
            l = a.opacityFrom,
            h = a.opacityTo,
            c = a.stops,
            d = s.enabled,
            g = s.left,
            u = s.top,
            x = s.blur,
            m = s.color,
            v = s.opacity,
            y = t.config.xaxis.crosshairs.fill.color;

        if (t.config.xaxis.crosshairs.show) {
          "gradient" === r && (y = e.drawGradient("vertical", n, o, l, h, null, c, null));
          var w = e.drawRect();
          1 === t.config.xaxis.crosshairs.width && (w = e.drawLine()), w.attr({
            class: "apexcharts-xcrosshairs",
            x: 0,
            y: 0,
            y2: t.globals.gridHeight,
            width: f.isNumber(t.config.xaxis.crosshairs.width) ? t.config.xaxis.crosshairs.width : 0,
            height: t.globals.gridHeight,
            fill: y,
            filter: "none",
            "fill-opacity": t.config.xaxis.crosshairs.opacity,
            stroke: t.config.xaxis.crosshairs.stroke.color,
            "stroke-width": t.config.xaxis.crosshairs.stroke.width,
            "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray
          }), d && (w = i.dropShadow(w, {
            left: g,
            top: u,
            blur: x,
            color: m,
            opacity: v
          })), t.globals.dom.elGraphical.add(w);
        }
      }
    }, {
      key: "drawYCrosshairs",
      value: function value() {
        var t = this.w,
            e = new b(this.ctx),
            i = t.config.yaxis[0].crosshairs,
            a = t.globals.barPadForNumericAxis;

        if (t.config.yaxis[0].crosshairs.show) {
          var s = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
          s.attr({
            class: "apexcharts-ycrosshairs"
          }), t.globals.dom.elGraphical.add(s);
        }

        var r = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, i.stroke.color, 0, 0);
        r.attr({
          class: "apexcharts-ycrosshairs-hidden"
        }), t.globals.dom.elGraphical.add(r);
      }
    }]), t;
  }(),
      et = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "checkResponsiveConfig",
      value: function value(t) {
        var e = this,
            i = this.w,
            a = i.config;

        if (0 !== a.responsive.length) {
          var s = a.responsive.slice();
          s.sort(function (t, e) {
            return t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0;
          }).reverse();

          var r = new N({}),
              n = function n() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                a = s[0].breakpoint,
                n = window.innerWidth > 0 ? window.innerWidth : screen.width;

            if (n > a) {
              var o = y.extendArrayProps(r, i.globals.initialConfig, i);
              t = f.extend(o, t), t = f.extend(i.config, t), e.overrideResponsiveOptions(t);
            } else for (var l = 0; l < s.length; l++) {
              n < s[l].breakpoint && (t = y.extendArrayProps(r, s[l].options, i), t = f.extend(i.config, t), e.overrideResponsiveOptions(t));
            }
          };

          if (t) {
            var o = y.extendArrayProps(r, t, i);
            o = f.extend(i.config, o), n(o = f.extend(o, t));
          } else n({});
        }
      }
    }, {
      key: "overrideResponsiveOptions",
      value: function value(t) {
        var e = new N(t).init({
          responsiveOverride: !0
        });
        this.w.config = e;
      }
    }]), t;
  }(),
      it = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.colors = [], this.w = i.w;
      var a = this.w;
      this.isColorFn = !1, this.isBarDistributed = a.config.plotOptions.bar.distributed && ("bar" === a.config.chart.type || "rangeBar" === a.config.chart.type);
    }

    return a(t, [{
      key: "init",
      value: function value() {
        this.setDefaultColors();
      }
    }, {
      key: "setDefaultColors",
      value: function value() {
        var t = this,
            e = this.w,
            i = new f();

        if (e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode)), void 0 === e.config.colors ? e.globals.colors = this.predefined() : (e.globals.colors = e.config.colors, Array.isArray(e.config.colors) && e.config.colors.length > 0 && "function" == typeof e.config.colors[0] && (e.globals.colors = e.config.series.map(function (i, a) {
          var s = e.config.colors[a];
          return s || (s = e.config.colors[0]), "function" == typeof s ? (t.isColorFn = !0, s({
            value: e.globals.axisCharts ? e.globals.series[a][0] ? e.globals.series[a][0] : 0 : e.globals.series[a],
            seriesIndex: a,
            dataPointIndex: a,
            w: e
          })) : s;
        }))), e.globals.seriesColors.map(function (t, i) {
          t && (e.globals.colors[i] = t);
        }), e.config.theme.monochrome.enabled) {
          var a = [],
              s = e.globals.series.length;
          this.isBarDistributed && (s = e.globals.series[0].length * e.globals.series.length);

          for (var r = e.config.theme.monochrome.color, n = 1 / (s / e.config.theme.monochrome.shadeIntensity), o = e.config.theme.monochrome.shadeTo, l = 0, h = 0; h < s; h++) {
            var c = void 0;
            "dark" === o ? (c = i.shadeColor(-1 * l, r), l += n) : (c = i.shadeColor(l, r), l += n), a.push(c);
          }

          e.globals.colors = a.slice();
        }

        var d = e.globals.colors.slice();
        this.pushExtraColors(e.globals.colors);
        ["fill", "stroke"].forEach(function (i) {
          void 0 === e.config[i].colors ? e.globals[i].colors = t.isColorFn ? e.config.colors : d : e.globals[i].colors = e.config[i].colors.slice(), t.pushExtraColors(e.globals[i].colors);
        }), void 0 === e.config.dataLabels.style.colors ? e.globals.dataLabels.style.colors = d : e.globals.dataLabels.style.colors = e.config.dataLabels.style.colors.slice(), this.pushExtraColors(e.globals.dataLabels.style.colors, 50), void 0 === e.config.plotOptions.radar.polygons.fill.colors ? e.globals.radarPolygons.fill.colors = ["dark" === e.config.theme.mode ? "#424242" : "#fff"] : e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20), void 0 === e.config.markers.colors ? e.globals.markers.colors = d : e.globals.markers.colors = e.config.markers.colors.slice(), this.pushExtraColors(e.globals.markers.colors);
      }
    }, {
      key: "pushExtraColors",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
            a = this.w,
            s = e || a.globals.series.length;
        if (null === i && (i = this.isBarDistributed || "heatmap" === a.config.chart.type && a.config.plotOptions.heatmap.colorScale.inverse), i && (s = a.globals.series[0].length * a.globals.series.length), t.length < s) for (var r = s - t.length, n = 0; n < r; n++) {
          t.push(t[n]);
        }
      }
    }, {
      key: "updateThemeOptions",
      value: function value(t) {
        t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
        var e = t.theme.mode || "light",
            i = t.theme.palette ? t.theme.palette : "dark" === e ? "palette4" : "palette1",
            a = t.chart.foreColor ? t.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
        return t.tooltip.theme = e, t.chart.foreColor = a, t.theme.palette = i, t;
      }
    }, {
      key: "predefined",
      value: function value() {
        switch (this.w.config.theme.palette) {
          case "palette1":
            this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
            break;

          case "palette2":
            this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
            break;

          case "palette3":
            this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
            break;

          case "palette4":
            this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
            break;

          case "palette5":
            this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
            break;

          case "palette6":
            this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
            break;

          case "palette7":
            this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
            break;

          case "palette8":
            this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
            break;

          case "palette9":
            this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
            break;

          case "palette10":
            this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
            break;

          default:
            this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
        }

        return this.colors;
      }
    }]), t;
  }(),
      at = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "draw",
      value: function value() {
        this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
      }
    }, {
      key: "drawTitleSubtitle",
      value: function value(t) {
        var e = this.w,
            i = "title" === t ? e.config.title : e.config.subtitle,
            a = e.globals.svgWidth / 2,
            s = i.offsetY,
            r = "middle";

        if ("left" === i.align ? (a = 10, r = "start") : "right" === i.align && (a = e.globals.svgWidth - 10, r = "end"), a += i.offsetX, s = s + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
          var n = new b(this.ctx).drawText({
            x: a,
            y: s,
            text: i.text,
            textAnchor: r,
            fontSize: i.style.fontSize,
            fontFamily: i.style.fontFamily,
            fontWeight: i.style.fontWeight,
            foreColor: i.style.color,
            opacity: 1
          });
          n.node.setAttribute("class", "apexcharts-".concat(t, "-text")), e.globals.dom.Paper.add(n);
        }
      }
    }]), t;
  }(),
      st = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.dCtx = i;
    }

    return a(t, [{
      key: "getTitleSubtitleCoords",
      value: function value(t) {
        var e = this.w,
            i = 0,
            a = 0,
            s = "title" === t ? e.config.title.floating : e.config.subtitle.floating,
            r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));

        if (null !== r && !s) {
          var n = r.getBoundingClientRect();
          i = n.width, a = e.globals.axisCharts ? n.height + 5 : n.height;
        }

        return {
          width: i,
          height: a
        };
      }
    }, {
      key: "getLegendsRect",
      value: function value() {
        var t = this.w,
            e = t.globals.dom.baseEl.querySelector(".apexcharts-legend"),
            i = Object.assign({}, f.getBoundingClientRect(e));
        return null !== e && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = {
          x: i.x,
          y: i.y,
          height: i.height,
          width: 0 === i.height ? 0 : i.width
        } : this.dCtx.lgRect = {
          x: 0,
          y: 0,
          height: 0,
          width: 0
        }, "left" !== t.config.legend.position && "right" !== t.config.legend.position || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect;
      }
    }, {
      key: "getLargestStringFromMultiArr",
      value: function value(t, e) {
        var i = t;

        if (this.w.globals.isMultiLineX) {
          var a = e.map(function (t, e) {
            return Array.isArray(t) ? t.length : 1;
          }),
              s = Math.max.apply(Math, g(a));
          i = e[a.indexOf(s)];
        }

        return i;
      }
    }]), t;
  }(),
      rt = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.dCtx = i;
    }

    return a(t, [{
      key: "getxAxisLabelsCoords",
      value: function value() {
        var t,
            e = this.w,
            i = e.globals.labels.slice();

        if (e.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) {
          var a = this.getxAxisTimeScaleLabelsCoords();
          t = {
            width: a.width,
            height: a.height
          }, e.globals.rotateXLabels = !1;
        } else {
          this.dCtx.lgWidthForSideLegends = "left" !== e.config.legend.position && "right" !== e.config.legend.position || e.config.legend.floating ? 0 : this.dCtx.lgRect.width;
          var s = e.globals.xLabelFormatter,
              r = f.getLargestStringFromArr(i),
              n = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, i);
          e.globals.isBarHorizontal && (n = r = e.globals.yAxisScale[0].result.reduce(function (t, e) {
            return t.length > e.length ? t : e;
          }, 0));
          var o = new V(this.dCtx.ctx),
              l = r;
          r = o.xLabelFormat(s, r, l), n = o.xLabelFormat(s, n, l), (e.config.xaxis.convertedCatToNumeric && void 0 === r || "" === String(r).trim()) && (n = r = "1");
          var h = new b(this.dCtx.ctx),
              c = h.getTextRects(r, e.config.xaxis.labels.style.fontSize),
              d = c;

          if (r !== n && (d = h.getTextRects(n, e.config.xaxis.labels.style.fontSize)), (t = {
            width: c.width >= d.width ? c.width : d.width,
            height: c.height >= d.height ? c.height : d.height
          }).width * i.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e.config.xaxis.labels.rotate || e.config.xaxis.labels.rotateAlways) {
            if (!e.globals.isBarHorizontal) {
              e.globals.rotateXLabels = !0;

              var g = function g(t) {
                return h.getTextRects(t, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"), !1);
              };

              c = g(r), r !== n && (d = g(n)), t.height = (c.height > d.height ? c.height : d.height) / 1.5, t.width = c.width > d.width ? c.width : d.width;
            }
          } else e.globals.rotateXLabels = !1;
        }

        return e.config.xaxis.labels.show || (t = {
          width: 0,
          height: 0
        }), {
          width: t.width,
          height: t.height
        };
      }
    }, {
      key: "getxAxisTitleCoords",
      value: function value() {
        var t = this.w,
            e = 0,
            i = 0;

        if (void 0 !== t.config.xaxis.title.text) {
          var a = new b(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
          e = a.width, i = a.height;
        }

        return {
          width: e,
          height: i
        };
      }
    }, {
      key: "getxAxisTimeScaleLabelsCoords",
      value: function value() {
        var t,
            e = this.w;
        this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
        var i = this.dCtx.timescaleLabels.map(function (t) {
          return t.value;
        }),
            a = i.reduce(function (t, e) {
          return void 0 === t ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t.length > e.length ? t : e;
        }, 0);
        return 1.05 * (t = new b(this.dCtx.ctx).getTextRects(a, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = !0), t;
      }
    }, {
      key: "additionalPaddingXLabels",
      value: function value(t) {
        var e = this,
            i = this.w,
            a = i.globals,
            s = i.config,
            r = s.xaxis.type,
            n = t.width;
        a.skipLastTimelinelabel = !1, a.skipFirstTimelinelabel = !1;

        var o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal,
            l = function l(t, o) {
          (function (t) {
            return -1 !== a.collapsedSeriesIndices.indexOf(t);
          })(o) || ("datetime" !== r && e.dCtx.gridPad.left < n / 2 - e.dCtx.yAxisWidthLeft && !a.rotateXLabels && !s.xaxis.labels.trim && (e.dCtx.xPadLeft = n / 2 + 1), function (t) {
            if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) {
              var s = e.dCtx.timescaleLabels[0],
                  o = e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + n / 1.75 - e.dCtx.yAxisWidthRight,
                  l = s.position - n / 1.75 + e.dCtx.yAxisWidthLeft;
              o > a.gridWidth && (a.skipLastTimelinelabel = !0), l < 0 && (a.skipFirstTimelinelabel = !0);
            } else "datetime" === r ? e.dCtx.gridPad.right < n && !a.rotateXLabels && (a.skipLastTimelinelabel = !0) : "datetime" !== r && e.dCtx.gridPad.right < n / 2 - e.dCtx.yAxisWidthRight && !a.rotateXLabels && ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) && (e.dCtx.xPadRight = n / 2 + 1);
          }());
        };

        s.yaxis.forEach(function (t, i) {
          o ? (e.dCtx.gridPad.left < n && (e.dCtx.xPadLeft = n / 2 + 1), e.dCtx.xPadRight = n / 2 + 1) : l(0, i);
        });
      }
    }]), t;
  }(),
      nt = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.dCtx = i;
    }

    return a(t, [{
      key: "getyAxisLabelsCoords",
      value: function value() {
        var t = this,
            e = this.w,
            i = [],
            a = 10,
            s = new G(this.dCtx.ctx);
        return e.config.yaxis.map(function (r, n) {
          var o = e.globals.yAxisScale[n];

          if (!s.isYAxisHidden(n) && r.labels.show && o.result.length) {
            var l = e.globals.yLabelFormatters[n],
                h = String(o.niceMin).length > String(o.niceMax).length ? o.niceMin : o.niceMax,
                c = l(h, {
              seriesIndex: n,
              dataPointIndex: -1,
              w: e
            }),
                d = c;

            if (void 0 !== c && 0 !== c.length || (c = h), e.globals.isBarHorizontal) {
              a = 0;
              var g = e.globals.labels.slice();
              c = l(c = f.getLargestStringFromArr(g), {
                seriesIndex: n,
                dataPointIndex: -1,
                w: e
              }), d = t.dCtx.dimHelpers.getLargestStringFromMultiArr(c, g);
            }

            var u = new b(t.dCtx.ctx),
                p = u.getTextRects(c, r.labels.style.fontSize),
                x = p;
            c !== d && (x = u.getTextRects(d, r.labels.style.fontSize)), i.push({
              width: (x.width > p.width ? x.width : p.width) + a,
              height: x.height > p.height ? x.height : p.height
            });
          } else i.push({
            width: 0,
            height: 0
          });
        }), i;
      }
    }, {
      key: "getyAxisTitleCoords",
      value: function value() {
        var t = this,
            e = this.w,
            i = [];
        return e.config.yaxis.map(function (e, a) {
          if (e.show && void 0 !== e.title.text) {
            var s = new b(t.dCtx.ctx).getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, "rotate(-90 0 0)", !1);
            i.push({
              width: s.width,
              height: s.height
            });
          } else i.push({
            width: 0,
            height: 0
          });
        }), i;
      }
    }, {
      key: "getTotalYAxisWidth",
      value: function value() {
        var t = this.w,
            e = 0,
            i = 0,
            a = 0,
            s = t.globals.yAxisScale.length > 1 ? 10 : 0,
            r = new G(this.dCtx.ctx),
            n = function n(_n, o) {
          var l = t.config.yaxis[o].floating,
              h = 0;
          _n.width > 0 && !l ? (h = _n.width + s, function (e) {
            return t.globals.ignoreYAxisIndexes.indexOf(e) > -1;
          }(o) && (h = h - _n.width - s)) : h = l || r.isYAxisHidden(o) ? 0 : 5, t.config.yaxis[o].opposite ? a += h : i += h, e += h;
        };

        return t.globals.yLabelsCoords.map(function (t, e) {
          n(t, e);
        }), t.globals.yTitleCoords.map(function (t, e) {
          n(t, e);
        }), t.globals.isBarHorizontal && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = a, e;
      }
    }]), t;
  }(),
      ot = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.dCtx = i;
    }

    return a(t, [{
      key: "gridPadForColumnsInNumericAxis",
      value: function value(t) {
        var e = this.w;
        if (e.globals.noData || e.globals.allSeriesCollapsed) return 0;
        var i = e.config.chart.type,
            a = 0,
            s = "bar" === i || "rangeBar" === i ? e.config.series.length : 1;

        if (e.globals.comboBarCount > 0 && (s = e.globals.comboBarCount), e.globals.collapsedSeries.forEach(function (t) {
          "bar" !== t.type && "rangeBar" !== t.type || (s -= 1);
        }), e.config.chart.stacked && (s = 1), ("bar" === i || "rangeBar" === i || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && s > 0) {
          var r,
              n,
              o = Math.abs(e.globals.initialMaxX - e.globals.initialMinX);
          o <= 3 && (o = e.globals.dataPoints), r = o / t, e.globals.minXDiff && e.globals.minXDiff / r > 0 && (n = e.globals.minXDiff / r), n > t / 2 && (n /= 2), (a = n / s * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (a = 1), a = a / (s > 1 ? 1 : 1.5) + 5, e.globals.barPadForNumericAxis = a;
        }

        return a;
      }
    }, {
      key: "gridPadFortitleSubtitle",
      value: function value() {
        var t = this,
            e = this.w,
            i = e.globals,
            a = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
        ["title", "subtitle"].forEach(function (i) {
          void 0 !== e.config[i].text ? a += e.config[i].margin : a += t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5;
        }), !e.config.legend.show || "bottom" !== e.config.legend.position || e.config.legend.floating || e.globals.axisCharts || (a += 10);
        var s = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
            r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
        i.gridHeight = i.gridHeight - s.height - r.height - a, i.translateY = i.translateY + s.height + r.height + a;
      }
    }, {
      key: "setGridXPosForDualYAxis",
      value: function value(t, e) {
        var i = this.w,
            a = new G(this.dCtx.ctx);
        i.config.yaxis.map(function (s, r) {
          -1 !== i.globals.ignoreYAxisIndexes.indexOf(r) || s.floating || a.isYAxisHidden(r) || (s.opposite && (i.globals.translateX = i.globals.translateX - (e[r].width + t[r].width) - parseInt(i.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
        });
      }
    }]), t;
  }(),
      lt = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new st(this), this.dimYAxis = new nt(this), this.dimXAxis = new rt(this), this.dimGrid = new ot(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }

    return a(t, [{
      key: "plotCoords",
      value: function value() {
        var t = this.w.globals;
        this.lgRect = this.dimHelpers.getLegendsRect(), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
        var e = this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth);
        t.gridWidth = t.gridWidth - 2 * e, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (e > 0 ? e + 4 : 0), t.translateY = t.translateY + this.gridPad.top;
      }
    }, {
      key: "setDimensionsForAxisCharts",
      value: function value() {
        var t = this,
            e = this.w,
            i = e.globals,
            a = this.dimYAxis.getyAxisLabelsCoords(),
            s = this.dimYAxis.getyAxisTitleCoords();
        e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map(function (t, i) {
          e.globals.yLabelsCoords.push({
            width: a[i].width,
            index: i
          }), e.globals.yTitleCoords.push({
            width: s[i].width,
            index: i
          });
        }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
        var r = this.dimXAxis.getxAxisLabelsCoords(),
            n = this.dimXAxis.getxAxisTitleCoords();
        this.conditionalChecksForAxisCoords(r, n), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + e.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + e.config.xaxis.labels.offsetX;
        var o = this.yAxisWidth,
            l = this.xAxisHeight;
        i.xAxisLabelsHeight = this.xAxisHeight, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
        var h = 10;
        ("radar" === e.config.chart.type || this.isSparkline) && (o = 0, l = i.goldenPadding), this.isSparkline && (this.lgRect = {
          height: 0,
          width: 0
        }, l = 0, o = 0, h = 0), this.dimXAxis.additionalPaddingXLabels(r);

        var c = function c() {
          i.translateX = o, i.gridHeight = i.svgHeight - t.lgRect.height - l - (t.isSparkline ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - o;
        };

        switch ("top" === e.config.xaxis.position && (h = i.xAxisHeight - e.config.xaxis.axisTicks.height - 5), e.config.legend.position) {
          case "bottom":
            i.translateY = h, c();
            break;

          case "top":
            i.translateY = this.lgRect.height + h, c();
            break;

          case "left":
            i.translateY = h, i.translateX = this.lgRect.width + o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o;
            break;

          case "right":
            i.translateY = h, i.translateX = o, i.gridHeight = i.svgHeight - l - 12, i.gridWidth = i.svgWidth - this.lgRect.width - o - 5;
            break;

          default:
            throw new Error("Legend position not supported");
        }

        this.dimGrid.setGridXPosForDualYAxis(s, a), new $(this.ctx).setYAxisXPosition(a, s);
      }
    }, {
      key: "setDimensionsForNonAxisCharts",
      value: function value() {
        var t = this.w,
            e = t.globals,
            i = t.config,
            a = 0;
        t.config.legend.show && !t.config.legend.floating && (a = 20);
        var s = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar",
            r = i.plotOptions[s].offsetY,
            n = i.plotOptions[s].offsetX;
        if (!i.legend.show || i.legend.floating) return e.gridHeight = e.svgHeight - i.grid.padding.left + i.grid.padding.right, e.gridWidth = e.gridHeight, e.translateY = r, void (e.translateX = n + (e.svgWidth - e.gridWidth) / 2);

        switch (i.legend.position) {
          case "bottom":
            e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.gridHeight, e.translateY = r - 10, e.translateX = n + (e.svgWidth - e.gridWidth) / 2;
            break;

          case "top":
            e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.gridHeight, e.translateY = this.lgRect.height + r + 10, e.translateX = n + (e.svgWidth - e.gridWidth) / 2;
            break;

          case "left":
            e.gridWidth = e.svgWidth - this.lgRect.width - a, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + this.lgRect.width + a;
            break;

          case "right":
            e.gridWidth = e.svgWidth - this.lgRect.width - a - 5, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = n + 10;
            break;

          default:
            throw new Error("Legend position not supported");
        }
      }
    }, {
      key: "conditionalChecksForAxisCoords",
      value: function value(t, e) {
        var i = this.w;
        this.xAxisHeight = (t.height + e.height) * (i.globals.isMultiLineX ? 1.2 : i.globals.LINE_HEIGHT_RATIO) + (i.globals.rotateXLabels ? 22 : 10), this.xAxisWidth = t.width, this.xAxisHeight - e.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight), i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight), i.config.xaxis.floating && (this.xAxisHeight = 0);
        var a = 0,
            s = 0;
        i.config.yaxis.forEach(function (t) {
          a += t.labels.minWidth, s += t.labels.maxWidth;
        }), this.yAxisWidth < a && (this.yAxisWidth = a), this.yAxisWidth > s && (this.yAxisWidth = s);
      }
    }]), t;
  }(),
      ht = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.lgCtx = i;
    }

    return a(t, [{
      key: "getLegendStyles",
      value: function value() {
        var t = document.createElement("style");
        t.setAttribute("type", "text/css");
        var e = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-left, .apexcharts-legend.position-top.apexcharts-align-left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-center, .apexcharts-legend.position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-right, .apexcharts-legend.position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
        return t.appendChild(e), t;
      }
    }, {
      key: "getLegendBBox",
      value: function value() {
        var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),
            e = t.width;
        return {
          clwh: t.height,
          clww: e
        };
      }
    }, {
      key: "appendToForeignObject",
      value: function value() {
        var t = this.w.globals;
        t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject");
        var e = t.dom.elLegendForeign;
        e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("width", t.svgWidth), e.setAttribute("height", t.svgHeight), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.appendChild(t.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node);
      }
    }, {
      key: "toggleDataSeries",
      value: function value(t, e) {
        var i = this,
            a = this.w;

        if (a.globals.axisCharts || "radialBar" === a.config.chart.type) {
          a.globals.resized = !0;
          var s = null,
              r = null;
          if (a.globals.risingSeries = [], a.globals.axisCharts ? (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), r = parseInt(s.getAttribute("data:realIndex"), 10)) : (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), r = parseInt(s.getAttribute("rel"), 10) - 1), e) [{
            cs: a.globals.collapsedSeries,
            csi: a.globals.collapsedSeriesIndices
          }, {
            cs: a.globals.ancillaryCollapsedSeries,
            csi: a.globals.ancillaryCollapsedSeriesIndices
          }].forEach(function (t) {
            i.riseCollapsedSeries(t.cs, t.csi, r);
          });else this.hideSeries({
            seriesEl: s,
            realIndex: r
          });
        } else {
          var n = a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")),
              o = a.config.chart.type;

          if ("pie" === o || "polarArea" === o || "donut" === o) {
            var l = a.config.plotOptions.pie.donut.labels;
            new b(this.lgCtx.ctx).pathMouseDown(n.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(n.members[0].node, l);
          }

          n.fire("click");
        }
      }
    }, {
      key: "hideSeries",
      value: function value(t) {
        var e = t.seriesEl,
            i = t.realIndex,
            a = this.w,
            s = f.clone(a.config.series);

        if (a.globals.axisCharts) {
          var r = !1;

          if (a.config.yaxis[i] && a.config.yaxis[i].show && a.config.yaxis[i].showAlways && (r = !0, a.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (a.globals.ancillaryCollapsedSeries.push({
            index: i,
            data: s[i].data.slice(),
            type: e.parentNode.className.baseVal.split("-")[1]
          }), a.globals.ancillaryCollapsedSeriesIndices.push(i))), !r) {
            a.globals.collapsedSeries.push({
              index: i,
              data: s[i].data.slice(),
              type: e.parentNode.className.baseVal.split("-")[1]
            }), a.globals.collapsedSeriesIndices.push(i);
            var n = a.globals.risingSeries.indexOf(i);
            a.globals.risingSeries.splice(n, 1);
          }
        } else a.globals.collapsedSeries.push({
          index: i,
          data: s[i]
        }), a.globals.collapsedSeriesIndices.push(i);

        for (var o = e.childNodes, l = 0; l < o.length; l++) {
          o[l].classList.contains("apexcharts-series-markers-wrap") && (o[l].classList.contains("apexcharts-hide") ? o[l].classList.remove("apexcharts-hide") : o[l].classList.add("apexcharts-hide"));
        }

        a.globals.allSeriesCollapsed = a.globals.collapsedSeries.length === a.config.series.length, s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled);
      }
    }, {
      key: "riseCollapsedSeries",
      value: function value(t, e, i) {
        var a = this.w,
            s = f.clone(a.config.series);

        if (t.length > 0) {
          for (var r = 0; r < t.length; r++) {
            t[r].index === i && (a.globals.axisCharts ? (s[i].data = t[r].data.slice(), t.splice(r, 1), e.splice(r, 1), a.globals.risingSeries.push(i)) : (s[i] = t[r].data, t.splice(r, 1), e.splice(r, 1), a.globals.risingSeries.push(i)));
          }

          s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled);
        }
      }
    }, {
      key: "_getSeriesBasedOnCollapsedState",
      value: function value(t) {
        var e = this.w;
        return e.globals.axisCharts ? t.forEach(function (i, a) {
          e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a].data = []);
        }) : t.forEach(function (i, a) {
          e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a] = 0);
        }), t;
      }
    }]), t;
  }(),
      ct = function () {
    function t(i, a) {
      e(this, t), this.ctx = i, this.w = i.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new ht(this);
    }

    return a(t, [{
      key: "init",
      value: function value() {
        var t = this.w,
            e = t.globals,
            i = t.config;

        if ((i.legend.showForSingleSeries && 1 === e.series.length || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && i.legend.show) {
          for (; e.dom.elLegendWrap.firstChild;) {
            e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
          }

          this.drawLegends(), f.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical();
        }
      }
    }, {
      key: "drawLegends",
      value: function value() {
        var t = this.w,
            e = t.config.legend.fontFamily,
            i = t.globals.seriesNames,
            a = t.globals.colors.slice();

        if ("heatmap" === t.config.chart.type) {
          var s = t.config.plotOptions.heatmap.colorScale.ranges;
          i = s.map(function (t) {
            return t.name ? t.name : t.from + " - " + t.to;
          }), a = s.map(function (t) {
            return t.color;
          });
        } else this.isBarsDistributed && (i = t.globals.labels.slice());

        for (var r = t.globals.legendFormatter, n = t.config.legend.inverseOrder, o = n ? i.length - 1 : 0; n ? o >= 0 : o <= i.length - 1; n ? o-- : o++) {
          var l = r(i[o], {
            seriesIndex: o,
            w: t
          }),
              h = !1,
              c = !1;
          if (t.globals.collapsedSeries.length > 0) for (var d = 0; d < t.globals.collapsedSeries.length; d++) {
            t.globals.collapsedSeries[d].index === o && (h = !0);
          }
          if (t.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var g = 0; g < t.globals.ancillaryCollapsedSeriesIndices.length; g++) {
            t.globals.ancillaryCollapsedSeriesIndices[g] === o && (c = !0);
          }
          var u = document.createElement("span");
          u.classList.add("apexcharts-legend-marker");
          var f = t.config.legend.markers.offsetX,
              p = t.config.legend.markers.offsetY,
              x = t.config.legend.markers.height,
              m = t.config.legend.markers.width,
              v = t.config.legend.markers.strokeWidth,
              w = t.config.legend.markers.strokeColor,
              k = t.config.legend.markers.radius,
              A = u.style;
          A.background = a[o], A.color = a[o], t.config.legend.markers.fillColors && t.config.legend.markers.fillColors[o] && (A.background = t.config.legend.markers.fillColors[o]), void 0 !== t.globals.seriesColors[o] && (A.background = t.globals.seriesColors[o], A.color = t.globals.seriesColors[o]), A.height = Array.isArray(x) ? parseFloat(x[o]) + "px" : parseFloat(x) + "px", A.width = Array.isArray(m) ? parseFloat(m[o]) + "px" : parseFloat(m) + "px", A.left = Array.isArray(f) ? f[o] : f, A.top = Array.isArray(p) ? p[o] : p, A.borderWidth = Array.isArray(v) ? v[o] : v, A.borderColor = Array.isArray(w) ? w[o] : w, A.borderRadius = Array.isArray(k) ? parseFloat(k[o]) + "px" : parseFloat(k) + "px", t.config.legend.markers.customHTML && (Array.isArray(t.config.legend.markers.customHTML) ? t.config.legend.markers.customHTML[o] && (u.innerHTML = t.config.legend.markers.customHTML[o]()) : u.innerHTML = t.config.legend.markers.customHTML()), b.setAttrs(u, {
            rel: o + 1,
            "data:collapsed": h || c
          }), (h || c) && u.classList.add("apexcharts-inactive-legend");
          var S = document.createElement("div"),
              C = document.createElement("span");
          C.classList.add("apexcharts-legend-text"), C.innerHTML = Array.isArray(l) ? l.join(" ") : l;
          var L = t.config.legend.labels.useSeriesColors ? t.globals.colors[o] : t.config.legend.labels.colors;
          L || (L = t.config.chart.foreColor), C.style.color = L, C.style.fontSize = parseFloat(t.config.legend.fontSize) + "px", C.style.fontWeight = t.config.legend.fontWeight, C.style.fontFamily = e || t.config.chart.fontFamily, b.setAttrs(C, {
            rel: o + 1,
            i: o,
            "data:default-text": encodeURIComponent(l),
            "data:collapsed": h || c
          }), S.appendChild(u), S.appendChild(C);
          var P = new y(this.ctx);
          if (!t.config.legend.showForZeroSeries) 0 === P.getSeriesTotalByIndex(o) && P.seriesHaveSameValues(o) && !P.isSeriesNull(o) && -1 === t.globals.collapsedSeriesIndices.indexOf(o) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) && S.classList.add("apexcharts-hidden-zero-series");
          t.config.legend.showForNullSeries || P.isSeriesNull(o) && -1 === t.globals.collapsedSeriesIndices.indexOf(o) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) && S.classList.add("apexcharts-hidden-null-series"), t.globals.dom.elLegendWrap.appendChild(S), t.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(t.config.legend.horizontalAlign)), t.globals.dom.elLegendWrap.classList.add("position-" + t.config.legend.position), S.classList.add("apexcharts-legend-series"), S.style.margin = "".concat(t.config.legend.itemMargin.vertical, "px ").concat(t.config.legend.itemMargin.horizontal, "px"), t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? t.config.legend.width + "px" : "", t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? t.config.legend.height + "px" : "", b.setAttrs(S, {
            rel: o + 1,
            "data:collapsed": h || c
          }), (h || c) && S.classList.add("apexcharts-inactive-legend"), t.config.legend.onItemClick.toggleDataSeries || S.classList.add("apexcharts-no-click");
        }

        "heatmap" !== t.config.chart.type && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && t.globals.dom.elWrap.addEventListener("click", this.onLegendClick, !0), t.config.legend.onItemHover.highlightDataSeries && (t.globals.dom.elWrap.addEventListener("mousemove", this.onLegendHovered, !0), t.globals.dom.elWrap.addEventListener("mouseout", this.onLegendHovered, !0));
      }
    }, {
      key: "setLegendWrapXY",
      value: function value(t, e) {
        var i = this.w,
            a = i.globals.dom.baseEl.querySelector(".apexcharts-legend"),
            s = a.getBoundingClientRect(),
            r = 0,
            n = 0;
        if ("bottom" === i.config.legend.position) n += i.globals.svgHeight - s.height / 2;else if ("top" === i.config.legend.position) {
          var o = new lt(this.ctx),
              l = o.dimHelpers.getTitleSubtitleCoords("title").height,
              h = o.dimHelpers.getTitleSubtitleCoords("subtitle").height;
          n = n + (l > 0 ? l - 10 : 0) + (h > 0 ? h - 10 : 0);
        }
        a.style.position = "absolute", r = r + t + i.config.legend.offsetX, n = n + e + i.config.legend.offsetY, a.style.left = r + "px", a.style.top = n + "px", "bottom" === i.config.legend.position ? (a.style.top = "auto", a.style.bottom = 5 - i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (a.style.left = "auto", a.style.right = 25 + i.config.legend.offsetX + "px");
        ["width", "height"].forEach(function (t) {
          a.style[t] && (a.style[t] = parseInt(i.config.legend[t], 10) + "px");
        });
      }
    }, {
      key: "legendAlignHorizontal",
      value: function value() {
        var t = this.w;
        t.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
        var e = this.legendHelpers.getLegendBBox(),
            i = new lt(this.ctx),
            a = i.dimHelpers.getTitleSubtitleCoords("title"),
            s = i.dimHelpers.getTitleSubtitleCoords("subtitle"),
            r = 0;
        "bottom" === t.config.legend.position ? r = -e.clwh / 1.8 : "top" === t.config.legend.position && (r = a.height + s.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, r);
      }
    }, {
      key: "legendAlignVertical",
      value: function value() {
        var t = this.w,
            e = this.legendHelpers.getLegendBBox(),
            i = 0;
        "left" === t.config.legend.position && (i = 20), "right" === t.config.legend.position && (i = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20);
      }
    }, {
      key: "onLegendHovered",
      value: function value(t) {
        var e = this.w,
            i = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");

        if ("heatmap" === e.config.chart.type || this.isBarsDistributed) {
          if (i) {
            var a = parseInt(t.target.getAttribute("rel"), 10) - 1;
            this.ctx.events.fireEvent("legendHover", [this.ctx, a, this.w]), new X(this.ctx).highlightRangeInSeries(t, t.target);
          }
        } else !t.target.classList.contains("apexcharts-inactive-legend") && i && new X(this.ctx).toggleSeriesOnHover(t, t.target);
      }
    }, {
      key: "onLegendClick",
      value: function value(t) {
        if (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker")) {
          var e = parseInt(t.target.getAttribute("rel"), 10) - 1,
              i = "true" === t.target.getAttribute("data:collapsed"),
              a = this.w.config.chart.events.legendClick;
          "function" == typeof a && a(this.ctx, e, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, e, this.w]);
          var s = this.w.config.legend.markers.onClick;
          "function" == typeof s && t.target.classList.contains("apexcharts-legend-marker") && (s(this.ctx, e, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, e, this.w])), this.legendHelpers.toggleDataSeries(e, i);
        }
      }
    }]), t;
  }(),
      dt = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar;
    }

    return a(t, [{
      key: "createToolbar",
      value: function value() {
        var t = this,
            e = this.w,
            i = function i() {
          return document.createElement("div");
        },
            a = i();

        if (a.setAttribute("class", "apexcharts-toolbar"), a.style.top = e.config.chart.toolbar.offsetY + "px", a.style.right = 3 - e.config.chart.toolbar.offsetX + "px", e.globals.dom.elWrap.appendChild(a), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var s = 0; s < this.t.customIcons.length; s++) {
          this.elCustomIcons.push(i());
        }

        var r = [],
            n = function n(i, a, s) {
          var n = i.toLowerCase();
          t.t[n] && e.config.chart.zoom.enabled && r.push({
            el: a,
            icon: "string" == typeof t.t[n] ? t.t[n] : s,
            title: t.localeValues[i],
            class: "apexcharts-".concat(n, "-icon")
          });
        };

        n("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), n("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');

        var o = function o(i) {
          t.t[i] && e.config.chart[i].enabled && r.push({
            el: "zoom" === i ? t.elZoom : t.elSelection,
            icon: "string" == typeof t.t[i] ? t.t[i] : "zoom" === i ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
            title: t.localeValues["zoom" === i ? "selectionZoom" : "selection"],
            class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i, "-icon")
          });
        };

        o("zoom"), o("selection"), this.t.pan && e.config.chart.zoom.enabled && r.push({
          el: this.elPan,
          icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
          title: this.localeValues.pan,
          class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
        }), n("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r.push({
          el: this.elMenuIcon,
          icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
          title: this.localeValues.menu,
          class: "apexcharts-menu-icon"
        });

        for (var l = 0; l < this.elCustomIcons.length; l++) {
          r.push({
            el: this.elCustomIcons[l],
            icon: this.t.customIcons[l].icon,
            title: this.t.customIcons[l].title,
            index: this.t.customIcons[l].index,
            class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
          });
        }

        r.forEach(function (t, e) {
          t.index && f.moveIndexInArray(r, e, t.index);
        });

        for (var h = 0; h < r.length; h++) {
          b.setAttrs(r[h].el, {
            class: r[h].class,
            title: r[h].title
          }), r[h].el.innerHTML = r[h].icon, a.appendChild(r[h].el);
        }

        this._createHamburgerMenu(a), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
      }
    }, {
      key: "_createHamburgerMenu",
      value: function value(t) {
        this.elMenuItems = [], t.appendChild(this.elMenu), b.setAttrs(this.elMenu, {
          class: "apexcharts-menu"
        });
        var e = [{
          name: "exportSVG",
          title: this.localeValues.exportToSVG
        }, {
          name: "exportPNG",
          title: this.localeValues.exportToPNG
        }, {
          name: "exportCSV",
          title: this.localeValues.exportToCSV
        }];
        this.w.globals.allSeriesHasEqualX || e.splice(2, 1);

        for (var i = 0; i < e.length; i++) {
          this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = e[i].title, b.setAttrs(this.elMenuItems[i], {
            class: "apexcharts-menu-item ".concat(e[i].name),
            title: e[i].title
          }), this.elMenu.appendChild(this.elMenuItems[i]);
        }
      }
    }, {
      key: "addToolbarEventListeners",
      value: function value() {
        var t = this;
        this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function (e) {
          e.classList.contains("exportSVG") ? e.addEventListener("click", t.handleDownload.bind(t, "svg")) : e.classList.contains("exportPNG") ? e.addEventListener("click", t.handleDownload.bind(t, "png")) : e.classList.contains("exportCSV") && e.addEventListener("click", t.handleDownload.bind(t, "csv"));
        });

        for (var e = 0; e < this.t.customIcons.length; e++) {
          this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w));
        }
      }
    }, {
      key: "toggleZoomSelection",
      value: function value(t) {
        this.ctx.getSyncedCharts().forEach(function (e) {
          e.ctx.toolbar.toggleOtherControls();
          var i = "selection" === t ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
              a = "selection" === t ? "selectionEnabled" : "zoomEnabled";
          e.w.globals[a] = !e.w.globals[a], i.classList.contains(e.ctx.toolbar.selectedClass) ? i.classList.remove(e.ctx.toolbar.selectedClass) : i.classList.add(e.ctx.toolbar.selectedClass);
        });
      }
    }, {
      key: "getToolbarIconsReference",
      value: function value() {
        var t = this.w;
        this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
      }
    }, {
      key: "enableZoomPanFromToolbar",
      value: function value(t) {
        this.toggleOtherControls(), "pan" === t ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
        var e = "pan" === t ? this.elPan : this.elZoom,
            i = "pan" === t ? this.elZoom : this.elPan;
        e && e.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
      }
    }, {
      key: "togglePanning",
      value: function value() {
        this.ctx.getSyncedCharts().forEach(function (t) {
          t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);
        });
      }
    }, {
      key: "toggleOtherControls",
      value: function value() {
        var t = this,
            e = this.w;
        e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function (e) {
          e && e.classList.remove(t.selectedClass);
        });
      }
    }, {
      key: "handleZoomIn",
      value: function value() {
        var t = this.w,
            e = (t.globals.minX + t.globals.maxX) / 2,
            i = (t.globals.minX + e) / 2,
            a = (t.globals.maxX + e) / 2,
            s = this._getNewMinXMaxX(i, a);

        t.globals.disableZoomIn || this.zoomUpdateOptions(s.minX, s.maxX);
      }
    }, {
      key: "handleZoomOut",
      value: function value() {
        var t = this.w;

        if (!("datetime" === t.config.xaxis.type && new Date(t.globals.minX).getUTCFullYear() < 1e3)) {
          var e = (t.globals.minX + t.globals.maxX) / 2,
              i = t.globals.minX - (e - t.globals.minX),
              a = t.globals.maxX - (e - t.globals.maxX),
              s = this._getNewMinXMaxX(i, a);

          t.globals.disableZoomOut || this.zoomUpdateOptions(s.minX, s.maxX);
        }
      }
    }, {
      key: "_getNewMinXMaxX",
      value: function value(t, e) {
        var i = this.w.config.xaxis.convertedCatToNumeric;
        return {
          minX: i ? Math.floor(t) : t,
          maxX: i ? Math.floor(e) : e
        };
      }
    }, {
      key: "zoomUpdateOptions",
      value: function value(t, e) {
        var i = this.w;

        if (void 0 !== t || void 0 !== e) {
          if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = i.globals.dataPoints), e - t < 2))) {
            var a = {
              min: t,
              max: e
            },
                s = this.getBeforeZoomRange(a);
            s && (a = s.xaxis);
            var r = {
              xaxis: a
            },
                n = f.clone(i.globals.initialConfig.yaxis);
            if (i.config.chart.zoom.autoScaleYaxis) n = new q(this.ctx).autoScaleY(this.ctx, n, {
              xaxis: a
            });
            i.config.chart.group || (r.yaxis = n), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a, n);
          }
        } else this.handleZoomReset();
      }
    }, {
      key: "zoomCallback",
      value: function value(t, e) {
        "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
          xaxis: t,
          yaxis: e
        });
      }
    }, {
      key: "getBeforeZoomRange",
      value: function value(t, e) {
        var i = null;
        return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, {
          xaxis: t,
          yaxis: e
        })), i;
      }
    }, {
      key: "toggleMenu",
      value: function value() {
        var t = this;
        window.setTimeout(function () {
          t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open");
        }, 0);
      }
    }, {
      key: "handleDownload",
      value: function value(t) {
        var e = this.w,
            i = new _(this.ctx);

        switch (t) {
          case "svg":
            i.exportToSVG(this.ctx);
            break;

          case "png":
            i.exportToPng(this.ctx);
            break;

          case "csv":
            i.exportToCSV({
              series: e.config.series,
              columnDelimiter: e.config.chart.toolbar.export.csv.columnDelimiter
            });
        }
      }
    }, {
      key: "handleZoomReset",
      value: function value(t) {
        this.ctx.getSyncedCharts().forEach(function (t) {
          var e = t.w;
          e.globals.lastXAxis.min = void 0, e.globals.lastXAxis.max = void 0, t.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e.config.chart.events.zoomed && t.ctx.toolbar.zoomCallback({
            min: e.config.xaxis.min,
            max: e.config.xaxis.max
          }), e.globals.zoomed = !1;
          var i = t.ctx.series.emptyCollapsedSeries(f.clone(e.globals.initialSeries));

          t.updateHelpers._updateSeries(i, e.config.chart.animations.dynamicAnimation.enabled);
        });
      }
    }, {
      key: "destroy",
      value: function value() {
        this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
      }
    }]), t;
  }(),
      gt = function (t) {
    o(s, dt);
    var i = d(s);

    function s(t) {
      var a;
      return e(this, s), (a = i.call(this, t)).ctx = t, a.w = t.w, a.dragged = !1, a.graphics = new b(a.ctx), a.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], a.clientX = 0, a.clientY = 0, a.startX = 0, a.endX = 0, a.dragX = 0, a.startY = 0, a.endY = 0, a.dragY = 0, a.moveDirection = "none", a;
    }

    return a(s, [{
      key: "init",
      value: function value(t) {
        var e = this,
            i = t.xyRatios,
            a = this.w,
            s = this;
        this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a.globals.dom.elGraphical.add(this.zoomRect), a.globals.dom.elGraphical.add(this.selectionRect), "x" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
          minX: 0,
          minY: 0,
          maxX: a.globals.gridWidth,
          maxY: a.globals.gridHeight
        }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
          minX: 0,
          maxX: a.globals.gridWidth
        }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a.globals.dom.baseEl.querySelector("".concat(a.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function (t) {
          e.hoverArea.addEventListener(t, s.svgMouseEvents.bind(s, i), {
            capture: !1,
            passive: !0
          });
        });
      }
    }, {
      key: "destroy",
      value: function value() {
        this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
      }
    }, {
      key: "svgMouseEvents",
      value: function value(t, e) {
        var i = this.w,
            a = this,
            s = this.ctx.toolbar,
            r = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type,
            n = i.config.chart.toolbar.autoSelected;
        e.shiftKey ? (this.shiftWasPressed = !0, s.enableZoomPanFromToolbar("pan" === n ? "zoom" : "pan")) : this.shiftWasPressed && (s.enableZoomPanFromToolbar(n), this.shiftWasPressed = !1);
        var o = e.target.classList;

        if (!(o.contains("apexcharts-selection-rect") || o.contains("apexcharts-legend-marker") || o.contains("apexcharts-legend-text") || e.target.parentNode.classList.contains("apexcharts-toolbar"))) {
          if (a.clientX = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientX : "touchend" === e.type ? e.changedTouches[0].clientX : e.clientX, a.clientY = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientY : "touchend" === e.type ? e.changedTouches[0].clientY : e.clientY, "mousedown" === e.type && 1 === e.which) {
            var l = a.gridRect.getBoundingClientRect();
            a.startX = a.clientX - l.left, a.startY = a.clientY - l.top, a.dragged = !1, a.w.globals.mousedown = !0;
          }

          if (("mousemove" === e.type && 1 === e.which || "touchmove" === e.type) && (a.dragged = !0, i.globals.panEnabled ? (i.globals.selection = null, a.w.globals.mousedown && a.panDragging({
            context: a,
            zoomtype: r,
            xyRatios: t
          })) : (a.w.globals.mousedown && i.globals.zoomEnabled || a.w.globals.mousedown && i.globals.selectionEnabled) && (a.selection = a.selectionDrawing({
            context: a,
            zoomtype: r
          }))), "mouseup" === e.type || "touchend" === e.type || "mouseleave" === e.type) {
            var h = a.gridRect.getBoundingClientRect();
            a.w.globals.mousedown && (a.endX = a.clientX - h.left, a.endY = a.clientY - h.top, a.dragX = Math.abs(a.endX - a.startX), a.dragY = Math.abs(a.endY - a.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && a.selectionDrawn({
              context: a,
              zoomtype: r
            }), i.globals.panEnabled && i.config.xaxis.convertedCatToNumeric && a.delayedPanScrolled()), i.globals.zoomEnabled && a.hideSelectionRect(this.selectionRect), a.dragged = !1, a.w.globals.mousedown = !1;
          }

          this.makeSelectionRectDraggable();
        }
      }
    }, {
      key: "makeSelectionRectDraggable",
      value: function value() {
        var t = this.w;

        if (this.selectionRect) {
          var e = this.selectionRect.node.getBoundingClientRect();
          e.width > 0 && e.height > 0 && this.slDraggableRect.selectize({
            points: "l, r",
            pointSize: 8,
            pointType: "rect"
          }).resize({
            constraint: {
              minX: 0,
              minY: 0,
              maxX: t.globals.gridWidth,
              maxY: t.globals.gridHeight
            }
          }).on("resizing", this.selectionDragging.bind(this, "resizing"));
        }
      }
    }, {
      key: "preselectedSelection",
      value: function value() {
        var t = this.w,
            e = this.xyRatios;
        if (!t.globals.zoomEnabled) if (void 0 !== t.globals.selection && null !== t.globals.selection) this.drawSelectionRect(t.globals.selection);else if (void 0 !== t.config.chart.selection.xaxis.min && void 0 !== t.config.chart.selection.xaxis.max) {
          var i = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio,
              a = {
            x: i,
            y: 0,
            width: t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - i,
            height: t.globals.gridHeight,
            translateX: 0,
            translateY: 0,
            selectionEnabled: !0
          };
          this.drawSelectionRect(a), this.makeSelectionRectDraggable(), "function" == typeof t.config.chart.events.selection && t.config.chart.events.selection(this.ctx, {
            xaxis: {
              min: t.config.chart.selection.xaxis.min,
              max: t.config.chart.selection.xaxis.max
            },
            yaxis: {}
          });
        }
      }
    }, {
      key: "drawSelectionRect",
      value: function value(t) {
        var e = t.x,
            i = t.y,
            a = t.width,
            s = t.height,
            r = t.translateX,
            n = void 0 === r ? 0 : r,
            o = t.translateY,
            l = void 0 === o ? 0 : o,
            h = this.w,
            c = this.zoomRect,
            d = this.selectionRect;

        if (this.dragged || null !== h.globals.selection) {
          var g = {
            transform: "translate(" + n + ", " + l + ")"
          };
          h.globals.zoomEnabled && this.dragged && (a < 0 && (a = 1), c.attr({
            x: e,
            y: i,
            width: a,
            height: s,
            fill: h.config.chart.zoom.zoomedArea.fill.color,
            "fill-opacity": h.config.chart.zoom.zoomedArea.fill.opacity,
            stroke: h.config.chart.zoom.zoomedArea.stroke.color,
            "stroke-width": h.config.chart.zoom.zoomedArea.stroke.width,
            "stroke-opacity": h.config.chart.zoom.zoomedArea.stroke.opacity
          }), b.setAttrs(c.node, g)), h.globals.selectionEnabled && (d.attr({
            x: e,
            y: i,
            width: a > 0 ? a : 0,
            height: s > 0 ? s : 0,
            fill: h.config.chart.selection.fill.color,
            "fill-opacity": h.config.chart.selection.fill.opacity,
            stroke: h.config.chart.selection.stroke.color,
            "stroke-width": h.config.chart.selection.stroke.width,
            "stroke-dasharray": h.config.chart.selection.stroke.dashArray,
            "stroke-opacity": h.config.chart.selection.stroke.opacity
          }), b.setAttrs(d.node, g));
        }
      }
    }, {
      key: "hideSelectionRect",
      value: function value(t) {
        t && t.attr({
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
    }, {
      key: "selectionDrawing",
      value: function value(t) {
        var e = t.context,
            i = t.zoomtype,
            a = this.w,
            s = e,
            r = this.gridRect.getBoundingClientRect(),
            n = s.startX - 1,
            o = s.startY,
            l = !1,
            h = !1,
            c = s.clientX - r.left - n,
            d = s.clientY - r.top - o,
            g = {};
        return Math.abs(c + n) > a.globals.gridWidth ? c = a.globals.gridWidth - n : s.clientX - r.left < 0 && (c = n), n > s.clientX - r.left && (l = !0, c = Math.abs(c)), o > s.clientY - r.top && (h = !0, d = Math.abs(d)), g = "x" === i ? {
          x: l ? n - c : n,
          y: 0,
          width: c,
          height: a.globals.gridHeight
        } : "y" === i ? {
          x: 0,
          y: h ? o - d : o,
          width: a.globals.gridWidth,
          height: d
        } : {
          x: l ? n - c : n,
          y: h ? o - d : o,
          width: c,
          height: d
        }, s.drawSelectionRect(g), s.selectionDragging("resizing"), g;
      }
    }, {
      key: "selectionDragging",
      value: function value(t, e) {
        var i = this,
            a = this.w,
            s = this.xyRatios,
            r = this.selectionRect,
            n = 0;
        "resizing" === t && (n = 30);

        var o = function o(t) {
          return parseFloat(r.node.getAttribute(t));
        },
            l = {
          x: o("x"),
          y: o("y"),
          width: o("width"),
          height: o("height")
        };

        a.globals.selection = l, "function" == typeof a.config.chart.events.selection && a.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function () {
          var t = i.gridRect.getBoundingClientRect(),
              e = r.node.getBoundingClientRect(),
              n = a.globals.xAxisScale.niceMin + (e.left - t.left) * s.xRatio,
              o = a.globals.xAxisScale.niceMin + (e.right - t.left) * s.xRatio,
              l = a.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * s.yRatio[0],
              h = a.globals.yAxisScale[0].niceMax - (e.top - t.top) * s.yRatio[0];
          a.config.chart.events.selection(i.ctx, {
            xaxis: {
              min: n,
              max: o
            },
            yaxis: {
              min: l,
              max: h
            }
          });
        }, n));
      }
    }, {
      key: "selectionDrawn",
      value: function value(t) {
        var e = t.context,
            i = t.zoomtype,
            a = this.w,
            s = e,
            r = this.xyRatios,
            n = this.ctx.toolbar;

        if (s.startX > s.endX) {
          var o = s.startX;
          s.startX = s.endX, s.endX = o;
        }

        if (s.startY > s.endY) {
          var l = s.startY;
          s.startY = s.endY, s.endY = l;
        }

        var h = a.globals.xAxisScale.niceMin + s.startX * r.xRatio,
            c = a.globals.xAxisScale.niceMin + s.endX * r.xRatio,
            d = [],
            g = [];
        if (a.config.yaxis.forEach(function (t, e) {
          d.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.startY), g.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * s.endY);
        }), s.dragged && (s.dragX > 10 || s.dragY > 10) && h !== c) if (a.globals.zoomEnabled) {
          var u = f.clone(a.globals.initialConfig.yaxis),
              p = f.clone(a.globals.initialConfig.xaxis);

          if (a.globals.zoomed = !0, a.config.xaxis.convertedCatToNumeric && (h = Math.floor(h), c = Math.floor(c), h < 1 && (h = 1, c = a.globals.dataPoints), c - h < 2 && (c = h + 1)), "xy" !== i && "x" !== i || (p = {
            min: h,
            max: c
          }), "xy" !== i && "y" !== i || u.forEach(function (t, e) {
            u[e].min = g[e], u[e].max = d[e];
          }), a.config.chart.zoom.autoScaleYaxis) {
            var x = new q(s.ctx);
            u = x.autoScaleY(s.ctx, u, {
              xaxis: p
            });
          }

          if (n) {
            var b = n.getBeforeZoomRange(p, u);
            b && (p = b.xaxis ? b.xaxis : p, u = b.yaxis ? b.yaxis : u);
          }

          var m = {
            xaxis: p
          };
          a.config.chart.group || (m.yaxis = u), s.ctx.updateHelpers._updateOptions(m, !1, s.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a.config.chart.events.zoomed && n.zoomCallback(p, u);
        } else if (a.globals.selectionEnabled) {
          var v,
              y = null;
          v = {
            min: h,
            max: c
          }, "xy" !== i && "y" !== i || (y = f.clone(a.config.yaxis)).forEach(function (t, e) {
            y[e].min = g[e], y[e].max = d[e];
          }), a.globals.selection = s.selection, "function" == typeof a.config.chart.events.selection && a.config.chart.events.selection(s.ctx, {
            xaxis: v,
            yaxis: y
          });
        }
      }
    }, {
      key: "panDragging",
      value: function value(t) {
        var e = t.context,
            i = this.w,
            a = e;

        if (void 0 !== i.globals.lastClientPosition.x) {
          var s = i.globals.lastClientPosition.x - a.clientX,
              r = i.globals.lastClientPosition.y - a.clientY;
          Math.abs(s) > Math.abs(r) && s > 0 ? this.moveDirection = "left" : Math.abs(s) > Math.abs(r) && s < 0 ? this.moveDirection = "right" : Math.abs(r) > Math.abs(s) && r > 0 ? this.moveDirection = "up" : Math.abs(r) > Math.abs(s) && r < 0 && (this.moveDirection = "down");
        }

        i.globals.lastClientPosition = {
          x: a.clientX,
          y: a.clientY
        };
        var n = i.globals.minX,
            o = i.globals.maxX;
        i.config.xaxis.convertedCatToNumeric || a.panScrolled(n, o);
      }
    }, {
      key: "delayedPanScrolled",
      value: function value() {
        var t = this.w,
            e = t.globals.minX,
            i = t.globals.maxX,
            a = (t.globals.maxX - t.globals.minX) / 2;
        "left" === this.moveDirection ? (e = t.globals.minX + a, i = t.globals.maxX + a) : "right" === this.moveDirection && (e = t.globals.minX - a, i = t.globals.maxX - a), e = Math.floor(e), i = Math.floor(i), this.updateScrolledChart({
          xaxis: {
            min: e,
            max: i
          }
        }, e, i);
      }
    }, {
      key: "panScrolled",
      value: function value(t, e) {
        var i = this.w,
            a = this.xyRatios,
            s = f.clone(i.globals.initialConfig.yaxis);
        "left" === this.moveDirection ? (t = i.globals.minX + i.globals.gridWidth / 15 * a.xRatio, e = i.globals.maxX + i.globals.gridWidth / 15 * a.xRatio) : "right" === this.moveDirection && (t = i.globals.minX - i.globals.gridWidth / 15 * a.xRatio, e = i.globals.maxX - i.globals.gridWidth / 15 * a.xRatio), (t < i.globals.initialMinX || e > i.globals.initialMaxX) && (t = i.globals.minX, e = i.globals.maxX);
        var r = {
          min: t,
          max: e
        };
        i.config.chart.zoom.autoScaleYaxis && (s = new q(this.ctx).autoScaleY(this.ctx, s, {
          xaxis: r
        }));
        var n = {
          xaxis: {
            min: t,
            max: e
          }
        };
        i.config.chart.group || (n.yaxis = s), this.updateScrolledChart(n, t, e);
      }
    }, {
      key: "updateScrolledChart",
      value: function value(t, e, i) {
        var a = this.w;
        this.ctx.updateHelpers._updateOptions(t, !1, !1), "function" == typeof a.config.chart.events.scrolled && a.config.chart.events.scrolled(this.ctx, {
          xaxis: {
            min: e,
            max: i
          }
        });
      }
    }]), s;
  }(),
      ut = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.ttCtx = i, this.ctx = i.ctx;
    }

    return a(t, [{
      key: "getNearestValues",
      value: function value(t) {
        var e = t.hoverArea,
            i = t.elGrid,
            a = t.clientX,
            s = t.clientY,
            r = this.w,
            n = r.globals.gridWidth,
            o = n / (r.globals.dataPoints - 1),
            l = i.getBoundingClientRect(),
            h = this.hasBars();
        !r.globals.comboCharts && !h || r.config.xaxis.convertedCatToNumeric || (o = n / r.globals.dataPoints);
        var c = a - l.left - r.globals.barPadForNumericAxis,
            d = s - l.top;
        c < 0 || d < 0 || c > r.globals.gridWidth || d > r.globals.gridHeight ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : r.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : r.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
        var g = Math.round(c / o);
        h && !r.config.xaxis.convertedCatToNumeric && (g = Math.ceil(c / o), g -= 1);

        for (var u, p = null, x = null, b = [], m = 0; m < r.globals.seriesXvalues.length; m++) {
          b.push([r.globals.seriesXvalues[m][0] - 1e-6].concat(r.globals.seriesXvalues[m]));
        }

        return b = b.map(function (t) {
          return t.filter(function (t) {
            return t;
          });
        }), u = r.globals.seriesYvalues.map(function (t) {
          return t.filter(function (t) {
            return f.isNumber(t);
          });
        }), r.globals.isXNumeric && (p = (x = this.closestInMultiArray(c, d, b, u)).index, g = x.j, null !== p && (b = r.globals.seriesXvalues[p], g = (x = this.closestInArray(c, b)).index)), r.globals.capturedSeriesIndex = null === p ? -1 : p, (!g || g < 1) && (g = 0), r.globals.capturedDataPointIndex = g, {
          capturedSeries: p,
          j: g,
          hoverX: c,
          hoverY: d
        };
      }
    }, {
      key: "closestInMultiArray",
      value: function value(t, e, i, a) {
        var s = this.w,
            r = 0,
            n = null,
            o = -1;
        s.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n = 0;
        var l = a[r][0],
            h = i[r][0],
            c = Math.abs(t - h),
            d = Math.abs(e - l),
            g = d + c;
        return a.map(function (s, r) {
          s.map(function (s, l) {
            var h = Math.abs(e - a[r][l]),
                u = Math.abs(t - i[r][l]),
                f = u + h;
            f < g && (g = f, c = u, d = h, n = r, o = l);
          });
        }), {
          index: n,
          j: o
        };
      }
    }, {
      key: "getFirstActiveXArray",
      value: function value(t) {
        for (var e = 0, i = t.map(function (t, e) {
          return t.length > 0 ? e : -1;
        }), a = 0; a < i.length; a++) {
          if (-1 !== i[a]) {
            e = i[a];
            break;
          }
        }

        return e;
      }
    }, {
      key: "closestInArray",
      value: function value(t, e) {
        for (var i = e[0], a = null, s = Math.abs(t - i), r = 0; r < e.length; r++) {
          var n = Math.abs(t - e[r]);
          n < s && (s = n, a = r);
        }

        return {
          index: a
        };
      }
    }, {
      key: "isXoverlap",
      value: function value(t) {
        var e = [],
            i = this.w.globals.seriesX.filter(function (t) {
          return void 0 !== t[0];
        });
        if (i.length > 0) for (var a = 0; a < i.length - 1; a++) {
          void 0 !== i[a][t] && void 0 !== i[a + 1][t] && i[a][t] !== i[a + 1][t] && e.push("unEqual");
        }
        return 0 === e.length;
      }
    }, {
      key: "isInitialSeriesSameLen",
      value: function value() {
        for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++) {
          if (e[i].data.length !== e[i + 1].data.length) {
            t = !1;
            break;
          }
        }

        return t;
      }
    }, {
      key: "getBarsHeight",
      value: function value(t) {
        return g(t).reduce(function (t, e) {
          return t + e.getBBox().height;
        }, 0);
      }
    }, {
      key: "getElMarkers",
      value: function value() {
        return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers");
      }
    }, {
      key: "getAllMarkers",
      value: function value() {
        var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
        (t = g(t)).sort(function (t, e) {
          return Number(e.getAttribute("data:realIndex")) < Number(t.getAttribute("data:realIndex")) ? 0 : -1;
        });
        var e = [];
        return t.forEach(function (t) {
          e.push(t.querySelector(".apexcharts-marker"));
        }), e;
      }
    }, {
      key: "hasMarkers",
      value: function value() {
        return this.getElMarkers().length > 0;
      }
    }, {
      key: "getElBars",
      value: function value() {
        return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series");
      }
    }, {
      key: "hasBars",
      value: function value() {
        return this.getElBars().length > 0;
      }
    }, {
      key: "getHoverMarkerSize",
      value: function value(t) {
        var e = this.w,
            i = e.config.markers.hover.size;
        return void 0 === i && (i = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), i;
      }
    }, {
      key: "toggleAllTooltipSeriesGroups",
      value: function value(t) {
        var e = this.w,
            i = this.ttCtx;
        0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));

        for (var a = i.allTooltipSeriesGroups, s = 0; s < a.length; s++) {
          "enable" === t ? (a[s].classList.add("apexcharts-active"), a[s].style.display = e.config.tooltip.items.display) : (a[s].classList.remove("apexcharts-active"), a[s].style.display = "none");
        }
      }
    }]), t;
  }(),
      ft = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.ctx = i.ctx, this.ttCtx = i, this.tooltipUtil = new ut(i);
    }

    return a(t, [{
      key: "drawSeriesTexts",
      value: function value(t) {
        var e = t.shared,
            i = void 0 === e || e,
            a = t.ttItems,
            s = t.i,
            r = void 0 === s ? 0 : s,
            n = t.j,
            o = void 0 === n ? null : n,
            l = t.y1,
            h = t.y2,
            c = this.w;
        void 0 !== c.config.tooltip.custom ? this.handleCustomTooltip({
          i: r,
          j: o,
          y1: l,
          y2: h,
          w: c
        }) : this.toggleActiveInactiveSeries(i);
        var d = this.getValuesToPrint({
          i: r,
          j: o
        });
        this.printLabels({
          i: r,
          j: o,
          values: d,
          ttItems: a,
          shared: i
        });
        var g = this.ttCtx.getElTooltip();
        this.ttCtx.tooltipRect.ttWidth = g.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = g.getBoundingClientRect().height;
      }
    }, {
      key: "printLabels",
      value: function value(t) {
        var e,
            i = this,
            a = t.i,
            s = t.j,
            r = t.values,
            n = t.ttItems,
            o = t.shared,
            l = this.w,
            h = r.xVal,
            c = r.zVal,
            d = r.xAxisTTVal,
            g = "",
            u = l.globals.colors[a];
        null !== s && l.config.plotOptions.bar.distributed && (u = l.globals.colors[s]);

        for (var f = function f(t, r) {
          var f = i.getFormatters(a);
          g = i.getSeriesName({
            fn: f.yLbTitleFormatter,
            index: a,
            seriesIndex: a,
            j: s
          });
          var p = l.config.tooltip.inverseOrder ? r : t;

          if (l.globals.axisCharts) {
            var x = function x(t) {
              return f.yLbFormatter(l.globals.series[t][s], {
                series: l.globals.series,
                seriesIndex: t,
                dataPointIndex: s,
                w: l
              });
            };

            o ? (f = i.getFormatters(p), g = i.getSeriesName({
              fn: f.yLbTitleFormatter,
              index: p,
              seriesIndex: a,
              j: s
            }), u = l.globals.colors[p], e = x(p)) : e = x(a);
          }

          null === s && (e = f.yLbFormatter(l.globals.series[a], l)), i.DOMHandling({
            i: a,
            t: p,
            j: s,
            ttItems: n,
            values: {
              val: e,
              xVal: h,
              xAxisTTVal: d,
              zVal: c
            },
            seriesName: g,
            shared: o,
            pColor: u
          });
        }, p = 0, x = l.globals.series.length - 1; p < l.globals.series.length; p++, x--) {
          f(p, x);
        }
      }
    }, {
      key: "getFormatters",
      value: function value(t) {
        var e,
            i = this.w,
            a = i.globals.yLabelFormatters[t];
        return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (a = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (a = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, "function" != typeof a && (a = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function (t) {
          return t;
        }), "function" != typeof e && (e = function e(t) {
          return t;
        }), {
          yLbFormatter: a,
          yLbTitleFormatter: e
        };
      }
    }, {
      key: "getSeriesName",
      value: function value(t) {
        var e = t.fn,
            i = t.index,
            a = t.seriesIndex,
            s = t.j,
            r = this.w;
        return e(String(r.globals.seriesNames[i]), {
          series: r.globals.series,
          seriesIndex: a,
          dataPointIndex: s,
          w: r
        });
      }
    }, {
      key: "DOMHandling",
      value: function value(t) {
        t.i;
        var e = t.t,
            i = (t.j, t.ttItems),
            a = t.values,
            s = t.seriesName,
            r = t.shared,
            n = t.pColor,
            o = this.w,
            l = this.ttCtx,
            h = a.val,
            c = a.xVal,
            d = a.xAxisTTVal,
            g = a.zVal,
            u = null;
        u = i[e].children, o.config.tooltip.fillSeriesColor && (i[e].style.backgroundColor = n, u[0].style.display = "none"), l.showTooltipTitle && (null === l.tooltipTitle && (l.tooltipTitle = o.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), l.tooltipTitle.innerHTML = c), l.blxaxisTooltip && (l.xaxisTooltipText.innerHTML = "" !== d ? d : c);
        var f = i[e].querySelector(".apexcharts-tooltip-text-label");
        f && (f.innerHTML = s || "");
        var p = i[e].querySelector(".apexcharts-tooltip-text-value");
        (p && (p.innerHTML = void 0 !== h ? h : ""), u[0] && u[0].classList.contains("apexcharts-tooltip-marker") && (o.config.tooltip.marker.fillColors && Array.isArray(o.config.tooltip.marker.fillColors) && (n = o.config.tooltip.marker.fillColors[e]), u[0].style.backgroundColor = n), o.config.tooltip.marker.show || (u[0].style.display = "none"), null !== g) && (i[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = o.config.tooltip.z.title, i[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== g ? g : "");
        r && u[0] && (null == h || o.globals.collapsedSeriesIndices.indexOf(e) > -1 ? u[0].parentNode.style.display = "none" : u[0].parentNode.style.display = o.config.tooltip.items.display);
      }
    }, {
      key: "toggleActiveInactiveSeries",
      value: function value(t) {
        var e = this.w;
        if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");else {
          this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
          var i = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
          i && (i.classList.add("apexcharts-active"), i.style.display = e.config.tooltip.items.display);
        }
      }
    }, {
      key: "getValuesToPrint",
      value: function value(t) {
        var e = t.i,
            i = t.j,
            a = this.w,
            s = this.ctx.series.filteredSeriesX(),
            r = "",
            n = "",
            o = null,
            l = null,
            h = {
          series: a.globals.series,
          seriesIndex: e,
          dataPointIndex: i,
          w: a
        },
            c = a.globals.ttZFormatter;
        null === i ? l = a.globals.series[e] : a.globals.isXNumeric ? (r = s[e][i], 0 === s[e].length && (r = s[this.tooltipUtil.getFirstActiveXArray(s)][i])) : r = void 0 !== a.globals.labels[i] ? a.globals.labels[i] : "";
        var d = r;
        a.globals.isXNumeric && "datetime" === a.config.xaxis.type ? r = new V(this.ctx).xLabelFormat(a.globals.ttKeyFormatter, d, d) : a.globals.isBarHorizontal || (r = a.globals.xLabelFormatter(d, h));
        return void 0 !== a.config.tooltip.x.formatter && (r = a.globals.ttKeyFormatter(d, h)), a.globals.seriesZ.length > 0 && a.globals.seriesZ[0].length > 0 && (o = c(a.globals.seriesZ[e][i], a)), n = "function" == typeof a.config.xaxis.tooltip.formatter ? a.globals.xaxisTooltipFormatter(d, h) : r, {
          val: Array.isArray(l) ? l.join(" ") : l,
          xVal: Array.isArray(r) ? r.join(" ") : r,
          xAxisTTVal: Array.isArray(n) ? n.join(" ") : n,
          zVal: o
        };
      }
    }, {
      key: "handleCustomTooltip",
      value: function value(t) {
        var e = t.i,
            i = t.j,
            a = t.y1,
            s = t.y2,
            r = t.w,
            n = this.ttCtx.getElTooltip(),
            o = r.config.tooltip.custom;
        Array.isArray(o) && o[e] && (o = o[e]), n.innerHTML = o({
          ctx: this.ctx,
          series: r.globals.series,
          seriesIndex: e,
          dataPointIndex: i,
          y1: a,
          y2: s,
          w: r
        });
      }
    }]), t;
  }(),
      pt = function () {
    function t(i) {
      e(this, t), this.ttCtx = i, this.ctx = i.ctx, this.w = i.w;
    }

    return a(t, [{
      key: "moveXCrosshairs",
      value: function value(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
            i = this.ttCtx,
            a = this.w,
            s = i.getElXCrosshairs(),
            r = t - i.xcrosshairsWidth / 2,
            n = a.globals.labels.slice().length;

        if (null !== e && (r = a.globals.gridWidth / n * e), null !== s && (s.setAttribute("x", r), s.setAttribute("x1", r), s.setAttribute("x2", r), s.setAttribute("y2", a.globals.gridHeight), s.classList.add("apexcharts-active")), r < 0 && (r = 0), r > a.globals.gridWidth && (r = a.globals.gridWidth), i.blxaxisTooltip) {
          var o = r;
          "tickWidth" !== a.config.xaxis.crosshairs.width && "barWidth" !== a.config.xaxis.crosshairs.width || (o = r + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o);
        }
      }
    }, {
      key: "moveYCrosshairs",
      value: function value(t) {
        var e = this.ttCtx;
        null !== e.ycrosshairs && b.setAttrs(e.ycrosshairs, {
          y1: t,
          y2: t
        }), null !== e.ycrosshairsHidden && b.setAttrs(e.ycrosshairsHidden, {
          y1: t,
          y2: t
        });
      }
    }, {
      key: "moveXAxisTooltip",
      value: function value(t) {
        var e = this.w,
            i = this.ttCtx;

        if (null !== i.xaxisTooltip) {
          i.xaxisTooltip.classList.add("apexcharts-active");
          var a = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY;

          if (t -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) {
            t += e.globals.translateX;
            var s;
            s = new b(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = s.width + "px", i.xaxisTooltip.style.left = t + "px", i.xaxisTooltip.style.top = a + "px";
          }
        }
      }
    }, {
      key: "moveYAxisTooltip",
      value: function value(t) {
        var e = this.w,
            i = this.ttCtx;
        null === i.yaxisTTEls && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        var a = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10),
            s = e.globals.translateY + a,
            r = i.yaxisTTEls[t].getBoundingClientRect().height,
            n = e.globals.translateYAxisX[t] - 2;
        e.config.yaxis[t].opposite && (n -= 26), s -= r / 2, -1 === e.globals.ignoreYAxisIndexes.indexOf(t) ? (i.yaxisTTEls[t].classList.add("apexcharts-active"), i.yaxisTTEls[t].style.top = s + "px", i.yaxisTTEls[t].style.left = n + e.config.yaxis[t].tooltip.offsetX + "px") : i.yaxisTTEls[t].classList.remove("apexcharts-active");
      }
    }, {
      key: "moveTooltip",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
            a = this.w,
            s = this.ttCtx,
            r = s.getElTooltip(),
            n = s.tooltipRect,
            o = null !== i ? parseFloat(i) : 1,
            l = parseFloat(t) + o + 5,
            h = parseFloat(e) + o / 2;

        if (l > a.globals.gridWidth / 2 && (l = l - n.ttWidth - o - 15), l > a.globals.gridWidth - n.ttWidth - 10 && (l = a.globals.gridWidth - n.ttWidth), l < -20 && (l = -20), a.config.tooltip.followCursor) {
          var c = s.getElGrid(),
              d = c.getBoundingClientRect();
          h = s.e.clientY + a.globals.translateY - d.top - n.ttHeight / 2;
        }

        if (!a.config.tooltip.followCursor) {
          var g = this.positionChecks(n, l, h);
          l = g.x, h = g.y;
        }

        isNaN(l) || (l += a.globals.translateX, r.style.left = l + "px", r.style.top = h + "px");
      }
    }, {
      key: "positionChecks",
      value: function value(t, e, i) {
        var a = this.w;
        return t.ttHeight / 2 + i > a.globals.gridHeight && (i = a.globals.gridHeight - t.ttHeight + a.globals.translateY), i < 0 && (i = 0), {
          x: e,
          y: i
        };
      }
    }, {
      key: "moveMarkers",
      value: function value(t, e) {
        var i = this.w,
            a = this.ttCtx;
        if (i.globals.markers.size[t] > 0) for (var s = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), r = 0; r < s.length; r++) {
          parseInt(s[r].getAttribute("rel"), 10) === e && (a.marker.resetPointsSize(), a.marker.enlargeCurrentPoint(e, s[r]));
        } else a.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t);
      }
    }, {
      key: "moveDynamicPointOnHover",
      value: function value(t, e) {
        var i,
            a,
            s = this.w,
            r = this.ttCtx,
            n = s.globals.pointsArray,
            o = r.tooltipUtil.getHoverMarkerSize(e),
            l = s.config.series[e].type;

        if (!l || "column" !== l && "candlestick" !== l) {
          i = n[e][t][0], a = n[e][t][1] ? n[e][t][1] : 0;
          var h = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle"));
          h && a < s.globals.gridHeight && a > 0 && (h.setAttribute("r", o), h.setAttribute("cx", i), h.setAttribute("cy", a)), this.moveXCrosshairs(i), r.fixedTooltip || this.moveTooltip(i, a, o);
        }
      }
    }, {
      key: "moveDynamicPointsOnHover",
      value: function value(t) {
        var e,
            i = this.ttCtx,
            a = i.w,
            s = 0,
            r = 0,
            n = a.globals.pointsArray;
        e = new X(this.ctx).getActiveConfigSeriesIndex(!0);
        var o = i.tooltipUtil.getHoverMarkerSize(e);
        n[e] && (s = n[e][t][0], r = n[e][t][1]);
        var l = i.tooltipUtil.getAllMarkers();
        if (null !== l) for (var h = 0; h < a.globals.series.length; h++) {
          var c = n[h];

          if (a.globals.comboCharts && void 0 === c && l.splice(h, 0, null), c && c.length) {
            var d = n[h][t][1];
            l[h].setAttribute("cx", s), null !== d && !isNaN(d) && d < a.globals.gridHeight && d > 0 ? (l[h] && l[h].setAttribute("r", o), l[h] && l[h].setAttribute("cy", d)) : l[h] && l[h].setAttribute("r", 0);
          }
        }

        if (this.moveXCrosshairs(s), !i.fixedTooltip) {
          var g = r || a.globals.gridHeight;
          this.moveTooltip(s, g, o);
        }
      }
    }, {
      key: "moveStickyTooltipOverBars",
      value: function value(t) {
        var e,
            i = this.w,
            a = this.ttCtx,
            s = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length,
            r = s >= 2 && s % 2 == 0 ? Math.floor(s / 2) : Math.floor(s / 2) + 1,
            n = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(t, "']")),
            o = n ? parseFloat(n.getAttribute("cx")) : 0,
            l = n ? parseFloat(n.getAttribute("barWidth")) : 0;
        i.globals.isXNumeric ? o -= s % 2 != 0 ? l / 2 : 0 : (o = a.xAxisTicksPositions[t - 1] + a.dataPointsDividedWidth / 2, isNaN(o) && (o = a.xAxisTicksPositions[t] - a.dataPointsDividedWidth / 2));
        var h = a.getElGrid().getBoundingClientRect();

        if (e = a.e.clientY - h.top - a.tooltipRect.ttHeight / 2, this.moveXCrosshairs(o), !a.fixedTooltip) {
          var c = e || i.globals.gridHeight;
          this.moveTooltip(o, c);
        }
      }
    }]), t;
  }(),
      xt = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.ttCtx = i, this.ctx = i.ctx, this.tooltipPosition = new pt(i);
    }

    return a(t, [{
      key: "drawDynamicPoints",
      value: function value() {
        var t = this.w,
            e = new b(this.ctx),
            i = new z(this.ctx),
            a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        a = g(a), t.config.chart.stacked && a.sort(function (t, e) {
          return parseFloat(t.getAttribute("data:realIndex")) - parseFloat(e.getAttribute("data:realIndex"));
        });

        for (var s = 0; s < a.length; s++) {
          var r = a[s].querySelector(".apexcharts-series-markers-wrap");

          if (null !== r) {
            var n = void 0,
                o = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
            "line" !== t.config.chart.type && "area" !== t.config.chart.type || t.globals.comboCharts || t.config.tooltip.intersect || (o += " no-pointer-events");
            var l = i.getMarkerConfig(o, s);
            (n = e.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
            var h = document.createElementNS(t.globals.SVGNS, "g");
            h.classList.add("apexcharts-series-markers"), h.appendChild(n.node), r.appendChild(h);
          }
        }
      }
    }, {
      key: "enlargeCurrentPoint",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
            s = this.w;
        "bubble" !== s.config.chart.type && this.newPointSize(t, e);
        var r = e.getAttribute("cx"),
            n = e.getAttribute("cy");

        if (null !== i && null !== a && (r = i, n = a), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) {
          if ("radar" === s.config.chart.type) {
            var o = this.ttCtx.getElGrid(),
                l = o.getBoundingClientRect();
            r = this.ttCtx.e.clientX - l.left;
          }

          this.tooltipPosition.moveTooltip(r, n, s.config.markers.hover.size);
        }
      }
    }, {
      key: "enlargePoints",
      value: function value(t) {
        for (var e = this.w, i = this.ttCtx, a = t, s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), r = e.config.markers.hover.size, n = 0; n < s.length; n++) {
          var o = s[n].getAttribute("rel"),
              l = s[n].getAttribute("index");

          if (void 0 === r && (r = e.globals.markers.size[l] + e.config.markers.hover.sizeOffset), a === parseInt(o, 10)) {
            this.newPointSize(a, s[n]);
            var h = s[n].getAttribute("cx"),
                c = s[n].getAttribute("cy");
            this.tooltipPosition.moveXCrosshairs(h), i.fixedTooltip || this.tooltipPosition.moveTooltip(h, c, r);
          } else this.oldPointSize(s[n]);
        }
      }
    }, {
      key: "newPointSize",
      value: function value(t, e) {
        var i = this.w,
            a = i.config.markers.hover.size,
            s = 0 === t ? e.parentNode.firstChild : e.parentNode.lastChild;

        if ("0" !== s.getAttribute("default-marker-size")) {
          var r = parseInt(s.getAttribute("index"), 10);
          void 0 === a && (a = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset), s.setAttribute("r", a);
        }
      }
    }, {
      key: "oldPointSize",
      value: function value(t) {
        var e = parseFloat(t.getAttribute("default-marker-size"));
        t.setAttribute("r", e);
      }
    }, {
      key: "resetPointsSize",
      value: function value() {
        for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e = 0; e < t.length; e++) {
          var i = parseFloat(t[e].getAttribute("default-marker-size"));
          f.isNumber(i) ? t[e].setAttribute("r", i) : t[e].setAttribute("r", 0);
        }
      }
    }]), t;
  }(),
      bt = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.ttCtx = i;
    }

    return a(t, [{
      key: "getAttr",
      value: function value(t, e) {
        return parseFloat(t.target.getAttribute(e));
      }
    }, {
      key: "handleHeatTooltip",
      value: function value(t) {
        var e = t.e,
            i = t.opt,
            a = t.x,
            s = t.y,
            r = this.ttCtx,
            n = this.w;

        if (e.target.classList.contains("apexcharts-heatmap-rect")) {
          var o = this.getAttr(e, "i"),
              l = this.getAttr(e, "j"),
              h = this.getAttr(e, "cx"),
              c = this.getAttr(e, "cy"),
              d = this.getAttr(e, "width"),
              g = this.getAttr(e, "height");

          if (r.tooltipLabels.drawSeriesTexts({
            ttItems: i.ttItems,
            i: o,
            j: l,
            shared: !1
          }), n.globals.capturedSeriesIndex = o, n.globals.capturedDataPointIndex = l, a = h + r.tooltipRect.ttWidth / 2 + d, s = c + r.tooltipRect.ttHeight / 2 - g / 2, r.tooltipPosition.moveXCrosshairs(h + d / 2), a > n.globals.gridWidth / 2 && (a = h - r.tooltipRect.ttWidth / 2 + d), r.w.config.tooltip.followCursor) {
            var u = r.getElGrid().getBoundingClientRect();
            s = r.e.clientY - u.top + n.globals.translateY / 2 - 10;
          }
        }

        return {
          x: a,
          y: s
        };
      }
    }, {
      key: "handleMarkerTooltip",
      value: function value(t) {
        var e,
            i,
            a = t.e,
            s = t.opt,
            r = t.x,
            n = t.y,
            o = this.w,
            l = this.ttCtx;

        if (a.target.classList.contains("apexcharts-marker")) {
          var h = parseInt(s.paths.getAttribute("cx"), 10),
              c = parseInt(s.paths.getAttribute("cy"), 10),
              d = parseFloat(s.paths.getAttribute("val"));

          if (i = parseInt(s.paths.getAttribute("rel"), 10), e = parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l.intersect) {
            var g = f.findAncestor(s.paths, "apexcharts-series");
            g && (e = parseInt(g.getAttribute("data:realIndex"), 10));
          }

          if (l.tooltipLabels.drawSeriesTexts({
            ttItems: s.ttItems,
            i: e,
            j: i,
            shared: !l.showOnIntersect && o.config.tooltip.shared
          }), "mouseup" === a.type && l.markerClick(a, e, i), o.globals.capturedSeriesIndex = e, o.globals.capturedDataPointIndex = i, r = h, n = c + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) {
            var u = l.getElGrid().getBoundingClientRect();
            n = l.e.clientY + o.globals.translateY - u.top;
          }

          d < 0 && (n = c), l.marker.enlargeCurrentPoint(i, s.paths, r, n);
        }

        return {
          x: r,
          y: n
        };
      }
    }, {
      key: "handleBarTooltip",
      value: function value(t) {
        var e,
            i,
            a = t.e,
            s = t.opt,
            r = this.w,
            n = this.ttCtx,
            o = n.getElTooltip(),
            l = 0,
            h = 0,
            c = 0,
            d = this.getBarTooltipXY({
          e: a,
          opt: s
        });
        e = d.i;
        var g = d.barHeight,
            u = d.j;

        if (r.globals.capturedSeriesIndex = e, r.globals.capturedDataPointIndex = u, r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (h = d.x, c = d.y, i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[e] : r.config.stroke.width, l = h) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2), isNaN(c) ? c = r.globals.svgHeight - n.tooltipRect.ttHeight : c < 0 && (c = 0), h + n.tooltipRect.ttWidth > r.globals.gridWidth ? h -= n.tooltipRect.ttWidth : h < 0 && (h = 0), n.w.config.tooltip.followCursor) {
          var f = n.getElGrid().getBoundingClientRect();
          c = n.e.clientY - f.top;
        }

        if (null === n.tooltip && (n.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r.config.tooltip.shared || (r.globals.comboBarCount > 0 ? n.tooltipPosition.moveXCrosshairs(l + i / 2) : n.tooltipPosition.moveXCrosshairs(l)), !n.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n.tooltipUtil.hasBars())) {
          var p = r.globals.isMultipleYAxis ? r.config.yaxis[x] && r.config.yaxis[x].reversed : r.config.yaxis[0].reversed;
          p && (h -= n.tooltipRect.ttWidth) < 0 && (h = 0), o.style.left = h + r.globals.translateX + "px";
          var x = parseInt(s.paths.parentNode.getAttribute("data:realIndex"), 10);
          !p || r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || (c = c + g - 2 * (r.globals.series[e][u] < 0 ? g : 0)), n.tooltipRect.ttHeight + c > r.globals.gridHeight ? (c = r.globals.gridHeight - n.tooltipRect.ttHeight + r.globals.translateY, o.style.top = c + "px") : o.style.top = c + r.globals.translateY - n.tooltipRect.ttHeight / 2 + "px";
        }
      }
    }, {
      key: "getBarTooltipXY",
      value: function value(t) {
        var e = t.e,
            i = t.opt,
            a = this.w,
            s = null,
            r = this.ttCtx,
            n = 0,
            o = 0,
            l = 0,
            h = 0,
            c = 0,
            d = e.target.classList;

        if (d.contains("apexcharts-bar-area") || d.contains("apexcharts-candlestick-area") || d.contains("apexcharts-rangebar-area")) {
          var g = e.target,
              u = g.getBoundingClientRect(),
              f = i.elGrid.getBoundingClientRect(),
              p = u.height;
          c = u.height;
          var x = u.width,
              b = parseInt(g.getAttribute("cx"), 10),
              m = parseInt(g.getAttribute("cy"), 10);
          h = parseFloat(g.getAttribute("barWidth"));
          var v = "touchmove" === e.type ? e.touches[0].clientX : e.clientX;
          s = parseInt(g.getAttribute("j"), 10), n = parseInt(g.parentNode.getAttribute("rel"), 10) - 1;
          var y = g.getAttribute("data-range-y1"),
              w = g.getAttribute("data-range-y2");
          a.globals.comboCharts && (n = parseInt(g.parentNode.getAttribute("data:realIndex"), 10)), r.tooltipLabels.drawSeriesTexts({
            ttItems: i.ttItems,
            i: n,
            j: s,
            y1: y ? parseInt(y, 10) : null,
            y2: w ? parseInt(w, 10) : null,
            shared: !r.showOnIntersect && a.config.tooltip.shared
          }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (o = v - f.left + 15, l = m - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = e.clientY - f.top - r.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((o = b) < r.xyRatios.baseLineInvertedY && (o = b - r.tooltipRect.ttWidth), l = m - r.dataPointsDividedHeight + p / 2 - r.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? b - x / 2 : b - r.dataPointsDividedWidth + x / 2, l = m);
        }

        return {
          x: o,
          y: l,
          barHeight: c,
          barWidth: h,
          i: n,
          j: s
        };
      }
    }]), t;
  }(),
      mt = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.ttCtx = i;
    }

    return a(t, [{
      key: "drawXaxisTooltip",
      value: function value() {
        var t = this.w,
            e = this.ttCtx,
            i = "bottom" === t.config.xaxis.position;
        e.xaxisOffY = i ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
        var a = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
            s = t.globals.dom.elWrap;
        e.blxaxisTooltip && null === t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e.xaxisTooltip = document.createElement("div"), e.xaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + t.config.tooltip.theme), s.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement("div"), e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText));
      }
    }, {
      key: "drawYaxisTooltip",
      value: function value() {
        for (var t = this.w, e = this.ttCtx, i = function i(_i2) {
          var a = t.config.yaxis[_i2].opposite || t.config.yaxis[_i2].crosshairs.opposite;
          e.yaxisOffX = a ? t.globals.gridWidth + 1 : 1;
          var s = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(_i2, a ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
          t.globals.yAxisSameScaleIndices.map(function (e, a) {
            e.map(function (e, a) {
              a === _i2 && (s += t.config.yaxis[a].show ? " " : " apexcharts-yaxistooltip-hidden");
            });
          });
          var r = t.globals.dom.elWrap;
          null === t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(_i2)) && (e.yaxisTooltip = document.createElement("div"), e.yaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + t.config.tooltip.theme), r.appendChild(e.yaxisTooltip), 0 === _i2 && (e.yaxisTooltipText = []), e.yaxisTooltipText[_i2] = document.createElement("div"), e.yaxisTooltipText[_i2].classList.add("apexcharts-yaxistooltip-text"), e.yaxisTooltip.appendChild(e.yaxisTooltipText[_i2]));
        }, a = 0; a < t.config.yaxis.length; a++) {
          i(a);
        }
      }
    }, {
      key: "setXCrosshairWidth",
      value: function value() {
        var t = this.w,
            e = this.ttCtx,
            i = e.getElXCrosshairs();

        if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
          var a = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");

          if (null !== a && "barWidth" === t.config.xaxis.crosshairs.width) {
            var s = parseFloat(a.getAttribute("barWidth"));
            e.xcrosshairsWidth = s;
          } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
            var r = t.globals.labels.length;
            e.xcrosshairsWidth = t.globals.gridWidth / r;
          }
        } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
          var n = t.globals.labels.length;
          e.xcrosshairsWidth = t.globals.gridWidth / n;
        } else if ("barWidth" === t.config.xaxis.crosshairs.width) {
          var o = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");

          if (null !== o) {
            var l = parseFloat(o.getAttribute("barWidth"));
            e.xcrosshairsWidth = l;
          } else e.xcrosshairsWidth = 1;
        }

        t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), null !== i && e.xcrosshairsWidth > 0 && i.setAttribute("width", e.xcrosshairsWidth);
      }
    }, {
      key: "handleYCrosshair",
      value: function value() {
        var t = this.w,
            e = this.ttCtx;
        e.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
      }
    }, {
      key: "drawYaxisTooltipText",
      value: function value(t, e, i) {
        var a = this.ttCtx,
            s = this.w,
            r = s.globals.yLabelFormatters[t];

        if (a.yaxisTooltips[t]) {
          var n = a.getElGrid().getBoundingClientRect(),
              o = (e - n.top) * i.yRatio[t],
              l = s.globals.maxYArr[t] - s.globals.minYArr[t],
              h = s.globals.minYArr[t] + (l - o);
          a.tooltipPosition.moveYCrosshairs(e - n.top), a.yaxisTooltipText[t].innerHTML = r(h), a.tooltipPosition.moveYAxisTooltip(t);
        }
      }
    }]), t;
  }(),
      vt = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
      var a = this.w;
      this.tConfig = a.config.tooltip, this.tooltipUtil = new ut(this), this.tooltipLabels = new ft(this), this.tooltipPosition = new pt(this), this.marker = new xt(this), this.intersect = new bt(this), this.axesTooltip = new mt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a.globals.isBarHorizontal && this.tConfig.shared;
    }

    return a(t, [{
      key: "getElTooltip",
      value: function value(t) {
        return t || (t = this), t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip");
      }
    }, {
      key: "getElXCrosshairs",
      value: function value() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
      }
    }, {
      key: "getElGrid",
      value: function value() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
      }
    }, {
      key: "drawTooltip",
      value: function value(t) {
        var e = this.w;
        this.xyRatios = t, this.blxaxisTooltip = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.yaxisTooltips = e.config.yaxis.map(function (t, i) {
          return !!(t.show && t.tooltip.enabled && e.globals.axisCharts);
        }), this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1);
        var i = document.createElement("div");

        if (i.classList.add("apexcharts-tooltip"), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) {
          this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
          var a = new j(this.ctx);
          this.xAxisTicksPositions = a.getXAxisTicksPositions();
        }

        if (!e.globals.comboCharts && !this.tConfig.intersect && "bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) {
          this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
          var s = e.globals.series.length;
          (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (s = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s), this.addSVGEvents();
        }
      }
    }, {
      key: "createTTElements",
      value: function value(t) {
        for (var e = this.w, i = [], a = this.getElTooltip(), s = 0; s < t; s++) {
          var r = document.createElement("div");
          r.classList.add("apexcharts-tooltip-series-group"), this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(s) < 0 && r.classList.add("apexcharts-tooltip-series-group-hidden");
          var n = document.createElement("span");
          n.classList.add("apexcharts-tooltip-marker"), n.style.backgroundColor = e.globals.colors[s], r.appendChild(n);
          var o = document.createElement("div");
          o.classList.add("apexcharts-tooltip-text"), o.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, o.style.fontSize = this.tConfig.style.fontSize;
          var l = document.createElement("div");
          l.classList.add("apexcharts-tooltip-y-group");
          var h = document.createElement("span");
          h.classList.add("apexcharts-tooltip-text-label"), l.appendChild(h);
          var c = document.createElement("span");
          c.classList.add("apexcharts-tooltip-text-value"), l.appendChild(c);
          var d = document.createElement("div");
          d.classList.add("apexcharts-tooltip-z-group");
          var g = document.createElement("span");
          g.classList.add("apexcharts-tooltip-text-z-label"), d.appendChild(g);
          var u = document.createElement("span");
          u.classList.add("apexcharts-tooltip-text-z-value"), d.appendChild(u), o.appendChild(l), o.appendChild(d), r.appendChild(o), a.appendChild(r), i.push(r);
        }

        return i;
      }
    }, {
      key: "addSVGEvents",
      value: function value() {
        var t = this.w,
            e = t.config.chart.type,
            i = this.getElTooltip(),
            a = !("bar" !== e && "candlestick" !== e && "rangeBar" !== e),
            s = "area" === e || "line" === e || "scatter" === e || "bubble" === e || "radar" === e,
            r = t.globals.dom.Paper.node,
            n = this.getElGrid();
        n && (this.seriesBound = n.getBoundingClientRect());
        var o,
            l = [],
            h = [],
            c = {
          hoverArea: r,
          elGrid: n,
          tooltipEl: i,
          tooltipY: l,
          tooltipX: h,
          ttItems: this.ttItems
        };
        if (t.globals.axisCharts && (s ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" === e && (o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap")), o && o.length)) for (var d = 0; d < o.length; d++) {
          l.push(o[d].getAttribute("cy")), h.push(o[d].getAttribute("cx"));
        }
        if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || a && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r], c);else if (a && !t.globals.comboCharts || s && this.showOnIntersect) this.addDatapointEventsListeners(c);else if (!t.globals.axisCharts || "heatmap" === e) {
          var g = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
          this.addPathsEventListeners(g, c);
        }

        if (this.showOnIntersect) {
          var u = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
          u.length > 0 && this.addPathsEventListeners(u, c), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c);
        }
      }
    }, {
      key: "drawFixedTooltipRect",
      value: function value() {
        var t = this.w,
            e = this.getElTooltip(),
            i = e.getBoundingClientRect(),
            a = i.width + 10,
            s = i.height + 10,
            r = this.tConfig.fixed.offsetX,
            n = this.tConfig.fixed.offsetY,
            o = this.tConfig.fixed.position.toLowerCase();
        return o.indexOf("right") > -1 && (r = r + t.globals.svgWidth - a + 10), o.indexOf("bottom") > -1 && (n = n + t.globals.svgHeight - s - 10), e.style.left = r + "px", e.style.top = n + "px", {
          x: r,
          y: n,
          ttWidth: a,
          ttHeight: s
        };
      }
    }, {
      key: "addDatapointEventsListeners",
      value: function value(t) {
        var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area");
        this.addPathsEventListeners(e, t);
      }
    }, {
      key: "addPathsEventListeners",
      value: function value(t, e) {
        for (var i = this, a = function a(_a) {
          var s = {
            paths: t[_a],
            tooltipEl: e.tooltipEl,
            tooltipY: e.tooltipY,
            tooltipX: e.tooltipX,
            elGrid: e.elGrid,
            hoverArea: e.hoverArea,
            ttItems: e.ttItems
          };
          ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function (e) {
            return t[_a].addEventListener(e, i.seriesHover.bind(i, s), {
              capture: !1,
              passive: !0
            });
          });
        }, s = 0; s < t.length; s++) {
          a(s);
        }
      }
    }, {
      key: "seriesHover",
      value: function value(t, e) {
        var i = this,
            a = [],
            s = this.w;
        s.config.chart.group && (a = this.ctx.getGroupedCharts()), s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || 0 === s.globals.dataPoints) || (a.length ? a.forEach(function (a) {
          var s = i.getElTooltip(a),
              r = {
            paths: t.paths,
            tooltipEl: s,
            tooltipY: t.tooltipY,
            tooltipX: t.tooltipX,
            elGrid: t.elGrid,
            hoverArea: t.hoverArea,
            ttItems: a.w.globals.tooltip.ttItems
          };
          a.w.globals.minX === i.w.globals.minX && a.w.globals.maxX === i.w.globals.maxX && a.w.globals.tooltip.seriesHoverByContext({
            chartCtx: a,
            ttCtx: a.w.globals.tooltip,
            opt: r,
            e: e
          });
        }) : this.seriesHoverByContext({
          chartCtx: this.ctx,
          ttCtx: this.w.globals.tooltip,
          opt: t,
          e: e
        }));
      }
    }, {
      key: "seriesHoverByContext",
      value: function value(t) {
        var e = t.chartCtx,
            i = t.ttCtx,
            a = t.opt,
            s = t.e,
            r = e.w,
            n = this.getElTooltip();
        (i.tooltipRect = {
          x: 0,
          y: 0,
          ttWidth: n.getBoundingClientRect().width,
          ttHeight: n.getBoundingClientRect().height
        }, i.e = s, !i.tooltipUtil.hasBars() || r.globals.comboCharts || i.isBarShared) || this.tConfig.onDatasetHover.highlightDataSeries && new X(e).toggleSeriesOnHover(s, s.target.parentNode);
        i.fixedTooltip && i.drawFixedTooltipRect(), r.globals.axisCharts ? i.axisChartsTooltips({
          e: s,
          opt: a,
          tooltipRect: i.tooltipRect
        }) : i.nonAxisChartsTooltips({
          e: s,
          opt: a,
          tooltipRect: i.tooltipRect
        });
      }
    }, {
      key: "axisChartsTooltips",
      value: function value(t) {
        var e,
            i,
            a = t.e,
            s = t.opt,
            r = this.w,
            n = s.elGrid.getBoundingClientRect(),
            o = "touchmove" === a.type ? a.touches[0].clientX : a.clientX,
            l = "touchmove" === a.type ? a.touches[0].clientY : a.clientY;
        if (this.clientY = l, this.clientX = o, r.globals.capturedSeriesIndex = -1, r.globals.capturedDataPointIndex = -1, l < n.top || l > n.top + n.height) this.handleMouseOut(s);else {
          if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
            var h = parseInt(s.paths.getAttribute("index"), 10);
            if (this.tConfig.enabledOnSeries.indexOf(h) < 0) return void this.handleMouseOut(s);
          }

          var c = this.getElTooltip(),
              d = this.getElXCrosshairs(),
              g = r.globals.xyCharts || "bar" === r.config.chart.type && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();

          if (r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && (g = !1), "mousemove" === a.type || "touchmove" === a.type || "mouseup" === a.type) {
            null !== d && d.classList.add("apexcharts-active");
            var u = this.yaxisTooltips.filter(function (t) {
              return !0 === t;
            });
            if (null !== this.ycrosshairs && u.length && this.ycrosshairs.classList.add("apexcharts-active"), g && !this.showOnIntersect) this.handleStickyTooltip(a, o, l, s);else if ("heatmap" === r.config.chart.type) {
              var f = this.intersect.handleHeatTooltip({
                e: a,
                opt: s,
                x: e,
                y: i
              });
              e = f.x, i = f.y, c.style.left = e + "px", c.style.top = i + "px";
            } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
              e: a,
              opt: s
            }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
              e: a,
              opt: s,
              x: e,
              y: i
            });
            if (this.yaxisTooltips.length) for (var p = 0; p < r.config.yaxis.length; p++) {
              this.axesTooltip.drawYaxisTooltipText(p, l, this.xyRatios);
            }
            s.tooltipEl.classList.add("apexcharts-active");
          } else "mouseout" !== a.type && "touchend" !== a.type || this.handleMouseOut(s);
        }
      }
    }, {
      key: "nonAxisChartsTooltips",
      value: function value(t) {
        var e = t.e,
            i = t.opt,
            a = t.tooltipRect,
            s = this.w,
            r = i.paths.getAttribute("rel"),
            n = this.getElTooltip(),
            o = s.globals.dom.elWrap.getBoundingClientRect();

        if ("mousemove" === e.type || "touchmove" === e.type) {
          n.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
            ttItems: i.ttItems,
            i: parseInt(r, 10) - 1,
            shared: !1
          });
          var l = s.globals.clientX - o.left - a.ttWidth / 2,
              h = s.globals.clientY - o.top - a.ttHeight - 10;
          n.style.left = l + "px", n.style.top = h + "px";
        } else "mouseout" !== e.type && "touchend" !== e.type || n.classList.remove("apexcharts-active");
      }
    }, {
      key: "handleStickyTooltip",
      value: function value(t, e, i, a) {
        var s = this.w,
            r = this.tooltipUtil.getNearestValues({
          context: this,
          hoverArea: a.hoverArea,
          elGrid: a.elGrid,
          clientX: e,
          clientY: i
        }),
            n = r.j,
            o = r.capturedSeries;
        r.hoverX < 0 || r.hoverX > s.globals.gridWidth ? this.handleMouseOut(a) : null !== o ? this.handleStickyCapturedSeries(t, o, a, n) : this.tooltipUtil.isXoverlap(n) && this.create(t, this, 0, n, a.ttItems);
      }
    }, {
      key: "handleStickyCapturedSeries",
      value: function value(t, e, i, a) {
        var s = this.w;
        null === s.globals.series[e][a] ? this.handleMouseOut(i) : void 0 !== s.globals.series[e][a] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(a) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, e, a, i.ttItems) : this.create(t, this, e, a, i.ttItems, !1) : this.tooltipUtil.isXoverlap(a) && this.create(t, this, 0, a, i.ttItems);
      }
    }, {
      key: "deactivateHoverFilter",
      value: function value() {
        for (var t = this.w, e = new b(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), a = 0; a < i.length; a++) {
          e.pathMouseLeave(i[a]);
        }
      }
    }, {
      key: "handleMouseOut",
      value: function value(t) {
        var e = this.w,
            i = this.getElXCrosshairs();

        if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.blxaxisTooltip && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
          null === this.yaxisTTEls && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));

          for (var a = 0; a < this.yaxisTTEls.length; a++) {
            this.yaxisTTEls[a].classList.remove("apexcharts-active");
          }
        }

        e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function (t) {
          var e = t.getAttribute("data:default-text");
          t.innerHTML = decodeURIComponent(e);
        });
      }
    }, {
      key: "markerClick",
      value: function value(t, e, i) {
        var a = this.w;
        "function" == typeof a.config.chart.events.markerClick && a.config.chart.events.markerClick(t, this.ctx, {
          seriesIndex: e,
          dataPointIndex: i,
          w: a
        }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, {
          seriesIndex: e,
          dataPointIndex: i,
          w: a
        }]);
      }
    }, {
      key: "create",
      value: function value(t, e, i, a, s) {
        var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
            n = this.w,
            o = e;
        "mouseup" === t.type && this.markerClick(t, i, a), null === r && (r = this.tConfig.shared);
        var l = this.tooltipUtil.hasMarkers(),
            h = this.tooltipUtil.getElBars();

        if (n.config.legend.tooltipHoverFormatter) {
          var c = n.config.legend.tooltipHoverFormatter,
              d = Array.from(this.legendLabels);
          d.forEach(function (t) {
            var e = t.getAttribute("data:default-text");
            t.innerHTML = decodeURIComponent(e);
          });

          for (var g = 0; g < d.length; g++) {
            var u = d[g],
                f = parseInt(u.getAttribute("i"), 10),
                p = decodeURIComponent(u.getAttribute("data:default-text")),
                x = c(p, {
              seriesIndex: r ? f : i,
              dataPointIndex: a,
              w: n
            });
            if (r) u.innerHTML = n.globals.collapsedSeriesIndices.indexOf(f) < 0 ? x : p;else if (u.innerHTML = f === i ? x : p, i === f) break;
          }
        }

        if (r) {
          if (o.tooltipLabels.drawSeriesTexts({
            ttItems: s,
            i: i,
            j: a,
            shared: !this.showOnIntersect && this.tConfig.shared
          }), l && (n.globals.markers.largestSize > 0 ? o.marker.enlargePoints(a) : o.tooltipPosition.moveDynamicPointsOnHover(a)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(h), this.barSeriesHeight > 0)) {
            var m = new b(this.ctx),
                v = n.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a, "']"));
            this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a);

            for (var y = 0; y < v.length; y++) {
              m.pathMouseEnter(v[y]);
            }
          }
        } else o.tooltipLabels.drawSeriesTexts({
          shared: !1,
          ttItems: s,
          i: i,
          j: a
        }), this.tooltipUtil.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(a), l && o.tooltipPosition.moveMarkers(i, a);
      }
    }]), t;
  }(),
      yt = function (t) {
    o(s, F);
    var i = d(s);

    function s() {
      return e(this, s), i.apply(this, arguments);
    }

    return a(s, [{
      key: "draw",
      value: function value(t, e) {
        var i = this,
            a = this.w;
        this.graphics = new b(this.ctx), this.bar = new F(this.ctx, this.xyRatios);
        var s = new y(this.ctx, a);
        t = s.getLogSeries(t), this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t), "100%" === a.config.chart.stackType && (t = a.globals.seriesPercent.slice()), this.series = t, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];

        for (var r = 0; r < t.length; r++) {
          t[r].length > 0 && (this.totalItems += t[r].length);
        }

        for (var o = this.graphics.group({
          class: "apexcharts-bar-series apexcharts-plot-series"
        }), l = 0, h = 0, c = function c(s, r) {
          var c = void 0,
              d = void 0,
              g = void 0,
              u = void 0,
              p = [],
              x = [],
              b = a.globals.comboCharts ? e[s] : s;
          i.yRatio.length > 1 && (i.yaxisIndex = b), i.isReversed = a.config.yaxis[i.yaxisIndex] && a.config.yaxis[i.yaxisIndex].reversed;
          var m = i.graphics.group({
            class: "apexcharts-series",
            seriesName: f.escapeString(a.globals.seriesNames[b]),
            rel: s + 1,
            "data:realIndex": b
          });
          i.ctx.series.addCollapsedClassToSeries(m, b);
          var v = i.graphics.group({
            class: "apexcharts-datalabels",
            "data:realIndex": b
          }),
              y = 0,
              w = 0,
              k = i.initialPositions(l, h, c, d, g, u);
          h = k.y, y = k.barHeight, d = k.yDivision, u = k.zeroW, l = k.x, w = k.barWidth, c = k.xDivision, g = k.zeroH, i.yArrj = [], i.yArrjF = [], i.yArrjVal = [], i.xArrj = [], i.xArrjF = [], i.xArrjVal = [], 1 === i.prevY.length && i.prevY[0].every(function (t) {
            return isNaN(t);
          }) && (i.prevY[0] = i.prevY[0].map(function (t) {
            return g;
          }), i.prevYF[0] = i.prevYF[0].map(function (t) {
            return 0;
          }));

          for (var A = 0; A < a.globals.dataPoints; A++) {
            var S = i.barHelpers.getStrokeWidth(s, A, b),
                C = {
              indexes: {
                i: s,
                j: A,
                realIndex: b,
                bc: r
              },
              strokeWidth: S,
              x: l,
              y: h,
              elSeries: m
            },
                L = null;
            i.isHorizontal ? (L = i.drawStackedBarPaths(n(n({}, C), {}, {
              zeroW: u,
              barHeight: y,
              yDivision: d
            })), w = i.series[s][A] / i.invertedYRatio) : (L = i.drawStackedColumnPaths(n(n({}, C), {}, {
              xDivision: c,
              barWidth: w,
              zeroH: g
            })), y = i.series[s][A] / i.yRatio[i.yaxisIndex]), h = L.y, l = L.x, p.push(l), x.push(h);
            var P = i.barHelpers.getPathFillColor(t, s, A, b);
            m = i.renderSeries({
              realIndex: b,
              pathFill: P,
              j: A,
              i: s,
              pathFrom: L.pathFrom,
              pathTo: L.pathTo,
              strokeWidth: S,
              elSeries: m,
              x: l,
              y: h,
              series: t,
              barHeight: y,
              barWidth: w,
              elDataLabelsWrap: v,
              type: "bar",
              visibleSeries: 0
            });
          }

          a.globals.seriesXvalues[b] = p, a.globals.seriesYvalues[b] = x, i.prevY.push(i.yArrj), i.prevYF.push(i.yArrjF), i.prevYVal.push(i.yArrjVal), i.prevX.push(i.xArrj), i.prevXF.push(i.xArrjF), i.prevXVal.push(i.xArrjVal), o.add(m);
        }, d = 0, g = 0; d < t.length; d++, g++) {
          c(d, g);
        }

        return o;
      }
    }, {
      key: "initialPositions",
      value: function value(t, e, i, a, s, r) {
        var n,
            o,
            l = this.w;
        return this.isHorizontal ? (n = (n = a = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight, 10) / 100, r = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (a - n) / 2) : (o = i = l.globals.gridWidth / l.globals.dataPoints, o = l.globals.isXNumeric && l.globals.dataPoints > 1 ? (i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : o * parseInt(l.config.plotOptions.bar.columnWidth, 10) / 100, s = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t = l.globals.padHorizontal + (i - o) / 2), {
          x: t,
          y: e,
          yDivision: a,
          xDivision: i,
          barHeight: n,
          barWidth: o,
          zeroH: s,
          zeroW: r
        };
      }
    }, {
      key: "drawStackedBarPaths",
      value: function value(t) {
        for (var e, i = t.indexes, a = t.barHeight, s = t.strokeWidth, r = t.zeroW, n = t.x, o = t.y, l = t.yDivision, h = t.elSeries, c = this.w, d = o, g = i.i, u = i.j, f = 0, p = 0; p < this.prevXF.length; p++) {
          f += this.prevXF[p][u];
        }

        if (g > 0) {
          var x = r;
          this.prevXVal[g - 1][u] < 0 ? x = this.series[g][u] >= 0 ? this.prevX[g - 1][u] + f - 2 * (this.isReversed ? f : 0) : this.prevX[g - 1][u] : this.prevXVal[g - 1][u] >= 0 && (x = this.series[g][u] >= 0 ? this.prevX[g - 1][u] : this.prevX[g - 1][u] - f + 2 * (this.isReversed ? f : 0)), e = x;
        } else e = r;

        n = null === this.series[g][u] ? e : e + this.series[g][u] / this.invertedYRatio - 2 * (this.isReversed ? this.series[g][u] / this.invertedYRatio : 0), this.xArrj.push(n), this.xArrjF.push(Math.abs(e - n)), this.xArrjVal.push(this.series[g][u]);
        var b = this.barHelpers.getBarpaths({
          barYPosition: d,
          barHeight: a,
          x1: e,
          x2: n,
          strokeWidth: s,
          series: this.series,
          realIndex: i.realIndex,
          i: g,
          j: u,
          w: c
        });
        return this.barHelpers.barBackground({
          j: u,
          i: g,
          y1: d,
          y2: a,
          elSeries: h
        }), o += l, {
          pathTo: b.pathTo,
          pathFrom: b.pathFrom,
          x: n,
          y: o
        };
      }
    }, {
      key: "drawStackedColumnPaths",
      value: function value(t) {
        var e = t.indexes,
            i = t.x,
            a = t.y,
            s = t.xDivision,
            r = t.barWidth,
            n = t.zeroH,
            o = (t.strokeWidth, t.elSeries),
            l = this.w,
            h = e.i,
            c = e.j,
            d = e.bc;

        if (l.globals.isXNumeric) {
          var g = l.globals.seriesX[h][c];
          g || (g = 0), i = (g - l.globals.minX) / this.xRatio - r / 2;
        }

        for (var u, f = i, p = 0, x = 0; x < this.prevYF.length; x++) {
          p += isNaN(this.prevYF[x][c]) ? 0 : this.prevYF[x][c];
        }

        if (h > 0 && !l.globals.isXNumeric || h > 0 && l.globals.isXNumeric && l.globals.seriesX[h - 1][c] === l.globals.seriesX[h][c]) {
          var b,
              m,
              v = Math.min(this.yRatio.length + 1, h + 1);
          if (void 0 !== this.prevY[h - 1]) for (var y = 1; y < v; y++) {
            if (!isNaN(this.prevY[h - y][c])) {
              m = this.prevY[h - y][c];
              break;
            }
          }

          for (var w = 1; w < v; w++) {
            if (this.prevYVal[h - w][c] < 0) {
              b = this.series[h][c] >= 0 ? m - p + 2 * (this.isReversed ? p : 0) : m;
              break;
            }

            if (this.prevYVal[h - w][c] >= 0) {
              b = this.series[h][c] >= 0 ? m : m + p - 2 * (this.isReversed ? p : 0);
              break;
            }
          }

          void 0 === b && (b = l.globals.gridHeight), u = this.prevYF[0].every(function (t) {
            return 0 === t;
          }) && this.prevYF.slice(1, h).every(function (t) {
            return t.every(function (t) {
              return isNaN(t);
            });
          }) ? l.globals.gridHeight - n : b;
        } else u = l.globals.gridHeight - n;

        a = u - this.series[h][c] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[h][c] / this.yRatio[this.yaxisIndex] : 0), this.yArrj.push(a), this.yArrjF.push(Math.abs(u - a)), this.yArrjVal.push(this.series[h][c]);
        var k = this.barHelpers.getColumnPaths({
          barXPosition: f,
          barWidth: r,
          y1: u,
          y2: a,
          yRatio: this.yRatio[this.yaxisIndex],
          strokeWidth: this.strokeWidth,
          series: this.series,
          realIndex: e.realIndex,
          i: h,
          j: c,
          w: l
        });
        return this.barHelpers.barBackground({
          bc: d,
          j: c,
          i: h,
          x1: f,
          x2: r,
          elSeries: o
        }), i += s, {
          pathTo: k.pathTo,
          pathFrom: k.pathFrom,
          x: l.globals.isXNumeric ? i - s : i,
          y: a
        };
      }
    }]), s;
  }(),
      wt = function (t) {
    o(s, F);
    var i = d(s);

    function s() {
      return e(this, s), i.apply(this, arguments);
    }

    return a(s, [{
      key: "draw",
      value: function value(t, e) {
        var i = this.w,
            a = new b(this.ctx),
            s = new T(this.ctx);
        this.candlestickOptions = this.w.config.plotOptions.candlestick;
        var r = new y(this.ctx, i);
        t = r.getLogSeries(t), this.series = t, this.yRatio = r.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);

        for (var n = a.group({
          class: "apexcharts-candlestick-series apexcharts-plot-series"
        }), o = 0; o < t.length; o++) {
          var l,
              h,
              c = void 0,
              d = void 0,
              g = [],
              u = [],
              p = i.globals.comboCharts ? e[o] : o,
              x = a.group({
            class: "apexcharts-series",
            seriesName: f.escapeString(i.globals.seriesNames[p]),
            rel: o + 1,
            "data:realIndex": p
          });
          t[o].length > 0 && (this.visibleI = this.visibleI + 1);
          var m, v;
          this.yRatio.length > 1 && (this.yaxisIndex = p);
          var w = this.barHelpers.initialPositions();
          d = w.y, m = w.barHeight, c = w.x, v = w.barWidth, l = w.xDivision, h = w.zeroH, u.push(c + v / 2);

          for (var k = a.group({
            class: "apexcharts-datalabels",
            "data:realIndex": p
          }), A = 0; A < i.globals.dataPoints; A++) {
            var S,
                C = this.barHelpers.getStrokeWidth(o, A, p),
                L = this.drawCandleStickPaths({
              indexes: {
                i: o,
                j: A,
                realIndex: p
              },
              x: c,
              y: d,
              xDivision: l,
              barWidth: v,
              zeroH: h,
              strokeWidth: C,
              elSeries: x
            });
            d = L.y, c = L.x, S = L.color, A > 0 && u.push(c + v / 2), g.push(d);
            var P = s.fillPath({
              seriesNumber: p,
              dataPointIndex: A,
              color: S,
              value: t[o][A]
            }),
                z = this.candlestickOptions.wick.useFillColor ? S : void 0;
            this.renderSeries({
              realIndex: p,
              pathFill: P,
              lineFill: z,
              j: A,
              i: o,
              pathFrom: L.pathFrom,
              pathTo: L.pathTo,
              strokeWidth: C,
              elSeries: x,
              x: c,
              y: d,
              series: t,
              barHeight: m,
              barWidth: v,
              elDataLabelsWrap: k,
              visibleSeries: this.visibleI,
              type: "candlestick"
            });
          }

          i.globals.seriesXvalues[p] = u, i.globals.seriesYvalues[p] = g, n.add(x);
        }

        return n;
      }
    }, {
      key: "drawCandleStickPaths",
      value: function value(t) {
        var e = t.indexes,
            i = t.x,
            a = (t.y, t.xDivision),
            s = t.barWidth,
            r = t.zeroH,
            n = t.strokeWidth,
            o = this.w,
            l = new b(this.ctx),
            h = e.i,
            c = e.j,
            d = !0,
            g = o.config.plotOptions.candlestick.colors.upward,
            u = o.config.plotOptions.candlestick.colors.downward,
            f = this.yRatio[this.yaxisIndex],
            p = e.realIndex,
            x = this.getOHLCValue(p, c),
            m = r,
            v = r;
        x.o > x.c && (d = !1);
        var y = Math.min(x.o, x.c),
            w = Math.max(x.o, x.c);
        o.globals.isXNumeric && (i = (o.globals.seriesX[p][c] - o.globals.minX) / this.xRatio - s / 2);
        var k = i + s * this.visibleI;
        void 0 === this.series[h][c] || null === this.series[h][c] ? y = r : (y = r - y / f, w = r - w / f, m = r - x.h / f, v = r - x.l / f);
        var A = l.move(k, r),
            S = l.move(k, y);
        return o.globals.previousPaths.length > 0 && (S = this.getPreviousPath(p, c, !0)), A = l.move(k, w) + l.line(k + s / 2, w) + l.line(k + s / 2, m) + l.line(k + s / 2, w) + l.line(k + s, w) + l.line(k + s, y) + l.line(k + s / 2, y) + l.line(k + s / 2, v) + l.line(k + s / 2, y) + l.line(k, y) + l.line(k, w - n / 2), S += l.move(k, y), o.globals.isXNumeric || (i += a), {
          pathTo: A,
          pathFrom: S,
          x: i,
          y: w,
          barXPosition: k,
          color: d ? g : u
        };
      }
    }, {
      key: "getOHLCValue",
      value: function value(t, e) {
        var i = this.w;
        return {
          o: i.globals.seriesCandleO[t][e],
          h: i.globals.seriesCandleH[t][e],
          l: i.globals.seriesCandleL[t][e],
          c: i.globals.seriesCandleC[t][e]
        };
      }
    }]), s;
  }(),
      kt = function () {
    function t(i, a) {
      e(this, t), this.ctx = i, this.w = i.w, this.xRatio = a.xRatio, this.yRatio = a.yRatio, this.negRange = !1, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }

    return a(t, [{
      key: "draw",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = i.group({
          class: "apexcharts-heatmap"
        });
        a.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
        var s = e.globals.gridWidth / e.globals.dataPoints,
            r = e.globals.gridHeight / e.globals.series.length,
            n = 0,
            o = !1;
        this.checkColorRange();
        var l = t.slice();
        e.config.yaxis[0].reversed && (o = !0, l.reverse());

        for (var h = o ? 0 : l.length - 1; o ? h < l.length : h >= 0; o ? h++ : h--) {
          var c = i.group({
            class: "apexcharts-series apexcharts-heatmap-series",
            seriesName: f.escapeString(e.globals.seriesNames[h]),
            rel: h + 1,
            "data:realIndex": h
          });

          if (this.ctx.series.addCollapsedClassToSeries(c, h), e.config.chart.dropShadow.enabled) {
            var d = e.config.chart.dropShadow;
            new p(this.ctx).dropShadow(c, d, h);
          }

          for (var g = 0, u = 0; u < l[h].length; u++) {
            var x = 1,
                m = e.config.plotOptions.heatmap.shadeIntensity,
                v = this.determineHeatColor(h, u);
            x = e.globals.hasNegs || this.negRange ? e.config.plotOptions.heatmap.reverseNegativeShade ? v.percent < 0 ? v.percent / 100 * (1.25 * m) : (1 - v.percent / 100) * (1.25 * m) : v.percent <= 0 ? 1 - (1 + v.percent / 100) * m : (1 - v.percent / 100) * m : 1 - v.percent / 100;
            var y = v.color,
                w = new f();
            if (e.config.plotOptions.heatmap.enableShades && (x < 0 && (x = 0), y = "dark" === this.w.config.theme.mode ? f.hexToRgba(w.shadeColor(-1 * x, v.color), e.config.fill.opacity) : f.hexToRgba(w.shadeColor(x, v.color), e.config.fill.opacity)), "image" === e.config.fill.type) y = new T(this.ctx).fillPath({
              seriesNumber: h,
              dataPointIndex: u,
              opacity: e.globals.hasNegs ? v.percent < 0 ? 1 - (1 + v.percent / 100) : m + v.percent / 100 : v.percent / 100,
              patternID: f.randomId(),
              width: e.config.fill.image.width ? e.config.fill.image.width : s,
              height: e.config.fill.image.height ? e.config.fill.image.height : r
            });
            var k = this.rectRadius,
                A = i.drawRect(g, n, s, r, k);

            if (A.attr({
              cx: g,
              cy: n
            }), A.node.classList.add("apexcharts-heatmap-rect"), c.add(A), A.attr({
              fill: y,
              i: h,
              index: h,
              j: u,
              val: l[h][u],
              "stroke-width": this.strokeWidth,
              stroke: e.config.plotOptions.heatmap.useFillColorAsStroke ? y : e.globals.stroke.colors[0],
              color: y
            }), A.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, A)), A.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, A)), A.node.addEventListener("mousedown", i.pathMouseDown.bind(this, A)), e.config.chart.animations.enabled && !e.globals.dataChanged) {
              var S = 1;
              e.globals.resized || (S = e.config.chart.animations.speed), this.animateHeatMap(A, g, n, s, r, S);
            }

            if (e.globals.dataChanged) {
              var C = 1;

              if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
                C = this.dynamicAnim.speed;
                var L = e.globals.previousPaths[h] && e.globals.previousPaths[h][u] && e.globals.previousPaths[h][u].color;
                L || (L = "rgba(255, 255, 255, 0)"), this.animateHeatColor(A, f.isColorHex(L) ? L : f.rgb2hex(L), f.isColorHex(y) ? y : f.rgb2hex(y), C);
              }
            }

            var P = this.calculateHeatmapDataLabels({
              x: g,
              y: n,
              i: h,
              j: u,
              heatColorProps: v,
              series: l,
              rectHeight: r,
              rectWidth: s
            });
            null !== P && c.add(P), g += s;
          }

          n += r, a.add(c);
        }

        var z = e.globals.yAxisScale[0].result.slice();
        e.config.yaxis[0].reversed ? z.unshift("") : z.push(""), e.globals.yAxisScale[0].result = z;
        var I = e.globals.gridHeight / e.globals.series.length;
        return e.config.yaxis[0].labels.offsetY = -I / 2, a;
      }
    }, {
      key: "checkColorRange",
      value: function value() {
        var t = this,
            e = this.w.config.plotOptions.heatmap;
        e.colorScale.ranges.length > 0 && e.colorScale.ranges.map(function (e, i) {
          e.from <= 0 && (t.negRange = !0);
        });
      }
    }, {
      key: "determineHeatColor",
      value: function value(t, e) {
        var i = this.w,
            a = i.globals.series[t][e],
            s = i.config.plotOptions.heatmap,
            r = s.colorScale.inverse ? e : t,
            n = i.globals.colors[r],
            o = null,
            l = Math.min.apply(Math, g(i.globals.series[t])),
            h = Math.max.apply(Math, g(i.globals.series[t]));
        s.distributed || (l = i.globals.minY, h = i.globals.maxY), void 0 !== s.colorScale.min && (l = s.colorScale.min < i.globals.minY ? s.colorScale.min : i.globals.minY, h = s.colorScale.max > i.globals.maxY ? s.colorScale.max : i.globals.maxY);
        var c = Math.abs(h) + Math.abs(l),
            d = 100 * a / (0 === c ? c - 1e-6 : c);
        s.colorScale.ranges.length > 0 && s.colorScale.ranges.map(function (t, e) {
          if (a >= t.from && a <= t.to) {
            n = t.color, o = t.foreColor ? t.foreColor : null, l = t.from, h = t.to;
            var i = Math.abs(h) + Math.abs(l);
            d = 100 * a / (0 === i ? i - 1e-6 : i);
          }
        });
        return {
          color: n,
          foreColor: o,
          percent: d
        };
      }
    }, {
      key: "calculateHeatmapDataLabels",
      value: function value(t) {
        var e = t.x,
            i = t.y,
            a = t.i,
            s = t.j,
            r = t.heatColorProps,
            n = (t.series, t.rectHeight),
            o = t.rectWidth,
            l = this.w,
            h = l.config.dataLabels,
            c = new b(this.ctx),
            d = new M(this.ctx),
            g = h.formatter,
            u = null;

        if (h.enabled) {
          u = c.group({
            class: "apexcharts-data-labels"
          });
          var f = h.offsetX,
              p = h.offsetY,
              x = e + o / 2 + f,
              m = i + n / 2 + parseFloat(h.style.fontSize) / 3 + p,
              v = g(l.globals.series[a][s], {
            seriesIndex: a,
            dataPointIndex: s,
            w: l
          });
          d.plotDataLabelsText({
            x: x,
            y: m,
            text: v,
            i: a,
            j: s,
            color: r.foreColor,
            parent: u,
            dataLabelsConfig: h
          });
        }

        return u;
      }
    }, {
      key: "animateHeatMap",
      value: function value(t, e, i, a, s, r) {
        var n = new x(this.ctx);
        n.animateRect(t, {
          x: e + a / 2,
          y: i + s / 2,
          width: 0,
          height: 0
        }, {
          x: e,
          y: i,
          width: a,
          height: s
        }, r, function () {
          n.animationCompleted(t);
        });
      }
    }, {
      key: "animateHeatColor",
      value: function value(t, e, i, a) {
        t.attr({
          fill: e
        }).animate(a).attr({
          fill: i
        });
      }
    }]), t;
  }(),
      At = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "drawYAxisTexts",
      value: function value(t, e, i, a) {
        var s = this.w,
            r = s.config.yaxis[0],
            n = s.globals.yLabelFormatters[0];
        return new b(this.ctx).drawText({
          x: t + r.labels.offsetX,
          y: e + r.labels.offsetY,
          text: n(a, i),
          textAnchor: "middle",
          fontSize: r.labels.style.fontSize,
          fontFamily: r.labels.style.fontFamily,
          foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[i] : r.labels.style.colors
        });
      }
    }]), t;
  }(),
      St = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
      var a = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors, this.defaultSize = a.globals.svgHeight < a.globals.svgWidth ? a.globals.gridHeight : a.globals.gridWidth, this.centerY = this.defaultSize / 2, this.centerX = a.globals.gridWidth / 2, this.fullAngle = 360, a.globals.radialSize = this.defaultSize / 2.05 - a.config.stroke.width - (a.config.chart.sparkline.enabled ? 0 : a.config.chart.dropShadow.blur), this.donutSize = a.globals.radialSize * parseInt(a.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }

    return a(t, [{
      key: "draw",
      value: function value(t) {
        var e = this,
            i = this.w,
            a = new b(this.ctx);
        if (this.ret = a.group({
          class: "apexcharts-pie"
        }), i.globals.noData) return this.ret;

        for (var s = 0, r = 0; r < t.length; r++) {
          s += f.negToZero(t[r]);
        }

        var n = [],
            o = a.group();
        0 === s && (s = 1e-5), t.forEach(function (t) {
          e.maxY = Math.max(e.maxY, t);
        }), "polarArea" === this.chartType && this.drawPolarElements();

        for (var l = 0; l < t.length; l++) {
          var h = this.fullAngle * f.negToZero(t[l]) / s;
          n.push(h), "polarArea" === this.chartType ? (n[l] = this.fullAngle / t.length, this.sliceSizes.push(i.globals.radialSize * t[l] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
        }

        if (i.globals.dataChanged) {
          for (var c, d = 0, g = 0; g < i.globals.previousPaths.length; g++) {
            d += f.negToZero(i.globals.previousPaths[g]);
          }

          for (var u = 0; u < i.globals.previousPaths.length; u++) {
            c = this.fullAngle * f.negToZero(i.globals.previousPaths[u]) / d, this.prevSectorAngleArr.push(c);
          }
        }

        this.donutSize < 0 && (this.donutSize = 0);
        var p = i.config.plotOptions.pie.customScale,
            x = i.globals.gridWidth / 2,
            m = i.globals.gridHeight / 2,
            v = x - i.globals.gridWidth / 2 * p,
            y = m - i.globals.gridHeight / 2 * p;

        if ("donut" === this.chartType) {
          var w = a.drawCircle(this.donutSize);
          w.attr({
            cx: this.centerX,
            cy: this.centerY,
            fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
          }), o.add(w);
        }

        var k = this.drawArcs(n, t);

        if (this.sliceLabels.forEach(function (t) {
          k.add(t);
        }), o.attr({
          transform: "translate(".concat(v, ", ").concat(y, ") scale(").concat(p, ")")
        }), o.add(k), this.ret.add(o), this.donutDataLabels.show) {
          var A = this.renderInnerDataLabels(this.donutDataLabels, {
            hollowSize: this.donutSize,
            centerX: this.centerX,
            centerY: this.centerY,
            opacity: this.donutDataLabels.show,
            translateX: v,
            translateY: y
          });
          this.ret.add(A);
        }

        return this.ret;
      }
    }, {
      key: "drawArcs",
      value: function value(t, e) {
        var i = this.w,
            a = new p(this.ctx),
            s = new b(this.ctx),
            r = new T(this.ctx),
            n = s.group({
          class: "apexcharts-slices"
        }),
            o = i.config.plotOptions.pie.startAngle % this.fullAngle,
            l = o,
            h = o,
            c = o,
            d = o;
        this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;

        for (var g = 0; g < t.length; g++) {
          var u = s.group({
            class: "apexcharts-series apexcharts-pie-series",
            seriesName: f.escapeString(i.globals.seriesNames[g]),
            rel: g + 1,
            "data:realIndex": g
          });
          n.add(u), h = d, c = (l = c) + t[g], d = h + this.prevSectorAngleArr[g];
          var x = c < l ? this.fullAngle + c - l : c - l,
              m = r.fillPath({
            seriesNumber: g,
            size: this.sliceSizes[g],
            value: e[g]
          }),
              v = this.getChangedPath(h, d),
              y = s.drawPath({
            d: v,
            stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[g] : this.lineColorArr,
            strokeWidth: 0,
            fill: m,
            fillOpacity: i.config.fill.opacity,
            classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(g)
          });

          if (y.attr({
            index: 0,
            j: g
          }), i.config.chart.dropShadow.enabled) {
            var w = i.config.chart.dropShadow;
            a.dropShadow(y, w, g);
          }

          this.addListeners(y, this.donutDataLabels), b.setAttrs(y.node, {
            "data:angle": x,
            "data:startAngle": l,
            "data:strokeWidth": this.strokeWidth,
            "data:value": e[g]
          });
          var k = {
            x: 0,
            y: 0
          };
          "pie" === this.chartType || "polarArea" === this.chartType ? k = f.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (l + x / 2) % this.fullAngle) : "donut" === this.chartType && (k = f.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (l + x / 2) % this.fullAngle)), u.add(y);
          var A = 0;

          if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (A = x / this.fullAngle * i.config.chart.animations.speed) && (A = 1), this.animDur = A + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(y, {
            size: this.sliceSizes[g],
            endAngle: c,
            startAngle: l,
            prevStartAngle: h,
            prevEndAngle: d,
            animateStartingPos: !0,
            i: g,
            animBeginArr: this.animBeginArr,
            shouldSetPrevPaths: !0,
            dur: i.config.chart.animations.dynamicAnimation.speed
          }) : this.animatePaths(y, {
            size: this.sliceSizes[g],
            endAngle: c,
            startAngle: l,
            i: g,
            totalItems: t.length - 1,
            animBeginArr: this.animBeginArr,
            dur: A
          }), i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && y.click(this.pieClicked.bind(this, g)), i.config.dataLabels.enabled) {
            var S = k.x,
                C = k.y,
                L = 100 * x / this.fullAngle + "%";

            if (0 !== x && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[g]) {
              var P = i.config.dataLabels.formatter;
              void 0 !== P && (L = P(i.globals.seriesPercent[g][0], {
                seriesIndex: g,
                w: i
              }));
              var z = i.globals.dataLabels.style.colors[g],
                  I = s.group({
                class: "apexcharts-datalabels"
              }),
                  M = s.drawText({
                x: S,
                y: C,
                text: L,
                textAnchor: "middle",
                fontSize: i.config.dataLabels.style.fontSize,
                fontFamily: i.config.dataLabels.style.fontFamily,
                fontWeight: i.config.dataLabels.style.fontWeight,
                foreColor: z
              });

              if (I.add(M), i.config.dataLabels.dropShadow.enabled) {
                var E = i.config.dataLabels.dropShadow;
                a.dropShadow(M, E);
              }

              M.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && !1 === i.globals.resized && (M.node.classList.add("apexcharts-pie-label-delay"), M.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(I);
            }
          }
        }

        return n;
      }
    }, {
      key: "addListeners",
      value: function value(t, e) {
        var i = new b(this.ctx);
        t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, e)));
      }
    }, {
      key: "animatePaths",
      value: function value(t, e) {
        var i = this.w,
            a = e.endAngle < e.startAngle ? this.fullAngle + e.endAngle - e.startAngle : e.endAngle - e.startAngle,
            s = a,
            r = e.startAngle,
            n = e.startAngle;
        void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (r = e.prevEndAngle, s = e.prevEndAngle < e.prevStartAngle ? this.fullAngle + e.prevEndAngle - e.prevStartAngle : e.prevEndAngle - e.prevStartAngle), e.i === i.config.series.length - 1 && (a + n > this.fullAngle ? e.endAngle = e.endAngle - (a + n) : a + n < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (a + n)))), a === this.fullAngle && (a = this.fullAngle - .01), this.animateArc(t, r, n, a, s, e);
      }
    }, {
      key: "animateArc",
      value: function value(t, e, i, a, s, r) {
        var n,
            o = this,
            l = this.w,
            h = new x(this.ctx),
            c = r.size;
        (isNaN(e) || isNaN(s)) && (e = i, s = a, r.dur = 0);
        var d = a,
            g = i,
            u = e < i ? this.fullAngle + e - i : e - i;
        l.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (n = o.getPiePath({
          me: o,
          startAngle: r.prevStartAngle,
          angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
          size: c
        }), t.attr({
          d: n
        })), 0 !== r.dur ? t.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll(function () {
          "pie" !== o.chartType && "donut" !== o.chartType && "polarArea" !== o.chartType || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({
            "stroke-width": o.strokeWidth
          }), r.i === l.config.series.length - 1 && h.animationCompleted(t);
        }).during(function (l) {
          d = u + (a - u) * l, r.animateStartingPos && (d = s + (a - s) * l, g = e - s + (i - (e - s)) * l), n = o.getPiePath({
            me: o,
            startAngle: g,
            angle: d,
            size: c
          }), t.node.setAttribute("data:pathOrig", n), t.attr({
            d: n
          });
        }) : (n = o.getPiePath({
          me: o,
          startAngle: g,
          angle: a,
          size: c
        }), r.isTrack || (l.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", n), t.attr({
          d: n,
          "stroke-width": o.strokeWidth
        }));
      }
    }, {
      key: "pieClicked",
      value: function value(t) {
        var e,
            i = this.w,
            a = this.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0),
            s = i.globals.dom.Paper.select(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(t)).members[0];

        if ("true" !== s.attr("data:pieClicked")) {
          var r = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
          Array.prototype.forEach.call(r, function (t) {
            t.setAttribute("data:pieClicked", "false");
            var e = t.getAttribute("data:pathOrig");
            t.setAttribute("d", e);
          }), s.attr("data:pieClicked", "true");
          var n = parseInt(s.attr("data:startAngle"), 10),
              o = parseInt(s.attr("data:angle"), 10);
          e = this.getPiePath({
            me: this,
            startAngle: n,
            angle: o,
            size: a
          }), 360 !== o && s.plot(e);
        } else {
          s.attr({
            "data:pieClicked": "false"
          }), this.revertDataLabelsInner(s.node, this.donutDataLabels);
          var l = s.attr("data:pathOrig");
          s.attr({
            d: l
          });
        }
      }
    }, {
      key: "getChangedPath",
      value: function value(t, e) {
        var i = "";
        return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
          me: this,
          startAngle: t,
          angle: e - t,
          size: this.size
        })), i;
      }
    }, {
      key: "getPiePath",
      value: function value(t) {
        var e = t.me,
            i = t.startAngle,
            a = t.angle,
            s = t.size,
            r = i,
            n = Math.PI * (r - 90) / 180,
            o = a + i;
        Math.ceil(o) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (o = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(o) > this.fullAngle && (o -= this.fullAngle);
        var l = Math.PI * (o - 90) / 180,
            h = e.centerX + s * Math.cos(n),
            c = e.centerY + s * Math.sin(n),
            d = e.centerX + s * Math.cos(l),
            g = e.centerY + s * Math.sin(l),
            u = f.polarToCartesian(e.centerX, e.centerY, e.donutSize, o),
            p = f.polarToCartesian(e.centerX, e.centerY, e.donutSize, r),
            x = a > 180 ? 1 : 0,
            b = ["M", h, c, "A", s, s, 0, x, 1, d, g];
        return "donut" === e.chartType ? [].concat(b, ["L", u.x, u.y, "A", e.donutSize, e.donutSize, 0, x, 0, p.x, p.y, "L", h, c, "z"]).join(" ") : "pie" === e.chartType || "polarArea" === e.chartType ? [].concat(b, ["L", e.centerX, e.centerY, "L", h, c]).join(" ") : [].concat(b).join(" ");
      }
    }, {
      key: "drawPolarElements",
      value: function value() {
        var t = this.w,
            e = new q(this.ctx),
            i = new b(this.ctx),
            a = new At(this.ctx),
            s = i.group(),
            r = i.group(),
            n = void 0 === t.config.yaxis[0].max && void 0 === t.config.yaxis[0].min,
            o = e.niceScale(0, Math.ceil(this.maxY), t.config.yaxis[0].tickAmount, 0, n),
            l = o.result.reverse(),
            h = o.result.length;
        this.maxY = o.niceMax;

        for (var c = t.globals.radialSize, d = c / (h - 1), g = 0; g < h - 1; g++) {
          var u = i.drawCircle(c);

          if (u.attr({
            cx: this.centerX,
            cy: this.centerY,
            fill: "none",
            "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth,
            stroke: t.config.plotOptions.polarArea.rings.strokeColor
          }), t.config.yaxis[0].show) {
            var f = a.drawYAxisTexts(this.centerX, this.centerY - c + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, g, l[g]);
            r.add(f);
          }

          s.add(u), c -= d;
        }

        this.ret.add(s), this.ret.add(r);
      }
    }, {
      key: "renderInnerDataLabels",
      value: function value(t, e) {
        var i = this.w,
            a = new b(this.ctx),
            s = a.group({
          class: "apexcharts-datalabels-group",
          transform: "translate(".concat(e.translateX ? e.translateX : 0, ", ").concat(e.translateY ? e.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")
        }),
            r = t.total.show;
        s.node.style.opacity = e.opacity;
        var n,
            o,
            l = e.centerX,
            h = e.centerY;
        n = void 0 === t.name.color ? i.globals.colors[0] : t.name.color;
        var c = t.name.fontSize,
            d = t.name.fontFamily,
            g = t.value.fontWeight;
        o = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color;
        var u = t.value.formatter,
            f = "",
            p = "";

        if (r ? (n = t.total.color, c = t.total.fontSize, d = t.total.fontFamily, g = t.total.fontWeight, p = t.total.label, f = t.total.formatter(i)) : 1 === i.globals.series.length && (f = u(i.globals.series[0], i), p = i.globals.seriesNames[0]), p && (p = t.name.formatter(p, t.total.show, i)), t.name.show) {
          var x = a.drawText({
            x: l,
            y: h + parseFloat(t.name.offsetY),
            text: p,
            textAnchor: "middle",
            foreColor: n,
            fontSize: c,
            fontWeight: g,
            fontFamily: d
          });
          x.node.classList.add("apexcharts-datalabel-label"), s.add(x);
        }

        if (t.value.show) {
          var m = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY,
              v = a.drawText({
            x: l,
            y: h + m,
            text: f,
            textAnchor: "middle",
            foreColor: o,
            fontWeight: t.value.fontWeight,
            fontSize: t.value.fontSize,
            fontFamily: t.value.fontFamily
          });
          v.node.classList.add("apexcharts-datalabel-value"), s.add(v);
        }

        return s;
      }
    }, {
      key: "printInnerLabels",
      value: function value(t, e, i, a) {
        var s,
            r = this.w;
        a ? s = void 0 === t.name.color ? r.globals.colors[parseInt(a.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : r.globals.series.length > 1 && t.total.show && (s = t.total.color);
        var n = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
            o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
        i = (0, t.value.formatter)(i, r), a || "function" != typeof t.total.formatter || (i = t.total.formatter(r));
        var l = e === t.total.label;
        e = t.name.formatter(e, l, r), null !== n && (n.textContent = e), null !== o && (o.textContent = i), null !== n && (n.style.fill = s);
      }
    }, {
      key: "printDataLabelsInner",
      value: function value(t, e) {
        var i = this.w,
            a = t.getAttribute("data:value"),
            s = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
        i.globals.series.length > 1 && this.printInnerLabels(e, s, a, t);
        var r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
        null !== r && (r.style.opacity = 1);
      }
    }, {
      key: "revertDataLabelsInner",
      value: function value(t, e, i) {
        var a = this,
            s = this.w,
            r = s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
            n = !1,
            o = s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),
            l = function l(t) {
          var i = t.makeSliceOut,
              s = t.printLabel;
          Array.prototype.forEach.call(o, function (t) {
            "true" === t.getAttribute("data:pieClicked") && (i && (n = !0), s && a.printDataLabelsInner(t, e));
          });
        };

        if (l({
          makeSliceOut: !0,
          printLabel: !1
        }), e.total.show && s.globals.series.length > 1) n && !e.total.showAlways ? l({
          makeSliceOut: !1,
          printLabel: !0
        }) : this.printInnerLabels(e, e.total.label, e.total.formatter(s));else if (l({
          makeSliceOut: !1,
          printLabel: !0
        }), !n) if (s.globals.selectedDataPoints.length && s.globals.series.length > 1) {
          if (s.globals.selectedDataPoints[0].length > 0) {
            var h = s.globals.selectedDataPoints[0],
                c = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(h));
            this.printDataLabelsInner(c, e);
          } else r && s.globals.selectedDataPoints.length && 0 === s.globals.selectedDataPoints[0].length && (r.style.opacity = 0);
        } else r && s.globals.series.length > 1 && (r.style.opacity = 0);
      }
    }]), t;
  }(),
      Ct = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var a = this.w;
      this.graphics = new b(this.ctx), this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors, this.defaultSize = a.globals.svgHeight < a.globals.svgWidth ? a.globals.gridHeight + 1.5 * a.globals.goldenPadding : a.globals.gridWidth, this.maxValue = this.w.globals.maxY, this.minValue = this.w.globals.minY, this.polygons = a.config.plotOptions.radar.polygons, this.strokeWidth = a.config.stroke.show ? a.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a.config.chart.dropShadow.blur, a.config.xaxis.labels.show && (this.size = this.size - a.globals.xAxisLabelsWidth / 1.75), void 0 !== a.config.plotOptions.radar.size && (this.size = a.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }

    return a(t, [{
      key: "draw",
      value: function value(t) {
        var e = this,
            i = this.w,
            a = new T(this.ctx),
            s = [],
            r = new M(this.ctx);
        t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
        var o = i.globals.gridWidth / 2,
            l = i.globals.gridHeight / 2,
            h = o + i.config.plotOptions.radar.offsetX,
            c = l + i.config.plotOptions.radar.offsetY,
            d = this.graphics.group({
          class: "apexcharts-radar-series apexcharts-plot-series",
          transform: "translate(".concat(h || 0, ", ").concat(c || 0, ")")
        }),
            g = [],
            u = null,
            x = null;

        if (this.yaxisLabels = this.graphics.group({
          class: "apexcharts-yaxis"
        }), t.forEach(function (t, o) {
          var l = t.length === i.globals.dataPoints,
              h = e.graphics.group().attr({
            class: "apexcharts-series",
            "data:longestSeries": l,
            seriesName: f.escapeString(i.globals.seriesNames[o]),
            rel: o + 1,
            "data:realIndex": o
          });
          e.dataRadiusOfPercent[o] = [], e.dataRadius[o] = [], e.angleArr[o] = [], t.forEach(function (t, i) {
            var a = Math.abs(e.maxValue - e.minValue);
            t += Math.abs(e.minValue), e.dataRadiusOfPercent[o][i] = t / a, e.dataRadius[o][i] = e.dataRadiusOfPercent[o][i] * e.size, e.angleArr[o][i] = i * e.disAngle;
          }), g = e.getDataPointsPos(e.dataRadius[o], e.angleArr[o]);
          var c = e.createPaths(g, {
            x: 0,
            y: 0
          });
          u = e.graphics.group({
            class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
          }), x = e.graphics.group({
            class: "apexcharts-datalabels",
            "data:realIndex": o
          }), i.globals.delayedElements.push({
            el: u.node,
            index: o
          });
          var d = {
            i: o,
            realIndex: o,
            animationDelay: o,
            initialSpeed: i.config.chart.animations.speed,
            dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
            className: "apexcharts-radar",
            shouldClipToGrid: !1,
            bindEventsOnPaths: !1,
            stroke: i.globals.stroke.colors[o],
            strokeLineCap: i.config.stroke.lineCap
          },
              b = null;
          i.globals.previousPaths.length > 0 && (b = e.getPreviousPath(o));

          for (var m = 0; m < c.linePathsTo.length; m++) {
            var v = e.graphics.renderPaths(n(n({}, d), {}, {
              pathFrom: null === b ? c.linePathsFrom[m] : b,
              pathTo: c.linePathsTo[m],
              strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[o] : e.strokeWidth,
              fill: "none",
              drawShadow: !1
            }));
            h.add(v);
            var y = a.fillPath({
              seriesNumber: o
            }),
                w = e.graphics.renderPaths(n(n({}, d), {}, {
              pathFrom: null === b ? c.areaPathsFrom[m] : b,
              pathTo: c.areaPathsTo[m],
              strokeWidth: 0,
              fill: y,
              drawShadow: !1
            }));

            if (i.config.chart.dropShadow.enabled) {
              var k = new p(e.ctx),
                  A = i.config.chart.dropShadow;
              k.dropShadow(w, Object.assign({}, A, {
                noUserSpaceOnUse: !0
              }), o);
            }

            h.add(w);
          }

          t.forEach(function (t, a) {
            var s = new z(e.ctx).getMarkerConfig("apexcharts-marker", o, a),
                l = e.graphics.drawMarker(g[a].x, g[a].y, s);
            l.attr("rel", a), l.attr("j", a), l.attr("index", o), l.node.setAttribute("default-marker-size", s.pSize);
            var c = e.graphics.group({
              class: "apexcharts-series-markers"
            });
            c && c.add(l), u.add(c), h.add(u);
            var d = i.config.dataLabels;

            if (d.enabled) {
              var f = d.formatter(i.globals.series[o][a], {
                seriesIndex: o,
                dataPointIndex: a,
                w: i
              });
              r.plotDataLabelsText({
                x: g[a].x,
                y: g[a].y,
                text: f,
                textAnchor: "middle",
                i: o,
                j: o,
                parent: x,
                offsetCorrection: !1,
                dataLabelsConfig: n({}, d)
              });
            }

            h.add(x);
          }), s.push(h);
        }), this.drawPolygons({
          parent: d
        }), i.config.xaxis.labels.show) {
          var b = this.drawXAxisTexts();
          d.add(b);
        }

        return d.add(this.yaxisLabels), s.forEach(function (t) {
          d.add(t);
        }), d;
      }
    }, {
      key: "drawPolygons",
      value: function value(t) {
        for (var e = this, i = this.w, a = t.parent, s = new At(this.ctx), r = i.globals.yAxisScale[0].result.reverse(), n = r.length, o = [], l = this.size / (n - 1), h = 0; h < n; h++) {
          o[h] = l * h;
        }

        o.reverse();
        var c = [],
            d = [];
        o.forEach(function (t, i) {
          var a = e.getPolygonPos(t),
              s = "";
          a.forEach(function (t, a) {
            if (0 === i) {
              var r = e.graphics.drawLine(t.x, t.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[a] : e.polygons.connectorColors);
              d.push(r);
            }

            0 === a && e.yaxisLabelsTextsPos.push({
              x: t.x,
              y: t.y
            }), s += t.x + "," + t.y + " ";
          }), c.push(s);
        }), c.forEach(function (t, s) {
          var r = e.polygons.strokeColors,
              n = e.polygons.strokeWidth,
              o = e.graphics.drawPolygon(t, Array.isArray(r) ? r[s] : r, Array.isArray(n) ? n[s] : n, i.globals.radarPolygons.fill.colors[s]);
          a.add(o);
        }), d.forEach(function (t) {
          a.add(t);
        }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function (t, i) {
          var a = s.drawYAxisTexts(t.x, t.y, i, r[i]);
          e.yaxisLabels.add(a);
        });
      }
    }, {
      key: "drawXAxisTexts",
      value: function value() {
        var t = this,
            e = this.w,
            i = e.config.xaxis.labels,
            a = this.graphics.group({
          class: "apexcharts-xaxis"
        }),
            s = this.getPolygonPos(this.size);
        return e.globals.labels.forEach(function (r, o) {
          var l = e.config.xaxis.labels.formatter,
              h = new M(t.ctx);

          if (s[o]) {
            var c = t.getTextPos(s[o], t.size),
                d = l(r, {
              seriesIndex: -1,
              dataPointIndex: o,
              w: e
            });
            h.plotDataLabelsText({
              x: c.newX,
              y: c.newY,
              text: d,
              textAnchor: c.textAnchor,
              i: o,
              j: o,
              parent: a,
              color: i.style.colors[o] ? i.style.colors[o] : "#a8a8a8",
              dataLabelsConfig: n({
                textAnchor: c.textAnchor,
                dropShadow: {
                  enabled: !1
                }
              }, i),
              offsetCorrection: !1
            });
          }
        }), a;
      }
    }, {
      key: "createPaths",
      value: function value(t, e) {
        var i = this,
            a = [],
            s = [],
            r = [],
            n = [];

        if (t.length) {
          s = [this.graphics.move(e.x, e.y)], n = [this.graphics.move(e.x, e.y)];
          var o = this.graphics.move(t[0].x, t[0].y),
              l = this.graphics.move(t[0].x, t[0].y);
          t.forEach(function (e, a) {
            o += i.graphics.line(e.x, e.y), l += i.graphics.line(e.x, e.y), a === t.length - 1 && (o += "Z", l += "Z");
          }), a.push(o), r.push(l);
        }

        return {
          linePathsFrom: s,
          linePathsTo: a,
          areaPathsFrom: n,
          areaPathsTo: r
        };
      }
    }, {
      key: "getTextPos",
      value: function value(t, e) {
        var i = "middle",
            a = t.x,
            s = t.y;
        return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = "start", a += 10) : t.x < 0 && (i = "end", a -= 10) : i = "middle", Math.abs(t.y) >= e - 10 && (t.y < 0 ? s -= 10 : t.y > 0 && (s += 10)), {
          textAnchor: i,
          newX: a,
          newY: s
        };
      }
    }, {
      key: "getPreviousPath",
      value: function value(t) {
        for (var e = this.w, i = null, a = 0; a < e.globals.previousPaths.length; a++) {
          var s = e.globals.previousPaths[a];
          s.paths.length > 0 && parseInt(s.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[a].paths[0] && (i = e.globals.previousPaths[a].paths[0].d);
        }

        return i;
      }
    }, {
      key: "getDataPointsPos",
      value: function value(t, e) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
        t = t || [], e = e || [];

        for (var a = [], s = 0; s < i; s++) {
          var r = {};
          r.x = t[s] * Math.sin(e[s]), r.y = -t[s] * Math.cos(e[s]), a.push(r);
        }

        return a;
      }
    }, {
      key: "getPolygonPos",
      value: function value(t) {
        for (var e = [], i = 2 * Math.PI / this.dataPointsLen, a = 0; a < this.dataPointsLen; a++) {
          var s = {};
          s.x = t * Math.sin(a * i), s.y = -t * Math.cos(a * i), e.push(s);
        }

        return e;
      }
    }]), t;
  }(),
      Lt = function (t) {
    o(s, St);
    var i = d(s);

    function s(t) {
      var a;
      e(this, s), (a = i.call(this, t)).ctx = t, a.w = t.w, a.animBeginArr = [0], a.animDur = 0;
      var r = a.w;
      return a.startAngle = r.config.plotOptions.radialBar.startAngle, a.endAngle = r.config.plotOptions.radialBar.endAngle, a.totalAngle = Math.abs(r.config.plotOptions.radialBar.endAngle - r.config.plotOptions.radialBar.startAngle), a.trackStartAngle = r.config.plotOptions.radialBar.track.startAngle, a.trackEndAngle = r.config.plotOptions.radialBar.track.endAngle, a.radialDataLabels = r.config.plotOptions.radialBar.dataLabels, a.trackStartAngle || (a.trackStartAngle = a.startAngle), a.trackEndAngle || (a.trackEndAngle = a.endAngle), 360 === a.endAngle && (a.endAngle = 359.99), a.margin = parseInt(r.config.plotOptions.radialBar.track.margin, 10), a;
    }

    return a(s, [{
      key: "draw",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = i.group({
          class: "apexcharts-radialbar"
        });
        if (e.globals.noData) return a;
        var s = i.group(),
            r = this.defaultSize / 2,
            n = e.globals.gridWidth / 2,
            o = this.defaultSize / 2.05;
        e.config.chart.sparkline.enabled || (o = o - e.config.stroke.width - e.config.chart.dropShadow.blur);
        var l = e.globals.fill.colors;

        if (e.config.plotOptions.radialBar.track.show) {
          var h = this.drawTracks({
            size: o,
            centerX: n,
            centerY: r,
            colorArr: l,
            series: t
          });
          s.add(h);
        }

        var c = this.drawArcs({
          size: o,
          centerX: n,
          centerY: r,
          colorArr: l,
          series: t
        }),
            d = 360;
        e.config.plotOptions.radialBar.startAngle < 0 && (d = this.totalAngle);
        var g = (360 - d) / 360;

        if (e.globals.radialSize = o - o * g, this.radialDataLabels.value.show) {
          var u = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
          e.globals.radialSize += u * g;
        }

        return s.add(c.g), "front" === e.config.plotOptions.radialBar.hollow.position && (c.g.add(c.elHollow), c.dataLabels && c.g.add(c.dataLabels)), a.add(s), a;
      }
    }, {
      key: "drawTracks",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = i.group({
          class: "apexcharts-tracks"
        }),
            s = new p(this.ctx),
            r = new T(this.ctx),
            n = this.getStrokeWidth(t);
        t.size = t.size - n / 2;

        for (var o = 0; o < t.series.length; o++) {
          var l = i.group({
            class: "apexcharts-radialbar-track apexcharts-track"
          });
          a.add(l), l.attr({
            rel: o + 1
          }), t.size = t.size - n - this.margin;
          var h = e.config.plotOptions.radialBar.track,
              c = r.fillPath({
            seriesNumber: 0,
            size: t.size,
            fillColors: Array.isArray(h.background) ? h.background[o] : h.background,
            solid: !0
          }),
              d = this.trackStartAngle,
              g = this.trackEndAngle;
          Math.abs(g) + Math.abs(d) >= 360 && (g = 360 - Math.abs(this.startAngle) - .1);
          var u = i.drawPath({
            d: "",
            stroke: c,
            strokeWidth: n * parseInt(h.strokeWidth, 10) / 100,
            fill: "none",
            strokeOpacity: h.opacity,
            classes: "apexcharts-radialbar-area"
          });

          if (h.dropShadow.enabled) {
            var f = h.dropShadow;
            s.dropShadow(u, f);
          }

          l.add(u), u.attr("id", "apexcharts-radialbarTrack-" + o), this.animatePaths(u, {
            centerX: t.centerX,
            centerY: t.centerY,
            endAngle: g,
            startAngle: d,
            size: t.size,
            i: o,
            totalItems: 2,
            animBeginArr: 0,
            dur: 0,
            isTrack: !0,
            easing: e.globals.easing
          });
        }

        return a;
      }
    }, {
      key: "drawArcs",
      value: function value(t) {
        var e = this.w,
            i = new b(this.ctx),
            a = new T(this.ctx),
            s = new p(this.ctx),
            r = i.group(),
            n = this.getStrokeWidth(t);
        t.size = t.size - n / 2;
        var o = e.config.plotOptions.radialBar.hollow.background,
            l = t.size - n * t.series.length - this.margin * t.series.length - n * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2,
            h = l - e.config.plotOptions.radialBar.hollow.margin;
        void 0 !== e.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t, r, l, o));
        var c = this.drawHollow({
          size: h,
          centerX: t.centerX,
          centerY: t.centerY,
          fill: o || "transparent"
        });

        if (e.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
          var d = e.config.plotOptions.radialBar.hollow.dropShadow;
          s.dropShadow(c, d);
        }

        var g = 1;
        !this.radialDataLabels.total.show && e.globals.series.length > 1 && (g = 0);
        var u = null;
        this.radialDataLabels.show && (u = this.renderInnerDataLabels(this.radialDataLabels, {
          hollowSize: l,
          centerX: t.centerX,
          centerY: t.centerY,
          opacity: g
        })), "back" === e.config.plotOptions.radialBar.hollow.position && (r.add(c), u && r.add(u));
        var x = !1;
        e.config.plotOptions.radialBar.inverseOrder && (x = !0);

        for (var m = x ? t.series.length - 1 : 0; x ? m >= 0 : m < t.series.length; x ? m-- : m++) {
          var v = i.group({
            class: "apexcharts-series apexcharts-radial-series",
            seriesName: f.escapeString(e.globals.seriesNames[m])
          });
          r.add(v), v.attr({
            rel: m + 1,
            "data:realIndex": m
          }), this.ctx.series.addCollapsedClassToSeries(v, m), t.size = t.size - n - this.margin;
          var y = a.fillPath({
            seriesNumber: m,
            size: t.size,
            value: t.series[m]
          }),
              w = this.startAngle,
              k = void 0,
              A = f.negToZero(t.series[m] > 100 ? 100 : t.series[m]) / 100,
              S = Math.round(this.totalAngle * A) + this.startAngle,
              C = void 0;
          e.globals.dataChanged && (k = this.startAngle, C = Math.round(this.totalAngle * f.negToZero(e.globals.previousPaths[m]) / 100) + k), Math.abs(S) + Math.abs(w) >= 360 && (S -= .01), Math.abs(C) + Math.abs(k) >= 360 && (C -= .01);
          var L = S - w,
              P = Array.isArray(e.config.stroke.dashArray) ? e.config.stroke.dashArray[m] : e.config.stroke.dashArray,
              z = i.drawPath({
            d: "",
            stroke: y,
            strokeWidth: n,
            fill: "none",
            fillOpacity: e.config.fill.opacity,
            classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + m,
            strokeDashArray: P
          });

          if (b.setAttrs(z.node, {
            "data:angle": L,
            "data:value": t.series[m]
          }), e.config.chart.dropShadow.enabled) {
            var I = e.config.chart.dropShadow;
            s.dropShadow(z, I, m);
          }

          this.addListeners(z, this.radialDataLabels), v.add(z), z.attr({
            index: 0,
            j: m
          });
          var M = 0;
          !this.initialAnim || e.globals.resized || e.globals.dataChanged || (M = (S - w) / 360 * e.config.chart.animations.speed, this.animDur = M / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), e.globals.dataChanged && (M = (S - w) / 360 * e.config.chart.animations.dynamicAnimation.speed, this.animDur = M / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(z, {
            centerX: t.centerX,
            centerY: t.centerY,
            endAngle: S,
            startAngle: w,
            prevEndAngle: C,
            prevStartAngle: k,
            size: t.size,
            i: m,
            totalItems: 2,
            animBeginArr: this.animBeginArr,
            dur: M,
            shouldSetPrevPaths: !0,
            easing: e.globals.easing
          });
        }

        return {
          g: r,
          elHollow: c,
          dataLabels: u
        };
      }
    }, {
      key: "drawHollow",
      value: function value(t) {
        var e = new b(this.ctx).drawCircle(2 * t.size);
        return e.attr({
          class: "apexcharts-radialbar-hollow",
          cx: t.centerX,
          cy: t.centerY,
          r: t.size,
          fill: t.fill
        }), e;
      }
    }, {
      key: "drawHollowImage",
      value: function value(t, e, i, a) {
        var s = this.w,
            r = new T(this.ctx),
            n = f.randomId(),
            o = s.config.plotOptions.radialBar.hollow.image;
        if (s.config.plotOptions.radialBar.hollow.imageClipped) r.clippedImgArea({
          width: i,
          height: i,
          image: o,
          patternID: "pattern".concat(s.globals.cuid).concat(n)
        }), a = "url(#pattern".concat(s.globals.cuid).concat(n, ")");else {
          var l = s.config.plotOptions.radialBar.hollow.imageWidth,
              h = s.config.plotOptions.radialBar.hollow.imageHeight;

          if (void 0 === l && void 0 === h) {
            var c = s.globals.dom.Paper.image(o).loaded(function (e) {
              this.move(t.centerX - e.width / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY);
            });
            e.add(c);
          } else {
            var d = s.globals.dom.Paper.image(o).loaded(function (e) {
              this.move(t.centerX - l / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - h / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, h);
            });
            e.add(d);
          }
        }
        return a;
      }
    }, {
      key: "getStrokeWidth",
      value: function value(t) {
        var e = this.w;
        return t.size * (100 - parseInt(e.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t.series.length + 1) - this.margin;
      }
    }]), s;
  }(),
      Pt = function () {
    function t(i) {
      e(this, t), this.w = i.w, this.lineCtx = i;
    }

    return a(t, [{
      key: "sameValueSeriesFix",
      value: function value(t, e) {
        var i = this.w;

        if ("line" === i.config.chart.type && ("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[t]) && new y(this.lineCtx.ctx, i).seriesHaveSameValues(t)) {
          var a = e[t].slice();
          a[a.length - 1] = a[a.length - 1] + 1e-6, e[t] = a;
        }

        return e;
      }
    }, {
      key: "calculatePoints",
      value: function value(t) {
        var e = t.series,
            i = t.realIndex,
            a = t.x,
            s = t.y,
            r = t.i,
            n = t.j,
            o = t.prevY,
            l = this.w,
            h = [],
            c = [];

        if (0 === n) {
          var d = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX;
          l.globals.isXNumeric && (d = (l.globals.seriesX[i][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX), h.push(d), c.push(f.isNumber(e[r][0]) ? o + l.config.markers.offsetY : null), h.push(a + l.config.markers.offsetX), c.push(f.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null);
        } else h.push(a + l.config.markers.offsetX), c.push(f.isNumber(e[r][n + 1]) ? s + l.config.markers.offsetY : null);

        return {
          x: h,
          y: c
        };
      }
    }, {
      key: "checkPreviousPaths",
      value: function value(t) {
        for (var e = t.pathFromLine, i = t.pathFromArea, a = t.realIndex, s = this.w, r = 0; r < s.globals.previousPaths.length; r++) {
          var n = s.globals.previousPaths[r];
          ("line" === n.type || "area" === n.type) && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(a, 10) && ("line" === n.type ? (this.lineCtx.appendPathFrom = !1, e = s.globals.previousPaths[r].paths[0].d) : "area" === n.type && (this.lineCtx.appendPathFrom = !1, i = s.globals.previousPaths[r].paths[0].d, s.config.stroke.show && s.globals.previousPaths[r].paths[1] && (e = s.globals.previousPaths[r].paths[1].d)));
        }

        return {
          pathFromLine: e,
          pathFromArea: i
        };
      }
    }, {
      key: "determineFirstPrevY",
      value: function value(t) {
        var e = t.i,
            i = t.series,
            a = t.prevY,
            s = t.lineYPosition,
            r = this.w;
        if (void 0 !== i[e][0]) a = (s = r.config.chart.stacked && e > 0 ? this.lineCtx.prevSeriesY[e - 1][0] : this.lineCtx.zeroY) - i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);else if (r.config.chart.stacked && e > 0 && void 0 === i[e][0]) for (var n = e - 1; n >= 0; n--) {
          if (null !== i[n][0] && void 0 !== i[n][0]) {
            a = s = this.lineCtx.prevSeriesY[n][0];
            break;
          }
        }
        return {
          prevY: a,
          lineYPosition: s
        };
      }
    }]), t;
  }(),
      Tt = function () {
    function t(i, a, s) {
      e(this, t), this.ctx = i, this.w = i.w, this.xyRatios = a, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s, this.scatter = new I(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Pt(this), this.markers = new z(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }

    return a(t, [{
      key: "draw",
      value: function value(t, e, i) {
        var a = this.w,
            s = new b(this.ctx),
            r = a.globals.comboCharts ? e : a.config.chart.type,
            n = s.group({
          class: "apexcharts-".concat(r, "-series apexcharts-plot-series")
        }),
            o = new y(this.ctx, a);
        this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = o.getLogSeries(t), this.yRatio = o.getLogYRatios(this.yRatio);

        for (var l = [], h = 0; h < t.length; h++) {
          t = this.lineHelpers.sameValueSeriesFix(h, t);
          var c = a.globals.comboCharts ? i[h] : h;

          this._initSerieVariables(t, h, c);

          var d = [],
              g = [],
              u = a.globals.padHorizontal + this.categoryAxisCorrection;
          this.ctx.series.addCollapsedClassToSeries(this.elSeries, c), a.globals.isXNumeric && a.globals.seriesX.length > 0 && (u = (a.globals.seriesX[c][0] - a.globals.minX) / this.xRatio), g.push(u);
          var f,
              p = u,
              x = p,
              m = this.zeroY;
          m = this.lineHelpers.determineFirstPrevY({
            i: h,
            series: t,
            prevY: m,
            lineYPosition: 0
          }).prevY, d.push(m), f = m;

          var v = this._calculatePathsFrom({
            series: t,
            i: h,
            realIndex: c,
            prevX: x,
            prevY: m
          }),
              w = this._iterateOverDataPoints({
            series: t,
            realIndex: c,
            i: h,
            x: u,
            y: 1,
            pX: p,
            pY: f,
            pathsFrom: v,
            linePaths: [],
            areaPaths: [],
            seriesIndex: i,
            lineYPosition: 0,
            xArrj: g,
            yArrj: d
          });

          this._handlePaths({
            type: r,
            realIndex: c,
            i: h,
            paths: w
          }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries);
        }

        if (a.config.chart.stacked) for (var k = l.length; k > 0; k--) {
          n.add(l[k - 1]);
        } else for (var A = 0; A < l.length; A++) {
          n.add(l[A]);
        }
        return n;
      }
    }, {
      key: "_initSerieVariables",
      value: function value(t, e, i) {
        var a = this.w,
            s = new b(this.ctx);
        this.xDivision = a.globals.gridWidth / (a.globals.dataPoints - ("on" === a.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[i] : a.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a.globals.gridHeight || "end" === a.config.plotOptions.area.fillTo) && (this.areaBottomY = a.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s.group({
          class: "apexcharts-series",
          seriesName: f.escapeString(a.globals.seriesNames[i])
        }), this.elPointsMain = s.group({
          class: "apexcharts-series-markers-wrap",
          "data:realIndex": i
        }), this.elDataLabelsWrap = s.group({
          class: "apexcharts-datalabels",
          "data:realIndex": i
        });
        var r = t[e].length === a.globals.dataPoints;
        this.elSeries.attr({
          "data:longestSeries": r,
          rel: e + 1,
          "data:realIndex": i
        }), this.appendPathFrom = !0;
      }
    }, {
      key: "_calculatePathsFrom",
      value: function value(t) {
        var e,
            i,
            a,
            s,
            r = t.series,
            n = t.i,
            o = t.realIndex,
            l = t.prevX,
            h = t.prevY,
            c = this.w,
            d = new b(this.ctx);

        if (null === r[n][0]) {
          for (var g = 0; g < r[n].length; g++) {
            if (null !== r[n][g]) {
              l = this.xDivision * g, h = this.zeroY - r[n][g] / this.yRatio[this.yaxisIndex], e = d.move(l, h), i = d.move(l, this.areaBottomY);
              break;
            }
          }
        } else e = d.move(l, h), i = d.move(l, this.areaBottomY) + d.line(l, h);

        if (a = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), s = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), c.globals.previousPaths.length > 0) {
          var u = this.lineHelpers.checkPreviousPaths({
            pathFromLine: a,
            pathFromArea: s,
            realIndex: o
          });
          a = u.pathFromLine, s = u.pathFromArea;
        }

        return {
          prevX: l,
          prevY: h,
          linePath: e,
          areaPath: i,
          pathFromLine: a,
          pathFromArea: s
        };
      }
    }, {
      key: "_handlePaths",
      value: function value(t) {
        var e = t.type,
            i = t.realIndex,
            a = t.i,
            s = t.paths,
            r = this.w,
            o = new b(this.ctx),
            l = new T(this.ctx);
        this.prevSeriesY.push(s.yArrj), r.globals.seriesXvalues[i] = s.xArrj, r.globals.seriesYvalues[i] = s.yArrj, this.pointsChart || r.globals.delayedElements.push({
          el: this.elPointsMain.node,
          index: i
        });
        var h = {
          i: a,
          realIndex: i,
          animationDelay: a,
          initialSpeed: r.config.chart.animations.speed,
          dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-".concat(e)
        };
        if ("area" === e) for (var c = l.fillPath({
          seriesNumber: i
        }), d = 0; d < s.areaPaths.length; d++) {
          var g = o.renderPaths(n(n({}, h), {}, {
            pathFrom: s.pathFromArea,
            pathTo: s.areaPaths[d],
            stroke: "none",
            strokeWidth: 0,
            strokeLineCap: null,
            fill: c
          }));
          this.elSeries.add(g);
        }

        if (r.config.stroke.show && !this.pointsChart) {
          var u = null;
          u = "line" === e ? l.fillPath({
            seriesNumber: i,
            i: a
          }) : r.globals.stroke.colors[i];

          for (var f = 0; f < s.linePaths.length; f++) {
            var p = o.renderPaths(n(n({}, h), {}, {
              pathFrom: s.pathFromLine,
              pathTo: s.linePaths[f],
              stroke: u,
              strokeWidth: this.strokeWidth,
              strokeLineCap: r.config.stroke.lineCap,
              fill: "none"
            }));
            this.elSeries.add(p);
          }
        }
      }
    }, {
      key: "_iterateOverDataPoints",
      value: function value(t) {
        for (var e = t.series, i = t.realIndex, a = t.i, s = t.x, r = t.y, n = t.pX, o = t.pY, l = t.pathsFrom, h = t.linePaths, c = t.areaPaths, d = t.seriesIndex, g = t.lineYPosition, u = t.xArrj, p = t.yArrj, x = this.w, m = new b(this.ctx), v = this.yRatio, y = l.prevY, w = l.linePath, k = l.areaPath, A = l.pathFromLine, S = l.pathFromArea, C = f.isNumber(x.globals.minYArr[i]) ? x.globals.minYArr[i] : x.globals.minY, L = x.globals.dataPoints > 1 ? x.globals.dataPoints - 1 : x.globals.dataPoints, P = 0; P < L; P++) {
          var T = void 0 === e[a][P + 1] || null === e[a][P + 1];

          if (x.globals.isXNumeric) {
            var z = x.globals.seriesX[i][P + 1];
            void 0 === x.globals.seriesX[i][P + 1] && (z = x.globals.seriesX[i][L - 1]), s = (z - x.globals.minX) / this.xRatio;
          } else s += this.xDivision;

          if (x.config.chart.stacked) {
            if (a > 0 && x.globals.collapsedSeries.length < x.config.series.length - 1) {
              g = this.prevSeriesY[function (t) {
                for (var e = t, i = 0; i < x.globals.series.length; i++) {
                  if (x.globals.collapsedSeriesIndices.indexOf(t) > -1) {
                    e--;
                    break;
                  }
                }

                return e >= 0 ? e : 0;
              }(a - 1)][P + 1];
            } else g = this.zeroY;
          } else g = this.zeroY;
          r = T ? g - C / v[this.yaxisIndex] + 2 * (this.isReversed ? C / v[this.yaxisIndex] : 0) : g - e[a][P + 1] / v[this.yaxisIndex] + 2 * (this.isReversed ? e[a][P + 1] / v[this.yaxisIndex] : 0), u.push(s), p.push(r);

          var I = this.lineHelpers.calculatePoints({
            series: e,
            x: s,
            y: r,
            realIndex: i,
            i: a,
            j: P,
            prevY: y
          }),
              M = this._createPaths({
            series: e,
            i: a,
            realIndex: i,
            j: P,
            x: s,
            y: r,
            pX: n,
            pY: o,
            linePath: w,
            areaPath: k,
            linePaths: h,
            areaPaths: c,
            seriesIndex: d
          });

          c = M.areaPaths, h = M.linePaths, n = M.pX, o = M.pY, k = M.areaPath, w = M.linePath, this.appendPathFrom && (A += m.line(s, this.zeroY), S += m.line(s, this.zeroY)), this.handleNullDataPoints(e, I, a, P, i), this._handleMarkersAndLabels({
            pointsPos: I,
            series: e,
            x: s,
            y: r,
            prevY: y,
            i: a,
            j: P,
            realIndex: i
          });
        }

        return {
          yArrj: p,
          xArrj: u,
          pathFromArea: S,
          areaPaths: c,
          pathFromLine: A,
          linePaths: h
        };
      }
    }, {
      key: "_handleMarkersAndLabels",
      value: function value(t) {
        var e = t.pointsPos,
            i = (t.series, t.x, t.y, t.prevY, t.i),
            a = t.j,
            s = t.realIndex,
            r = this.w,
            n = new M(this.ctx);
        if (this.pointsChart) this.scatter.draw(this.elSeries, a, {
          realIndex: s,
          pointsPos: e,
          zRatio: this.zRatio,
          elParent: this.elPointsMain
        });else {
          r.globals.series[i].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
          var o = this.markers.plotChartMarkers(e, s, a + 1);
          null !== o && this.elPointsMain.add(o);
        }
        var l = n.drawDataLabel(e, s, a + 1, null);
        null !== l && this.elDataLabelsWrap.add(l);
      }
    }, {
      key: "_createPaths",
      value: function value(t) {
        var e = t.series,
            i = t.i,
            a = t.realIndex,
            s = t.j,
            r = t.x,
            n = t.y,
            o = t.pX,
            l = t.pY,
            h = t.linePath,
            c = t.areaPath,
            d = t.linePaths,
            g = t.areaPaths,
            u = t.seriesIndex,
            f = this.w,
            p = new b(this.ctx),
            x = f.config.stroke.curve,
            m = this.areaBottomY;

        if (Array.isArray(f.config.stroke.curve) && (x = Array.isArray(u) ? f.config.stroke.curve[u[i]] : f.config.stroke.curve[i]), "smooth" === x) {
          var v = .35 * (r - o);
          f.globals.hasNullValues ? (null !== e[i][s] && (null !== e[i][s + 1] ? (h = p.move(o, l) + p.curve(o + v, l, r - v, n, r + 1, n), c = p.move(o + 1, l) + p.curve(o + v, l, r - v, n, r + 1, n) + p.line(r, m) + p.line(o, m) + "z") : (h = p.move(o, l), c = p.move(o, l) + "z")), d.push(h), g.push(c)) : (h += p.curve(o + v, l, r - v, n, r, n), c += p.curve(o + v, l, r - v, n, r, n)), o = r, l = n, s === e[i].length - 2 && (c = c + p.curve(o, l, r, n, r, m) + p.move(r, n) + "z", f.globals.hasNullValues || (d.push(h), g.push(c)));
        } else {
          if (null === e[i][s + 1]) {
            h += p.move(r, n);
            var y = f.globals.isXNumeric ? (f.globals.seriesX[a][s] - f.globals.minX) / this.xRatio : r - this.xDivision;
            c = c + p.line(y, m) + p.move(r, n) + "z";
          }

          null === e[i][s] && (h += p.move(r, n), c += p.move(r, m)), "stepline" === x ? (h = h + p.line(r, null, "H") + p.line(null, n, "V"), c = c + p.line(r, null, "H") + p.line(null, n, "V")) : "straight" === x && (h += p.line(r, n), c += p.line(r, n)), s === e[i].length - 2 && (c = c + p.line(r, m) + p.move(r, n) + "z", d.push(h), g.push(c));
        }

        return {
          linePaths: d,
          areaPaths: g,
          pX: o,
          pY: l,
          linePath: h,
          areaPath: c
        };
      }
    }, {
      key: "handleNullDataPoints",
      value: function value(t, e, i, a, s) {
        var r = this.w;

        if (null === t[i][a] && r.config.markers.showNullDataPoints || 1 === t[i].length) {
          var n = this.markers.plotChartMarkers(e, s, a + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0);
          null !== n && this.elPointsMain.add(n);
        }
      }
    }]), t;
  }(),
      zt = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }

    return a(t, [{
      key: "calculateTimeScaleTicks",
      value: function value(t, e) {
        var i = this,
            a = this.w;
        if (a.globals.allSeriesCollapsed) return a.globals.labels = [], a.globals.timescaleLabels = [], [];
        var s = new D(this.ctx),
            r = (e - t) / 864e5;
        this.determineInterval(r), a.globals.disableZoomIn = !1, a.globals.disableZoomOut = !1, r < .005 ? a.globals.disableZoomIn = !0 : r > 5e4 && (a.globals.disableZoomOut = !0);
        var o = s.getTimeUnitsfromTimestamp(t, e, this.utc),
            l = a.globals.gridWidth / r,
            h = l / 24,
            c = h / 60,
            d = Math.floor(24 * r),
            g = Math.floor(24 * r * 60),
            u = Math.floor(r),
            f = Math.floor(r / 30),
            p = Math.floor(r / 365),
            x = {
          minMinute: o.minMinute,
          minHour: o.minHour,
          minDate: o.minDate,
          minMonth: o.minMonth,
          minYear: o.minYear
        },
            b = {
          firstVal: x,
          currentMinute: x.minMinute,
          currentHour: x.minHour,
          currentMonthDate: x.minDate,
          currentDate: x.minDate,
          currentMonth: x.minMonth,
          currentYear: x.minYear,
          daysWidthOnXAxis: l,
          hoursWidthOnXAxis: h,
          minutesWidthOnXAxis: c,
          numberOfMinutes: g,
          numberOfHours: d,
          numberOfDays: u,
          numberOfMonths: f,
          numberOfYears: p
        };

        switch (this.tickInterval) {
          case "years":
            this.generateYearScale(b);
            break;

          case "months":
          case "half_year":
            this.generateMonthScale(b);
            break;

          case "months_days":
          case "months_fortnight":
          case "days":
          case "week_days":
            this.generateDayScale(b);
            break;

          case "hours":
            this.generateHourScale(b);
            break;

          case "minutes":
            this.generateMinuteScale(b);
        }

        var m = this.timeScaleArray.map(function (t) {
          var e = {
            position: t.position,
            unit: t.unit,
            year: t.year,
            day: t.day ? t.day : 1,
            hour: t.hour ? t.hour : 0,
            month: t.month + 1
          };
          return "month" === t.unit ? n(n({}, e), {}, {
            day: 1,
            value: t.value + 1
          }) : "day" === t.unit || "hour" === t.unit ? n(n({}, e), {}, {
            value: t.value
          }) : "minute" === t.unit ? n(n({}, e), {}, {
            value: t.value,
            minute: t.value
          }) : t;
        });
        return m.filter(function (t) {
          var e = 1,
              s = Math.ceil(a.globals.gridWidth / 120),
              r = t.value;
          void 0 !== a.config.xaxis.tickAmount && (s = a.config.xaxis.tickAmount), m.length > s && (e = Math.floor(m.length / s));
          var n = !1,
              o = !1;

          switch (i.tickInterval) {
            case "years":
              "year" === t.unit && (n = !0);
              break;

            case "half_year":
              e = 7, "year" === t.unit && (n = !0);
              break;

            case "months":
              e = 1, "year" === t.unit && (n = !0);
              break;

            case "months_fortnight":
              e = 15, "year" !== t.unit && "month" !== t.unit || (n = !0), 30 === r && (o = !0);
              break;

            case "months_days":
              e = 10, "month" === t.unit && (n = !0), 30 === r && (o = !0);
              break;

            case "week_days":
              e = 8, "month" === t.unit && (n = !0);
              break;

            case "days":
              e = 1, "month" === t.unit && (n = !0);
              break;

            case "hours":
              "day" === t.unit && (n = !0);
              break;

            case "minutes":
              r % 5 != 0 && (o = !0);
          }

          if ("minutes" === i.tickInterval || "hours" === i.tickInterval) {
            if (!o) return !0;
          } else if ((r % e == 0 || n) && !o) return !0;
        });
      }
    }, {
      key: "recalcDimensionsBasedOnFormat",
      value: function value(t, e) {
        var i = this.w,
            a = this.formatDates(t),
            s = this.removeOverlappingTS(a);
        i.globals.timescaleLabels = s.slice(), new lt(this.ctx).plotCoords();
      }
    }, {
      key: "determineInterval",
      value: function value(t) {
        switch (!0) {
          case t > 1825:
            this.tickInterval = "years";
            break;

          case t > 800 && t <= 1825:
            this.tickInterval = "half_year";
            break;

          case t > 180 && t <= 800:
            this.tickInterval = "months";
            break;

          case t > 90 && t <= 180:
            this.tickInterval = "months_fortnight";
            break;

          case t > 60 && t <= 90:
            this.tickInterval = "months_days";
            break;

          case t > 30 && t <= 60:
            this.tickInterval = "week_days";
            break;

          case t > 2 && t <= 30:
            this.tickInterval = "days";
            break;

          case t > .1 && t <= 2:
            this.tickInterval = "hours";
            break;

          case t < .1:
            this.tickInterval = "minutes";
            break;

          default:
            this.tickInterval = "days";
        }
      }
    }, {
      key: "generateYearScale",
      value: function value(t) {
        var e = t.firstVal,
            i = t.currentMonth,
            a = t.currentYear,
            s = t.daysWidthOnXAxis,
            r = t.numberOfYears,
            n = e.minYear,
            o = 0,
            l = new D(this.ctx);

        if (e.minDate > 1 || e.minMonth > 0) {
          var h = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
          o = (l.determineDaysOfYear(e.minYear) - h + 1) * s, n = e.minYear + 1, this.timeScaleArray.push({
            position: o,
            value: n,
            unit: "year",
            year: n,
            month: f.monthMod(i + 1)
          });
        } else 1 === e.minDate && 0 === e.minMonth && this.timeScaleArray.push({
          position: o,
          value: n,
          unit: "year",
          year: a,
          month: f.monthMod(i + 1)
        });

        for (var c = n, d = o, g = 0; g < r; g++) {
          c++, d = l.determineDaysOfYear(c - 1) * s + d, this.timeScaleArray.push({
            position: d,
            value: c,
            unit: "year",
            year: c,
            month: 1
          });
        }
      }
    }, {
      key: "generateMonthScale",
      value: function value(t) {
        var e = t.firstVal,
            i = t.currentMonthDate,
            a = t.currentMonth,
            s = t.currentYear,
            r = t.daysWidthOnXAxis,
            n = t.numberOfMonths,
            o = a,
            l = 0,
            h = new D(this.ctx),
            c = "month",
            d = 0;

        if (e.minDate > 1) {
          l = (h.determineDaysOfMonths(a + 1, e.minYear) - i + 1) * r, o = f.monthMod(a + 1);
          var g = s + d,
              u = f.monthMod(o),
              p = o;
          0 === o && (c = "year", p = g, u = 1, g += d += 1), this.timeScaleArray.push({
            position: l,
            value: p,
            unit: c,
            year: g,
            month: u
          });
        } else this.timeScaleArray.push({
          position: l,
          value: o,
          unit: c,
          year: s,
          month: f.monthMod(a)
        });

        for (var x = o + 1, b = l, m = 0, v = 1; m < n; m++, v++) {
          0 === (x = f.monthMod(x)) ? (c = "year", d += 1) : c = "month";

          var y = this._getYear(s, x, d);

          b = h.determineDaysOfMonths(x, y) * r + b;
          var w = 0 === x ? y : x;
          this.timeScaleArray.push({
            position: b,
            value: w,
            unit: c,
            year: y,
            month: 0 === x ? 1 : x
          }), x++;
        }
      }
    }, {
      key: "generateDayScale",
      value: function value(t) {
        var e = t.firstVal,
            i = t.currentMonth,
            a = t.currentYear,
            s = t.hoursWidthOnXAxis,
            r = t.numberOfDays,
            n = new D(this.ctx),
            o = "day",
            l = e.minDate + 1,
            h = l,
            c = function c(t, e, i) {
          return t > n.determineDaysOfMonths(e + 1, i) ? (h = 1, o = "month", g = e += 1, e) : e;
        },
            d = (24 - e.minHour) * s,
            g = l,
            u = c(h, i, a);

        0 === e.minHour && 1 === e.minDate && (d = 0, g = f.monthMod(e.minMonth), o = "month", h = e.minDate, r++), this.timeScaleArray.push({
          position: d,
          value: g,
          unit: o,
          year: this._getYear(a, u, 0),
          month: f.monthMod(u),
          day: h
        });

        for (var p = d, x = 0; x < r; x++) {
          o = "day", u = c(h += 1, u, this._getYear(a, u, 0));

          var b = this._getYear(a, u, 0);

          p = 24 * s + p;
          var m = 1 === h ? f.monthMod(u) : h;
          this.timeScaleArray.push({
            position: p,
            value: m,
            unit: o,
            year: b,
            month: f.monthMod(u),
            day: m
          });
        }
      }
    }, {
      key: "generateHourScale",
      value: function value(t) {
        var e = t.firstVal,
            i = t.currentDate,
            a = t.currentMonth,
            s = t.currentYear,
            r = t.minutesWidthOnXAxis,
            n = t.numberOfHours,
            o = new D(this.ctx),
            l = "hour",
            h = function h(t, e) {
          return t > o.determineDaysOfMonths(e + 1, s) && (x = 1, e += 1), {
            month: e,
            date: x
          };
        },
            c = function c(t, e) {
          return t > o.determineDaysOfMonths(e + 1, s) ? e += 1 : e;
        },
            d = 60 - e.minMinute,
            g = d * r,
            u = e.minHour + 1,
            p = u + 1;

        60 === d && (g = 0, p = (u = e.minHour) + 1);
        var x = i,
            b = c(x, a);
        this.timeScaleArray.push({
          position: g,
          value: u,
          unit: l,
          day: x,
          hour: p,
          year: s,
          month: f.monthMod(b)
        });

        for (var m = g, v = 0; v < n; v++) {
          if (l = "hour", p >= 24) p = 0, l = "day", b = h(x += 1, b).month, b = c(x, b);

          var y = this._getYear(s, b, 0);

          m = 0 === p && 0 === v ? d * r : 60 * r + m;
          var w = 0 === p ? x : p;
          this.timeScaleArray.push({
            position: m,
            value: w,
            unit: l,
            hour: p,
            day: x,
            year: y,
            month: f.monthMod(b)
          }), p++;
        }
      }
    }, {
      key: "generateMinuteScale",
      value: function value(t) {
        var e = t.firstVal,
            i = t.currentMinute,
            a = t.currentHour,
            s = t.currentDate,
            r = t.currentMonth,
            n = t.currentYear,
            o = t.minutesWidthOnXAxis,
            l = t.numberOfMinutes,
            h = o - (i - e.minMinute),
            c = e.minMinute + 1,
            d = c + 1,
            g = s,
            u = r,
            p = n,
            x = a;
        this.timeScaleArray.push({
          position: h,
          value: c,
          unit: "minute",
          day: g,
          hour: x,
          minute: d,
          year: p,
          month: f.monthMod(u)
        });

        for (var b = h, m = 0; m < l; m++) {
          d >= 60 && (d = 0, 24 === (x += 1) && (x = 0)), b = o + b, this.timeScaleArray.push({
            position: b,
            value: d,
            unit: "minute",
            hour: x,
            minute: d,
            day: g,
            year: this._getYear(n, u, 0),
            month: f.monthMod(u)
          }), d++;
        }
      }
    }, {
      key: "createRawDateString",
      value: function value(t, e) {
        var i = t.year;
        return i += "-" + ("0" + t.month.toString()).slice(-2), "day" === t.unit ? i += "day" === t.unit ? "-" + ("0" + e).slice(-2) : "-01" : i += "-" + ("0" + (t.day ? t.day : "1")).slice(-2), "hour" === t.unit ? i += "hour" === t.unit ? "T" + ("0" + e).slice(-2) : "T00" : i += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), i += "minute" === t.unit ? ":" + ("0" + e).slice(-2) + ":00" : ":00:00", this.utc && (i += ".000Z"), i;
      }
    }, {
      key: "formatDates",
      value: function value(t) {
        var e = this,
            i = this.w;
        return t.map(function (t) {
          var a = t.value.toString(),
              s = new D(e.ctx),
              r = e.createRawDateString(t, a),
              n = s.getDate(s.parseDate(r));

          if (e.utc || (n = s.getDate(s.parseDateWithTimezone(r))), void 0 === i.config.xaxis.labels.format) {
            var o = "dd MMM",
                l = i.config.xaxis.labels.datetimeFormatter;
            "year" === t.unit && (o = l.year), "month" === t.unit && (o = l.month), "day" === t.unit && (o = l.day), "hour" === t.unit && (o = l.hour), "minute" === t.unit && (o = l.minute), a = s.formatDate(n, o);
          } else a = s.formatDate(n, i.config.xaxis.labels.format);

          return {
            dateString: r,
            position: t.position,
            value: a,
            unit: t.unit,
            year: t.year,
            month: t.month
          };
        });
      }
    }, {
      key: "removeOverlappingTS",
      value: function value(t) {
        var e,
            i = this,
            a = new b(this.ctx),
            s = !1;
        t.length > 0 && t[0].value && t.every(function (e) {
          return e.value.length === t[0].value.length;
        }) && (s = !0, e = a.getTextRects(t[0].value).width);
        var r = 0,
            n = t.map(function (n, o) {
          if (o > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
            var l = s ? e : a.getTextRects(t[r].value).width,
                h = t[r].position;
            return n.position > h + l + 10 ? (r = o, n) : null;
          }

          return n;
        });
        return n = n.filter(function (t) {
          return null !== t;
        });
      }
    }, {
      key: "_getYear",
      value: function value(t, e, i) {
        return t + Math.floor(e / 12) + i;
      }
    }]), t;
  }(),
      It = function () {
    function t(i, a) {
      e(this, t), this.ctx = a, this.w = a.w, this.el = i;
    }

    return a(t, [{
      key: "setupElements",
      value: function value() {
        var t = this.w.globals,
            e = this.w.config,
            i = e.chart.type;
        t.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "scatter", "bubble", "radar", "heatmap"].indexOf(i) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "scatter", "bubble"].indexOf(i) > -1, t.isBarHorizontal = ("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.cuid, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), b.setAttrs(t.dom.elWrap, {
          id: t.chartClass.substring(1),
          class: "apexcharts-canvas " + t.chartClass.substring(1)
        }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({
          class: "apexcharts-svg",
          "xmlns:data": "ApexChartsNS",
          transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")")
        }), t.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t.dom.elGraphical = t.dom.Paper.group().attr({
          class: "apexcharts-inner apexcharts-graphical"
        }), t.dom.elAnnotations = t.dom.Paper.group().attr({
          class: "apexcharts-annotations"
        }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
      }
    }, {
      key: "plotChartType",
      value: function value(t, e) {
        var i = this.w,
            a = i.config,
            s = i.globals,
            r = {
          series: [],
          i: []
        },
            n = {
          series: [],
          i: []
        },
            o = {
          series: [],
          i: []
        },
            l = {
          series: [],
          i: []
        },
            h = {
          series: [],
          i: []
        },
            c = {
          series: [],
          i: []
        };
        s.series.map(function (e, d) {
          void 0 !== t[d].type ? ("column" === t[d].type || "bar" === t[d].type ? (s.series.length > 1 && a.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), h.series.push(e), h.i.push(d), i.globals.columnSeries = h.series) : "area" === t[d].type ? (n.series.push(e), n.i.push(d)) : "line" === t[d].type ? (r.series.push(e), r.i.push(d)) : "scatter" === t[d].type ? (o.series.push(e), o.i.push(d)) : "bubble" === t[d].type ? (l.series.push(e), l.i.push(d)) : "candlestick" === t[d].type ? (c.series.push(e), c.i.push(d)) : console.warn("You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble"), s.comboCharts = !0) : (r.series.push(e), r.i.push(d));
        });
        var d = new Tt(this.ctx, e),
            g = new wt(this.ctx, e);
        this.ctx.pie = new St(this.ctx);
        var u = new Lt(this.ctx),
            f = new R(this.ctx, e),
            p = new Ct(this.ctx),
            x = [];

        if (s.comboCharts) {
          if (n.series.length > 0 && x.push(d.draw(n.series, "area", n.i)), h.series.length > 0) if (i.config.chart.stacked) {
            var b = new yt(this.ctx, e);
            x.push(b.draw(h.series, h.i));
          } else {
            var m = new F(this.ctx, e);
            x.push(m.draw(h.series, h.i));
          }

          if (r.series.length > 0 && x.push(d.draw(r.series, "line", r.i)), c.series.length > 0 && x.push(g.draw(c.series, c.i)), o.series.length > 0) {
            var v = new Tt(this.ctx, e, !0);
            x.push(v.draw(o.series, "scatter", o.i));
          }

          if (l.series.length > 0) {
            var y = new Tt(this.ctx, e, !0);
            x.push(y.draw(l.series, "bubble", l.i));
          }
        } else switch (a.chart.type) {
          case "line":
            x = d.draw(s.series, "line");
            break;

          case "area":
            x = d.draw(s.series, "area");
            break;

          case "bar":
            if (a.chart.stacked) x = new yt(this.ctx, e).draw(s.series);else x = new F(this.ctx, e).draw(s.series);
            break;

          case "candlestick":
            x = new wt(this.ctx, e).draw(s.series);
            break;

          case "rangeBar":
            x = f.draw(s.series);
            break;

          case "heatmap":
            x = new kt(this.ctx, e).draw(s.series);
            break;

          case "pie":
          case "donut":
          case "polarArea":
            x = this.ctx.pie.draw(s.series);
            break;

          case "radialBar":
            x = u.draw(s.series);
            break;

          case "radar":
            x = p.draw(s.series);
            break;

          default:
            x = d.draw(s.series);
        }

        return x;
      }
    }, {
      key: "setSVGDimensions",
      value: function value() {
        var t = this.w.globals,
            e = this.w.config;
        t.svgWidth = e.chart.width, t.svgHeight = e.chart.height;
        var i = f.getDimensions(this.el),
            a = e.chart.width.toString().split(/[0-9]+/g).pop();
        if ("%" === a ? f.isNumber(i[0]) && (0 === i[0].width && (i = f.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(e.chart.width, 10) / 100) : "px" !== a && "" !== a || (t.svgWidth = parseInt(e.chart.width, 10)), "auto" !== t.svgHeight && "" !== t.svgHeight) {
          if ("%" === e.chart.height.toString().split(/[0-9]+/g).pop()) {
            var s = f.getDimensions(this.el.parentNode);
            t.svgHeight = s[1] * parseInt(e.chart.height, 10) / 100;
          } else t.svgHeight = parseInt(e.chart.height, 10);
        } else t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2;
        t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), b.setAttrs(t.dom.Paper.node, {
          width: t.svgWidth,
          height: t.svgHeight
        });
        var r = e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0;
        t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + r + "px", t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px";
      }
    }, {
      key: "shiftGraphPosition",
      value: function value() {
        var t = this.w.globals,
            e = t.translateY,
            i = {
          transform: "translate(" + t.translateX + ", " + e + ")"
        };
        b.setAttrs(t.dom.elGraphical.node, i);
      }
    }, {
      key: "resizeNonAxisCharts",
      value: function value() {
        var t = this.w,
            e = t.globals,
            i = 0,
            a = t.config.chart.sparkline.enabled ? 1 : 15;
        a += t.config.grid.padding.bottom, "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || !t.config.legend.show || t.config.legend.floating || (i = new ct(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
        var s = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar"),
            r = 2.05 * t.globals.radialSize;

        if (s && !t.config.chart.sparkline.enabled) {
          var n = f.getBoundingClientRect(s);
          r = n.bottom;
          var o = n.bottom - n.top;
          r = Math.max(2.05 * t.globals.radialSize, o);
        }

        var l = r + e.translateY + i + a;
        e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", l), e.dom.elWrap.style.height = l + "px", b.setAttrs(e.dom.Paper.node, {
          height: l
        }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px";
      }
    }, {
      key: "coreCalculations",
      value: function value() {
        new Z(this.ctx).init();
      }
    }, {
      key: "resetGlobals",
      value: function value() {
        var t = this,
            e = function e() {
          return t.w.config.series.map(function (t) {
            return [];
          });
        },
            i = new O(),
            a = this.w.globals;

        i.initGlobalVars(a), a.seriesXvalues = e(), a.seriesYvalues = e();
      }
    }, {
      key: "isMultipleY",
      value: function value() {
        if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0;
      }
    }, {
      key: "xySettings",
      value: function value() {
        var t = null,
            e = this.w;

        if (e.globals.axisCharts) {
          if ("back" === e.config.xaxis.crosshairs.position) new tt(this.ctx).drawXCrosshairs();
          if ("back" === e.config.yaxis[0].crosshairs.position) new tt(this.ctx).drawYCrosshairs();

          if ("datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter) {
            this.ctx.timeScale = new zt(this.ctx);
            var i = [];
            isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
          }

          t = new y(this.ctx).getCalculatedRatios();
        }

        return t;
      }
    }, {
      key: "updateSourceChart",
      value: function value(t) {
        this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
          chart: {
            selection: {
              xaxis: {
                min: t.w.globals.minX,
                max: t.w.globals.maxX
              }
            }
          }
        }, !1, !1);
      }
    }, {
      key: "setupBrushHandler",
      value: function value() {
        var t = this,
            e = this.w;

        if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
          var i = e.config.chart.brush.targets || [e.config.chart.brush.target];
          i.forEach(function (e) {
            var i = ApexCharts.getChartByID(e);
            i.w.globals.brushSource = t.ctx, "function" != typeof i.w.config.chart.events.zoomed && (i.w.config.chart.events.zoomed = function () {
              t.updateSourceChart(i);
            }), "function" != typeof i.w.config.chart.events.scrolled && (i.w.config.chart.events.scrolled = function () {
              t.updateSourceChart(i);
            });
          }), e.config.chart.events.selection = function (t, a) {
            i.forEach(function (t) {
              var i = ApexCharts.getChartByID(t),
                  s = f.clone(e.config.yaxis);

              if (e.config.chart.brush.autoScaleYaxis && 1 === i.w.globals.series.length) {
                var r = new q(i);
                s = r.autoScaleY(i, s, a);
              }

              var o = i.w.config.yaxis.reduce(function (t, e, a) {
                return [].concat(g(t), [n(n({}, i.w.config.yaxis[a]), {}, {
                  min: s[0].min,
                  max: s[0].max
                })]);
              }, []);

              i.ctx.updateHelpers._updateOptions({
                xaxis: {
                  min: a.xaxis.min,
                  max: a.xaxis.max
                },
                yaxis: o
              }, !1, !1, !1, !1);
            });
          };
        }
      }
    }]), t;
  }(),
      Mt = function () {
    function i(t) {
      e(this, i), this.ctx = t, this.w = t.w;
    }

    return a(i, [{
      key: "_updateOptions",
      value: function value(e) {
        var i = this,
            a = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
            o = [this.ctx];
        r && (o = this.ctx.getSyncedCharts()), this.ctx.w.globals.isExecCalled && (o = [this.ctx], this.ctx.w.globals.isExecCalled = !1), o.forEach(function (r) {
          var o = r.w;
          return o.globals.shouldAnimate = s, a || (o.globals.resized = !0, o.globals.dataChanged = !0, s && r.series.getPreviousPaths()), e && "object" === t(e) && (r.config = new N(e), e = y.extendArrayProps(r.config, e, o), r.w.globals.chartID !== i.ctx.w.globals.chartID && delete e.series, o.config = f.extend(o.config, e), n && (o.globals.lastXAxis = e.xaxis ? f.clone(e.xaxis) : [], o.globals.lastYAxis = e.yaxis ? f.clone(e.yaxis) : [], o.globals.initialConfig = f.extend({}, o.config), o.globals.initialSeries = f.clone(o.config.series))), r.update(e);
        });
      }
    }, {
      key: "_updateSeries",
      value: function value(t, e) {
        var i,
            a = this,
            s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
            r = this.w;
        return r.globals.shouldAnimate = e, r.globals.dataChanged = !0, e && this.ctx.series.getPreviousPaths(), r.globals.axisCharts ? (0 === (i = t.map(function (t, e) {
          return a._extendSeries(t, e);
        })).length && (i = [{
          data: []
        }]), r.config.series = i) : r.config.series = t.slice(), s && (r.globals.initialSeries = f.clone(r.config.series)), this.ctx.update({
          series: t
        });
      }
    }, {
      key: "_extendSeries",
      value: function value(t, e) {
        var i = this.w,
            a = i.config.series[e];
        return n(n({}, i.config.series[e]), {}, {
          name: t.name ? t.name : a && a.name,
          color: t.color ? t.color : a && a.color,
          type: t.type ? t.type : a && a.type,
          data: t.data ? t.data : a && a.data
        });
      }
    }, {
      key: "toggleDataPointSelection",
      value: function value(t, e) {
        var i = this.w,
            a = null,
            s = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
        return i.globals.axisCharts ? a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(e, "'], ").concat(s, " circle[j='").concat(e, "'], ").concat(s, " rect[j='").concat(e, "']")).members[0] : void 0 === e && (a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(t, "']")).members[0], "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(t)), a ? (new b(this.ctx).pathMouseDown(a, null), a.node ? a.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
      }
    }, {
      key: "forceXAxisUpdate",
      value: function value(t) {
        var e = this.w;

        if (["min", "max"].forEach(function (i) {
          void 0 !== t.xaxis[i] && (e.config.xaxis[i] = t.xaxis[i], e.globals.lastXAxis[i] = t.xaxis[i]);
        }), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) {
          var i = new H(t);
          t = i.convertCatToNumericXaxis(t, this.ctx);
        }

        return t;
      }
    }, {
      key: "forceYAxisUpdate",
      value: function value(t) {
        var e = this.w;
        return e.config.chart.stacked && "100%" === e.config.chart.stackType && (Array.isArray(t.yaxis) ? t.yaxis.forEach(function (e, i) {
          t.yaxis[i].min = 0, t.yaxis[i].max = 100;
        }) : (t.yaxis.min = 0, t.yaxis.max = 100)), t;
      }
    }, {
      key: "revertDefaultAxisMinMax",
      value: function value() {
        var t = this,
            e = this.w;
        e.config.xaxis.min = e.globals.lastXAxis.min, e.config.xaxis.max = e.globals.lastXAxis.max;

        var i = function i(t) {
          void 0 !== e.globals.lastYAxis[t] && (e.config.yaxis[t].min = e.globals.lastYAxis[t].min, e.config.yaxis[t].max = e.globals.lastYAxis[t].max);
        };

        e.config.yaxis.map(function (a, s) {
          e.globals.zoomed || void 0 !== e.globals.lastYAxis[s] ? i(s) : void 0 !== t.ctx.opts.yaxis[s] && (a.min = t.ctx.opts.yaxis[s].min, a.max = t.ctx.opts.yaxis[s].max);
        });
      }
    }]), i;
  }();

  A = "undefined" != typeof window ? window : void 0, S = function S(e, i) {
    var a = (void 0 !== this ? this : e).SVG = function (t) {
      if (a.supported) return t = new a.Doc(t), a.parser.draw || a.prepare(), t;
    };

    if (a.ns = "http://www.w3.org/2000/svg", a.xmlns = "http://www.w3.org/2000/xmlns/", a.xlink = "http://www.w3.org/1999/xlink", a.svgjs = "http://svgjs.com/svgjs", a.supported = !0, !a.supported) return !1;
    a.did = 1e3, a.eid = function (t) {
      return "Svgjs" + d(t) + a.did++;
    }, a.create = function (t) {
      var e = i.createElementNS(this.ns, t);
      return e.setAttribute("id", this.eid(t)), e;
    }, a.extend = function () {
      var t, e;
      e = (t = [].slice.call(arguments)).pop();

      for (var i = t.length - 1; i >= 0; i--) {
        if (t[i]) for (var s in e) {
          t[i].prototype[s] = e[s];
        }
      }

      a.Set && a.Set.inherit && a.Set.inherit();
    }, a.invent = function (t) {
      var e = "function" == typeof t.create ? t.create : function () {
        this.constructor.call(this, a.create(t.create));
      };
      return t.inherit && (e.prototype = new t.inherit()), t.extend && a.extend(e, t.extend), t.construct && a.extend(t.parent || a.Container, t.construct), e;
    }, a.adopt = function (t) {
      return t ? t.instance ? t.instance : ((i = "svg" == t.nodeName ? t.parentNode instanceof e.SVGElement ? new a.Nested() : new a.Doc() : "linearGradient" == t.nodeName ? new a.Gradient("linear") : "radialGradient" == t.nodeName ? new a.Gradient("radial") : a[d(t.nodeName)] ? new a[d(t.nodeName)]() : new a.Element(t)).type = t.nodeName, i.node = t, t.instance = i, i instanceof a.Doc && i.namespace().defs(), i.setData(JSON.parse(t.getAttribute("svgjs:data")) || {}), i) : null;
      var i;
    }, a.prepare = function () {
      var t = i.getElementsByTagName("body")[0],
          e = (t ? new a.Doc(t) : a.adopt(i.documentElement).nested()).size(2, 0);
      a.parser = {
        body: t || i.documentElement,
        draw: e.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
        poly: e.polyline().node,
        path: e.path().node,
        native: a.create("svg")
      };
    }, a.parser = {
      native: a.create("svg")
    }, i.addEventListener("DOMContentLoaded", function () {
      a.parser.draw || a.prepare();
    }, !1), a.regex = {
      numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
      hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
      rgb: /rgb\((\d+),(\d+),(\d+)\)/,
      reference: /#([a-z0-9\-_]+)/i,
      transforms: /\)\s*,?\s*/,
      whitespace: /\s/g,
      isHex: /^#[a-f0-9]{3,6}$/i,
      isRgb: /^rgb\(/,
      isCss: /[^:]+:[^;]+;?/,
      isBlank: /^(\s+)?$/,
      isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
      isPercent: /^-?[\d\.]+%$/,
      isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
      delimiter: /[\s,]+/,
      hyphen: /([^e])\-/gi,
      pathLetters: /[MLHVCSQTAZ]/gi,
      isPathLetter: /[MLHVCSQTAZ]/i,
      numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
      dots: /\./g
    }, a.utils = {
      map: function map(t, e) {
        for (var i = t.length, a = [], s = 0; s < i; s++) {
          a.push(e(t[s]));
        }

        return a;
      },
      filter: function filter(t, e) {
        for (var i = t.length, a = [], s = 0; s < i; s++) {
          e(t[s]) && a.push(t[s]);
        }

        return a;
      },
      filterSVGElements: function filterSVGElements(t) {
        return this.filter(t, function (t) {
          return t instanceof e.SVGElement;
        });
      }
    }, a.defaults = {
      attrs: {
        "fill-opacity": 1,
        "stroke-opacity": 1,
        "stroke-width": 0,
        "stroke-linejoin": "miter",
        "stroke-linecap": "butt",
        fill: "#000000",
        stroke: "#000000",
        opacity: 1,
        x: 0,
        y: 0,
        cx: 0,
        cy: 0,
        width: 0,
        height: 0,
        r: 0,
        rx: 0,
        ry: 0,
        offset: 0,
        "stop-opacity": 1,
        "stop-color": "#000000",
        "font-size": 16,
        "font-family": "Helvetica, Arial, sans-serif",
        "text-anchor": "start"
      }
    }, a.Color = function (e) {
      var i, s;
      this.r = 0, this.g = 0, this.b = 0, e && ("string" == typeof e ? a.regex.isRgb.test(e) ? (i = a.regex.rgb.exec(e.replace(a.regex.whitespace, "")), this.r = parseInt(i[1]), this.g = parseInt(i[2]), this.b = parseInt(i[3])) : a.regex.isHex.test(e) && (i = a.regex.hex.exec(4 == (s = e).length ? ["#", s.substring(1, 2), s.substring(1, 2), s.substring(2, 3), s.substring(2, 3), s.substring(3, 4), s.substring(3, 4)].join("") : s), this.r = parseInt(i[1], 16), this.g = parseInt(i[2], 16), this.b = parseInt(i[3], 16)) : "object" === t(e) && (this.r = e.r, this.g = e.g, this.b = e.b));
    }, a.extend(a.Color, {
      toString: function toString() {
        return this.toHex();
      },
      toHex: function toHex() {
        return "#" + g(this.r) + g(this.g) + g(this.b);
      },
      toRgb: function toRgb() {
        return "rgb(" + [this.r, this.g, this.b].join() + ")";
      },
      brightness: function brightness() {
        return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11;
      },
      morph: function morph(t) {
        return this.destination = new a.Color(t), this;
      },
      at: function at(t) {
        return this.destination ? (t = t < 0 ? 0 : t > 1 ? 1 : t, new a.Color({
          r: ~~(this.r + (this.destination.r - this.r) * t),
          g: ~~(this.g + (this.destination.g - this.g) * t),
          b: ~~(this.b + (this.destination.b - this.b) * t)
        })) : this;
      }
    }), a.Color.test = function (t) {
      return t += "", a.regex.isHex.test(t) || a.regex.isRgb.test(t);
    }, a.Color.isRgb = function (t) {
      return t && "number" == typeof t.r && "number" == typeof t.g && "number" == typeof t.b;
    }, a.Color.isColor = function (t) {
      return a.Color.isRgb(t) || a.Color.test(t);
    }, a.Array = function (t, e) {
      0 == (t = (t || []).valueOf()).length && e && (t = e.valueOf()), this.value = this.parse(t);
    }, a.extend(a.Array, {
      toString: function toString() {
        return this.value.join(" ");
      },
      valueOf: function valueOf() {
        return this.value;
      },
      parse: function parse(t) {
        return t = t.valueOf(), Array.isArray(t) ? t : this.split(t);
      }
    }), a.PointArray = function (t, e) {
      a.Array.call(this, t, e || [[0, 0]]);
    }, a.PointArray.prototype = new a.Array(), a.PointArray.prototype.constructor = a.PointArray;

    for (var s = {
      M: function M(t, e, i) {
        return e.x = i.x = t[0], e.y = i.y = t[1], ["M", e.x, e.y];
      },
      L: function L(t, e) {
        return e.x = t[0], e.y = t[1], ["L", t[0], t[1]];
      },
      H: function H(t, e) {
        return e.x = t[0], ["H", t[0]];
      },
      V: function V(t, e) {
        return e.y = t[0], ["V", t[0]];
      },
      C: function C(t, e) {
        return e.x = t[4], e.y = t[5], ["C", t[0], t[1], t[2], t[3], t[4], t[5]];
      },
      Q: function Q(t, e) {
        return e.x = t[2], e.y = t[3], ["Q", t[0], t[1], t[2], t[3]];
      },
      Z: function Z(t, e, i) {
        return e.x = i.x, e.y = i.y, ["Z"];
      }
    }, r = "mlhvqtcsaz".split(""), n = 0, o = r.length; n < o; ++n) {
      s[r[n]] = function (t) {
        return function (e, i, a) {
          if ("H" == t) e[0] = e[0] + i.x;else if ("V" == t) e[0] = e[0] + i.y;else if ("A" == t) e[5] = e[5] + i.x, e[6] = e[6] + i.y;else for (var r = 0, n = e.length; r < n; ++r) {
            e[r] = e[r] + (r % 2 ? i.y : i.x);
          }
          return s[t](e, i, a);
        };
      }(r[n].toUpperCase());
    }

    a.PathArray = function (t, e) {
      a.Array.call(this, t, e || [["M", 0, 0]]);
    }, a.PathArray.prototype = new a.Array(), a.PathArray.prototype.constructor = a.PathArray, a.extend(a.PathArray, {
      toString: function toString() {
        return function (t) {
          for (var e = 0, i = t.length, a = ""; e < i; e++) {
            a += t[e][0], null != t[e][1] && (a += t[e][1], null != t[e][2] && (a += " ", a += t[e][2], null != t[e][3] && (a += " ", a += t[e][3], a += " ", a += t[e][4], null != t[e][5] && (a += " ", a += t[e][5], a += " ", a += t[e][6], null != t[e][7] && (a += " ", a += t[e][7])))));
          }

          return a + " ";
        }(this.value);
      },
      move: function move(t, e) {
        var i = this.bbox();
        return i.x, i.y, this;
      },
      at: function at(t) {
        if (!this.destination) return this;

        for (var e = this.value, i = this.destination.value, s = [], r = new a.PathArray(), n = 0, o = e.length; n < o; n++) {
          s[n] = [e[n][0]];

          for (var l = 1, h = e[n].length; l < h; l++) {
            s[n][l] = e[n][l] + (i[n][l] - e[n][l]) * t;
          }

          "A" === s[n][0] && (s[n][4] = +(0 != s[n][4]), s[n][5] = +(0 != s[n][5]));
        }

        return r.value = s, r;
      },
      parse: function parse(t) {
        if (t instanceof a.PathArray) return t.valueOf();
        var e,
            i = {
          M: 2,
          L: 2,
          H: 1,
          V: 1,
          C: 6,
          S: 4,
          Q: 4,
          T: 2,
          A: 7,
          Z: 0
        };
        t = "string" == typeof t ? t.replace(a.regex.numbersWithDots, h).replace(a.regex.pathLetters, " $& ").replace(a.regex.hyphen, "$1 -").trim().split(a.regex.delimiter) : t.reduce(function (t, e) {
          return [].concat.call(t, e);
        }, []);
        var r = [],
            n = new a.Point(),
            o = new a.Point(),
            l = 0,
            c = t.length;

        do {
          a.regex.isPathLetter.test(t[l]) ? (e = t[l], ++l) : "M" == e ? e = "L" : "m" == e && (e = "l"), r.push(s[e].call(null, t.slice(l, l += i[e.toUpperCase()]).map(parseFloat), n, o));
        } while (c > l);

        return r;
      },
      bbox: function bbox() {
        return a.parser.draw || a.prepare(), a.parser.path.setAttribute("d", this.toString()), a.parser.path.getBBox();
      }
    }), a.Number = a.invent({
      create: function create(t, e) {
        this.value = 0, this.unit = e || "", "number" == typeof t ? this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37 : "string" == typeof t ? (e = t.match(a.regex.numberAndUnit)) && (this.value = parseFloat(e[1]), "%" == e[5] ? this.value /= 100 : "s" == e[5] && (this.value *= 1e3), this.unit = e[5]) : t instanceof a.Number && (this.value = t.valueOf(), this.unit = t.unit);
      },
      extend: {
        toString: function toString() {
          return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
        },
        toJSON: function toJSON() {
          return this.toString();
        },
        valueOf: function valueOf() {
          return this.value;
        },
        plus: function plus(t) {
          return t = new a.Number(t), new a.Number(this + t, this.unit || t.unit);
        },
        minus: function minus(t) {
          return t = new a.Number(t), new a.Number(this - t, this.unit || t.unit);
        },
        times: function times(t) {
          return t = new a.Number(t), new a.Number(this * t, this.unit || t.unit);
        },
        divide: function divide(t) {
          return t = new a.Number(t), new a.Number(this / t, this.unit || t.unit);
        },
        to: function to(t) {
          var e = new a.Number(this);
          return "string" == typeof t && (e.unit = t), e;
        },
        morph: function morph(t) {
          return this.destination = new a.Number(t), t.relative && (this.destination.value += this.value), this;
        },
        at: function at(t) {
          return this.destination ? new a.Number(this.destination).minus(this).times(t).plus(this) : this;
        }
      }
    }), a.Element = a.invent({
      create: function create(t) {
        this._stroke = a.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t) && (this.type = t.nodeName, this.node.instance = this, this._stroke = t.getAttribute("stroke") || this._stroke);
      },
      extend: {
        x: function x(t) {
          return this.attr("x", t);
        },
        y: function y(t) {
          return this.attr("y", t);
        },
        cx: function cx(t) {
          return null == t ? this.x() + this.width() / 2 : this.x(t - this.width() / 2);
        },
        cy: function cy(t) {
          return null == t ? this.y() + this.height() / 2 : this.y(t - this.height() / 2);
        },
        move: function move(t, e) {
          return this.x(t).y(e);
        },
        center: function center(t, e) {
          return this.cx(t).cy(e);
        },
        width: function width(t) {
          return this.attr("width", t);
        },
        height: function height(t) {
          return this.attr("height", t);
        },
        size: function size(t, e) {
          var i = u(this, t, e);
          return this.width(new a.Number(i.width)).height(new a.Number(i.height));
        },
        clone: function clone(t) {
          this.writeDataToDom();
          var e = x(this.node.cloneNode(!0));
          return t ? t.add(e) : this.after(e), e;
        },
        remove: function remove() {
          return this.parent() && this.parent().removeElement(this), this;
        },
        replace: function replace(t) {
          return this.after(t).remove(), t;
        },
        addTo: function addTo(t) {
          return t.put(this);
        },
        putIn: function putIn(t) {
          return t.add(this);
        },
        id: function id(t) {
          return this.attr("id", t);
        },
        show: function show() {
          return this.style("display", "");
        },
        hide: function hide() {
          return this.style("display", "none");
        },
        visible: function visible() {
          return "none" != this.style("display");
        },
        toString: function toString() {
          return this.attr("id");
        },
        classes: function classes() {
          var t = this.attr("class");
          return null == t ? [] : t.trim().split(a.regex.delimiter);
        },
        hasClass: function hasClass(t) {
          return -1 != this.classes().indexOf(t);
        },
        addClass: function addClass(t) {
          if (!this.hasClass(t)) {
            var e = this.classes();
            e.push(t), this.attr("class", e.join(" "));
          }

          return this;
        },
        removeClass: function removeClass(t) {
          return this.hasClass(t) && this.attr("class", this.classes().filter(function (e) {
            return e != t;
          }).join(" ")), this;
        },
        toggleClass: function toggleClass(t) {
          return this.hasClass(t) ? this.removeClass(t) : this.addClass(t);
        },
        reference: function reference(t) {
          return a.get(this.attr(t));
        },
        parent: function parent(t) {
          var i = this;
          if (!i.node.parentNode) return null;
          if (i = a.adopt(i.node.parentNode), !t) return i;

          for (; i && i.node instanceof e.SVGElement;) {
            if ("string" == typeof t ? i.matches(t) : i instanceof t) return i;
            if (!i.node.parentNode || "#document" == i.node.parentNode.nodeName) return null;
            i = a.adopt(i.node.parentNode);
          }
        },
        doc: function doc() {
          return this instanceof a.Doc ? this : this.parent(a.Doc);
        },
        parents: function parents(t) {
          var e = [],
              i = this;

          do {
            if (!(i = i.parent(t)) || !i.node) break;
            e.push(i);
          } while (i.parent);

          return e;
        },
        matches: function matches(t) {
          return function (t, e) {
            return (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e);
          }(this.node, t);
        },
        native: function native() {
          return this.node;
        },
        svg: function svg(t) {
          var e = i.createElement("svg");
          if (!(t && this instanceof a.Parent)) return e.appendChild(t = i.createElement("svg")), this.writeDataToDom(), t.appendChild(this.node.cloneNode(!0)), e.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
          e.innerHTML = "<svg>" + t.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";

          for (var s = 0, r = e.firstChild.childNodes.length; s < r; s++) {
            this.node.appendChild(e.firstChild.firstChild);
          }

          return this;
        },
        writeDataToDom: function writeDataToDom() {
          return (this.each || this.lines) && (this.each ? this : this.lines()).each(function () {
            this.writeDataToDom();
          }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
        },
        setData: function setData(t) {
          return this.dom = t, this;
        },
        is: function is(t) {
          return function (t, e) {
            return t instanceof e;
          }(this, t);
        }
      }
    }), a.easing = {
      "-": function _(t) {
        return t;
      },
      "<>": function _(t) {
        return -Math.cos(t * Math.PI) / 2 + .5;
      },
      ">": function _(t) {
        return Math.sin(t * Math.PI / 2);
      },
      "<": function _(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      }
    }, a.morph = function (t) {
      return function (e, i) {
        return new a.MorphObj(e, i).at(t);
      };
    }, a.Situation = a.invent({
      create: function create(t) {
        this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new a.Number(t.duration).valueOf(), this.delay = new a.Number(t.delay).valueOf(), this.start = +new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
      }
    }), a.FX = a.invent({
      create: function create(t) {
        this._target = t, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
      },
      extend: {
        animate: function animate(e, i, s) {
          "object" === t(e) && (i = e.ease, s = e.delay, e = e.duration);
          var r = new a.Situation({
            duration: e || 1e3,
            delay: s || 0,
            ease: a.easing[i || "-"] || i
          });
          return this.queue(r), this;
        },
        target: function target(t) {
          return t && t instanceof a.Element ? (this._target = t, this) : this._target;
        },
        timeToAbsPos: function timeToAbsPos(t) {
          return (t - this.situation.start) / (this.situation.duration / this._speed);
        },
        absPosToTime: function absPosToTime(t) {
          return this.situation.duration / this._speed * t + this.situation.start;
        },
        startAnimFrame: function startAnimFrame() {
          this.stopAnimFrame(), this.animationFrame = e.requestAnimationFrame(function () {
            this.step();
          }.bind(this));
        },
        stopAnimFrame: function stopAnimFrame() {
          e.cancelAnimationFrame(this.animationFrame);
        },
        start: function start() {
          return !this.active && this.situation && (this.active = !0, this.startCurrent()), this;
        },
        startCurrent: function startCurrent() {
          return this.situation.start = +new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
        },
        queue: function queue(t) {
          return ("function" == typeof t || t instanceof a.Situation) && this.situations.push(t), this.situation || (this.situation = this.situations.shift()), this;
        },
        dequeue: function dequeue() {
          return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a.Situation ? this.start() : this.situation.call(this)), this;
        },
        initAnimations: function initAnimations() {
          var t,
              e = this.situation;
          if (e.init) return this;

          for (var i in e.animations) {
            t = this.target()[i](), Array.isArray(t) || (t = [t]), Array.isArray(e.animations[i]) || (e.animations[i] = [e.animations[i]]);

            for (var s = t.length; s--;) {
              e.animations[i][s] instanceof a.Number && (t[s] = new a.Number(t[s])), e.animations[i][s] = t[s].morph(e.animations[i][s]);
            }
          }

          for (var i in e.attrs) {
            e.attrs[i] = new a.MorphObj(this.target().attr(i), e.attrs[i]);
          }

          for (var i in e.styles) {
            e.styles[i] = new a.MorphObj(this.target().style(i), e.styles[i]);
          }

          return e.initialTransformation = this.target().matrixify(), e.init = !0, this;
        },
        clearQueue: function clearQueue() {
          return this.situations = [], this;
        },
        clearCurrent: function clearCurrent() {
          return this.situation = null, this;
        },
        stop: function stop(t, e) {
          var i = this.active;
          return this.active = !1, e && this.clearQueue(), t && this.situation && (!i && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
        },
        after: function after(t) {
          var e = this.last();
          return this.target().on("finished.fx", function i(a) {
            a.detail.situation == e && (t.call(this, e), this.off("finished.fx", i));
          }), this._callStart();
        },
        during: function during(t) {
          var e = this.last(),
              i = function i(_i3) {
            _i3.detail.situation == e && t.call(this, _i3.detail.pos, a.morph(_i3.detail.pos), _i3.detail.eased, e);
          };

          return this.target().off("during.fx", i).on("during.fx", i), this.after(function () {
            this.off("during.fx", i);
          }), this._callStart();
        },
        afterAll: function afterAll(t) {
          var e = function e(i) {
            t.call(this), this.off("allfinished.fx", e);
          };

          return this.target().off("allfinished.fx", e).on("allfinished.fx", e), this._callStart();
        },
        last: function last() {
          return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
        },
        add: function add(t, e, i) {
          return this.last()[i || "animations"][t] = e, this._callStart();
        },
        step: function step(t) {
          var e, i, a;
          t || (this.absPos = this.timeToAbsPos(+new Date())), !1 !== this.situation.loops ? (e = Math.max(this.absPos, 0), i = Math.floor(e), !0 === this.situation.loops || i < this.situation.loops ? (this.pos = e - i, a = this.situation.loop, this.situation.loop = i) : (this.absPos = this.situation.loops, this.pos = 1, a = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
          var s = this.situation.ease(this.pos);

          for (var r in this.situation.once) {
            r > this.lastPos && r <= s && (this.situation.once[r].call(this.target(), this.pos, s), delete this.situation.once[r]);
          }

          return this.active && this.target().fire("during", {
            pos: this.pos,
            eased: s,
            fx: this,
            situation: this.situation
          }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
            fx: this,
            situation: this.situation
          }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s, this) : this;
        },
        eachAt: function eachAt() {
          var t,
              e = this,
              i = this.target(),
              s = this.situation;

          for (var r in s.animations) {
            t = [].concat(s.animations[r]).map(function (t) {
              return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t;
            }), i[r].apply(i, t);
          }

          for (var r in s.attrs) {
            t = [r].concat(s.attrs[r]).map(function (t) {
              return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t;
            }), i.attr.apply(i, t);
          }

          for (var r in s.styles) {
            t = [r].concat(s.styles[r]).map(function (t) {
              return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t;
            }), i.style.apply(i, t);
          }

          if (s.transforms.length) {
            t = s.initialTransformation, r = 0;

            for (var n = s.transforms.length; r < n; r++) {
              var o = s.transforms[r];
              o instanceof a.Matrix ? t = o.relative ? t.multiply(new a.Matrix().morph(o).at(s.ease(this.pos))) : t.morph(o).at(s.ease(this.pos)) : (o.relative || o.undo(t.extract()), t = t.multiply(o.at(s.ease(this.pos))));
            }

            i.matrix(t);
          }

          return this;
        },
        once: function once(t, e, i) {
          var a = this.last();
          return i || (t = a.ease(t)), a.once[t] = e, this;
        },
        _callStart: function _callStart() {
          return setTimeout(function () {
            this.start();
          }.bind(this), 0), this;
        }
      },
      parent: a.Element,
      construct: {
        animate: function animate(t, e, i) {
          return (this.fx || (this.fx = new a.FX(this))).animate(t, e, i);
        },
        delay: function delay(t) {
          return (this.fx || (this.fx = new a.FX(this))).delay(t);
        },
        stop: function stop(t, e) {
          return this.fx && this.fx.stop(t, e), this;
        },
        finish: function finish() {
          return this.fx && this.fx.finish(), this;
        }
      }
    }), a.MorphObj = a.invent({
      create: function create(t, e) {
        return a.Color.isColor(e) ? new a.Color(t).morph(e) : a.regex.delimiter.test(t) ? a.regex.pathLetters.test(t) ? new a.PathArray(t).morph(e) : new a.Array(t).morph(e) : a.regex.numberAndUnit.test(e) ? new a.Number(t).morph(e) : (this.value = t, void (this.destination = e));
      },
      extend: {
        at: function at(t, e) {
          return e < 1 ? this.value : this.destination;
        },
        valueOf: function valueOf() {
          return this.value;
        }
      }
    }), a.extend(a.FX, {
      attr: function attr(e, i, a) {
        if ("object" === t(e)) for (var s in e) {
          this.attr(s, e[s]);
        } else this.add(e, i, "attrs");
        return this;
      },
      plot: function plot(t, e, i, a) {
        return 4 == arguments.length ? this.plot([t, e, i, a]) : this.add("plot", new (this.target().morphArray)(t));
      }
    }), a.Box = a.invent({
      create: function create(e, i, s, r) {
        if (!("object" !== t(e) || e instanceof a.Element)) return a.Box.call(this, null != e.left ? e.left : e.x, null != e.top ? e.top : e.y, e.width, e.height);
        4 == arguments.length && (this.x = e, this.y = i, this.width = s, this.height = r), b(this);
      }
    }), a.BBox = a.invent({
      create: function create(t) {
        if (a.Box.apply(this, [].slice.call(arguments)), t instanceof a.Element) {
          var e;

          try {
            if (!i.documentElement.contains) {
              for (var s = t.node; s.parentNode;) {
                s = s.parentNode;
              }

              if (s != i) throw new Error("Element not in the dom");
            }

            e = t.node.getBBox();
          } catch (i) {
            if (t instanceof a.Shape) {
              a.parser.draw || a.prepare();
              var r = t.clone(a.parser.draw.instance).show();
              e = r.node.getBBox(), r.remove();
            } else e = {
              x: t.node.clientLeft,
              y: t.node.clientTop,
              width: t.node.clientWidth,
              height: t.node.clientHeight
            };
          }

          a.Box.call(this, e);
        }
      },
      inherit: a.Box,
      parent: a.Element,
      construct: {
        bbox: function bbox() {
          return new a.BBox(this);
        }
      }
    }), a.BBox.prototype.constructor = a.BBox, a.Matrix = a.invent({
      create: function create(e) {
        var i = p([1, 0, 0, 1, 0, 0]);
        e = e instanceof a.Element ? e.matrixify() : "string" == typeof e ? p(e.split(a.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? p([].slice.call(arguments)) : Array.isArray(e) ? p(e) : "object" === t(e) ? e : i;

        for (var s = v.length - 1; s >= 0; --s) {
          this[v[s]] = null != e[v[s]] ? e[v[s]] : i[v[s]];
        }
      },
      extend: {
        extract: function extract() {
          var t = f(this, 0, 1),
              e = (f(this, 1, 0), 180 / Math.PI * Math.atan2(t.y, t.x) - 90);
          return {
            x: this.e,
            y: this.f,
            transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
            transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
            rotation: e,
            a: this.a,
            b: this.b,
            c: this.c,
            d: this.d,
            e: this.e,
            f: this.f,
            matrix: new a.Matrix(this)
          };
        },
        clone: function clone() {
          return new a.Matrix(this);
        },
        morph: function morph(t) {
          return this.destination = new a.Matrix(t), this;
        },
        multiply: function multiply(t) {
          return new a.Matrix(this.native().multiply(function (t) {
            return t instanceof a.Matrix || (t = new a.Matrix(t)), t;
          }(t).native()));
        },
        inverse: function inverse() {
          return new a.Matrix(this.native().inverse());
        },
        translate: function translate(t, e) {
          return new a.Matrix(this.native().translate(t || 0, e || 0));
        },
        native: function native() {
          for (var t = a.parser.native.createSVGMatrix(), e = v.length - 1; e >= 0; e--) {
            t[v[e]] = this[v[e]];
          }

          return t;
        },
        toString: function toString() {
          return "matrix(" + m(this.a) + "," + m(this.b) + "," + m(this.c) + "," + m(this.d) + "," + m(this.e) + "," + m(this.f) + ")";
        }
      },
      parent: a.Element,
      construct: {
        ctm: function ctm() {
          return new a.Matrix(this.node.getCTM());
        },
        screenCTM: function screenCTM() {
          if (this instanceof a.Nested) {
            var t = this.rect(1, 1),
                e = t.node.getScreenCTM();
            return t.remove(), new a.Matrix(e);
          }

          return new a.Matrix(this.node.getScreenCTM());
        }
      }
    }), a.Point = a.invent({
      create: function create(e, i) {
        var a;
        a = Array.isArray(e) ? {
          x: e[0],
          y: e[1]
        } : "object" === t(e) ? {
          x: e.x,
          y: e.y
        } : null != e ? {
          x: e,
          y: null != i ? i : e
        } : {
          x: 0,
          y: 0
        }, this.x = a.x, this.y = a.y;
      },
      extend: {
        clone: function clone() {
          return new a.Point(this);
        },
        morph: function morph(t, e) {
          return this.destination = new a.Point(t, e), this;
        }
      }
    }), a.extend(a.Element, {
      point: function point(t, e) {
        return new a.Point(t, e).transform(this.screenCTM().inverse());
      }
    }), a.extend(a.Element, {
      attr: function attr(e, i, s) {
        if (null == e) {
          for (e = {}, s = (i = this.node.attributes).length - 1; s >= 0; s--) {
            e[i[s].nodeName] = a.regex.isNumber.test(i[s].nodeValue) ? parseFloat(i[s].nodeValue) : i[s].nodeValue;
          }

          return e;
        }

        if ("object" === t(e)) for (var r in e) {
          this.attr(r, e[r]);
        } else if (null === i) this.node.removeAttribute(e);else {
          if (null == i) return null == (i = this.node.getAttribute(e)) ? a.defaults.attrs[e] : a.regex.isNumber.test(i) ? parseFloat(i) : i;
          "stroke-width" == e ? this.attr("stroke", parseFloat(i) > 0 ? this._stroke : null) : "stroke" == e && (this._stroke = i), "fill" != e && "stroke" != e || (a.regex.isImage.test(i) && (i = this.doc().defs().image(i, 0, 0)), i instanceof a.Image && (i = this.doc().defs().pattern(0, 0, function () {
            this.add(i);
          }))), "number" == typeof i ? i = new a.Number(i) : a.Color.isColor(i) ? i = new a.Color(i) : Array.isArray(i) && (i = new a.Array(i)), "leading" == e ? this.leading && this.leading(i) : "string" == typeof s ? this.node.setAttributeNS(s, e, i.toString()) : this.node.setAttribute(e, i.toString()), !this.rebuild || "font-size" != e && "x" != e || this.rebuild(e, i);
        }
        return this;
      }
    }), a.extend(a.Element, {
      transform: function transform(e, i) {
        var s;
        return "object" !== t(e) ? (s = new a.Matrix(this).extract(), "string" == typeof e ? s[e] : s) : (s = new a.Matrix(this), i = !!i || !!e.relative, null != e.a && (s = i ? s.multiply(new a.Matrix(e)) : new a.Matrix(e)), this.attr("transform", s));
      }
    }), a.extend(a.Element, {
      untransform: function untransform() {
        return this.attr("transform", null);
      },
      matrixify: function matrixify() {
        return (this.attr("transform") || "").split(a.regex.transforms).slice(0, -1).map(function (t) {
          var e = t.trim().split("(");
          return [e[0], e[1].split(a.regex.delimiter).map(function (t) {
            return parseFloat(t);
          })];
        }).reduce(function (t, e) {
          return "matrix" == e[0] ? t.multiply(p(e[1])) : t[e[0]].apply(t, e[1]);
        }, new a.Matrix());
      },
      toParent: function toParent(t) {
        if (this == t) return this;
        var e = this.screenCTM(),
            i = t.screenCTM().inverse();
        return this.addTo(t).untransform().transform(i.multiply(e)), this;
      },
      toDoc: function toDoc() {
        return this.toParent(this.doc());
      }
    }), a.Transformation = a.invent({
      create: function create(e, i) {
        if (arguments.length > 1 && "boolean" != typeof i) return this.constructor.call(this, [].slice.call(arguments));
        if (Array.isArray(e)) for (var a = 0, s = this.arguments.length; a < s; ++a) {
          this[this.arguments[a]] = e[a];
        } else if ("object" === t(e)) for (a = 0, s = this.arguments.length; a < s; ++a) {
          this[this.arguments[a]] = e[this.arguments[a]];
        }
        this.inversed = !1, !0 === i && (this.inversed = !0);
      }
    }), a.Translate = a.invent({
      parent: a.Matrix,
      inherit: a.Transformation,
      create: function create(t, e) {
        this.constructor.apply(this, [].slice.call(arguments));
      },
      extend: {
        arguments: ["transformedX", "transformedY"],
        method: "translate"
      }
    }), a.extend(a.Element, {
      style: function style(e, i) {
        if (0 == arguments.length) return this.node.style.cssText || "";
        if (arguments.length < 2) {
          if ("object" === t(e)) for (var s in e) {
            this.style(s, e[s]);
          } else {
            if (!a.regex.isCss.test(e)) return this.node.style[c(e)];

            for (e = e.split(/\s*;\s*/).filter(function (t) {
              return !!t;
            }).map(function (t) {
              return t.split(/\s*:\s*/);
            }); i = e.pop();) {
              this.style(i[0], i[1]);
            }
          }
        } else this.node.style[c(e)] = null === i || a.regex.isBlank.test(i) ? "" : i;
        return this;
      }
    }), a.Parent = a.invent({
      create: function create(t) {
        this.constructor.call(this, t);
      },
      inherit: a.Element,
      extend: {
        children: function children() {
          return a.utils.map(a.utils.filterSVGElements(this.node.childNodes), function (t) {
            return a.adopt(t);
          });
        },
        add: function add(t, e) {
          return null == e ? this.node.appendChild(t.node) : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]), this;
        },
        put: function put(t, e) {
          return this.add(t, e), t;
        },
        has: function has(t) {
          return this.index(t) >= 0;
        },
        index: function index(t) {
          return [].slice.call(this.node.childNodes).indexOf(t.node);
        },
        get: function get(t) {
          return a.adopt(this.node.childNodes[t]);
        },
        first: function first() {
          return this.get(0);
        },
        last: function last() {
          return this.get(this.node.childNodes.length - 1);
        },
        each: function each(t, e) {
          for (var i = this.children(), s = 0, r = i.length; s < r; s++) {
            i[s] instanceof a.Element && t.apply(i[s], [s, i]), e && i[s] instanceof a.Container && i[s].each(t, e);
          }

          return this;
        },
        removeElement: function removeElement(t) {
          return this.node.removeChild(t.node), this;
        },
        clear: function clear() {
          for (; this.node.hasChildNodes();) {
            this.node.removeChild(this.node.lastChild);
          }

          return delete this._defs, this;
        },
        defs: function defs() {
          return this.doc().defs();
        }
      }
    }), a.extend(a.Parent, {
      ungroup: function ungroup(t, e) {
        return 0 === e || this instanceof a.Defs || this.node == a.parser.draw || (t = t || (this instanceof a.Doc ? this : this.parent(a.Parent)), e = e || 1 / 0, this.each(function () {
          return this instanceof a.Defs ? this : this instanceof a.Parent ? this.ungroup(t, e - 1) : this.toParent(t);
        }), this.node.firstChild || this.remove()), this;
      },
      flatten: function flatten(t, e) {
        return this.ungroup(t, e);
      }
    }), a.Container = a.invent({
      create: function create(t) {
        this.constructor.call(this, t);
      },
      inherit: a.Parent
    }), a.ViewBox = a.invent({
      parent: a.Container,
      construct: {}
    }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function (t) {
      a.Element.prototype[t] = function (e) {
        return a.on(this.node, t, e), this;
      };
    }), a.listeners = [], a.handlerMap = [], a.listenerId = 0, a.on = function (t, e, i, s, r) {
      var n = i.bind(s || t.instance || t),
          o = (a.handlerMap.indexOf(t) + 1 || a.handlerMap.push(t)) - 1,
          l = e.split(".")[0],
          h = e.split(".")[1] || "*";
      a.listeners[o] = a.listeners[o] || {}, a.listeners[o][l] = a.listeners[o][l] || {}, a.listeners[o][l][h] = a.listeners[o][l][h] || {}, i._svgjsListenerId || (i._svgjsListenerId = ++a.listenerId), a.listeners[o][l][h][i._svgjsListenerId] = n, t.addEventListener(l, n, r || !1);
    }, a.off = function (t, e, i) {
      var s = a.handlerMap.indexOf(t),
          r = e && e.split(".")[0],
          n = e && e.split(".")[1],
          o = "";
      if (-1 != s) if (i) {
        if ("function" == typeof i && (i = i._svgjsListenerId), !i) return;
        a.listeners[s][r] && a.listeners[s][r][n || "*"] && (t.removeEventListener(r, a.listeners[s][r][n || "*"][i], !1), delete a.listeners[s][r][n || "*"][i]);
      } else if (n && r) {
        if (a.listeners[s][r] && a.listeners[s][r][n]) {
          for (var l in a.listeners[s][r][n]) {
            a.off(t, [r, n].join("."), l);
          }

          delete a.listeners[s][r][n];
        }
      } else if (n) for (var h in a.listeners[s]) {
        for (var o in a.listeners[s][h]) {
          n === o && a.off(t, [h, n].join("."));
        }
      } else if (r) {
        if (a.listeners[s][r]) {
          for (var o in a.listeners[s][r]) {
            a.off(t, [r, o].join("."));
          }

          delete a.listeners[s][r];
        }
      } else {
        for (var h in a.listeners[s]) {
          a.off(t, h);
        }

        delete a.listeners[s], delete a.handlerMap[s];
      }
    }, a.extend(a.Element, {
      on: function on(t, e, i, s) {
        return a.on(this.node, t, e, i, s), this;
      },
      off: function off(t, e) {
        return a.off(this.node, t, e), this;
      },
      fire: function fire(t, i) {
        return t instanceof e.Event ? this.node.dispatchEvent(t) : this.node.dispatchEvent(t = new a.CustomEvent(t, {
          detail: i,
          cancelable: !0
        })), this._event = t, this;
      },
      event: function event() {
        return this._event;
      }
    }), a.Defs = a.invent({
      create: "defs",
      inherit: a.Container
    }), a.G = a.invent({
      create: "g",
      inherit: a.Container,
      extend: {
        x: function x(t) {
          return null == t ? this.transform("x") : this.transform({
            x: t - this.x()
          }, !0);
        }
      },
      construct: {
        group: function group() {
          return this.put(new a.G());
        }
      }
    }), a.Doc = a.invent({
      create: function create(t) {
        t && ("svg" == (t = "string" == typeof t ? i.getElementById(t) : t).nodeName ? this.constructor.call(this, t) : (this.constructor.call(this, a.create("svg")), t.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
      },
      inherit: a.Container,
      extend: {
        namespace: function namespace() {
          return this.attr({
            xmlns: a.ns,
            version: "1.1"
          }).attr("xmlns:xlink", a.xlink, a.xmlns).attr("xmlns:svgjs", a.svgjs, a.xmlns);
        },
        defs: function defs() {
          var t;
          return this._defs || ((t = this.node.getElementsByTagName("defs")[0]) ? this._defs = a.adopt(t) : this._defs = new a.Defs(), this.node.appendChild(this._defs.node)), this._defs;
        },
        parent: function parent() {
          return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
        },
        remove: function remove() {
          return this.parent() && this.parent().removeChild(this.node), this;
        },
        clear: function clear() {
          for (; this.node.hasChildNodes();) {
            this.node.removeChild(this.node.lastChild);
          }

          return delete this._defs, a.parser.draw && !a.parser.draw.parentNode && this.node.appendChild(a.parser.draw), this;
        },
        clone: function clone(t) {
          this.writeDataToDom();
          var e = this.node,
              i = x(e.cloneNode(!0));
          return t ? (t.node || t).appendChild(i.node) : e.parentNode.insertBefore(i.node, e.nextSibling), i;
        }
      }
    }), a.extend(a.Element, {}), a.Gradient = a.invent({
      create: function create(t) {
        this.constructor.call(this, a.create(t + "Gradient")), this.type = t;
      },
      inherit: a.Container,
      extend: {
        at: function at(t, e, i) {
          return this.put(new a.Stop()).update(t, e, i);
        },
        update: function update(t) {
          return this.clear(), "function" == typeof t && t.call(this, this), this;
        },
        fill: function fill() {
          return "url(#" + this.id() + ")";
        },
        toString: function toString() {
          return this.fill();
        },
        attr: function attr(t, e, i) {
          return "transform" == t && (t = "gradientTransform"), a.Container.prototype.attr.call(this, t, e, i);
        }
      },
      construct: {
        gradient: function gradient(t, e) {
          return this.defs().gradient(t, e);
        }
      }
    }), a.extend(a.Gradient, a.FX, {
      from: function from(t, e) {
        return "radial" == (this._target || this).type ? this.attr({
          fx: new a.Number(t),
          fy: new a.Number(e)
        }) : this.attr({
          x1: new a.Number(t),
          y1: new a.Number(e)
        });
      },
      to: function to(t, e) {
        return "radial" == (this._target || this).type ? this.attr({
          cx: new a.Number(t),
          cy: new a.Number(e)
        }) : this.attr({
          x2: new a.Number(t),
          y2: new a.Number(e)
        });
      }
    }), a.extend(a.Defs, {
      gradient: function gradient(t, e) {
        return this.put(new a.Gradient(t)).update(e);
      }
    }), a.Stop = a.invent({
      create: "stop",
      inherit: a.Element,
      extend: {
        update: function update(t) {
          return ("number" == typeof t || t instanceof a.Number) && (t = {
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
          }), null != t.opacity && this.attr("stop-opacity", t.opacity), null != t.color && this.attr("stop-color", t.color), null != t.offset && this.attr("offset", new a.Number(t.offset)), this;
        }
      }
    }), a.Pattern = a.invent({
      create: "pattern",
      inherit: a.Container,
      extend: {
        fill: function fill() {
          return "url(#" + this.id() + ")";
        },
        update: function update(t) {
          return this.clear(), "function" == typeof t && t.call(this, this), this;
        },
        toString: function toString() {
          return this.fill();
        },
        attr: function attr(t, e, i) {
          return "transform" == t && (t = "patternTransform"), a.Container.prototype.attr.call(this, t, e, i);
        }
      },
      construct: {
        pattern: function pattern(t, e, i) {
          return this.defs().pattern(t, e, i);
        }
      }
    }), a.extend(a.Defs, {
      pattern: function pattern(t, e, i) {
        return this.put(new a.Pattern()).update(i).attr({
          x: 0,
          y: 0,
          width: t,
          height: e,
          patternUnits: "userSpaceOnUse"
        });
      }
    }), a.Shape = a.invent({
      create: function create(t) {
        this.constructor.call(this, t);
      },
      inherit: a.Element
    }), a.Symbol = a.invent({
      create: "symbol",
      inherit: a.Container,
      construct: {
        symbol: function symbol() {
          return this.put(new a.Symbol());
        }
      }
    }), a.Use = a.invent({
      create: "use",
      inherit: a.Shape,
      extend: {
        element: function element(t, e) {
          return this.attr("href", (e || "") + "#" + t, a.xlink);
        }
      },
      construct: {
        use: function use(t, e) {
          return this.put(new a.Use()).element(t, e);
        }
      }
    }), a.Rect = a.invent({
      create: "rect",
      inherit: a.Shape,
      construct: {
        rect: function rect(t, e) {
          return this.put(new a.Rect()).size(t, e);
        }
      }
    }), a.Circle = a.invent({
      create: "circle",
      inherit: a.Shape,
      construct: {
        circle: function circle(t) {
          return this.put(new a.Circle()).rx(new a.Number(t).divide(2)).move(0, 0);
        }
      }
    }), a.extend(a.Circle, a.FX, {
      rx: function rx(t) {
        return this.attr("r", t);
      },
      ry: function ry(t) {
        return this.rx(t);
      }
    }), a.Ellipse = a.invent({
      create: "ellipse",
      inherit: a.Shape,
      construct: {
        ellipse: function ellipse(t, e) {
          return this.put(new a.Ellipse()).size(t, e).move(0, 0);
        }
      }
    }), a.extend(a.Ellipse, a.Rect, a.FX, {
      rx: function rx(t) {
        return this.attr("rx", t);
      },
      ry: function ry(t) {
        return this.attr("ry", t);
      }
    }), a.extend(a.Circle, a.Ellipse, {
      x: function x(t) {
        return null == t ? this.cx() - this.rx() : this.cx(t + this.rx());
      },
      y: function y(t) {
        return null == t ? this.cy() - this.ry() : this.cy(t + this.ry());
      },
      cx: function cx(t) {
        return null == t ? this.attr("cx") : this.attr("cx", t);
      },
      cy: function cy(t) {
        return null == t ? this.attr("cy") : this.attr("cy", t);
      },
      width: function width(t) {
        return null == t ? 2 * this.rx() : this.rx(new a.Number(t).divide(2));
      },
      height: function height(t) {
        return null == t ? 2 * this.ry() : this.ry(new a.Number(t).divide(2));
      },
      size: function size(t, e) {
        var i = u(this, t, e);
        return this.rx(new a.Number(i.width).divide(2)).ry(new a.Number(i.height).divide(2));
      }
    }), a.Line = a.invent({
      create: "line",
      inherit: a.Shape,
      extend: {
        array: function array() {
          return new a.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
        },
        plot: function plot(t, e, i, s) {
          return null == t ? this.array() : (t = void 0 !== e ? {
            x1: t,
            y1: e,
            x2: i,
            y2: s
          } : new a.PointArray(t).toLine(), this.attr(t));
        },
        move: function move(t, e) {
          return this.attr(this.array().move(t, e).toLine());
        },
        size: function size(t, e) {
          var i = u(this, t, e);
          return this.attr(this.array().size(i.width, i.height).toLine());
        }
      },
      construct: {
        line: function line(t, e, i, s) {
          return a.Line.prototype.plot.apply(this.put(new a.Line()), null != t ? [t, e, i, s] : [0, 0, 0, 0]);
        }
      }
    }), a.Polyline = a.invent({
      create: "polyline",
      inherit: a.Shape,
      construct: {
        polyline: function polyline(t) {
          return this.put(new a.Polyline()).plot(t || new a.PointArray());
        }
      }
    }), a.Polygon = a.invent({
      create: "polygon",
      inherit: a.Shape,
      construct: {
        polygon: function polygon(t) {
          return this.put(new a.Polygon()).plot(t || new a.PointArray());
        }
      }
    }), a.extend(a.Polyline, a.Polygon, {
      array: function array() {
        return this._array || (this._array = new a.PointArray(this.attr("points")));
      },
      plot: function plot(t) {
        return null == t ? this.array() : this.clear().attr("points", "string" == typeof t ? t : this._array = new a.PointArray(t));
      },
      clear: function clear() {
        return delete this._array, this;
      },
      move: function move(t, e) {
        return this.attr("points", this.array().move(t, e));
      },
      size: function size(t, e) {
        var i = u(this, t, e);
        return this.attr("points", this.array().size(i.width, i.height));
      }
    }), a.extend(a.Line, a.Polyline, a.Polygon, {
      morphArray: a.PointArray,
      x: function x(t) {
        return null == t ? this.bbox().x : this.move(t, this.bbox().y);
      },
      y: function y(t) {
        return null == t ? this.bbox().y : this.move(this.bbox().x, t);
      },
      width: function width(t) {
        var e = this.bbox();
        return null == t ? e.width : this.size(t, e.height);
      },
      height: function height(t) {
        var e = this.bbox();
        return null == t ? e.height : this.size(e.width, t);
      }
    }), a.Path = a.invent({
      create: "path",
      inherit: a.Shape,
      extend: {
        morphArray: a.PathArray,
        array: function array() {
          return this._array || (this._array = new a.PathArray(this.attr("d")));
        },
        plot: function plot(t) {
          return null == t ? this.array() : this.clear().attr("d", "string" == typeof t ? t : this._array = new a.PathArray(t));
        },
        clear: function clear() {
          return delete this._array, this;
        }
      },
      construct: {
        path: function path(t) {
          return this.put(new a.Path()).plot(t || new a.PathArray());
        }
      }
    }), a.Image = a.invent({
      create: "image",
      inherit: a.Shape,
      extend: {
        load: function load(t) {
          if (!t) return this;
          var i = this,
              s = new e.Image();
          return a.on(s, "load", function () {
            a.off(s);
            var e = i.parent(a.Pattern);
            null !== e && (0 == i.width() && 0 == i.height() && i.size(s.width, s.height), e && 0 == e.width() && 0 == e.height() && e.size(i.width(), i.height()), "function" == typeof i._loaded && i._loaded.call(i, {
              width: s.width,
              height: s.height,
              ratio: s.width / s.height,
              url: t
            }));
          }), a.on(s, "error", function (t) {
            a.off(s), "function" == typeof i._error && i._error.call(i, t);
          }), this.attr("href", s.src = this.src = t, a.xlink);
        },
        loaded: function loaded(t) {
          return this._loaded = t, this;
        },
        error: function error(t) {
          return this._error = t, this;
        }
      },
      construct: {
        image: function image(t, e, i) {
          return this.put(new a.Image()).load(t).size(e || 0, i || e || 0);
        }
      }
    }), a.Text = a.invent({
      create: function create() {
        this.constructor.call(this, a.create("text")), this.dom.leading = new a.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", a.defaults.attrs["font-family"]);
      },
      inherit: a.Shape,
      extend: {
        x: function x(t) {
          return null == t ? this.attr("x") : this.attr("x", t);
        },
        text: function text(t) {
          if (void 0 === t) {
            t = "";

            for (var e = this.node.childNodes, i = 0, s = e.length; i < s; ++i) {
              0 != i && 3 != e[i].nodeType && 1 == a.adopt(e[i]).dom.newLined && (t += "\n"), t += e[i].textContent;
            }

            return t;
          }

          if (this.clear().build(!0), "function" == typeof t) t.call(this, this);else {
            i = 0;

            for (var r = (t = t.split("\n")).length; i < r; i++) {
              this.tspan(t[i]).newLine();
            }
          }
          return this.build(!1).rebuild();
        },
        size: function size(t) {
          return this.attr("font-size", t).rebuild();
        },
        leading: function leading(t) {
          return null == t ? this.dom.leading : (this.dom.leading = new a.Number(t), this.rebuild());
        },
        lines: function lines() {
          var t = (this.textPath && this.textPath() || this).node,
              e = a.utils.map(a.utils.filterSVGElements(t.childNodes), function (t) {
            return a.adopt(t);
          });
          return new a.Set(e);
        },
        rebuild: function rebuild(t) {
          if ("boolean" == typeof t && (this._rebuild = t), this._rebuild) {
            var e = this,
                i = 0,
                s = this.dom.leading * new a.Number(this.attr("font-size"));
            this.lines().each(function () {
              this.dom.newLined && (e.textPath() || this.attr("x", e.attr("x")), "\n" == this.text() ? i += s : (this.attr("dy", s + i), i = 0));
            }), this.fire("rebuild");
          }

          return this;
        },
        build: function build(t) {
          return this._build = !!t, this;
        },
        setData: function setData(t) {
          return this.dom = t, this.dom.leading = new a.Number(t.leading || 1.3), this;
        }
      },
      construct: {
        text: function text(t) {
          return this.put(new a.Text()).text(t);
        },
        plain: function plain(t) {
          return this.put(new a.Text()).plain(t);
        }
      }
    }), a.Tspan = a.invent({
      create: "tspan",
      inherit: a.Shape,
      extend: {
        text: function text(t) {
          return null == t ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t ? t.call(this, this) : this.plain(t), this);
        },
        dx: function dx(t) {
          return this.attr("dx", t);
        },
        dy: function dy(t) {
          return this.attr("dy", t);
        },
        newLine: function newLine() {
          var t = this.parent(a.Text);
          return this.dom.newLined = !0, this.dy(t.dom.leading * t.attr("font-size")).attr("x", t.x());
        }
      }
    }), a.extend(a.Text, a.Tspan, {
      plain: function plain(t) {
        return !1 === this._build && this.clear(), this.node.appendChild(i.createTextNode(t)), this;
      },
      tspan: function tspan(t) {
        var e = (this.textPath && this.textPath() || this).node,
            i = new a.Tspan();
        return !1 === this._build && this.clear(), e.appendChild(i.node), i.text(t);
      },
      clear: function clear() {
        for (var t = (this.textPath && this.textPath() || this).node; t.hasChildNodes();) {
          t.removeChild(t.lastChild);
        }

        return this;
      },
      length: function length() {
        return this.node.getComputedTextLength();
      }
    }), a.TextPath = a.invent({
      create: "textPath",
      inherit: a.Parent,
      parent: a.Text,
      construct: {
        morphArray: a.PathArray,
        array: function array() {
          var t = this.track();
          return t ? t.array() : null;
        },
        plot: function plot(t) {
          var e = this.track(),
              i = null;
          return e && (i = e.plot(t)), null == t ? i : this;
        },
        track: function track() {
          var t = this.textPath();
          if (t) return t.reference("href");
        },
        textPath: function textPath() {
          if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return a.adopt(this.node.firstChild);
        }
      }
    }), a.Nested = a.invent({
      create: function create() {
        this.constructor.call(this, a.create("svg")), this.style("overflow", "visible");
      },
      inherit: a.Container,
      construct: {
        nested: function nested() {
          return this.put(new a.Nested());
        }
      }
    });
    var l = {
      stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
      fill: ["color", "opacity", "rule"],
      prefix: function prefix(t, e) {
        return "color" == e ? t : t + "-" + e;
      }
    };

    function h(t, e, i, s) {
      return i + s.replace(a.regex.dots, " .");
    }

    function c(t) {
      return t.toLowerCase().replace(/-(.)/g, function (t, e) {
        return e.toUpperCase();
      });
    }

    function d(t) {
      return t.charAt(0).toUpperCase() + t.slice(1);
    }

    function g(t) {
      var e = t.toString(16);
      return 1 == e.length ? "0" + e : e;
    }

    function u(t, e, i) {
      if (null == e || null == i) {
        var a = t.bbox();
        null == e ? e = a.width / a.height * i : null == i && (i = a.height / a.width * e);
      }

      return {
        width: e,
        height: i
      };
    }

    function f(t, e, i) {
      return {
        x: e * t.a + i * t.c + 0,
        y: e * t.b + i * t.d + 0
      };
    }

    function p(t) {
      return {
        a: t[0],
        b: t[1],
        c: t[2],
        d: t[3],
        e: t[4],
        f: t[5]
      };
    }

    function x(t) {
      for (var i = t.childNodes.length - 1; i >= 0; i--) {
        t.childNodes[i] instanceof e.SVGElement && x(t.childNodes[i]);
      }

      return a.adopt(t).id(a.eid(t.nodeName));
    }

    function b(t) {
      return null == t.x && (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t.w = t.width, t.h = t.height, t.x2 = t.x + t.width, t.y2 = t.y + t.height, t.cx = t.x + t.width / 2, t.cy = t.y + t.height / 2, t;
    }

    function m(t) {
      return Math.abs(t) > 1e-37 ? t : 0;
    }

    ["fill", "stroke"].forEach(function (t) {
      var e = {};
      e[t] = function (e) {
        if (void 0 === e) return this;
        if ("string" == typeof e || a.Color.isRgb(e) || e && "function" == typeof e.fill) this.attr(t, e);else for (var i = l[t].length - 1; i >= 0; i--) {
          null != e[l[t][i]] && this.attr(l.prefix(t, l[t][i]), e[l[t][i]]);
        }
        return this;
      }, a.extend(a.Element, a.FX, e);
    }), a.extend(a.Element, a.FX, {
      translate: function translate(t, e) {
        return this.transform({
          x: t,
          y: e
        });
      },
      matrix: function matrix(t) {
        return this.attr("transform", new a.Matrix(6 == arguments.length ? [].slice.call(arguments) : t));
      },
      opacity: function opacity(t) {
        return this.attr("opacity", t);
      },
      dx: function dx(t) {
        return this.x(new a.Number(t).plus(this instanceof a.FX ? 0 : this.x()), !0);
      },
      dy: function dy(t) {
        return this.y(new a.Number(t).plus(this instanceof a.FX ? 0 : this.y()), !0);
      }
    }), a.extend(a.Path, {
      length: function length() {
        return this.node.getTotalLength();
      },
      pointAt: function pointAt(t) {
        return this.node.getPointAtLength(t);
      }
    }), a.Set = a.invent({
      create: function create(t) {
        Array.isArray(t) ? this.members = t : this.clear();
      },
      extend: {
        add: function add() {
          for (var t = [].slice.call(arguments), e = 0, i = t.length; e < i; e++) {
            this.members.push(t[e]);
          }

          return this;
        },
        remove: function remove(t) {
          var e = this.index(t);
          return e > -1 && this.members.splice(e, 1), this;
        },
        each: function each(t) {
          for (var e = 0, i = this.members.length; e < i; e++) {
            t.apply(this.members[e], [e, this.members]);
          }

          return this;
        },
        clear: function clear() {
          return this.members = [], this;
        },
        length: function length() {
          return this.members.length;
        },
        has: function has(t) {
          return this.index(t) >= 0;
        },
        index: function index(t) {
          return this.members.indexOf(t);
        },
        get: function get(t) {
          return this.members[t];
        },
        first: function first() {
          return this.get(0);
        },
        last: function last() {
          return this.get(this.members.length - 1);
        },
        valueOf: function valueOf() {
          return this.members;
        }
      },
      construct: {
        set: function set(t) {
          return new a.Set(t);
        }
      }
    }), a.FX.Set = a.invent({
      create: function create(t) {
        this.set = t;
      }
    }), a.Set.inherit = function () {
      var t = [];

      for (var e in a.Shape.prototype) {
        "function" == typeof a.Shape.prototype[e] && "function" != typeof a.Set.prototype[e] && t.push(e);
      }

      for (var e in t.forEach(function (t) {
        a.Set.prototype[t] = function () {
          for (var e = 0, i = this.members.length; e < i; e++) {
            this.members[e] && "function" == typeof this.members[e][t] && this.members[e][t].apply(this.members[e], arguments);
          }

          return "animate" == t ? this.fx || (this.fx = new a.FX.Set(this)) : this;
        };
      }), t = [], a.FX.prototype) {
        "function" == typeof a.FX.prototype[e] && "function" != typeof a.FX.Set.prototype[e] && t.push(e);
      }

      t.forEach(function (t) {
        a.FX.Set.prototype[t] = function () {
          for (var e = 0, i = this.set.members.length; e < i; e++) {
            this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments);
          }

          return this;
        };
      });
    }, a.extend(a.Element, {}), a.extend(a.Element, {
      remember: function remember(e, i) {
        if ("object" === t(arguments[0])) for (var a in e) {
          this.remember(a, e[a]);
        } else {
          if (1 == arguments.length) return this.memory()[e];
          this.memory()[e] = i;
        }
        return this;
      },
      forget: function forget() {
        if (0 == arguments.length) this._memory = {};else for (var t = arguments.length - 1; t >= 0; t--) {
          delete this.memory()[arguments[t]];
        }
        return this;
      },
      memory: function memory() {
        return this._memory || (this._memory = {});
      }
    }), a.get = function (t) {
      var e = i.getElementById(function (t) {
        var e = (t || "").toString().match(a.regex.reference);
        if (e) return e[1];
      }(t) || t);
      return a.adopt(e);
    }, a.select = function (t, e) {
      return new a.Set(a.utils.map((e || i).querySelectorAll(t), function (t) {
        return a.adopt(t);
      }));
    }, a.extend(a.Parent, {
      select: function select(t) {
        return a.select(t, this.node);
      }
    });
    var v = "abcdef".split("");

    if ("function" != typeof e.CustomEvent) {
      var y = function y(t, e) {
        e = e || {
          bubbles: !1,
          cancelable: !1,
          detail: void 0
        };
        var a = i.createEvent("CustomEvent");
        return a.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), a;
      };

      y.prototype = e.Event.prototype, a.CustomEvent = y;
    } else a.CustomEvent = e.CustomEvent;

    return a;
  },  "object" === ( t(exports)) && "undefined" != 'object' ? module.exports = A.document ? S(A, A.document) : function (t) {
    return S(t, t.document);
  } : A.SVG = S(A, A.document),
  /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  function () {
    SVG.Filter = SVG.invent({
      create: "filter",
      inherit: SVG.Parent,
      extend: {
        source: "SourceGraphic",
        sourceAlpha: "SourceAlpha",
        background: "BackgroundImage",
        backgroundAlpha: "BackgroundAlpha",
        fill: "FillPaint",
        stroke: "StrokePaint",
        autoSetIn: !0,
        put: function put(t, e) {
          return this.add(t, e), !t.attr("in") && this.autoSetIn && t.attr("in", this.source), t.attr("result") || t.attr("result", t), t;
        },
        blend: function blend(t, e, i) {
          return this.put(new SVG.BlendEffect(t, e, i));
        },
        colorMatrix: function colorMatrix(t, e) {
          return this.put(new SVG.ColorMatrixEffect(t, e));
        },
        convolveMatrix: function convolveMatrix(t) {
          return this.put(new SVG.ConvolveMatrixEffect(t));
        },
        componentTransfer: function componentTransfer(t) {
          return this.put(new SVG.ComponentTransferEffect(t));
        },
        composite: function composite(t, e, i) {
          return this.put(new SVG.CompositeEffect(t, e, i));
        },
        flood: function flood(t, e) {
          return this.put(new SVG.FloodEffect(t, e));
        },
        offset: function offset(t, e) {
          return this.put(new SVG.OffsetEffect(t, e));
        },
        image: function image(t) {
          return this.put(new SVG.ImageEffect(t));
        },
        merge: function merge() {
          var t = [void 0];

          for (var e in arguments) {
            t.push(arguments[e]);
          }

          return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t))());
        },
        gaussianBlur: function gaussianBlur(t, e) {
          return this.put(new SVG.GaussianBlurEffect(t, e));
        },
        morphology: function morphology(t, e) {
          return this.put(new SVG.MorphologyEffect(t, e));
        },
        diffuseLighting: function diffuseLighting(t, e, i) {
          return this.put(new SVG.DiffuseLightingEffect(t, e, i));
        },
        displacementMap: function displacementMap(t, e, i, a, s) {
          return this.put(new SVG.DisplacementMapEffect(t, e, i, a, s));
        },
        specularLighting: function specularLighting(t, e, i, a) {
          return this.put(new SVG.SpecularLightingEffect(t, e, i, a));
        },
        tile: function tile() {
          return this.put(new SVG.TileEffect());
        },
        turbulence: function turbulence(t, e, i, a, s) {
          return this.put(new SVG.TurbulenceEffect(t, e, i, a, s));
        },
        toString: function toString() {
          return "url(#" + this.attr("id") + ")";
        }
      }
    }), SVG.extend(SVG.Defs, {
      filter: function filter(t) {
        var e = this.put(new SVG.Filter());
        return "function" == typeof t && t.call(e, e), e;
      }
    }), SVG.extend(SVG.Container, {
      filter: function filter(t) {
        return this.defs().filter(t);
      }
    }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
      filter: function filter(t) {
        return this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
      },
      unfilter: function unfilter(t) {
        return this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
      }
    }), SVG.Effect = SVG.invent({
      create: function create() {
        this.constructor.call(this);
      },
      inherit: SVG.Element,
      extend: {
        in: function _in(t) {
          return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t);
        },
        result: function result(t) {
          return null == t ? this.attr("result") : this.attr("result", t);
        },
        toString: function toString() {
          return this.result();
        }
      }
    }), SVG.ParentEffect = SVG.invent({
      create: function create() {
        this.constructor.call(this);
      },
      inherit: SVG.Parent,
      extend: {
        in: function _in(t) {
          return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t);
        },
        result: function result(t) {
          return null == t ? this.attr("result") : this.attr("result", t);
        },
        toString: function toString() {
          return this.result();
        }
      }
    });
    var t = {
      blend: function blend(t, e) {
        return this.parent() && this.parent().blend(this, t, e);
      },
      colorMatrix: function colorMatrix(t, e) {
        return this.parent() && this.parent().colorMatrix(t, e).in(this);
      },
      convolveMatrix: function convolveMatrix(t) {
        return this.parent() && this.parent().convolveMatrix(t).in(this);
      },
      componentTransfer: function componentTransfer(t) {
        return this.parent() && this.parent().componentTransfer(t).in(this);
      },
      composite: function composite(t, e) {
        return this.parent() && this.parent().composite(this, t, e);
      },
      flood: function flood(t, e) {
        return this.parent() && this.parent().flood(t, e);
      },
      offset: function offset(t, e) {
        return this.parent() && this.parent().offset(t, e).in(this);
      },
      image: function image(t) {
        return this.parent() && this.parent().image(t);
      },
      merge: function merge() {
        return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
      },
      gaussianBlur: function gaussianBlur(t, e) {
        return this.parent() && this.parent().gaussianBlur(t, e).in(this);
      },
      morphology: function morphology(t, e) {
        return this.parent() && this.parent().morphology(t, e).in(this);
      },
      diffuseLighting: function diffuseLighting(t, e, i) {
        return this.parent() && this.parent().diffuseLighting(t, e, i).in(this);
      },
      displacementMap: function displacementMap(t, e, i, a) {
        return this.parent() && this.parent().displacementMap(this, t, e, i, a);
      },
      specularLighting: function specularLighting(t, e, i, a) {
        return this.parent() && this.parent().specularLighting(t, e, i, a).in(this);
      },
      tile: function tile() {
        return this.parent() && this.parent().tile().in(this);
      },
      turbulence: function turbulence(t, e, i, a, s) {
        return this.parent() && this.parent().turbulence(t, e, i, a, s).in(this);
      }
    };
    SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({
      create: function create() {
        this.constructor.call(this);
      },
      inherit: SVG.Element,
      extend: {
        in: function _in(t) {
          this.attr("in", t);
        }
      }
    });
    var e = {
      blend: function blend(t, e, i) {
        this.attr({
          in: t,
          in2: e,
          mode: i || "normal"
        });
      },
      colorMatrix: function colorMatrix(t, e) {
        "matrix" == t && (e = s(e)), this.attr({
          type: t,
          values: void 0 === e ? null : e
        });
      },
      convolveMatrix: function convolveMatrix(t) {
        t = s(t), this.attr({
          order: Math.sqrt(t.split(" ").length),
          kernelMatrix: t
        });
      },
      composite: function composite(t, e, i) {
        this.attr({
          in: t,
          in2: e,
          operator: i
        });
      },
      flood: function flood(t, e) {
        this.attr("flood-color", t), null != e && this.attr("flood-opacity", e);
      },
      offset: function offset(t, e) {
        this.attr({
          dx: t,
          dy: e
        });
      },
      image: function image(t) {
        this.attr("href", t, SVG.xlink);
      },
      displacementMap: function displacementMap(t, e, i, a, s) {
        this.attr({
          in: t,
          in2: e,
          scale: i,
          xChannelSelector: a,
          yChannelSelector: s
        });
      },
      gaussianBlur: function gaussianBlur(t, e) {
        null != t || null != e ? this.attr("stdDeviation", r(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
      },
      morphology: function morphology(t, e) {
        this.attr({
          operator: t,
          radius: e
        });
      },
      tile: function tile() {},
      turbulence: function turbulence(t, e, i, a, s) {
        this.attr({
          numOctaves: e,
          seed: i,
          stitchTiles: a,
          baseFrequency: t,
          type: s
        });
      }
    },
        i = {
      merge: function merge() {
        var t;

        if (arguments[0] instanceof SVG.Set) {
          var e = this;
          arguments[0].each(function (t) {
            this instanceof SVG.MergeNode ? e.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e.put(new SVG.MergeNode(this));
          });
        } else {
          t = Array.isArray(arguments[0]) ? arguments[0] : arguments;

          for (var i = 0; i < t.length; i++) {
            t[i] instanceof SVG.MergeNode ? this.put(t[i]) : this.put(new SVG.MergeNode(t[i]));
          }
        }
      },
      componentTransfer: function componentTransfer(t) {
        if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach(function (t) {
          this[t] = new SVG["Func" + t.toUpperCase()]("identity"), this.rgb.add(this[t]), this.node.appendChild(this[t].node);
        }.bind(this)), t) for (var e in t.rgb && (["r", "g", "b"].forEach(function (e) {
          this[e].attr(t.rgb);
        }.bind(this)), delete t.rgb), t) {
          this[e].attr(t[e]);
        }
      },
      diffuseLighting: function diffuseLighting(t, e, i) {
        this.attr({
          surfaceScale: t,
          diffuseConstant: e,
          kernelUnitLength: i
        });
      },
      specularLighting: function specularLighting(t, e, i, a) {
        this.attr({
          surfaceScale: t,
          diffuseConstant: e,
          specularExponent: i,
          kernelUnitLength: a
        });
      }
    },
        a = {
      distantLight: function distantLight(t, e) {
        this.attr({
          azimuth: t,
          elevation: e
        });
      },
      pointLight: function pointLight(t, e, i) {
        this.attr({
          x: t,
          y: e,
          z: i
        });
      },
      spotLight: function spotLight(t, e, i, a, s, r) {
        this.attr({
          x: t,
          y: e,
          z: i,
          pointsAtX: a,
          pointsAtY: s,
          pointsAtZ: r
        });
      },
      mergeNode: function mergeNode(t) {
        this.attr("in", t);
      }
    };

    function s(t) {
      return Array.isArray(t) && (t = new SVG.Array(t)), t.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }

    function r(t) {
      if (!Array.isArray(t)) return t;

      for (var e = 0, i = t.length, a = []; e < i; e++) {
        a.push(t[e]);
      }

      return a.join(" ");
    }

    function n() {
      var t = function t() {};

      for (var e in "function" == typeof arguments[arguments.length - 1] && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) {
        for (var i in arguments[e]) {
          t(arguments[e][i], i, arguments[e]);
        }
      }
    }

    ["r", "g", "b", "a"].forEach(function (t) {
      a["Func" + t.toUpperCase()] = function (t) {
        switch (this.attr("type", t), t) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;

          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;

          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), n(e, function (t, e) {
      var i = e.charAt(0).toUpperCase() + e.slice(1);
      SVG[i + "Effect"] = SVG.invent({
        create: function create() {
          this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out");
        },
        inherit: SVG.Effect,
        extend: {}
      });
    }), n(i, function (t, e) {
      var i = e.charAt(0).toUpperCase() + e.slice(1);
      SVG[i + "Effect"] = SVG.invent({
        create: function create() {
          this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out");
        },
        inherit: SVG.ParentEffect,
        extend: {}
      });
    }), n(a, function (t, e) {
      var i = e.charAt(0).toUpperCase() + e.slice(1);
      SVG[i] = SVG.invent({
        create: function create() {
          this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments);
        },
        inherit: SVG.ChildEffect,
        extend: {}
      });
    }), SVG.extend(SVG.MergeEffect, {
      in: function _in(t) {
        return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this;
      }
    }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
      in2: function in2(t) {
        return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t);
      }
    }), SVG.filter = {
      sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
    };
  }.call(void 0), function () {
    function t(t, s, r, n, o, l, h) {
      for (var c = t.slice(s, r || h), d = n.slice(o, l || h), g = 0, u = {
        pos: [0, 0],
        start: [0, 0]
      }, f = {
        pos: [0, 0],
        start: [0, 0]
      };;) {
        if (c[g] = e.call(u, c[g]), d[g] = e.call(f, d[g]), c[g][0] != d[g][0] || "M" == c[g][0] || "A" == c[g][0] && (c[g][4] != d[g][4] || c[g][5] != d[g][5]) ? (Array.prototype.splice.apply(c, [g, 1].concat(a.call(u, c[g]))), Array.prototype.splice.apply(d, [g, 1].concat(a.call(f, d[g])))) : (c[g] = i.call(u, c[g]), d[g] = i.call(f, d[g])), ++g == c.length && g == d.length) break;
        g == c.length && c.push(["C", u.pos[0], u.pos[1], u.pos[0], u.pos[1], u.pos[0], u.pos[1]]), g == d.length && d.push(["C", f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]);
      }

      return {
        start: c,
        dest: d
      };
    }

    function e(t) {
      switch (t[0]) {
        case "z":
        case "Z":
          t[0] = "L", t[1] = this.start[0], t[2] = this.start[1];
          break;

        case "H":
          t[0] = "L", t[2] = this.pos[1];
          break;

        case "V":
          t[0] = "L", t[2] = t[1], t[1] = this.pos[0];
          break;

        case "T":
          t[0] = "Q", t[3] = t[1], t[4] = t[2], t[1] = this.reflection[1], t[2] = this.reflection[0];
          break;

        case "S":
          t[0] = "C", t[6] = t[4], t[5] = t[3], t[4] = t[2], t[3] = t[1], t[2] = this.reflection[1], t[1] = this.reflection[0];
      }

      return t;
    }

    function i(t) {
      var e = t.length;
      return this.pos = [t[e - 2], t[e - 1]], -1 != "SCQT".indexOf(t[0]) && (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]), t;
    }

    function a(t) {
      var e = [t];

      switch (t[0]) {
        case "M":
          return this.pos = this.start = [t[1], t[2]], e;

        case "L":
          t[5] = t[3] = t[1], t[6] = t[4] = t[2], t[1] = this.pos[0], t[2] = this.pos[1];
          break;

        case "Q":
          t[6] = t[4], t[5] = t[3], t[4] = 1 * t[4] / 3 + 2 * t[2] / 3, t[3] = 1 * t[3] / 3 + 2 * t[1] / 3, t[2] = 1 * this.pos[1] / 3 + 2 * t[2] / 3, t[1] = 1 * this.pos[0] / 3 + 2 * t[1] / 3;
          break;

        case "A":
          t = (e = function (t, e) {
            var i,
                a,
                s,
                r,
                n,
                o,
                l,
                h,
                c,
                d,
                g,
                u,
                f,
                p,
                x,
                b,
                m,
                v,
                y,
                w,
                k,
                A,
                S,
                C,
                L,
                P,
                T = Math.abs(e[1]),
                z = Math.abs(e[2]),
                I = e[3] % 360,
                M = e[4],
                E = e[5],
                X = e[6],
                Y = e[7],
                F = new SVG.Point(t),
                D = new SVG.Point(X, Y),
                R = [];
            if (0 === T || 0 === z || F.x === D.x && F.y === D.y) return [["C", F.x, F.y, D.x, D.y, D.x, D.y]];
            i = new SVG.Point((F.x - D.x) / 2, (F.y - D.y) / 2).transform(new SVG.Matrix().rotate(I)), (a = i.x * i.x / (T * T) + i.y * i.y / (z * z)) > 1 && (a = Math.sqrt(a), T *= a, z *= a);
            s = new SVG.Matrix().rotate(I).scale(1 / T, 1 / z).rotate(-I), F = F.transform(s), D = D.transform(s), r = [D.x - F.x, D.y - F.y], o = r[0] * r[0] + r[1] * r[1], n = Math.sqrt(o), r[0] /= n, r[1] /= n, l = o < 4 ? Math.sqrt(1 - o / 4) : 0, M === E && (l *= -1);
            h = new SVG.Point((D.x + F.x) / 2 + l * -r[1], (D.y + F.y) / 2 + l * r[0]), c = new SVG.Point(F.x - h.x, F.y - h.y), d = new SVG.Point(D.x - h.x, D.y - h.y), g = Math.acos(c.x / Math.sqrt(c.x * c.x + c.y * c.y)), c.y < 0 && (g *= -1);
            u = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)), d.y < 0 && (u *= -1);
            E && g > u && (u += 2 * Math.PI);
            !E && g < u && (u -= 2 * Math.PI);

            for (p = Math.ceil(2 * Math.abs(g - u) / Math.PI), b = [], m = g, f = (u - g) / p, x = 4 * Math.tan(f / 4) / 3, k = 0; k <= p; k++) {
              y = Math.cos(m), v = Math.sin(m), w = new SVG.Point(h.x + y, h.y + v), b[k] = [new SVG.Point(w.x + x * v, w.y - x * y), w, new SVG.Point(w.x - x * v, w.y + x * y)], m += f;
            }

            for (b[0][0] = b[0][1].clone(), b[b.length - 1][2] = b[b.length - 1][1].clone(), s = new SVG.Matrix().rotate(I).scale(T, z).rotate(-I), k = 0, A = b.length; k < A; k++) {
              b[k][0] = b[k][0].transform(s), b[k][1] = b[k][1].transform(s), b[k][2] = b[k][2].transform(s);
            }

            for (k = 1, A = b.length; k < A; k++) {
              w = b[k - 1][2], S = w.x, C = w.y, w = b[k][0], L = w.x, P = w.y, w = b[k][1], X = w.x, Y = w.y, R.push(["C", S, C, L, P, X, Y]);
            }

            return R;
          }(this.pos, t))[0];

      }

      return t[0] = "C", this.pos = [t[5], t[6]], this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]], e;
    }

    function s(t, e) {
      if (!1 === e) return !1;

      for (var i = e, a = t.length; i < a; ++i) {
        if ("M" == t[i][0]) return i;
      }

      return !1;
    }

    SVG.extend(SVG.PathArray, {
      morph: function morph(e) {
        for (var i = this.value, a = this.parse(e), r = 0, n = 0, o = !1, l = !1; !1 !== r || !1 !== n;) {
          var h;
          o = s(i, !1 !== r && r + 1), l = s(a, !1 !== n && n + 1), !1 === r && (r = 0 == (h = new SVG.PathArray(c.start).bbox()).height || 0 == h.width ? i.push(i[0]) - 1 : i.push(["M", h.x + h.width / 2, h.y + h.height / 2]) - 1), !1 === n && (n = 0 == (h = new SVG.PathArray(c.dest).bbox()).height || 0 == h.width ? a.push(a[0]) - 1 : a.push(["M", h.x + h.width / 2, h.y + h.height / 2]) - 1);
          var c = t(i, r, o, a, n, l);
          i = i.slice(0, r).concat(c.start, !1 === o ? [] : i.slice(o)), a = a.slice(0, n).concat(c.dest, !1 === l ? [] : a.slice(l)), r = !1 !== o && r + c.start.length, n = !1 !== l && n + c.dest.length;
        }

        return this.value = i, this.destination = new SVG.PathArray(), this.destination.value = a, this;
      }
    });
  }(),
  /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  function () {
    function t(t) {
      t.remember("_draggable", this), this.el = t;
    }

    t.prototype.init = function (t, e) {
      var i = this;
      this.constraint = t, this.value = e, this.el.on("mousedown.drag", function (t) {
        i.start(t);
      }), this.el.on("touchstart.drag", function (t) {
        i.start(t);
      });
    }, t.prototype.transformPoint = function (t, e) {
      var i = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
      return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m);
    }, t.prototype.getBBox = function () {
      var t = this.el.bbox();
      return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t;
    }, t.prototype.start = function (t) {
      if ("click" != t.type && "mousedown" != t.type && "mousemove" != t.type || 1 == (t.which || t.buttons)) {
        var e = this;

        if (this.el.fire("beforedrag", {
          event: t,
          handler: this
        }), !this.el.event().defaultPrevented) {
          t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var i,
              a = this.getBBox();
          if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
            case "middle":
              i /= 2;
              break;

            case "start":
              i = 0;
          }
          this.startPoints = {
            point: this.transformPoint(t, i),
            box: a,
            transform: this.el.transform()
          }, SVG.on(window, "mousemove.drag", function (t) {
            e.drag(t);
          }), SVG.on(window, "touchmove.drag", function (t) {
            e.drag(t);
          }), SVG.on(window, "mouseup.drag", function (t) {
            e.end(t);
          }), SVG.on(window, "touchend.drag", function (t) {
            e.end(t);
          }), this.el.fire("dragstart", {
            event: t,
            p: this.startPoints.point,
            m: this.m,
            handler: this
          });
        }
      }
    }, t.prototype.drag = function (t) {
      var e = this.getBBox(),
          i = this.transformPoint(t),
          a = this.startPoints.box.x + i.x - this.startPoints.point.x,
          s = this.startPoints.box.y + i.y - this.startPoints.point.y,
          r = this.constraint,
          n = i.x - this.startPoints.point.x,
          o = i.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", {
        event: t,
        p: i,
        m: this.m,
        handler: this
      }), this.el.event().defaultPrevented) return i;

      if ("function" == typeof r) {
        var l = r.call(this.el, a, s, this.m);
        "boolean" == typeof l && (l = {
          x: l,
          y: l
        }), !0 === l.x ? this.el.x(a) : !1 !== l.x && this.el.x(l.x), !0 === l.y ? this.el.y(s) : !1 !== l.y && this.el.y(l.y);
      } else "object" == _typeof(r) && (null != r.minX && a < r.minX ? n = (a = r.minX) - this.startPoints.box.x : null != r.maxX && a > r.maxX - e.width && (n = (a = r.maxX - e.width) - this.startPoints.box.x), null != r.minY && s < r.minY ? o = (s = r.minY) - this.startPoints.box.y : null != r.maxY && s > r.maxY - e.height && (o = (s = r.maxY - e.height) - this.startPoints.box.y), null != r.snapToGrid && (a -= a % r.snapToGrid, s -= s % r.snapToGrid, n -= n % r.snapToGrid, o -= o % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
        x: n,
        y: o
      }, !0) : this.el.move(a, s));

      return i;
    }, t.prototype.end = function (t) {
      var e = this.drag(t);
      this.el.fire("dragend", {
        event: t,
        p: e,
        m: this.m,
        handler: this
      }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, {
      draggable: function draggable(e, i) {
        "function" != typeof e && "object" != _typeof(e) || (i = e, e = !0);
        var a = this.remember("_draggable") || new t(this);
        return (e = void 0 === e || e) ? a.init(i || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
      }
    });
  }.call(void 0), function () {
    function t(t) {
      this.el = t, t.remember("_selectHandler", this), this.pointSelection = {
        isSelected: !1
      }, this.rectSelection = {
        isSelected: !1
      }, this.pointsList = {
        lt: [0, 0],
        rt: ["width", 0],
        rb: ["width", "height"],
        lb: [0, "height"],
        t: ["width", 0],
        r: ["width", "height"],
        b: ["width", "height"],
        l: [0, "height"]
      }, this.pointCoord = function (t, e, i) {
        var a = "string" != typeof t ? t : e[t];
        return i ? a / 2 : a;
      }, this.pointCoords = function (t, e) {
        var i = this.pointsList[t];
        return {
          x: this.pointCoord(i[0], e, "t" === t || "b" === t),
          y: this.pointCoord(i[1], e, "r" === t || "l" === t)
        };
      };
    }

    t.prototype.init = function (t, e) {
      var i = this.el.bbox();
      this.options = {};
      var a = this.el.selectize.defaults.points;

      for (var s in this.el.selectize.defaults) {
        this.options[s] = this.el.selectize.defaults[s], void 0 !== e[s] && (this.options[s] = e[s]);
      }

      var r = ["points", "pointsExclude"];

      for (var s in r) {
        var n = this.options[r[s]];
        "string" == typeof n ? n = n.length > 0 ? n.split(/\s*,\s*/i) : [] : "boolean" == typeof n && "points" === r[s] && (n = n ? a : []), this.options[r[s]] = n;
      }

      this.options.points = [a, this.options.points].reduce(function (t, e) {
        return t.filter(function (t) {
          return e.indexOf(t) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function (t, e) {
        return t.filter(function (t) {
          return e.indexOf(t) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup();
    }, t.prototype.selectPoints = function (t) {
      return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, t.prototype.getPointArray = function () {
      var t = this.el.bbox();
      return this.el.array().valueOf().map(function (e) {
        return [e[0] - t.x, e[1] - t.y];
      });
    }, t.prototype.drawPoints = function () {
      for (var t = this, e = this.getPointArray(), i = 0, a = e.length; i < a; ++i) {
        var s = function (e) {
          return function (i) {
            (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation();
            var a = i.pageX || i.touches[0].pageX,
                s = i.pageY || i.touches[0].pageY;
            t.el.fire("point", {
              x: a,
              y: s,
              i: e,
              event: i
            });
          };
        }(i),
            r = this.drawPoint(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s).on("mousedown", s);

        this.pointSelection.set.add(r);
      }
    }, t.prototype.drawPoint = function (t, e) {
      var i = this.options.pointType;

      switch (i) {
        case "circle":
          return this.drawCircle(t, e);

        case "rect":
          return this.drawRect(t, e);

        default:
          if ("function" == typeof i) return i.call(this, t, e);
          throw new Error("Unknown " + i + " point type!");
      }
    }, t.prototype.drawCircle = function (t, e) {
      return this.nested.circle(this.options.pointSize).center(t, e);
    }, t.prototype.drawRect = function (t, e) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, e);
    }, t.prototype.updatePointSelection = function () {
      var t = this.getPointArray();
      this.pointSelection.set.each(function (e) {
        this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1]);
      });
    }, t.prototype.updateRectSelection = function () {
      var t = this,
          e = this.el.bbox();

      if (this.rectSelection.set.get(0).attr({
        width: e.width,
        height: e.height
      }), this.options.points.length && this.options.points.map(function (i, a) {
        var s = t.pointCoords(i, e);
        t.rectSelection.set.get(a + 1).center(s.x, s.y);
      }), this.options.rotationPoint) {
        var i = this.rectSelection.set.length();
        this.rectSelection.set.get(i - 1).center(e.width / 2, 20);
      }
    }, t.prototype.selectRect = function (t) {
      var e = this,
          i = this.el.bbox();

      function a(t) {
        return function (i) {
          (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation();
          var a = i.pageX || i.touches[0].pageX,
              s = i.pageY || i.touches[0].pageY;
          e.el.fire(t, {
            x: a,
            y: s,
            event: i
          });
        };
      }

      if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
        this.options.points.map(function (t, s) {
          var r = e.pointCoords(t, i),
              n = e.drawPoint(r.x, r.y).attr("class", e.options.classPoints + "_" + t).on("mousedown", a(t)).on("touchstart", a(t));
          e.rectSelection.set.add(n);
        }), this.rectSelection.set.each(function () {
          this.addClass(e.options.classPoints);
        });
      }

      if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var s = function s(t) {
          (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation();
          var i = t.pageX || t.touches[0].pageX,
              a = t.pageY || t.touches[0].pageY;
          e.el.fire("rot", {
            x: i,
            y: a,
            event: t
          });
        },
            r = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s).on("mousedown", s);

        this.rectSelection.set.add(r);
      }
    }, t.prototype.handler = function () {
      var t = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, t.prototype.observe = function () {
      var t = this;
      if (MutationObserver) {
        if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function () {
          t.handler();
        }), this.observerInst.observe(this.el.node, {
          attributes: !0
        });else try {
          this.observerInst.disconnect(), delete this.observerInst;
        } catch (t) {}
      } else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function () {
        t.handler();
      });
    }, t.prototype.cleanup = function () {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function () {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function () {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, {
      selectize: function selectize(e, i) {
        return "object" == _typeof(e) && (i = e, e = !0), (this.remember("_selectHandler") || new t(this)).init(void 0 === e || e, i || {}), this;
      }
    }), SVG.Element.prototype.selectize.defaults = {
      points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
      pointsExclude: [],
      classRect: "svg_select_boundingRect",
      classPoints: "svg_select_points",
      pointSize: 7,
      rotationPoint: !0,
      deepSelect: !1,
      pointType: "circle"
    };
  }(), function () {
    (function () {
      function t(t) {
        t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint();
      }

      t.prototype.transformPoint = function (t, e, i) {
        return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m);
      }, t.prototype._extractPosition = function (t) {
        return {
          x: null != t.clientX ? t.clientX : t.touches[0].clientX,
          y: null != t.clientY ? t.clientY : t.touches[0].clientY
        };
      }, t.prototype.init = function (t) {
        var e = this;

        if (this.stop(), "stop" !== t) {
          for (var i in this.options = {}, this.el.resize.defaults) {
            this.options[i] = this.el.resize.defaults[i], void 0 !== t[i] && (this.options[i] = t[i]);
          }

          this.el.on("lt.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("rt.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("rb.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("lb.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("t.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("r.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("b.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("l.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("rot.resize", function (t) {
            e.resize(t || window.event);
          }), this.el.on("point.resize", function (t) {
            e.resize(t || window.event);
          }), this.update();
        }
      }, t.prototype.stop = function () {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, t.prototype.resize = function (t) {
        var e = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
          x: window.pageXOffset,
          y: window.pageYOffset
        };

        var i = this._extractPosition(t.detail.event);

        if (this.parameters = {
          type: this.el.type,
          p: this.transformPoint(i.x, i.y),
          x: t.detail.x,
          y: t.detail.y,
          box: this.el.bbox(),
          rotation: this.el.transform().rotation
        }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t.detail.i) {
          var a = this.el.array().valueOf();
          this.parameters.i = t.detail.i, this.parameters.pointCoords = [a[t.detail.i][0], a[t.detail.i][1]];
        }

        switch (t.type) {
          case "lt":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e);

              if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
                i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y + i[1]).size(this.parameters.box.width - i[0], this.parameters.box.height - i[1]);
              }
            };

            break;

          case "rt":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, 2);

              if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
                i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).size(this.parameters.box.width + i[0], this.parameters.box.height - i[1]);
              }
            };

            break;

          case "rb":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, 0);

              if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
                i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i[0], this.parameters.box.height + i[1]);
              }
            };

            break;

          case "lb":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, 1);

              if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
                i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).size(this.parameters.box.width - i[0], this.parameters.box.height + i[1]);
              }
            };

            break;

          case "t":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, 2);

              if (this.parameters.box.height - i[1] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).height(this.parameters.box.height - i[1]);
              }
            };

            break;

          case "r":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, 0);

              if (this.parameters.box.width + i[0] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i[0]);
              }
            };

            break;

          case "b":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, 0);

              if (this.parameters.box.height + i[1] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i[1]);
              }
            };

            break;

          case "l":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, 1);

              if (this.parameters.box.width - i[0] > 0) {
                if ("text" === this.parameters.type) return;
                this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).width(this.parameters.box.width - i[0]);
              }
            };

            break;

          case "rot":
            this.calc = function (t, e) {
              var i = t + this.parameters.p.x,
                  a = e + this.parameters.p.y,
                  s = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                  r = Math.atan2(a - this.parameters.box.y - this.parameters.box.height / 2, i - this.parameters.box.x - this.parameters.box.width / 2),
                  n = this.parameters.rotation + 180 * (r - s) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(n - n % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };

            break;

          case "point":
            this.calc = function (t, e) {
              var i = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                  a = this.el.array().valueOf();
              a[this.parameters.i][0] = this.parameters.pointCoords[0] + i[0], a[this.parameters.i][1] = this.parameters.pointCoords[1] + i[1], this.el.plot(a);
            };

        }

        this.el.fire("resizestart", {
          dx: this.parameters.x,
          dy: this.parameters.y,
          event: t
        }), SVG.on(window, "touchmove.resize", function (t) {
          e.update(t || window.event);
        }), SVG.on(window, "touchend.resize", function () {
          e.done();
        }), SVG.on(window, "mousemove.resize", function (t) {
          e.update(t || window.event);
        }), SVG.on(window, "mouseup.resize", function () {
          e.done();
        });
      }, t.prototype.update = function (t) {
        if (t) {
          var e = this._extractPosition(t),
              i = this.transformPoint(e.x, e.y),
              a = i.x - this.parameters.p.x,
              s = i.y - this.parameters.p.y;

          this.lastUpdateCall = [a, s], this.calc(a, s), this.el.fire("resizing", {
            dx: a,
            dy: s,
            event: t
          });
        } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, t.prototype.done = function () {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, t.prototype.snapToGrid = function (t, e, i, a) {
        var s;
        return void 0 !== a ? s = [(i + t) % this.options.snapToGrid, (a + e) % this.options.snapToGrid] : (i = null == i ? 3 : i, s = [(this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (s[0] -= this.options.snapToGrid), e < 0 && (s[1] -= this.options.snapToGrid), t -= Math.abs(s[0]) < this.options.snapToGrid / 2 ? s[0] : s[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(s[1]) < this.options.snapToGrid / 2 ? s[1] : s[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, i, a);
      }, t.prototype.constraintToBox = function (t, e, i, a) {
        var s,
            r,
            n = this.options.constraint || {};
        return void 0 !== a ? (s = i, r = a) : (s = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== n.minX && s + t < n.minX && (t = n.minX - s), void 0 !== n.maxX && s + t > n.maxX && (t = n.maxX - s), void 0 !== n.minY && r + e < n.minY && (e = n.minY - r), void 0 !== n.maxY && r + e > n.maxY && (e = n.maxY - r), [t, e];
      }, t.prototype.checkAspectRatio = function (t, e) {
        if (!this.options.saveAspectRatio) return t;
        var i = t.slice(),
            a = this.parameters.box.width / this.parameters.box.height,
            s = this.parameters.box.width + t[0],
            r = this.parameters.box.height - t[1],
            n = s / r;
        return n < a ? (i[1] = s / a - this.parameters.box.height, e && (i[1] = -i[1])) : n > a && (i[0] = this.parameters.box.width - r * a, e && (i[0] = -i[0])), i;
      }, SVG.extend(SVG.Element, {
        resize: function resize(e) {
          return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this;
        }
      }), SVG.Element.prototype.resize.defaults = {
        snapToAngle: .1,
        snapToGrid: 1,
        constraint: {},
        saveAspectRatio: !1
      };
    }).call(this);
  }();
  !function (t, e) {
    void 0 === e && (e = {});
    var i = e.insertAt;

    if (t && "undefined" != typeof document) {
      var a = document.head || document.getElementsByTagName("head")[0],
          s = document.createElement("style");
      s.type = "text/css", "top" === i && a.firstChild ? a.insertBefore(s, a.firstChild) : a.appendChild(s), s.styleSheet ? s.styleSheet.cssText = t : s.appendChild(document.createTextNode(t));
    }
  }('.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-candlestick>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}'), function () {
    function t(t) {
      var e = t.__resizeTriggers__,
          i = e.firstElementChild,
          a = e.lastElementChild,
          s = i ? i.firstElementChild : null;
      a && (a.scrollLeft = a.scrollWidth, a.scrollTop = a.scrollHeight), s && (s.style.width = i.offsetWidth + 1 + "px", s.style.height = i.offsetHeight + 1 + "px"), i && (i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight);
    }

    function e(e) {
      var i = this;
      t(this), this.__resizeRAF__ && r(this.__resizeRAF__), this.__resizeRAF__ = s(function () {
        (function (t) {
          return t.offsetWidth != t.__resizeLast__.width || t.offsetHeight != t.__resizeLast__.height;
        })(i) && (i.__resizeLast__.width = i.offsetWidth, i.__resizeLast__.height = i.offsetHeight, i.__resizeListeners__.forEach(function (t) {
          t.call(e);
        }));
      });
    }

    var i,
        a,
        s = (i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (t) {
      return window.setTimeout(t, 20);
    }, function (t) {
      return i(t);
    }),
        r = (a = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout, function (t) {
      return a(t);
    }),
        n = !1,
        o = "animationstart",
        l = "Webkit Moz O ms".split(" "),
        h = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "),
        c = document.createElement("fakeelement");
    if (void 0 !== c.style.animationName && (n = !0), !1 === n) for (var d = 0; d < l.length; d++) {
      if (void 0 !== c.style[l[d] + "AnimationName"]) {
        o = h[d];
        break;
      }
    }
    window.addResizeListener = function (i, a) {
      i.__resizeTriggers__ || ("static" == getComputedStyle(i).position && (i.style.position = "relative"), i.__resizeLast__ = {}, i.__resizeListeners__ = [], (i.__resizeTriggers__ = document.createElement("div")).className = "resize-triggers", i.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', i.appendChild(i.__resizeTriggers__), t(i), i.addEventListener("scroll", e, !0), o && i.__resizeTriggers__.addEventListener(o, function (e) {
        "resizeanim" == e.animationName && t(i);
      })), i.__resizeListeners__.push(a);
    }, window.removeResizeListener = function (t, i) {
      t && (t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(i), 1), t.__resizeListeners__.length || (t.removeEventListener("scroll", e), t.__resizeTriggers__.parentNode && (t.__resizeTriggers__ = !t.removeChild(t.__resizeTriggers__))));
    };
  }(), window.Apex = {};

  var Et = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "initModules",
      value: function value() {
        this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], this.ctx.animations = new x(this.ctx), this.ctx.axes = new K(this.ctx), this.ctx.core = new It(this.ctx.el, this.ctx), this.ctx.config = new N({}), this.ctx.data = new B(this.ctx), this.ctx.grid = new U(this.ctx), this.ctx.graphics = new b(this.ctx), this.ctx.coreUtils = new y(this.ctx), this.ctx.crosshairs = new tt(this.ctx), this.ctx.events = new J(this.ctx), this.ctx.exports = new _(this.ctx), this.ctx.localization = new Q(this.ctx), this.ctx.options = new L(), this.ctx.responsive = new et(this.ctx), this.ctx.series = new X(this.ctx), this.ctx.theme = new it(this.ctx), this.ctx.formatters = new V(this.ctx), this.ctx.titleSubtitle = new at(this.ctx), this.ctx.legend = new ct(this.ctx), this.ctx.toolbar = new dt(this.ctx), this.ctx.dimensions = new lt(this.ctx), this.ctx.updateHelpers = new Mt(this.ctx), this.ctx.zoomPanSelection = new gt(this.ctx), this.ctx.w.globals.tooltip = new vt(this.ctx);
      }
    }]), t;
  }(),
      Xt = function () {
    function t(i) {
      e(this, t), this.ctx = i, this.w = i.w;
    }

    return a(t, [{
      key: "clear",
      value: function value() {
        this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements();
      }
    }, {
      key: "killSVG",
      value: function value(t) {
        t.each(function (t, e) {
          this.removeClass("*"), this.off(), this.stop();
        }, !0), t.ungroup(), t.clear();
      }
    }, {
      key: "clearDomElements",
      value: function value() {
        var t = this,
            e = this.w.globals.dom.Paper.node;
        e.parentNode && e.parentNode.parentNode && (e.parentNode.parentNode.style.minHeight = "unset"), this.ctx.eventList.forEach(function (e) {
          t.w.globals.dom.baseEl.removeEventListener(e, t.ctx.events.documentEvent);
        });
        var i = this.w.globals.dom;
        if (null !== this.ctx.el) for (; this.ctx.el.firstChild;) {
          this.ctx.el.removeChild(this.ctx.el.firstChild);
        }
        this.killSVG(i.Paper), i.Paper.remove(), i.elWrap = null, i.elGraphical = null, i.elAnnotations = null, i.elLegendWrap = null, i.baseEl = null, i.elGridRect = null, i.elGridRectMask = null, i.elGridRectMarkerMask = null, i.elDefs = null;
      }
    }]), t;
  }(),
      Yt = function () {
    function t(i, a) {
      e(this, t), this.opts = a, this.ctx = this, this.w = new W(a).init(), this.el = i, this.w.globals.cuid = f.randomId(), this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid, new Et(this).initModules(), this.create = f.bind(this.create, this), this.windowResizeHandler = this._windowResize.bind(this);
    }

    return a(t, [{
      key: "render",
      value: function value() {
        var t = this;
        return new Promise(function (e, i) {
          if (null !== t.el) {
            void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({
              id: t.w.globals.chartID,
              group: t.w.config.chart.group,
              chart: t
            }), t.setLocale(t.w.config.chart.defaultLocale);
            var a = t.w.config.chart.events.beforeMount;
            "function" == typeof a && a(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), window.addResizeListener(t.el.parentNode, t._parentResizeCallback.bind(t));
            var s = t.create(t.w.config.series, {});
            if (!s) return e(t);
            t.mount(s).then(function () {
              "function" == typeof t.w.config.chart.events.mounted && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), e(s);
            }).catch(function (t) {
              i(t);
            });
          } else i(new Error("Element not found"));
        });
      }
    }, {
      key: "create",
      value: function value(t, e) {
        var i = this.w;
        new Et(this).initModules();
        var a = this.w.globals;
        (a.noData = !1, a.animationEnded = !1, this.responsive.checkResponsiveConfig(e), i.config.xaxis.convertedCatToNumeric) && new H(i.config).convertCatToNumericXaxis(i.config, this.ctx);
        if (null === this.el) return a.animationEnded = !0, null;
        if (this.core.setupElements(), 0 === a.svgWidth) return a.animationEnded = !0, null;
        var s = y.checkComboSeries(t);
        a.comboCharts = s.comboCharts, a.comboBarCount = s.comboBarCount;
        var r = t.every(function (t) {
          return t.data && 0 === t.data.length;
        });
        (0 === t.length || r) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new z(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters()), this.formatters.heatmapLabelFormatters(), this.dimensions.plotCoords();
        var n = this.core.xySettings();
        this.grid.createGridMask();
        var o = this.core.plotChartType(t, n),
            l = new M(this);
        l.bringForward(), i.config.dataLabels.background.enabled && l.dataLabelsBackground(), this.core.shiftGraphPosition();
        var h = {
          plot: {
            left: i.globals.translateX,
            top: i.globals.translateY,
            width: i.globals.gridWidth,
            height: i.globals.gridHeight
          }
        };
        return {
          elGraph: o,
          xyRatios: n,
          elInner: i.globals.dom.elGraphical,
          dimensions: h
        };
      }
    }, {
      key: "mount",
      value: function value() {
        var t = this,
            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
            i = this,
            a = i.w;
        return new Promise(function (s, r) {
          if (null === i.el) return r(new Error("Not enough data to display or target element not found"));
          (null === e || a.globals.allSeriesCollapsed) && i.series.handleNoData(), i.axes.drawAxis(a.config.chart.type, e.xyRatios), i.grid = new U(i);
          var n = i.grid.drawGrid();
          i.annotations = new P(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), "back" === a.config.grid.position && n && a.globals.dom.elGraphical.add(n.el);
          var o = new j(t.ctx),
              l = new $(t.ctx);
          if (null !== n && (o.xAxisLabelCorrections(n.xAxisTickWidth), l.setYAxisTextAlignments()), "back" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), Array.isArray(e.elGraph)) for (var h = 0; h < e.elGraph.length; h++) {
            a.globals.dom.elGraphical.add(e.elGraph[h]);
          } else a.globals.dom.elGraphical.add(e.elGraph);

          if ("front" === a.config.grid.position && n && a.globals.dom.elGraphical.add(n.el), "front" === a.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(), "front" === a.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(), "front" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), !a.globals.noData) {
            if (a.config.tooltip.enabled && !a.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios), a.globals.axisCharts && (a.globals.isXNumeric || a.config.xaxis.convertedCatToNumeric)) (a.config.chart.zoom.enabled || a.config.chart.selection && a.config.chart.selection.enabled || a.config.chart.pan && a.config.chart.pan.enabled) && i.zoomPanSelection.init({
              xyRatios: e.xyRatios
            });else {
              var c = a.config.chart.toolbar.tools;
              ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function (t) {
                c[t] = !1;
              });
            }
            a.config.chart.toolbar.show && !a.globals.allSeriesCollapsed && i.toolbar.createToolbar();
          }

          a.globals.memory.methodsToExec.length > 0 && a.globals.memory.methodsToExec.forEach(function (t) {
            t.method(t.params, !1, t.context);
          }), a.globals.axisCharts || a.globals.noData || i.core.resizeNonAxisCharts(), s(i);
        });
      }
    }, {
      key: "destroy",
      value: function value() {
        window.removeEventListener("resize", this.windowResizeHandler), window.removeResizeListener(this.el.parentNode, this._parentResizeCallback.bind(this));
        var t = this.w.config.chart.id;
        t && Apex._chartInstances.forEach(function (e, i) {
          e.id === t && Apex._chartInstances.splice(i, 1);
        }), new Xt(this.ctx).clear();
      }
    }, {
      key: "updateOptions",
      value: function value(t) {
        var e = this,
            i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
            n = this.w;
        return n.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map(function (t, i) {
          return e.updateHelpers._extendSeries(t, i);
        })), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), n.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, a, s, r);
      }
    }, {
      key: "updateSeries",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
            e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, i);
      }
    }, {
      key: "appendSeries",
      value: function value(t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            a = this.w.config.series.slice();
        return a.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a, e, i);
      }
    }, {
      key: "appendData",
      value: function value(t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            i = this;
        i.w.globals.dataChanged = !0, i.series.getPreviousPaths();

        for (var a = i.w.config.series.slice(), s = 0; s < a.length; s++) {
          if (null !== t[s] && void 0 !== t[s]) for (var r = 0; r < t[s].data.length; r++) {
            a[s].data.push(t[s].data[r]);
          }
        }

        return i.w.config.series = a, e && (i.w.globals.initialSeries = f.clone(i.w.config.series)), this.update({
          series: this.w.config.series
        });
      }
    }, {
      key: "update",
      value: function value(t) {
        var e = this;
        return new Promise(function (i, a) {
          new Xt(e.ctx).clear();
          var s = e.create(e.w.config.series, t);
          if (!s) return i(e);
          e.mount(s).then(function () {
            "function" == typeof e.w.config.chart.events.updated && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent("updated", [e, e.w]), e.w.globals.isDirty = !0, i(e);
          }).catch(function (t) {
            a(t);
          });
        });
      }
    }, {
      key: "getSyncedCharts",
      value: function value() {
        var t = this.getGroupedCharts(),
            e = [this];
        return t.length && (e = [], t.forEach(function (t) {
          e.push(t);
        })), e;
      }
    }, {
      key: "getGroupedCharts",
      value: function value() {
        var t = this;
        return Apex._chartInstances.filter(function (t) {
          if (t.group) return !0;
        }).map(function (e) {
          return t.w.config.chart.group === e.group ? e.chart : t;
        });
      }
    }, {
      key: "toggleSeries",
      value: function value(t) {
        return this.series.toggleSeries(t);
      }
    }, {
      key: "showSeries",
      value: function value(t) {
        this.series.showSeries(t);
      }
    }, {
      key: "hideSeries",
      value: function value(t) {
        this.series.hideSeries(t);
      }
    }, {
      key: "resetSeries",
      value: function value() {
        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
            e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        this.series.resetSeries(t, e);
      }
    }, {
      key: "addEventListener",
      value: function value(t, e) {
        this.events.addEventListener(t, e);
      }
    }, {
      key: "removeEventListener",
      value: function value(t, e) {
        this.events.removeEventListener(t, e);
      }
    }, {
      key: "addXaxisAnnotation",
      value: function value(t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
            a = this;
        i && (a = i), a.annotations.addXaxisAnnotationExternal(t, e, a);
      }
    }, {
      key: "addYaxisAnnotation",
      value: function value(t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
            a = this;
        i && (a = i), a.annotations.addYaxisAnnotationExternal(t, e, a);
      }
    }, {
      key: "addPointAnnotation",
      value: function value(t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
            a = this;
        i && (a = i), a.annotations.addPointAnnotationExternal(t, e, a);
      }
    }, {
      key: "clearAnnotations",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
            e = this;
        t && (e = t), e.annotations.clearAnnotations(e);
      }
    }, {
      key: "removeAnnotation",
      value: function value(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
            i = this;
        e && (i = e), i.annotations.removeAnnotation(i, t);
      }
    }, {
      key: "getChartArea",
      value: function value() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
      }
    }, {
      key: "getSeriesTotalXRange",
      value: function value(t, e) {
        return this.coreUtils.getSeriesTotalsXRange(t, e);
      }
    }, {
      key: "getHighestValueInSeries",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = new Z(this.ctx);
        return e.getMinYMaxY(t).highestY;
      }
    }, {
      key: "getLowestValueInSeries",
      value: function value() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = new Z(this.ctx);
        return e.getMinYMaxY(t).lowestY;
      }
    }, {
      key: "getSeriesTotal",
      value: function value() {
        return this.w.globals.seriesTotals;
      }
    }, {
      key: "toggleDataPointSelection",
      value: function value(t, e) {
        return this.updateHelpers.toggleDataPointSelection(t, e);
      }
    }, {
      key: "zoomX",
      value: function value(t, e) {
        this.ctx.toolbar.zoomUpdateOptions(t, e);
      }
    }, {
      key: "setLocale",
      value: function value(t) {
        this.localization.setCurrentLocaleValues(t);
      }
    }, {
      key: "dataURI",
      value: function value() {
        return new _(this.ctx).dataURI();
      }
    }, {
      key: "paper",
      value: function value() {
        return this.w.globals.dom.Paper;
      }
    }, {
      key: "_parentResizeCallback",
      value: function value() {
        !this.w.globals.noData && this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
      }
    }, {
      key: "_windowResize",
      value: function value() {
        var t = this;
        clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function () {
          t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update({
            series: t.w.config.series
          });
        }, 150);
      }
    }], [{
      key: "getChartByID",
      value: function value(t) {
        var e = Apex._chartInstances.filter(function (e) {
          return e.id === t;
        })[0];

        return e && e.chart;
      }
    }, {
      key: "initOnLoad",
      value: function value() {
        for (var e = document.querySelectorAll("[data-apexcharts]"), i = 0; i < e.length; i++) {
          new t(e[i], JSON.parse(e[i].getAttribute("data-options"))).render();
        }
      }
    }, {
      key: "exec",
      value: function value(t, e) {
        var i = this.getChartByID(t);

        if (i) {
          i.w.globals.isExecCalled = !0;
          var a = null;

          if (-1 !== i.publicMethods.indexOf(e)) {
            for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), n = 2; n < s; n++) {
              r[n - 2] = arguments[n];
            }

            a = i[e].apply(i, r);
          }

          return a;
        }
      }
    }, {
      key: "merge",
      value: function value(t, e) {
        return f.extend(t, e);
      }
    }]), t;
  }();

  module.exports = Yt;
});

var strings$a = {
  rus: {
    plot: {
      title: 'ÐÐµÑÐ½Ð¾Ð¹ ÑÑÐ°ÑÑÐ¾Ðº â',
      forestry: 'ÐÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      lessee: 'ÐÑÐµÐ½Ð´Ð°ÑÐ¾Ñ',
      term: 'Ð¡ÑÐ¾Ðº Ð´Ð¾Ð³Ð¾Ð²Ð¾ÑÐ° Ð°ÑÐµÐ½Ð´Ñ',
      cost: 'Ð¡ÑÐ¾Ð¸Ð¼Ð¾ÑÑÑ Ð´Ð¾Ð³Ð¾Ð²Ð¾ÑÐ° Ð°ÑÐµÐ½Ð´Ñ',
      volumes: 'ÐÐ¾Ð¿ÑÑÑÐ¸Ð¼ÑÐµ Ð¾Ð±ÑÐµÐ¼Ñ Ð¸Ð·ÑÑÑÐ¸Ñ'
    }
  }
};

var Plots = /*#__PURE__*/function (_BaseView) {
  _inherits(Plots, _BaseView);

  var _super = _createSuper(Plots);

  function Plots(container) {
    var _this;

    _classCallCheck(this, Plots);

    _this = _super.call(this, container, strings$a);

    _this._container.classList.add('scanex-forestry-view-plot');

    _this._container.innerHTML = "<div class=\"head1\">                \n                <label>".concat(_this.translate('plot.title'), "</label>\n                <label class=\"title\"></label>\n            </div>\n            <div class=\"head2\">\n                <label>").concat(_this.translate('plot.forestry'), ":</label>\n                <label class=\"forestry\"></label>\n            </div>\n            <div class=\"content\">\n                <div class=\"stats\"></div>\n                <div class=\"chart\"></div>\n            </div>");
    _this._title = _this._container.querySelector('.title');
    _this._forestry = _this._container.querySelector('.forestry');
    _this._stats = _this._container.querySelector('.stats');
    _this._chart = new apexcharts_common(_this._container.querySelector('.chart'), {
      chart: {
        type: 'donut',
        width: '400px',
        height: '250px'
      },
      dataLabels: {
        enabled: false
      },
      labels: [],
      series: [],
      legend: {
        position: 'bottom',
        width: '200px',
        horizontalAlign: 'right',
        formatter: function formatter(name, opts) {
          var val = parseFloat(opts.w.globals.series[opts.seriesIndex]);
          return "".concat(name, " - ").concat(_this.m(val));
        }
      },
      plotOptions: {
        pie: {
          donut: {
            size: '78%',
            labels: {
              show: true,
              value: {
                formatter: function formatter(val) {
                  return "".concat(_this.m(val), " ").concat(_this.translate('units.m3'));
                },
                fontSize: '12px',
                show: true
              },
              total: {
                formatter: function formatter(_ref) {
                  var series = _ref.config.series;
                  return "".concat(_this.m(series.reduce(function (p, c) {
                    return p + c;
                  }, 0)), " ").concat(_this.translate('units.m3'));
                },
                label: _this.translate('quadrant.stock.all'),
                fontSize: '12px',
                fontWeight: 600,
                show: true
              }
            }
          }
        }
      }
    });

    _this._chart.render();

    return _this;
  }

  _createClass(Plots, [{
    key: "open",
    value: function open(_ref2) {
      var _this2 = this;

      var gmx_id = _ref2.gmx_id,
          data = _objectWithoutProperties(_ref2, ["gmx_id"]);

      _get(_getPrototypeOf(Plots.prototype), "open", this).call(this);

      var Area = data.Area,
          Contract = data.Contract,
          Forestry = data.Forestry,
          Region = data.Region,
          Renter = data.Renter,
          SignedAt = data.SignedAt,
          Term = data.Term,
          RentCost = data.RentCost,
          Volumes = data.Volumes;
      this._title.innerText = Contract;
      this._forestry.innerText = Forestry;
      var start = SignedAt && new Date(SignedAt);
      var end;

      if (start) {
        var y = start.getFullYear();
        var m = start.getMonth();
        var d = start.getDate();
        var t = parseInt(Term, 10);
        end = new Date(y + (!isNaN(t) && t || 0), m, d);
      }

      this._stats.innerHTML = "<table cellpadding=\"0\" cellspacing=\"0\">\n            <tbody>\n                <tr>\n                    <td>".concat(this.translate('plot.lessee'), "</td>\n                    <td>").concat(Renter || '', "</td>\n                </tr>                    \n                <tr>\n                    <td>").concat(this.translate('plot.term'), "</td>\n                    <td>").concat(this.date(start), " - ").concat(this.date(end), "</td>\n                </tr>\n                <tr>\n                    <td>").concat(this.translate('plot.cost'), "</td>\n                    <td>").concat(this.rub(RentCost), "</td>\n                </tr>                                        \n            </tbody>\n        </table>\n        ").concat(Array.isArray(Volumes) && Volumes.length ? "\n        <div>".concat(this.translate('plot.volumes'), "</div>\n        <table cellpadding=\"0\" cellspacing=\"0\">\n            <tbody>").concat(Volumes.map(function (_ref3) {
        var farm = _ref3.farm,
            rent_cost = _ref3.rent_cost,
            value = _ref3.value;
        return "<tr>\n                    <td>".concat(farm, "</td>\n                    <td>").concat(_this2.m(value), "</td>\n                </tr>");
      }).join(''), "</tbody>\n        </table>") : '');

      if (Array.isArray(Volumes)) {
        var _Volumes$reduce = Volumes.reduce(function (a, _ref4) {
          var farm = _ref4.farm,
              value = _ref4.value;
          a.labels.push(farm);
          a.series.push(value || 0);
          return a;
        }, {
          labels: [],
          series: []
        }),
            labels = _Volumes$reduce.labels,
            series = _Volumes$reduce.series;

        this._chart.updateOptions({
          labels: labels
        });

        this._chart.updateSeries(series);
      }
    }
  }]);

  return Plots;
}(View);

var Plots$1 = /*#__PURE__*/function (_LayerController) {
  _inherits(Plots$1, _LayerController);

  var _super = _createSuper(Plots$1);

  function Plots$1(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layer = _ref.layer,
        legend = _ref.legend,
        path = _ref.path,
        permissions = _ref.permissions;

    _classCallCheck(this, Plots$1);

    _this = _super.call(this, {
      kind: 'plots',
      map: map,
      content: content,
      notifications: notifications,
      layer: layer,
      legend: legend
    });
    _this._path = path;
    _this._permissions = permissions;
    _this._view = _this._content.add(_this._kind, Plots);
    return _this;
  }

  _createClass(Plots$1, [{
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var _e$gmx, id, properties, data;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._permissions.ForestProjectsView) {
                  _context.next = 10;
                  break;
                }

                if (!this.canClick) {
                  _context.next = 8;
                  break;
                }

                L.DomEvent.stopPropagation(e);
                _e$gmx = e.gmx, id = _e$gmx.id, properties = _e$gmx.properties;
                _context.next = 6;
                return this.httpGet("".concat(this._path, "/Forest/GetPlot"), {
                  PlotID: properties.id
                });

              case 6:
                data = _context.sent;

                if (data) {
                  this._view.open(_objectSpread2({
                    gmx_id: id
                  }, data));
                } // this._layer.repaint();


              case 8:
                _context.next = 11;
                break;

              case 10:
                this._notifications.forbidden.open();

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _click(_x) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }]);

  return Plots$1;
}(LayerController);

var strings$b = {
  rus: {
    info: {
      approve: 'ÐÐ°ÑÐ° Ð¿ÑÐ¸Ð½ÑÑÐ¸Ñ ÑÐµÑÐµÐ½Ð¸Ñ Ð¾ Ð¿ÑÐ¾Ð²ÐµÐ´ÐµÐ½Ð¸Ð¸ Ð°ÑÐºÑÐ¸Ð¾Ð½Ð°',
      available: 'ÐÐ¾Ð¿ÑÑÑÐ¸Ð¼ÑÐµ Ð¾Ð±ÑÐµÐ¼Ñ Ð¸Ð·ÑÑÑÐ¸Ñ (Ð² Ð³Ð¾Ð´)',
      cost: 'ÐÐ°ÑÐ°Ð»ÑÐ½Ð°Ñ ÑÑÐ°Ð²ÐºÐ°',
      period: 'ÐÐµÑÐ¸Ð¾Ð´ Ð¿ÑÐ¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð°ÑÐºÑÐ¸Ð¾Ð½Ð° Ð¸ Ð¸Ð´ÐµÐ½ÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¾Ñ Ð»Ð¾ÑÐ° Ð°ÑÐºÑÐ¸Ð¾Ð½Ð°',
      status: 'Ð¡ÑÐ°ÑÑÑ Ð°ÑÐºÑÐ¸Ð¾Ð½Ð°'
    },
    project: {
      create: 'Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð¿ÑÐ¾ÐµÐºÑ',
      default: 'ÐÑÐ¾ÐµÐºÑ ÐÐ£',
      description: 'ÐÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ',
      edit: 'Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿ÑÐ¾ÐµÐºÑ',
      forestry: 'ÐÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      localForestry: 'Ð£Ñ. Ð»ÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      quadrants: 'ÐÐ²Ð°ÑÑÐ°Ð»Ñ',
      request: 'Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð·Ð°ÑÐ²ÐºÑ',
      save: 'Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¿ÑÐ¾ÐµÐºÑ',
      species: 'ÐÐ¾ÑÐ¾Ð´Ð°',
      stock: {
        permitted: 'ÐÐ¾ÑÑÑÐ¿Ð½ÑÐ¹',
        probable: 'ÐÑÐ¾Ð³Ð½Ð¾Ð·',
        total: 'Ð¢Ð°ÐºÑÐ°ÑÐ¸Ñ',
        table: 'ÐÐ°Ð½Ð½ÑÐµ Ð¾ Ð·Ð°Ð¿Ð°ÑÐ°Ñ',
        label: 'ÐÐ°Ð¿Ð°Ñ',
        all: 'ÐÐµÑÑ'
      },
      title: {
        create: 'Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¿ÑÐ¾ÐµÐºÑÐ° Ð»ÐµÑÐ½Ð¾Ð³Ð¾ ÑÑÐ°ÑÑÐºÐ°',
        edit: 'Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ð¿ÑÐ¾ÐµÐºÑÐ° Ð»ÐµÑÐ½Ð¾Ð³Ð¾ ÑÑÐ°ÑÑÐºÐ°'
      },
      tract: 'Ð£ÑÐ¾ÑÐ¸ÑÐµ'
    }
  }
};

var Info = /*#__PURE__*/function (_View) {
  _inherits(Info, _View);

  var _super = _createSuper(Info);

  function Info(container) {
    var _this;

    _classCallCheck(this, Info);

    _this = _super.call(this, container, strings$b);

    _this._container.classList.add('scanex-forestry-view-project');

    _this._container.innerHTML = "<div class=\"header\">    \n            <button class=\"scanex-requests-icon back\"></button>\n            <label class=\"title\"></label>\n        </div>\n        <div>\n            <label>".concat(_this.translate('project.forestry'), "</label>\n            <label class=\"forestry\"></label>\n        </div>        \n        <div class=\"content\">\n            <div class=\"stats\">\n                <div class=\"costs\"></div>\n                <div>").concat(_this.translate('info.available'), ", ").concat(_this.translate('units.m'), "<sup>3</sup></div>\n                <div class=\"species\"></div>\n            </div>\n            <div class=\"chart\"></div>\n        </div>");

    var btnBack = _this._container.querySelector('.back');

    btnBack.addEventListener('click', function (e) {
      e.stopPropagation();
      var event = document.createEvent('Event');
      event.initEvent('back', false, false);

      _this.dispatchEvent(event);
    });
    _this._title = _this._container.querySelector('.title');
    _this._forestry = _this._container.querySelector('.forestry');
    _this._costs = _this._container.querySelector('.costs');
    _this._species = _this._container.querySelector('.species');
    _this._chart = new apexcharts_common(_this._container.querySelector('.chart'), {
      chart: {
        type: 'donut',
        width: '400px' // height: '250px',

      },
      dataLabels: {
        enabled: false
      },
      labels: [],
      series: [],
      legend: {
        position: 'bottom',
        // width: '200px',                
        horizontalAlign: 'right',
        formatter: function formatter(name, opts) {
          var val = parseFloat(opts.w.globals.series[opts.seriesIndex]);
          return "".concat(name, " - ").concat(_this.m(val));
        }
      },
      plotOptions: {
        pie: {
          donut: {
            size: '78%',
            labels: {
              show: true,
              value: {
                formatter: function formatter(v) {
                  return "".concat(_this.m(v), " ").concat(_this.translate('units.m3'));
                },
                fontSize: '12px',
                show: true
              },
              total: {
                formatter: function formatter(_ref) {
                  var series = _ref.config.series;
                  return "".concat(_this.m(series.reduce(function (p, c) {
                    return p + c;
                  }, 0)), " ").concat(_this.translate('units.m3'));
                },
                label: _this.translate('project.stock.all'),
                fontSize: '12px',
                fontWeight: 600,
                show: true
              }
            }
          }
        }
      }
    });

    _this._chart.render();

    return _this;
  }

  _createClass(Info, [{
    key: "open",
    value: function open(data) {
      var _this2 = this;

      _get(_getPrototypeOf(Info.prototype), "open", this).call(this);

      var Addres = data.Addres,
          ApplicationForm = data.ApplicationForm,
          ApproveDate = data.ApproveDate,
          ApproveName = data.ApproveName,
          AuctionEnd = data.AuctionEnd,
          AuctionStart = data.AuctionStart,
          AuctionURL = data.AuctionURL,
          CadastralNum = data.CadastralNum,
          Comments = data.Comments,
          DeclineDate = data.DeclineDate,
          EgrFile = data.EgrFile,
          ForestAvailable = data.ForestAvailable,
          ForestBlocks = data.ForestBlocks,
          ForestProjectGeo = data.ForestProjectGeo,
          ForestProjectID = data.ForestProjectID,
          ForestStat = data.ForestStat,
          Forestry = data.Forestry,
          OGRN = data.OGRN,
          Opf = data.Opf,
          OrganizationName = data.OrganizationName,
          OwnerID = data.OwnerID,
          PeriodUsage = data.PeriodUsage,
          Phone = data.Phone,
          PostAddress = data.PostAddress,
          RentCost = data.RentCost,
          RentFile = data.RentFile,
          Square = data.Square,
          SquareStat = data.SquareStat,
          Status = data.Status,
          TargetUsage = data.TargetUsage,
          Title = data.Title;
      this._title.innerHTML = Title;
      this._forestry.innerHTML = "".concat(Forestry, " ").concat(ForestBlocks);
      var start = AuctionStart && new Date(AuctionStart);
      var end = AuctionEnd && new Date(AuctionEnd);
      this._costs.innerHTML = "<table cellpadding=\"0\" cellspacing=\"0\">\n            <tbody>\n                <tr>\n                    <td>".concat(this.translate('info.approve'), "</td>\n                    <td>").concat(ApproveDate || '', "</td>\n                </tr>\n                <tr>\n                    <td>").concat(this.translate('info.status'), "</td>\n                    <td>").concat(Status || '', "</td>\n                </tr>\n                <tr>\n                    <td>").concat(this.translate('info.period'), "</td>\n                    <td>").concat(start && end ? "".concat(this.date(start), " - ").concat(this.date(end)) : '', "</td>\n                </tr>\n                <tr>\n                    <td>").concat(this.translate('info.cost'), "</td>\n                    <td>").concat(this.rub(RentCost), "</td>\n                </tr>\n            </tbody>\n        </table>");

      if (Array.isArray(ForestAvailable) && ForestAvailable.length) {
        this._species.innerHTML = "<table cellpadding=\"0\" cellspacing=\"0\">                \n                <tbody>".concat(ForestAvailable.map(function (_ref2) {
          var species = _ref2.species,
              value = _ref2.value;
          return "<tr>\n                        <td>".concat(species, "</td>\n                        <td>").concat(_this2.m(value), "</td>\n                    </tr>");
        }).join(''), "</tbody>\n            </table>");

        var _ForestAvailable$redu = ForestAvailable.reduce(function (a, _ref3) {
          var species = _ref3.species,
              value = _ref3.value;
          a.labels.push(species);
          a.series.push(value);
          return a;
        }, {
          labels: [],
          series: []
        }),
            labels = _ForestAvailable$redu.labels,
            series = _ForestAvailable$redu.series;

        this._chart.updateOptions({
          labels: labels
        });

        this._chart.updateSeries(series);
      }
    }
  }]);

  return Info;
}(View);

var translate$6 = T.getText.bind(T);

var Quadrants = /*#__PURE__*/function (_EventTarget) {
  _inherits(Quadrants, _EventTarget);

  var _super = _createSuper(Quadrants);

  function Quadrants(container) {
    var _this;

    _classCallCheck(this, Quadrants);

    _this = _super.call(this);
    _this._container = container;

    _this._container.classList.add('quadrants');

    _this._items = [];
    return _this;
  }

  _createClass(Quadrants, [{
    key: "items",
    set: function set(items) {
      var _this2 = this;

      this._items = Array.isArray(items) && items || [];
      this._container.innerHTML = this._items.length ? "<table cellpadding=\"0\" cellspacing=\"0\">\n            <thead>\n                <tr>\n                    <th>".concat(translate$6('project.localForestry'), " / ").concat(translate$6('project.tract'), "</th>                    \n                    <th>").concat(translate$6('project.quadrants'), "</th>\n                </tr>\n            </thead>\n        </table>\n        <div class=\"scrollable style-4\">\n            <table cellpadding=\"0\" cellspacing=\"0\">\n                <tbody>").concat(this._items.map(function (_ref) {
        var local_forestry = _ref.local_forestry,
            stow = _ref.stow,
            num = _ref.num;
        return "<tr class=\"quadrant\">\n                        <td>".concat(local_forestry).concat(stow ? " / ".concat(stow) : '', "</td>\n                        <td>").concat(num, "</td>\n                    </tr>");
      }).join(''), "</tbody>\n            </table>\n        </div>") : '';

      var rows = this._container.querySelectorAll('tbody > tr');

      var _loop = function _loop(i) {
        var row = rows[i];
        var item = items[i];
        row.addEventListener('click', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('item:click', false, false);
          event.detail = item.gmx_id;

          _this2.dispatchEvent(event);
        });
        row.addEventListener('mouseenter', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('item:over', false, false);
          event.detail = item.gmx_id;

          _this2.dispatchEvent(event);
        });
        row.addEventListener('mouseleave', function (e) {
          e.stopPropagation();
          var event = document.createEvent('Event');
          event.initEvent('item:out', false, false);
          event.detail = item.gmx_id;

          _this2.dispatchEvent(event);
        });
      };

      for (var i = 0; i < rows.length; ++i) {
        _loop(i);
      }
    },
    get: function get() {
      return this._items;
    } // hilite(id){
    //     let rows = this._container.querySelectorAll('tbody > tr');
    //     for (let i = 0; i < rows.length; ++i) {
    //         const item = this._items[i];
    //         if(item.gmx_id === id) {
    //             rows[i].classList.add('hilite');
    //             let event = document.createEvent('Event');            
    //             event.initEvent('item:over', false, false);
    //             event.detail = item;
    //             this.dispatchEvent(event);
    //             break;
    //         }
    //     }
    // }
    // unhilite(id){
    //     let rows = this._container.querySelectorAll('tbody > tr');
    //     for (let i = 0; i < rows.length; ++i) {
    //         const item = this._items[i];
    //         if(item.gmx_id === id) {
    //             rows[i].classList.remove('hilite');
    //             let event = document.createEvent('Event');            
    //             event.initEvent('item:out', false, false);
    //             event.detail = item;
    //             this.dispatchEvent(event);
    //             break;
    //         }
    //     }
    // }

  }]);

  return Quadrants;
}(EventTarget);

var translate$7 = T.getText.bind(T);

var SpeciesTable = /*#__PURE__*/function (_EventTarget) {
  _inherits(SpeciesTable, _EventTarget);

  var _super = _createSuper(SpeciesTable);

  function SpeciesTable(container) {
    var _this;

    _classCallCheck(this, SpeciesTable);

    _this = _super.call(this);
    _this._container = container;
    return _this;
  }

  _createClass(SpeciesTable, [{
    key: "update",
    value: function update(species) {
      var rows = species.sort(function (a, b) {
        if (a.species > b.species) {
          return 1;
        } else if (a.species < b.species) {
          return -1;
        } else {
          return 0;
        }
      }).map(function (_ref) {
        var permitted_stock = _ref.permitted_stock,
            permitted_stock_deal = _ref.permitted_stock_deal,
            probable_stock = _ref.probable_stock,
            probable_stock_deal = _ref.probable_stock_deal,
            species = _ref.species,
            total_stock = _ref.total_stock,
            total_stock_deal = _ref.total_stock_deal;
        return "<tr class=\"type\">\n                <td class=\"label\">".concat(species, "</td>\n                <td class=\"value\">").concat(m(permitted_stock), "</td>\n                <td class=\"value\">").concat(m(permitted_stock_deal), "</td>\n                <td class=\"value\">").concat(m(probable_stock), "</td>\n                <td class=\"value\">").concat(m(probable_stock_deal), "</td>\n                <td class=\"value\">").concat(m(total_stock), "</td>\n                <td class=\"value\">").concat(m(total_stock_deal), "</td>\n            </tr>");
      }).join('');
      this._container.innerHTML = rows ? "<div class=\"title\">\n                <table cellpadding=\"0\" cellspacing=\"0\">\n                    <tbody>                 \n                        <tr>\n                            <td>".concat(translate$7('project.species'), "</td>\n                            <td class=\"label\" colspan=\"3\">").concat(translate$7('project.stock.label'), ", ").concat(translate$7('units.m'), "<sup>3</sup></td>\n                        </tr>\n                        <tr>\n                            <td></td>\n                            <td class=\"label\">").concat(translate$7('project.stock.permitted'), "</td>                        \n                            <td class=\"label\">").concat(translate$7('project.stock.probable'), "</td>\n                            <td class=\"label\">").concat(translate$7('project.stock.total'), "</td>\n                        </tr>\n                    </tbody>\t\t\t\t\t\t\n                </table>\n            </div>\n            <div class=\"content style-4\">\n                <table cellpadding=\"0\" cellspacing=\"0\">\n                    <tbody>").concat(rows, "</tbody>\n                </table>\n            </div>") : '';
    }
  }]);

  return SpeciesTable;
}(EventTarget);

var translate$8 = T.getText.bind(T);

var Species = /*#__PURE__*/function () {
  function Species(container) {
    var _this = this;

    _classCallCheck(this, Species);

    this._species = [];
    this._container = container;
    this._container.innerHTML = "<table cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t<thead class=\"menu\">\n\t\t\t\t<tr>\n\t\t\t\t\t<th colspan=\"3\">\n\t\t\t\t\t\t<button class=\"stock active\">".concat(translate$8('project.stock.table'), "</button>\n\t\t\t\t\t</th>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>\n\t\t\t\t\t\t<button class=\"permitted\">").concat(translate$8('project.stock.permitted'), "</button>\n\t\t\t\t\t</th>\t\n\t\t\t\t\t<th>\n\t\t\t\t\t\t<button class=\"probable\">").concat(translate$8('project.stock.probable'), "</button>\n\t\t\t\t\t</th>\n\t\t\t\t\t<th>\n\t\t\t\t\t\t<button class=\"total\">").concat(translate$8('project.stock.total'), "</button>\n\t\t\t\t\t</th>\t\t\t\t\t\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t\t<div class=\"table\"></div>\n\t\t\t\t\t\t<div class=\"chart\"></div>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>");
    this._buttons = this._container.querySelectorAll('button');

    var btnStock = this._container.querySelector('.stock');

    btnStock.addEventListener('click', function (e) {
      e.stopPropagation();
      _this.mode = 'stock';
    });

    var btnPermitted = this._container.querySelector('.permitted');

    btnPermitted.addEventListener('click', function (e) {
      e.stopPropagation();
      _this.mode = 'permitted';
    });

    var btnProbable = this._container.querySelector('.probable');

    btnProbable.addEventListener('click', function (e) {
      e.stopPropagation();
      _this.mode = 'probable';
    });

    var btnTotal = this._container.querySelector('.total');

    btnTotal.addEventListener('click', function (e) {
      e.stopPropagation();
      _this.mode = 'total';
    });

    var _formatter = function formatter(n, s, d) {
      if (s) {
        return d ? [n, ' - ', s.toLocaleString('ru-RU', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }), ' / ', d.toLocaleString(undefined, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })] : [n, ' - ', s.toLocaleString('ru-RU', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        })];
      } else {
        return n;
      }
    };

    this._chart = new apexcharts_common(this._container.querySelector('.chart'), {
      chart: {
        type: 'donut',
        width: '700px',
        height: '160px'
      },
      dataLabels: {
        enabled: false
      },
      labels: [],
      series: [],
      legend: {
        position: 'right',
        width: '200px',
        offsetY: -10,
        formatter: function formatter(seriesName, opts) {
          var i = opts.seriesIndex;
          var s = _this._species[i] || {};

          if (_this._mode === 'permitted') {
            var permitted_stock = s.permitted_stock,
                permitted_stock_deal = s.permitted_stock_deal;
            return _formatter(seriesName, permitted_stock, permitted_stock_deal);
          } else if (_this._mode === 'probable') {
            var probable_stock = s.probable_stock,
                probable_stock_deal = s.probable_stock_deal;
            return _formatter(seriesName, probable_stock, probable_stock_deal);
          } else {
            var total_stock = s.total_stock,
                total_stock_deal = s.total_stock_deal;
            return _formatter(seriesName, total_stock, total_stock_deal);
          }
        }
      },
      plotOptions: {
        pie: {
          donut: {
            size: '78%',
            labels: {
              show: true,
              value: {
                formatter: function formatter(v) {
                  return "".concat(m(v), " ").concat(translate$8('units.m3'));
                },
                fontSize: '12px',
                show: true
              },
              total: {
                formatter: function formatter(_ref) {
                  var series = _ref.config.series;
                  return "".concat(m(series.reduce(function (p, c) {
                    return p + c;
                  }, 0)), ", ").concat(translate$8('units.m3'));
                },
                label: translate$8('project.stock.all'),
                fontSize: '12px',
                fontWeight: 600,
                show: true
              }
            }
          }
        }
      }
    }); // this._chart.render();

    this.mode = 'stock';
  }

  _createClass(Species, [{
    key: "showStock",
    value: function showStock() {
      this._container.querySelector('.chart').style.display = 'none';
      this._container.querySelector('.table').style.display = 'block';
    }
  }, {
    key: "showSpecies",
    value: function showSpecies() {
      this._container.querySelector('.table').style.display = 'none';
      this._container.querySelector('.chart').style.display = 'block';
    }
  }, {
    key: "mode",
    get: function get() {
      return this._mode;
    },
    set: function set(mode) {
      var _iterator = _createForOfIteratorHelper(this._buttons),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var btn = _step.value;

          if (btn.classList.contains(mode)) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this._mode = mode;
      this.items = this._species;
    }
  }, {
    key: "items",
    set: function set(species) {
      var _this2 = this;

      this._species = Array.isArray(species) && species;

      if (this.mode === 'stock') {
        this.showStock();
        var t = new SpeciesTable(this._container.querySelector('.table'));
        t.update(this._species);
      } else {
        this.showSpecies();

        this._chart.render();

        var _this$_species$reduce = this._species.reduce(function (a, s) {
          a.labels.push(s.species);

          switch (_this2.mode) {
            case 'permitted':
              a.series.push(s.permitted_stock);
              break;

            case 'probable':
              a.series.push(s.probable_stock);
              break;

            default:
              a.series.push(s.total_stock);
              break;
          }

          return a;
        }, {
          labels: [],
          series: []
        }),
            labels = _this$_species$reduce.labels,
            series = _this$_species$reduce.series;

        this._chart.updateOptions({
          labels: labels
        });

        this._chart.updateSeries(series);
      }
    },
    get: function get() {
      return this._species;
    }
  }]);

  return Species;
}();

var STYLE = {
  fillStyle: document.createElement('canvas').getContext('2d').createPattern(L.gmxUtil.getPatternIcon(null, {
    type: '',
    color: parseInt('FFB801', 16),
    opacity: 1,
    weight: 1,
    fillOpacity: 0.64,
    fillPattern: {
      style: 'diagonal1',
      width: 8,
      step: 0,
      colors: [parseInt('FFB801', 16), parseInt('61E9F1', 16)]
    },
    common: true
  }).canvas, 'repeat')
};

var Project = /*#__PURE__*/function (_BaseView) {
  _inherits(Project, _BaseView);

  var _super = _createSuper(Project);

  function Project(container, _ref) {
    var _this;

    var layer = _ref.layer,
        forestryIndex = _ref.forestryIndex,
        projectIndex = _ref.projectIndex;

    _classCallCheck(this, Project);

    _this = _super.call(this, container, strings$b);
    _this._layer = layer;
    _this._forestryIndex = forestryIndex;
    _this._projectIndex = projectIndex;

    _this._container.classList.add('scanex-forestry-project');

    _this._container.innerHTML = "<div class=\"header\">\n            <div class=\"header-left\">\n                <button class=\"scanex-requests-icon back\"></button>\n                <label class=\"head\">".concat(_this.translate('project.title.edit'), "</label>\n                <input class=\"description\" type=\"text\" value=\"\"></input>\n            </div>\n            <div class=\"header-right\">                                \n                <button class=\"request\">").concat(_this.translate('project.request'), "</button>\n                <button class=\"save\">").concat(_this.translate('project.save'), "</button>\n            </div>\n        </div>\n        <div class=\"content\">\n            <div class=\"species\"></div>\n            <div class=\"quadrants\"></div>            \n        </div>");
    _this._description = _this._container.querySelector('.description');

    var btnBack = _this._container.querySelector('.back');

    btnBack.addEventListener('click', function (e) {
      e.stopPropagation();
      var event = document.createEvent('Event');
      event.initEvent('back', false, false);

      _this.dispatchEvent(event);
    });

    var btnSave = _this._container.querySelector('.save');

    btnSave.addEventListener('click', function (e) {
      e.stopPropagation();
      var event = document.createEvent('Event');
      event.initEvent('save', false, false);
      event.detail = {
        forestProjectID: _this._id,
        forestryID: _this._forestryID,
        title: _this._description.value,
        forestQs: _this._quadrants.items.map(function (_ref2) {
          var gmx_id = _ref2.gmx_id;
          return gmx_id;
        })
      };

      _this.dispatchEvent(event);
    });

    var btnRequest = _this._container.querySelector('.request');

    btnRequest.addEventListener('click', function (e) {
      e.stopPropagation();
      var event = document.createEvent('Event');
      event.initEvent('create', false, false);
      event.detail = {
        forestProjectID: _this._id,
        forestryID: _this._forestryID,
        title: _this._description.value,
        forestQs: _this._quadrants.items.map(function (_ref3) {
          var gmx_id = _ref3.gmx_id;
          return gmx_id;
        })
      };

      _this.dispatchEvent(event);
    });
    _this._quadrants = new Quadrants(_this._container.querySelector('.quadrants'));
    _this._species = new Species(_this._container.querySelector('.species'));
    return _this;
  }

  _createClass(Project, [{
    key: "clear",
    value: function clear() {
      this._quadrants.items = [];
      this._species.items = [];
      this._forestryID = null;
      this._id = null;
    }
  }, {
    key: "toggle",
    value: function toggle(gmx_id) {
      var ids = this.quadrants.slice();

      if (ids.includes(gmx_id)) {
        ids = ids.filter(function (id) {
          return id !== gmx_id;
        });
      } else {
        ids.push(gmx_id);
      }

      return ids;
    }
  }, {
    key: "getFilter",
    value: function getFilter(kind, properties) {
      if (kind === 'projects') {
        return this._gmx_id !== properties.id;
      } else {
        return true;
      }
    }
  }, {
    key: "getStyleHook",
    value: function getStyleHook(kind, _ref4) {
      var id = _ref4.id,
          properties = _ref4.properties;

      if (kind === 'quadrants') {
        if (this.quadrants.includes(id)) {
          return STYLE;
        } else if (this._forestryID) {
          return this._forestryIndex >= 0 && this._forestryID === properties[this._forestryIndex] ? {} : null;
        } else {
          return {};
        }
      } else if (kind === 'projects') {
        return this._projectIndex >= 0 && this._id === properties[this._projectIndex] ? null : {};
      } else {
        return {};
      }
    }
  }, {
    key: "open",
    value: function open() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        quadrants: [],
        species: []
      },
          gmx_id = _ref5.gmx_id,
          forestProjectID = _ref5.forestProjectID,
          title = _ref5.title,
          forestryID = _ref5.forestryID,
          quadrants = _ref5.quadrants,
          species = _ref5.species;

      _get(_getPrototypeOf(Project.prototype), "open", this).call(this);

      if (gmx_id) {
        this._gmx_id = gmx_id;
      }

      this._id = forestProjectID;
      this._description.value = title || "".concat(this.translate('project.default'), " - ").concat(new Date().toLocaleDateString());
      this._forestryID = forestryID;
      this._quadrants.items = quadrants;
      this._species.items = species;
    }
  }, {
    key: "close",
    value: function close() {
      this.clear();

      _get(_getPrototypeOf(Project.prototype), "close", this).call(this);
    }
  }, {
    key: "quadrants",
    get: function get() {
      return this._quadrants.items.map(function (_ref6) {
        var gmx_id = _ref6.gmx_id;
        return gmx_id;
      });
    }
  }]);

  return Project;
}(View);

var translate$9 = T.getText.bind(T);

var indexByName = function indexByName(layer, name) {
  var _layer$getGmxProperti = layer.getGmxProperties(),
      attributes = _layer$getGmxProperti.attributes;

  var i = attributes.indexOf(name);

  if (i >= 0) {
    i += 1;
  }

  return i;
};

var Projects = /*#__PURE__*/function (_LayerController) {
  _inherits(Projects, _LayerController);

  var _super = _createSuper(Projects);

  function Projects(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layers = _ref.layers,
        legend = _ref.legend,
        path = _ref.path,
        permissions = _ref.permissions;

    _classCallCheck(this, Projects);

    _this = _super.call(this, {
      kind: 'projects',
      map: map,
      content: content,
      notifications: notifications,
      layer: layers.projects,
      legend: legend
    });
    _this._path = path;
    _this._layers = layers;
    _this._permissions = permissions;
    _this._info = _this._content.add('view-project', Info);

    _this._info.on('back', function () {
      _this._back();
    });

    var forestryIndex = indexByName(layers.quadrants, 'forestry_id');
    var projectIndex = indexByName(layers.projects, 'id');
    _this._project = _this._content.add('edit-project', Project, {
      layer: _this._layer,
      forestryIndex: forestryIndex,
      projectIndex: projectIndex
    });

    _this._project.on('back', function () {
      _this._back();
    });

    _this._project.on('save', /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var _e$detail, forestProjectID, title, forestQs, data;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _e$detail = e.detail, forestProjectID = _e$detail.forestProjectID, title = _e$detail.title, forestQs = _e$detail.forestQs;
                _context.next = 3;
                return _this._save({
                  forestProjectID: forestProjectID,
                  title: title,
                  forestQs: forestQs
                });

              case 3:
                data = _context.sent;

                if (data) {
                  _this._back();
                }

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());

    _this._project.on('create', /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(e) {
        var _e$detail2, forestProjectID, title, forestQs, data, SquareStat, ForestStat;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _e$detail2 = e.detail, forestProjectID = _e$detail2.forestProjectID, title = _e$detail2.title, forestQs = _e$detail2.forestQs;
                _context2.next = 3;
                return _this._save({
                  forestProjectID: forestProjectID,
                  title: title,
                  forestQs: forestQs
                });

              case 3:
                data = _context2.sent;

                if (!data) {
                  _context2.next = 8;
                  break;
                }

                SquareStat = data.SquareStat, ForestStat = data.ForestStat;
                _context2.next = 8;
                return _this._createRequest(forestProjectID);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }());

    return _this;
  }

  _createClass(Projects, [{
    key: "_back",
    value: function _back() {
      this._layers.projects.repaint();

      var event = document.createEvent('Event');
      event.initEvent('back', false, false);
      this.dispatchEvent(event);
    }
  }, {
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(e) {
        var _e$gmx, id, properties, status_calc, forestry_id, plot_project_status_id;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.canClick) {
                  _context3.next = 16;
                  break;
                }

                L.DomEvent.stopPropagation(e);
                _e$gmx = e.gmx, id = _e$gmx.id, properties = _e$gmx.properties;
                status_calc = properties.status_calc, forestry_id = properties.forestry_id, plot_project_status_id = properties.plot_project_status_id;

                if (!(status_calc === 1)) {
                  _context3.next = 14;
                  break;
                }

                if (!(plot_project_status_id === 1)) {
                  _context3.next = 10;
                  break;
                }

                _context3.next = 8;
                return this.edit({
                  id: properties.id,
                  forestryID: forestry_id
                });

              case 8:
                _context3.next = 12;
                break;

              case 10:
                _context3.next = 12;
                return this.view({
                  id: properties.id,
                  forestryID: forestry_id
                });

              case 12:
                _context3.next = 16;
                break;

              case 14:
                _context3.next = 16;
                return this.view({
                  id: properties.id,
                  forestryID: forestry_id
                });

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _click(_x3) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }, {
    key: "_validate",
    value: function () {
      var _validate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(ids) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.httpPost("".concat(this._path, "/Forest/ValidateForestProjectGmxIds"), {
                  ForestBlocks: ids
                });

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _validate(_x4) {
        return _validate2.apply(this, arguments);
      }

      return _validate;
    }()
  }, {
    key: "create",
    value: function create() {
      this._legend.enable('quadrants');

      this._legend.enable('projects');

      this._legend.enable('plots');

      this._legend.enable('parks');

      this._project.open();

      this._layer.repaint();
    } // draft

  }, {
    key: "edit",
    value: function () {
      var _edit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref4) {
        var id, forestryID, data, title, gmxIds, res, Status, SquareStat, ForestStat;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                id = _ref4.id, forestryID = _ref4.forestryID;

                if (!this._permissions.ForestProjectsEdit) {
                  _context5.next = 27;
                  break;
                }

                this._legend.enable('quadrants');

                this._legend.enable('projects');

                this._legend.enable('plots');

                this._legend.enable('parks');

                _context5.next = 8;
                return this.httpGet("".concat(this._path, "/Forest/GetPlotProjectDraft"), {
                  ForestProjectID: id
                });

              case 8:
                data = _context5.sent;

                if (!data) {
                  _context5.next = 25;
                  break;
                }

                title = data.title, gmxIds = data.gmxIds;
                _context5.next = 13;
                return this._validate(gmxIds);

              case 13:
                res = _context5.sent;

                if (!res) {
                  _context5.next = 25;
                  break;
                }

                Status = res.Status, SquareStat = res.SquareStat, ForestStat = res.ForestStat;

                if (!(Status === 'valid')) {
                  _context5.next = 23;
                  break;
                }

                this._valid = {
                  forestProjectID: id,
                  title: title,
                  forestryID: forestryID,
                  quadrants: SquareStat,
                  species: ForestStat
                };

                this._project.open(this._valid);

                this._layers.quadrants.repaint();

                return _context5.abrupt("return", true);

              case 23:
                alert(translate$9('quadrant.invalid'));
                return _context5.abrupt("return", false);

              case 25:
                _context5.next = 28;
                break;

              case 27:
                this._notifications.forbidden.open();

              case 28:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function edit(_x5) {
        return _edit.apply(this, arguments);
      }

      return edit;
    }()
  }, {
    key: "view",
    value: function () {
      var _view = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref5) {
        var id, forestryID, data;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                id = _ref5.id, forestryID = _ref5.forestryID;

                if (!this._permissions.ForestProjectsView) {
                  _context6.next = 8;
                  break;
                }

                _context6.next = 4;
                return this.httpGet("".concat(this._path, "/Forest/GetPlotProjectApplication"), {
                  ForestProjectID: id
                });

              case 4:
                data = _context6.sent;

                if (data) {
                  this._info.open(data);
                }

                _context6.next = 9;
                break;

              case 8:
                this._notifications.forbidden.open();

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function view(_x6) {
        return _view.apply(this, arguments);
      }

      return view;
    }()
  }, {
    key: "_save",
    value: function () {
      var _save2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref6) {
        var forestProjectID, title, forestQs;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                forestProjectID = _ref6.forestProjectID, title = _ref6.title, forestQs = _ref6.forestQs;
                _context7.next = 3;
                return this.httpPost("".concat(this._path, "/Forest/StoreDraftForestProjectGmxIds"), {
                  forestProjectID: forestProjectID,
                  title: title,
                  forestQs: forestQs
                });

              case 3:
                return _context7.abrupt("return", _context7.sent);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _save(_x7) {
        return _save2.apply(this, arguments);
      }

      return _save;
    }()
  }, {
    key: "_createRequest",
    value: function () {
      var _createRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(id) {
        var data, event;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.httpPost("".concat(this._path, "/Forest/CreateApplicationFromDraft"), {
                  ForestProjectID: id
                });

              case 2:
                data = _context8.sent;

                if (data) {
                  event = document.createEvent('Event');
                  event.initEvent('create', false, false);
                  event.detail = id;
                  this.dispatchEvent(event);

                  this._project.close();
                }

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _createRequest(_x8) {
        return _createRequest2.apply(this, arguments);
      }

      return _createRequest;
    }()
  }, {
    key: "toggleQuadrant",
    value: function () {
      var _toggleQuadrant = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref7) {
        var gmx_id, forestryID, ids, data, Status, SquareStat, ForestStat;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                gmx_id = _ref7.gmx_id, forestryID = _ref7.forestryID;

                if (this._executing) {
                  _context9.next = 13;
                  break;
                }

                this._executing = true;
                ids = this._project.toggle(gmx_id);

                if (!(ids.length === 0)) {
                  _context9.next = 8;
                  break;
                }

                this._project.clear();

                _context9.next = 13;
                break;

              case 8:
                _context9.next = 10;
                return this._validate(ids);

              case 10:
                data = _context9.sent;
                this._executing = false;

                if (data) {
                  Status = data.Status, SquareStat = data.SquareStat, ForestStat = data.ForestStat;

                  if (Status === 'valid') {
                    this._valid = {
                      forestryID: forestryID,
                      quadrants: SquareStat,
                      species: ForestStat
                    };
                  } else {
                    alert(translate$9('quadrant.invalid'));
                  }

                  this._project.open(this._valid);

                  this._layers.quadrants.repaint();
                }

              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function toggleQuadrant(_x9) {
        return _toggleQuadrant.apply(this, arguments);
      }

      return toggleQuadrant;
    }()
  }]);

  return Projects;
}(LayerController);

var strings$c = {
  rus: {
    quadrant: {
      stock: {
        label: 'ÐÐ±ÑÐµÐ¼ Ð´ÑÐµÐ²ÐµÑÐ¸Ð½Ñ',
        all: 'ÐÐµÑÑ'
      },
      about: 'ÐÐ° Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð¸Ð¸ Ð´Ð°Ð½Ð½ÑÑ Ð»ÐµÑÐ¾ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð°',
      title: 'ÐÐ²Ð°ÑÑÐ°Ð»',
      stow: 'Ð£ÑÐ¾ÑÐ¸ÑÐµ',
      forestry: 'ÐÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      localForestry: 'Ð£ÑÐ°ÑÑÐºÐ¾Ð²Ð¾Ðµ Ð»ÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      invalid: 'ÐÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¹ ÑÐ¾ÑÑÐ°Ð² ÑÑÐ°ÑÑÐºÐ°'
    }
  }
};

var STYLES$2 = {
  fillStyle: document.createElement('canvas').getContext('2d').createPattern(L.gmxUtil.getPatternIcon(null, {
    type: '',
    color: parseInt('FFB801', 16),
    opacity: 1,
    weight: 1,
    fillOpacity: 0.64,
    fillPattern: {
      style: 'diagonal1',
      width: 8,
      step: 0,
      colors: [parseInt('FFB801', 16), parseInt('61E9F1', 16)]
    },
    common: true
  }).canvas, 'repeat'),
  strokeStyle: '#FFB801',
  lineWidth: 2
};

var Quadrants$1 = /*#__PURE__*/function (_BaseView) {
  _inherits(Quadrants, _BaseView);

  var _super = _createSuper(Quadrants);

  function Quadrants(container) {
    var _this;

    _classCallCheck(this, Quadrants);

    _this = _super.call(this, container, strings$c);

    _this._container.classList.add('scanex-forestry-quadrant');

    _this._container.innerHTML = "<div class=\"title\">".concat(_this.translate('quadrant.title'), "</div>\n\t\t<div class=\"forestry\"></div>\n\t\t<div class=\"stock\">").concat(_this.translate('quadrant.stock.label'), "</div>\n\t\t<div class=\"about\">").concat(_this.translate('quadrant.about'), "</div>\n\t\t<div class=\"chart\"></div>");
    _this._forestry = _this._container.querySelector('.forestry');
    _this._chart = new apexcharts_common(_this._container.querySelector('.chart'), {
      chart: {
        type: 'donut',
        height: '160px',
        width: '500px',
        fontFamily: 'Open Sans'
      },
      dataLabels: {
        enabled: false
      },
      labels: [],
      series: [],
      legend: {
        position: 'right',
        width: '200px',
        offsetY: -10,
        formatter: function formatter(name, opts) {
          var val = parseFloat(opts.w.globals.series[opts.seriesIndex]);
          return "".concat(name, " - ").concat(_this.m(val));
        },
        horizontalAlign: 'right'
      },
      plotOptions: {
        pie: {
          donut: {
            size: '78%',
            labels: {
              show: true,
              value: {
                formatter: function formatter(val) {
                  return "".concat(_this.m(val), " ").concat(_this.translate('units.m3'));
                },
                fontSize: '12px',
                show: true
              },
              total: {
                formatter: function formatter(_ref) {
                  var series = _ref.config.series;
                  return "".concat(_this.m(series.reduce(function (p, c) {
                    return p + c;
                  }, 0)), " ").concat(_this.translate('units.m3'));
                },
                label: _this.translate('quadrant.stock.all'),
                fontSize: '12px',
                fontWeight: 600,
                show: true
              }
            }
          }
        }
      }
    });

    _this._chart.render();

    return _this;
  }

  _createClass(Quadrants, [{
    key: "open",
    value: function open(data) {
      _get(_getPrototypeOf(Quadrants.prototype), "open", this).call(this);

      var gmx_id = data.gmx_id,
          Forestry = data.Forestry,
          LocalForestry = data.LocalForestry,
          Num = data.Num,
          Stock = data.Stock,
          Stow = data.Stow;
      this._gmx_id = gmx_id;
      this._forestry.innerHTML = "".concat(this.translate('quadrant.forestry'), ": ").concat(Forestry, ", ").concat(this.translate('quadrant.localForestry'), ": ").concat(LocalForestry).concat(Stow ? ", ".concat(this.translate('quadrant.stow'), ": ").concat(Stow) : '', ", ").concat(this.translate('quadrant.title'), " \u2116").concat(Num);

      if (Array.isArray(Stock)) {
        var _Stock$reduce = Stock.reduce(function (a, s) {
          a.labels.push(s.species);
          a.series.push(s.stock);
          return a;
        }, {
          labels: [],
          series: []
        }),
            labels = _Stock$reduce.labels,
            series = _Stock$reduce.series;

        this._chart.updateOptions({
          labels: labels
        });

        this._chart.updateSeries(series);
      }
    }
  }, {
    key: "getStyleHook",
    value: function getStyleHook(kind, item) {
      if (kind === 'quadrants') {
        return item.id === this._gmx_id ? STYLES$2 : {};
      } else {
        return {};
      }
    }
  }, {
    key: "close",
    value: function close() {
      this._gmx_id = null;

      _get(_getPrototypeOf(Quadrants.prototype), "close", this).call(this);
    }
  }, {
    key: "current",
    get: function get() {
      return this._gmx_id;
    }
  }]);

  return Quadrants;
}(View);

var Quadrants$2 = /*#__PURE__*/function (_LayerController) {
  _inherits(Quadrants, _LayerController);

  var _super = _createSuper(Quadrants);

  function Quadrants(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layer = _ref.layer,
        legend = _ref.legend,
        path = _ref.path,
        permissions = _ref.permissions;

    _classCallCheck(this, Quadrants);

    _this = _super.call(this, {
      kind: 'quadrants',
      map: map,
      content: content,
      notifications: notifications,
      layer: layer,
      legend: legend
    });
    _this._path = path;
    _this._permissions = permissions;
    _this._quadrants = _this._content.add('quadrants', Quadrants$1);

    _this._quadrants.on('close', function () {
      _this._layer.repaint();
    });

    return _this;
  }

  _createClass(Quadrants, [{
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var mode, _e$gmx, id, properties, event;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                L.DomEvent.stopPropagation(e);
                mode = this._content.getCurrentId();
                _e$gmx = e.gmx, id = _e$gmx.id, properties = _e$gmx.properties;

                if (!(mode === 'quadrants')) {
                  _context.next = 8;
                  break;
                }

                _context.next = 6;
                return this._toggleQuadrant(id, properties.id);

              case 6:
                _context.next = 17;
                break;

              case 8:
                if (!(mode === 'edit-project')) {
                  _context.next = 15;
                  break;
                }

                event = document.createEvent('Event');
                event.initEvent('quadrant:toggle', false, false);
                event.detail = {
                  gmx_id: id,
                  forestryID: properties.forestry_id
                };
                this.dispatchEvent(event);
                _context.next = 17;
                break;

              case 15:
                _context.next = 17;
                return this._toggleQuadrant(id, properties.id);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _click(_x) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }, {
    key: "_toggleQuadrant",
    value: function () {
      var _toggleQuadrant2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(gmx_id, id) {
        var data;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this._gmx_id && this._gmx_id === gmx_id)) {
                  _context2.next = 5;
                  break;
                }

                this._gmx_id = null;

                this._content.close();

                _context2.next = 10;
                break;

              case 5:
                this._gmx_id = gmx_id;
                _context2.next = 8;
                return this.httpGet("".concat(this._path, "/Forest/GetQuadrantInformation"), {
                  QuadrantID: id
                });

              case 8:
                data = _context2.sent;

                if (data) {
                  if (Array.isArray(data.Stock) && data.Stock.length > 0) {
                    this._quadrants.open(_objectSpread2({
                      gmx_id: gmx_id
                    }, data));
                  } else {
                    this._notifications.notAvailable.open({
                      gmx_id: gmx_id
                    });
                  }
                }

              case 10:
                this._layer.repaint();

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _toggleQuadrant(_x2, _x3) {
        return _toggleQuadrant2.apply(this, arguments);
      }

      return _toggleQuadrant;
    }()
  }]);

  return Quadrants;
}(LayerController);

var strings$d = {
  rus: {
    report: {
      title: 'Ð¡Ð²Ð¾Ð´Ð½Ð°Ñ Ð°Ð½Ð°Ð»Ð¸ÑÐ¸ÐºÐ°',
      type: 'Ð¢Ð¸Ð¿ Ð¾ÑÑÐµÑÐ°',
      typeOption: ['ÐÐ¿Ð»Ð°ÑÐµÐ½Ð¾ Ð¸ Ð²ÑÑÑÐ±Ð»ÐµÐ½Ð¾', 'ÐÐ°Ð»Ð°Ð½Ñ Ð´ÑÐµÐ²ÐµÑÐ¸Ð½Ñ', 'Ð¢Ð¾Ð¿-5 Ð½Ð°ÑÑÑÐ¸ÑÐµÐ»ÐµÐ¹'],
      region: 'Ð ÐµÐ³Ð¸Ð¾Ð½',
      forestry: 'ÐÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      districtForestry: 'Ð£ÑÐ°ÑÑÐºÐ¾Ð²Ð¾Ðµ Ð»ÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      sootn: 'Ð¡Ð¾Ð¾ÑÐ½Ð¾ÑÐµÐ½Ð¸Ðµ',
      oplach: 'Ð¾Ð¿Ð»Ð°ÑÐµÐ½Ð½Ð¾Ð¹',
      vyrub: 'Ð²ÑÑÑÐ±Ð»ÐµÐ½Ð½Ð¾Ð¹',
      dreves: 'Ð´ÑÐµÐ²ÐµÑÐ¸Ð½Ñ',
      vybpor: 'ÐÑÐ±Ð¾Ñ Ð¿Ð¾ÑÐ¾Ð´Ñ',
      period: 'ÐÐµÑÐ¸Ð¾Ð´',
      opl: 'ÐÐ¿Ð»Ð°ÑÐµÐ½Ð¾',
      vyr: 'ÐÑÑÑÐ±Ð»ÐµÐ½Ð¾',
      all: 'ÐÑÐµ',
      growth: 'ÐÑÐ¸ÑÐ¾ÑÑ',
      burntOut: 'Ð¡Ð³Ð¾ÑÐµÐ»Ð¾',
      cutDown: 'ÐÑÑÑÐ±Ð¸Ð»Ð¸',
      ballanceChanges: 'ÐÐ·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð±Ð°Ð»Ð°Ð½ÑÐ°',
      total: 'ÐÑÐ¾Ð³Ð¾',
      milr: 'Ð¼Ð»Ð½. ÑÑÐ±.',
      m3: 'Ð¼Ð»Ð½. ÑÑÐ±.',
      save: 'Ð¡ÑÐ¾ÑÐ¼Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð¾ÑÑÐµÑ'
    }
  }
};

var Reports = /*#__PURE__*/function (_BaseView) {
  _inherits(Reports, _BaseView);

  var _super = _createSuper(Reports);

  function Reports(container) {
    var _this;

    _classCallCheck(this, Reports);

    _this = _super.call(this, container, strings$d);

    _this._container.classList.add('scanex-forestry-analytics');

    return _this;
  }

  _createClass(Reports, [{
    key: "open",
    value: function open(data) {
      var _this2 = this;

      _get(_getPrototypeOf(Reports.prototype), "open", this).call(this);

      this._headerData = data;
      this.currentType = 0;

      var typeOption = this._parseOptions(this.translate('report.typeOption'));

      var regionOptions = this._parseOptionsHeader(data.regions);

      this.currentRegion = data.regions[0].id;

      var speciesOptions = this._parseOptionsHeader(data.species);

      this._container.innerHTML = "<div class=\"header\">".concat(this.translate('report.title'), "</div>\n\t\t\t<div class=\"content\">\n\t\t\t\t<div class=\"line\">\n\t\t\t\t\t<div class=\"left-wrap\">\n\t\t\t\t\t\t<div class=\"title\">").concat(this.translate('report.type'), "</div>\n\t\t\t\t\t\t<select name=\"type\" class=\"type style-4\">\n\t\t\t\t\t\t\t").concat(typeOption, "\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"right-wrap\">\n\t\t\t\t\t\t<button class=\"save\">\u0421\u0444\u043E\u0440\u043C\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043E\u0442\u0447\u0435\u0442</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"line\">\n\t\t\t\t\t<div class=\"left-wrap\">\n\t\t\t\t\t\t<div class=\"title\">").concat(this.translate('report.region'), "</div>\n\t\t\t\t\t\t<select name=\"region\" class=\"region\">\n\t\t\t\t\t\t\t").concat(regionOptions, "\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"right-wrap\">\n\t\t\t\t\t\t<div class=\"title\">").concat(this.translate('report.forestry'), "</div>\n\t\t\t\t\t\t<select name=\"forestry\" class=\"forestry\">\n\t\t\t\t\t\t </select>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"line\">\n\t\t\t\t\t<div class=\"left-wrap\">\n\t\t\t\t\t\t<div class=\"title\">").concat(this.translate('report.districtForestry'), "</div>\n\t\t\t\t\t\t<select name=\"localForestry\" class=\"localForestry\">\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"right-wrap\">\n\t\t\t\t\t\t<div class=\"title\">").concat(this.translate('report.period'), "</div>\n\t\t\t\t\t\t<div class=\"date-inputs\">\n\t\t\t\t\t\t\t<span class=\"date\">\n\t\t\t\t\t\t\t<input class=\"dateBegin\" type=\"text\" placeholder=\"\" value=\"\">\n\t\t\t\t\t\t\t<i class=\"scanex-uploaded-icon calendar\"></i>\n\t\t\t\t\t\t\t</span>\n\n\t\t\t\t\t\t\t<span class=\"date\">\n\t\t\t\t\t\t\t<input class=\"dateEnd\" type=\"text\" placeholder=\"\" value=\"\">\n\t\t\t\t\t\t\t<i class=\"scanex-uploaded-icon calendar\"></i>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"line species hidden\">\n\t\t\t\t\t<div class=\"left-wrap\">\n\t\t\t\t\t\t<div class=\"title\">").concat(this.translate('report.vybpor'), "</div>\n\t\t\t\t\t\t<select name=\"species\" class=\"species\">\n\t\t\t\t\t\t\t").concat(speciesOptions, "\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"chartCont\">\n\t\t\t\t</div>\n\t\t\t</div>");
      var i18n = {
        previousMonth: 'ÐÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ',
        nextMonth: 'Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ',
        months: ['Ð¯Ð½Ð²Ð°ÑÑ', 'Ð¤ÐµÐ²ÑÐ°Ð»Ñ', 'ÐÐ°ÑÑ', 'ÐÐ¿ÑÐµÐ»Ñ', 'ÐÐ°Ð¹', 'ÐÑÐ½Ñ', 'ÐÑÐ»Ñ', 'ÐÐ²Ð³ÑÑÑ', 'Ð¡ÐµÐ½ÑÑÐ±ÑÑ', 'ÐÐºÑÑÐ±ÑÑ', 'ÐÐ¾ÑÐ±ÑÑ', 'ÐÐµÐºÐ°Ð±ÑÑ'],
        weekdays: ['ÐÐ¾ÑÐºÑÐµÑÐµÐ½ÑÐµ', 'ÐÐ¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº', 'ÐÑÐ¾ÑÐ½Ð¸Ðº', 'Ð¡ÑÐµÐ´Ð°', 'Ð§ÐµÑÐ²ÐµÑÐ³', 'ÐÑÑÐ½Ð¸ÑÐ°', 'Ð¡ÑÐ±Ð±Ð¾ÑÐ°'],
        weekdaysShort: ['ÐÑ', 'ÐÐ½', 'ÐÑ', 'Ð¡Ñ', 'Ð§Ñ', 'ÐÑ', 'Ð¡Ð±']
      };
      this._lo = new pikaday({
        field: this._container.querySelector('.dateBegin'),
        format: 'DD.MM.YYYY',
        yearRange: 20,
        i18n: i18n // ,
        // keyboardInput: false,
        // blurFieldOnSelect: true

      });

      this._lo.setDate(new Date(2019, 0, 1));

      this._hi = new pikaday({
        field: this._container.querySelector('.dateEnd'),
        format: 'DD.MM.YYYY',
        yearRange: 20,
        i18n: i18n // ,
        // keyboardInput: false,
        // blurFieldOnSelect: true

      });

      this._hi.setDate(new Date());

      this._chartCont = this._container.querySelector('.chartCont');

      this._container.querySelector('.type').addEventListener('change', function (e) {
        e.stopPropagation();

        _this2._setType(e.target.selectedIndex);
      });

      this._container.querySelector('.region').addEventListener('change', function (e) {
        e.stopPropagation();

        _this2._setRegion(e.target.value);
      });

      this._container.querySelector('.forestry').addEventListener('change', function (e) {
        e.stopPropagation();

        _this2._setForestry(e.target.value);
      });

      this._container.querySelector('.species').addEventListener('change', function (e) {
        e.stopPropagation();
        _this2.currentSpecies = e.target.value;
      });

      this._container.querySelector('.save').addEventListener('click', /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
          var d1, d2, pdata, url;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  e.stopPropagation();
                  d1 = _this2._lo.getDate();
                  d2 = _this2._hi.getDate();
                  pdata = {
                    RegionID: _this2.currentRegion,
                    ForestryID: _this2.currentForestry,
                    LocalForestryID: _this2.currentLocalForestry,
                    DateBegin: d1 ? d1.toISOString() : '',
                    DateEnd: d2 ? d2.toISOString() : ''
                  };
                  url = _this2._path;

                  if (_this2.currentType === 0) {
                    url += '/Forest/GetSpeciesAnalytics';
                  } else if (_this2.currentType === 1) {
                    url += '/Forest/GetBallanceAnalytics';

                    if (_this2.currentSpecies) {
                      pdata.SpeciesCode = _this2.currentSpecies;
                    }
                  } else if (_this2.currentType === 2) {
                    url += '/Forest/GetOrganizationAnalytics';
                  }

                  url += '?' + Object.keys(pdata).map(function (key) {
                    return key + '=' + pdata[key];
                  }).join('&');

                  _this2._save(url);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());

      this._setType(0);

      this._setRegion(data.regions[0].id);

      this._setForestry(this.currentForestry);

      this.currentSpecies = data.species[0].idnDigital;
    }
  }, {
    key: "_save",
    value: function () {
      var _save2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url) {
        var response;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return fetch(url, {
                  method: 'GET',
                  credentials: 'include'
                });

              case 2:
                response = _context2.sent;
                _context2.next = 5;
                return response.json();

              case 5:
                this._res = _context2.sent;

                if (this.currentType === 0) {
                  this._parseTop5(this._res);
                } else if (this.currentType === 1) {
                  this._parseBallance(this._res);
                } else if (this.currentType === 2) {
                  this._parseTop5(this._res);
                }

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _save(_x2) {
        return _save2.apply(this, arguments);
      }

      return _save;
    }()
  }, {
    key: "_setForestry",
    value: function _setForestry(id) {
      var _this3 = this;

      this.currentForestry = id;

      var cont = this._container.querySelector('.localForestry');

      cont.options.length = 0;

      var arr = this._headerData.localForestries.filter(function (it) {
        return it.forestry == _this3.currentForestry;
      });

      arr.forEach(function (it) {
        var opt = document.createElement('option');
        opt.value = it.id;
        opt.textContent = it.name;
        cont.appendChild(opt);
      });
      this.currentLocalForestry = arr.length ? arr[0].id : '';
    }
  }, {
    key: "_setRegion",
    value: function _setRegion(id) {
      var _this4 = this;

      this.currentRegion = id;

      var cont = this._container.querySelector('.forestry');

      cont.options.length = 0;

      var arr = this._headerData.forestries.filter(function (it) {
        return it.region == _this4.currentRegion;
      });

      arr.forEach(function (it) {
        var opt = document.createElement('option');
        opt.value = it.id;
        opt.textContent = it.name;
        cont.appendChild(opt);
      });
      this.currentForestry = arr.length ? arr[0].id : '';
    }
  }, {
    key: "_setType",
    value: function _setType(id) {
      this.currentType = id;

      var cont = this._container.querySelector('.line.species');

      if (id === 1) {
        cont.classList.remove('hidden');

        this._container.classList.add('height638');
      } else {
        cont.classList.add('hidden');

        this._container.classList.remove('height638');
      }

      this._chartCont.innerHTML = '';
    }
  }, {
    key: "_parseOptionsHeader",
    value: function _parseOptionsHeader(data) {
      return data.map(function (it) {
        return "<option value=\"".concat(it.id || it.idnDigital, "\">").concat(it.name, "</option>");
      }).join('\n');
    }
  }, {
    key: "_parseOptions",
    value: function _parseOptions(data) {
      return data.map(function (it, ind) {
        return "<option value=\"".concat(ind, "\">").concat(it, "</option>");
      }).join('\n');
    }
  }, {
    key: "_parseTop5",
    value: function _parseTop5(data) {
      var maxHeight = 240;
      var maxValue = data.reduce(function (p, c) {
        return Math.max(p, c.payed, c.cutDown);
      }, 0);
      var str = data.map(function (it) {
        return "<div class=\"chart-row__left-el\">\n\t\t\t\t<div class=\"chart-row__left-el-chart\">\n\t\t\t\t\t<div class=\"chart-row__left-el-chart__text\">".concat(it.payed, " \u043C<sup>3</sup></div>\n\t\t\t\t\t<div class=\"chart-row__left-el-chart__arrow green-bg\" style=\"height: ").concat(Math.floor(maxHeight * Math.min(it.payed, maxValue) / maxValue), "px\"></div>\n\t\t\t\t\t<div class=\"chart-row__left-el-chart__text_bot\">").concat(it.organization || it.species, "</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"chart-row__left-el-chart\">\n\t\t\t\t\t<div class=\"chart-row__left-el-chart__text\">").concat(it.cutDown, " \u043C<sup>3</sup></div>\n\t\t\t\t\t<div class=\"chart-row__left-el-chart__arrow blue-bg\" style=\"height: ").concat(Math.floor(maxHeight * Math.min(it.cutDown, maxValue) / maxValue), "px\"></div>\n\t\t\t\t\t<div class=\"chart-row__left-el-chart__text_bot\">&nbsp;</div>\n\t\t\t\t</div>\n\t\t\t</div>");
      }).join('\n');
      this._chartCont.innerHTML = "<div class=\"line\">\n\t\t\t<div class=\"chart-header black\">".concat(this.translate('report.sootn'), "&nbsp;<span class=\"green\">").concat(this.translate('report.oplach'), "</span>&nbsp;\u0438&nbsp;<span class=\"blue\">").concat(this.translate('report.vyrub'), "</span>&nbsp;").concat(this.translate('report.dreves'), "\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"chart-row\">\n\t\t\t<div class=\"chart-row__left\">\n\t\t\t\t").concat(str, "\n\t\t\t</div>\n\t\t\t<div class=\"chart-row__right\">\n\t\t\t\t<div class=\"chart-row__right_line\">\n\t\t\t\t\t<div class=\"rec green-bg\"></div>\n\t\t\t\t\t<div class=\"rec-text\">").concat(this.translate('report.opl'), "</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"chart-row__right_line\">\n\t\t\t\t\t<div class=\"rec blue-bg\"></div>\n\t\t\t\t\t<div class=\"rec-text\">").concat(this.translate('report.vyr'), "</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>");
    }
  }, {
    key: "_parseBallance",
    value: function _parseBallance(data) {
      var maxValue = data.total;
      var maxWidth = 220;
      this._chartCont.innerHTML = "<table class=\"line\">\n            <tr>\n\t\t\t\t<td class=\"first\">".concat(this.translate('report.growth'), "</td>\n                <td class=\"sec\"><div class=\"horizont-sec-act green-bg\" style=\"width: ").concat(Math.floor(maxWidth * Math.min(data.growth.quantity, maxValue) / maxValue), "px\"></div></td>\n                <td class=\"third green\">").concat(data.growth.quantity, " \u043C<sup>3</sup></td>\n                <td class=\"last\">\u043D\u0430 \u0441\u0443\u043C\u043C\u0443&nbsp;&nbsp;<span class=\"green\">").concat(data.growth.summa, " ").concat(this.translate('report.milr'), "</span></td>\n            </tr>\n            <tr>\n\t\t\t\t<td class=\"first\">").concat(this.translate('report.burntOut'), "</td>\n                <td class=\"sec\"><div class=\"horizont-sec-act red-bg\" style=\"width: ").concat(Math.floor(maxWidth * Math.min(data.burntOut.quantity, maxValue) / maxValue), "px\"></div></td>\n                <td class=\"third red\">").concat(data.burntOut.quantity, " \u043C<sup>3</sup></td>\n                <td class=\"last\">\u043D\u0430 \u0441\u0443\u043C\u043C\u0443&nbsp;&nbsp;<span class=\"red\">").concat(data.burntOut.summa, " ").concat(this.translate('report.milr'), "</span></td>\n            </tr>\n            <tr>\n\t\t\t\t<td class=\"first\">").concat(this.translate('report.cutDown'), "</td>\n                <td class=\"sec\"><div class=\"horizont-sec-act red-bg\" style=\"width: ").concat(Math.floor(maxWidth * Math.min(data.cutDown.quantity, maxValue) / maxValue), "px\"></div></td>\n                <td class=\"third red\">").concat(data.cutDown.quantity, " \u043C<sup>3</sup></td>\n                <td class=\"last\">\u043D\u0430 \u0441\u0443\u043C\u043C\u0443&nbsp;&nbsp;<span class=\"red\">").concat(data.cutDown.summa, " ").concat(this.translate('report.milr'), "</span></td>\n            </tr>\n            <tr>\n\t\t\t\t<td class=\"first\">").concat(this.translate('report.ballanceChanges'), "</td>\n                <td class=\"sec\"><div class=\"horizont-sec-act red-bg\" style=\"width: ").concat(Math.floor(maxWidth * Math.min(data.ballanceChanges.quantity, maxValue) / maxValue), "px\"></div></td>\n                <td class=\"third red\">").concat(data.ballanceChanges.quantity, " \u043C<sup>3</sup></td>\n                <td class=\"last\">\u043D\u0430 \u0441\u0443\u043C\u043C\u0443&nbsp;&nbsp;<span class=\"red\">").concat(data.ballanceChanges.summa, " ").concat(this.translate('report.milr'), "</span></td>\n            </tr>\n            <tr>\n\t\t\t\t<td class=\"first\">").concat(this.translate('report.total'), "</td>\n                <td class=\"sec\"><div class=\"horizont-sec-act green-bg\" style=\"width: 100%\"></div></td>\n                <td class=\"third gray\">125 684 \u043C<sup>3</sup></td>\n                <td class=\"last\"></td>\n            </tr>\n\t\t</table>");
    }
  }]);

  return Reports;
}(View);

var Reports$1 = /*#__PURE__*/function (_Controller) {
  _inherits(Reports$1, _Controller);

  var _super = _createSuper(Reports$1);

  function Reports$1(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        path = _ref.path;

    _classCallCheck(this, Reports$1);

    _this = _super.call(this, {
      map: map,
      content: content,
      notifications: notifications
    });
    _this._path = path;
    _this._view = _this._content.add('reports', Reports);
    return _this;
  }

  _createClass(Reports$1, [{
    key: "view",
    value: function () {
      var _view = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var data;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.httpGet("".concat(this._path, "/Forest/GetReportHeaderData"));

              case 2:
                data = _context.sent;

                if (!data) {
                  _context.next = 6;
                  break;
                }

                _context.next = 6;
                return this._view.open(data);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function view() {
        return _view.apply(this, arguments);
      }

      return view;
    }()
  }]);

  return Reports$1;
}(Controller);

var strings$e = {
  rus: {
    request: {
      id: '#',
      status: 'Ð¡ÑÐ°ÑÑÑ',
      title: 'ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ',
      area: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ, Ð³Ð°',
      amount: 'ÐÐ±ÑÐ¸Ð¹ Ð·Ð°Ð¿Ð°Ñ, Ð¼',
      forestry: 'ÐÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾',
      local_forestry: 'Ð£Ñ. Ð»ÐµÑÐ½Ð¸ÑÐµÑÑÐ²Ð¾, ÐºÐ²Ð°ÑÑÐ°Ð»',
      header: 'ÐÑÐ±Ð¾Ñ Ð¿ÑÐ¾ÐµÐºÑÐ° Ð»ÐµÑÐ½Ð¾Ð³Ð¾ ÑÑÐ°ÑÑÐºÐ°',
      edit: 'Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ',
      create: 'Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð¿ÑÐ¾ÐµÐºÑ'
    }
  }
};

var Requests = /*#__PURE__*/function (_BaseView) {
  _inherits(Requests, _BaseView);

  var _super = _createSuper(Requests);

  function Requests(container) {
    var _this;

    _classCallCheck(this, Requests);

    _this = _super.call(this, container, strings$e);

    _this._container.classList.add('scanex-forestry-requests');

    _this._container.innerHTML = "<div class=\"header\">           \n            <label class=\"title\">".concat(_this.translate('request.header'), "</label>                   \n            <button class=\"create\">").concat(_this.translate('request.create'), "</button>                              \n        </div>\n        <table cellpadding=\"0\" cellspacing=\"0\">\n            <thead>\n                <tr height=\"42\">\n                    <th data-id=\"id\">").concat(_this.translate('request.id'), "</th>\n                    <th data-id=\"title\">").concat(_this.translate('request.title'), "</th>\n                    <th data-id=\"status\">").concat(_this.translate('request.status'), "</th>\n                    <th data-id=\"forestry\">").concat(_this.translate('request.forestry'), "</th>\n                    <th data-id=\"local_forestry\">").concat(_this.translate('request.local_forestry'), "</th>\n                    <th data-id=\"area\">").concat(_this.translate('request.area'), "</th>\n                    <th data-id=\"amount\">").concat(_this.translate('request.amount'), "<sup>3</sup></th>\n                    <th data-id=\"remove\"></th>\n                </tr>\n            </thead>\n        </table> \n        <div class=\"content style-4\">\n            <table cellpadding=\"0\" cellspacing=\"0\">\n                <tbody class=\"items\"></tbody>\n            </table>\n        </div>");
    _this._content = _this._container.querySelector('.items');

    _this._container.querySelector('.create').addEventListener('click', function (e) {
      e.stopPropagation();
      var event = document.createEvent('Event');
      event.initEvent('create', false, false);

      _this.dispatchEvent(event);
    });

    return _this;
  }

  _createClass(Requests, [{
    key: "getStyleHook",
    value: function getStyleHook() {
      return {};
    }
  }, {
    key: "open",
    value: function open(_ref) {
      var _this2 = this;

      var plotProjectsList = _ref.plotProjectsList;

      _get(_getPrototypeOf(Requests.prototype), "open", this).call(this);

      this._content.innerHTML = plotProjectsList.map(function (_ref2) {
        var number = _ref2.number,
            title = _ref2.title,
            status = _ref2.status,
            statusID = _ref2.statusID,
            forestry = _ref2.forestry,
            localForestries = _ref2.localForestries,
            totalSquare = _ref2.totalSquare;
        return "<tr height=\"42\" class=\"request\">\n                <td data-id=\"id\">".concat(number, "</td>\n                <td data-id=\"title\">").concat(title, "</td>\n                <td data-id=\"status\">").concat(status, "</td>\n                <td data-id=\"forestry\">").concat(forestry, "</td>\n                <td data-id=\"local_forestry\">").concat(localForestries, "</td>\n                <td data-id=\"area\">").concat(totalSquare.toLocaleString('ru-RU', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }), "</td>\n                <td data-id=\"amount\"></td>\n                <td data-id=\"remove\">").concat(statusID === 1 ? '<i class="scanex-requests-icon remove"></i>' : '', "</td>\n            </tr>");
      }).join('');

      var rows = this._content.querySelectorAll('.request');

      var _loop = function _loop(i) {
        var row = rows[i];
        var _plotProjectsList$i = plotProjectsList[i],
            id = _plotProjectsList$i.id,
            forestryID = _plotProjectsList$i.forestryID,
            statusID = _plotProjectsList$i.statusID;
        var rm = row.querySelector('.scanex-requests-icon');

        if (rm) {
          rm.addEventListener('click', function (e) {
            e.stopPropagation();
            var event = document.createEvent('Event');
            event.initEvent('remove', false, false);
            event.detail = id;

            _this2.dispatchEvent(event);
          });
        }

        row.addEventListener('click', function (e) {
          e.stopPropagation();
          var event;

          switch (statusID) {
            case 1:
              event = document.createEvent('Event');
              event.initEvent('edit', false, false);
              event.detail = {
                id: id,
                forestryID: forestryID
              };

              _this2.dispatchEvent(event);

              break;

            default:
              event = document.createEvent('Event');
              event.initEvent('view', false, false);
              event.detail = {
                id: id,
                forestryID: forestryID
              };

              _this2.dispatchEvent(event);

              break;
          }
        });
      };

      for (var i = 0; i < rows.length; ++i) {
        _loop(i);
      }
    }
  }]);

  return Requests;
}(View);

var Requests$1 = /*#__PURE__*/function (_Controller) {
  _inherits(Requests$1, _Controller);

  var _super = _createSuper(Requests$1);

  function Requests$1(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        legend = _ref.legend,
        layers = _ref.layers,
        permissions = _ref.permissions,
        path = _ref.path;

    _classCallCheck(this, Requests$1);

    _this = _super.call(this, {
      map: map,
      content: content,
      notifications: notifications
    });
    _this._legend = legend;
    _this._layers = layers;
    _this._permissions = permissions;
    _this._path = path;
    _this._view = _this._content.add('requests', Requests);

    _this._view.on('create', function () {
      var event = document.createEvent('Event');
      event.initEvent('create', false, false);

      _this.dispatchEvent(event);
    });

    _this._view.on('view', function (e) {
      var event = document.createEvent('Event');
      event.initEvent('view', false, false);
      event.detail = e.detail;

      _this.dispatchEvent(event);
    });

    _this._view.on('edit', function (e) {
      var event = document.createEvent('Event');
      event.initEvent('edit', false, false);
      event.detail = e.detail;

      _this.dispatchEvent(event);
    });

    _this._view.on('remove', /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var id;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                id = e.detail;
                _context.next = 3;
                return _this._remove(id);

              case 3:
                _context.next = 5;
                return _this.view();

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());

    return _this;
  }

  _createClass(Requests$1, [{
    key: "view",
    value: function () {
      var _view = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var data;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.httpGet("".concat(this._path, "/Forest/GetPlotProjectsList"));

              case 2:
                data = _context2.sent;

                if (data) {
                  this._legend.enable('projects');

                  this._legend.enable('plots');

                  this._view.open(data);

                  this._layers.projects.repaint();
                }

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function view() {
        return _view.apply(this, arguments);
      }

      return view;
    }()
  }, {
    key: "_remove",
    value: function () {
      var _remove2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(id) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this._permissions.ForestProjectsRemove) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 3;
                return this.httpPost("".concat(this._path, "/Forest/RemoveDraftForestProject"), {
                  forestProjectID: id
                });

              case 3:
                _context3.next = 6;
                break;

              case 5:
                this._notifications.forbidden.open();

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _remove(_x2) {
        return _remove2.apply(this, arguments);
      }

      return _remove;
    }()
  }]);

  return Requests$1;
}(Controller);

var Roads = /*#__PURE__*/function (_LayerController) {
  _inherits(Roads, _LayerController);

  var _super = _createSuper(Roads);

  function Roads(_ref) {
    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layer = _ref.layer,
        legend = _ref.legend;

    _classCallCheck(this, Roads);

    return _super.call(this, {
      kind: 'roads',
      map: map,
      content: content,
      notifications: notifications,
      layer: layer,
      legend: legend
    });
  }

  return Roads;
}(LayerController);

var strings$f = {
  rus: {
    stand: {
      title: 'ÐÑÐ´ÐµÐ»',
      usage: 'Ð¦ÐµÐ»ÐµÐ²Ð¾Ðµ Ð½Ð°Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð»ÐµÑÐ¾Ð²',
      year: 'ÐÐ¾Ð´ Ð°ÐºÑÑÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸',
      area: 'ÐÐ»Ð¾ÑÐ°Ð´Ñ Ð²ÑÐ´ÐµÐ»Ð°',
      category: 'ÐÐ°ÑÐµÐ³Ð¾ÑÐ¸Ñ Ð·ÐµÐ¼ÐµÐ»Ñ',
      protected: 'ÐÑÐ¾Ð±Ð¾Ð·Ð°ÑÐ¸ÑÐ½ÑÐµ ÑÑÐ°ÑÑÐºÐ¸ (ÐÐÐ£)',
      slope: 'Ð­ÐºÑÐ¿Ð¾Ð·Ð¸ÑÐ¸Ñ / ÐºÑÑÑÐ¸Ð·Ð½Ð°',
      targetSpecies: 'Ð¦ÐµÐ»ÐµÐ²Ð°Ñ Ð¿Ð¾ÑÐ¾Ð´Ð°',
      mainSpecies: 'ÐÑÐµÐ¾Ð±Ð»Ð°Ð´Ð°ÑÑÐ°Ñ Ð¿Ð¾ÑÐ¾Ð´Ð°',
      age: 'ÐÑÑÐ¿Ð¿Ð° Ð²Ð¾Ð·ÑÐ°ÑÑÐ°',
      klass: 'ÐÐ»Ð°ÑÑ Ð²Ð¾Ð·ÑÐ°ÑÑÐ°',
      bonitet: 'ÐÐ¾Ð½Ð¸ÑÐµÑ',
      type: 'Ð¢Ð¸Ð¿ Ð»ÐµÑÐ°',
      percentage: 'ÐÑÐ¾ÑÐµÐ½Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ',
      storey: {
        title: 'Ð¯ÑÑÑ',
        age: 'ÐÐ¾Ð·ÑÐ°ÑÑ, Ð»ÐµÑ',
        basal_area_sum: 'Ð¡ÑÐ¼Ð¼Ð° Ð¿Ð»Ð¾ÑÐ°Ð´ÐµÐ¹ ÑÐµÑÐµÐ½Ð¸Ð¹',
        dbh: 'ÐÐ¸Ð°Ð¼ÐµÑÑ',
        density: 'ÐÐ¾Ð»Ð½Ð¾ÑÐ°',
        gross_volume: 'ÐÐ°Ð¿Ð°Ñ Ð½Ð° 1 Ð³Ð°',
        height: 'ÐÑÑÐ¾ÑÐ°',
        marketability_class: 'ÐÐ»Ð°ÑÑ ÑÐ¾Ð²Ð°ÑÐ½Ð¾ÑÑÐ¸',
        origin_id: 'ÐÑÐ¾Ð¸ÑÑÐ¾Ð¶Ð´ÐµÐ½Ð¸Ðµ',
        rate: 'ÐÐ¾ÑÑÐ¸ÑÐ¸ÐµÐ½Ñ ÑÐ¾ÑÑÐ°Ð²Ð°',
        species: 'ÐÐ¾ÑÐ¾Ð´Ð½ÑÐ¹ ÑÐ¾ÑÑÐ°Ð²'
      },
      stock: {
        all: 'ÐÐµÑÑ'
      }
    }
  }
};

var STYLES$3 = {
  fillStyle: document.createElement('canvas').getContext('2d').createPattern(L.gmxUtil.getPatternIcon(null, {
    type: '',
    color: parseInt('FFB801', 16),
    opacity: 1,
    weight: 1,
    fillOpacity: 0.64,
    fillPattern: {
      style: 'diagonal1',
      width: 8,
      step: 0,
      colors: [parseInt('FFB801', 16), parseInt('61E9F1', 16)]
    },
    dashArray: [10, 10],
    common: true
  }).canvas, 'repeat'),
  strokeStyle: '#FFB801',
  lineWidth: 2
};

var Stands = /*#__PURE__*/function (_BaseView) {
  _inherits(Stands, _BaseView);

  var _super = _createSuper(Stands);

  function Stands(container) {
    var _this;

    _classCallCheck(this, Stands);

    _this = _super.call(this, container, strings$f);

    _this._container.classList.add('scanex-forestry-stand');

    _this._container.innerHTML = "\n\t\t<div class=\"header1\">".concat(_this.translate('stand.title'), "</div>\n\t\t<div class=\"header2\"></div>\n\t\t<div class=\"content\">\n\t\t\t<div class=\"stats\"></div>\t\t\t\n\t\t\t<div>\n\t\t\t\t<div class=\"chart\"></div>\n\t\t\t\t<div class=\"events\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"levels\"></div>\t\t\n\t\t</div>");
    _this._header = _this._container.querySelector('.header2');
    _this._stats = _this._container.querySelector('.stats');
    _this._chart = new apexcharts_common(_this._container.querySelector('.chart'), {
      chart: {
        type: 'donut',
        height: '180px',
        width: '500px',
        fontFamily: 'Open Sans'
      },
      dataLabels: {
        enabled: false
      },
      labels: [],
      series: [],
      legend: {
        position: 'right',
        // width: '150px',
        formatter: function formatter(name, opts) {
          var val = parseFloat(opts.w.globals.series[opts.seriesIndex]);
          return "".concat(name, " - ").concat(_this.m(val));
        },
        horizontalAlign: 'right'
      },
      plotOptions: {
        pie: {
          donut: {
            size: '78%',
            labels: {
              show: true,
              value: {
                formatter: function formatter(val) {
                  return "".concat(_this.m(val), " ").concat(_this.translate('units.m3'));
                },
                fontSize: '12px',
                show: true
              },
              total: {
                formatter: function formatter(_ref) {
                  var series = _ref.config.series;
                  return "".concat(_this.m(series.reduce(function (p, c) {
                    return p + c;
                  }, 0)), " ").concat(_this.translate('units.m3'));
                },
                label: _this.translate('stand.stock.all'),
                fontSize: '12px',
                fontWeight: 600,
                show: true
              }
            }
          }
        }
      }
    });

    _this._chart.render();

    _this._levels = _this._container.querySelector('.levels');
    _this._events = _this._container.querySelector('.events');
    return _this;
  }

  _createClass(Stands, [{
    key: "open",
    value: function open(data) {
      var _this2 = this;

      _get(_getPrototypeOf(Stands.prototype), "open", this).call(this);

      var gmx_id = data.gmx_id,
          Forestry = data.Forestry,
          LocalForestry = data.LocalForestry,
          Stow = data.Stow,
          Quadrant = data.Quadrant,
          Stand = data.Stand,
          ForestUseType = data.ForestUseType,
          UpdatingYear = data.UpdatingYear,
          Square = data.Square,
          LandCategory = data.LandCategory,
          OZU = data.OZU,
          Exposition = data.Exposition,
          Steepness = data.Steepness,
          TargetSpecies = data.TargetSpecies,
          PredominantSpecies = data.PredominantSpecies,
          AgeGroup = data.AgeGroup,
          AgeClass = data.AgeClass,
          Bonitet = data.Bonitet,
          Stock = data.Stock,
          StoreyInfo = data.StoreyInfo,
          StoreyAggInfo = data.StoreyAggInfo,
          Events = data.Events;
      this._gmx_id = gmx_id;
      this._header.innerText = [Forestry, LocalForestry, Stow, Quadrant, Stand].join(', ');
      this._stats.innerHTML = "<table cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>".concat(this.translate('stand.usage'), "</td>\n\t\t\t\t\t<td>").concat(ForestUseType, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.year'), "</td>\n\t\t\t\t\t<td>").concat(UpdatingYear, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.area'), "</td>\n\t\t\t\t\t<td>").concat(this.ha(Square), "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.category'), "</td>\n\t\t\t\t\t<td>").concat(LandCategory, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.protected'), "</td>\n\t\t\t\t\t<td>").concat(OZU, "</td>                    \n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.slope'), "</td>\n\t\t\t\t\t<td>").concat(Exposition, " / ").concat(Steepness, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<!--tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.targetSpecies'), "</td>\n\t\t\t\t\t<td>").concat(TargetSpecies, "</td>                    \n\t\t\t\t</tr-->\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.mainSpecies'), "</td>\n\t\t\t\t\t<td>").concat(PredominantSpecies, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.age'), "</td>\n\t\t\t\t\t<td>").concat(AgeGroup, "</td>                    \n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.klass'), "</td>\n\t\t\t\t\t<td>").concat(AgeClass, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.bonitet'), "</td>\n\t\t\t\t\t<td>").concat(Bonitet, "</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>").concat(this.translate('stand.type'), "</td>\n\t\t\t\t\t<td></td>                    \n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>");

      var _Stock$reduce = Stock.reduce(function (a, _ref2) {
        var stock = _ref2.stock,
            species = _ref2.species;
        a.labels.push(species);
        a.series.push(stock);
        return a;
      }, {
        labels: [],
        series: []
      }),
          labels = _Stock$reduce.labels,
          series = _Stock$reduce.series;

      this._chart.updateOptions({
        labels: labels
      });

      this._chart.updateSeries(series);

      if (Array.isArray(StoreyAggInfo)) {
        this._levels.innerHTML = "<table cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t\t<tbody>".concat(StoreyAggInfo.map(function (_ref3) {
          var storey = _ref3.storey,
              abbr = _ref3.abbr,
              age = _ref3.age,
              basal_area_sum = _ref3.basal_area_sum,
              dbh = _ref3.dbh,
              density = _ref3.density,
              gross_volume = _ref3.gross_volume,
              height = _ref3.height,
              marketability_class = _ref3.marketability_class,
              rate = _ref3.rate;
          return "<tr class=\"storey\">\n\t\t\t\t\t\t<td>".concat(_this2.translate('stand.storey.title'), "</td>\n\t\t\t\t\t\t<td>").concat(storey, "</td>\t\t\t\t\t\t\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.species'), "</td>\n\t\t\t\t\t\t<td>").concat(abbr, "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.rate'), "</td>\n\t\t\t\t\t\t<td>").concat(_this2.fmt(rate), "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.gross_volume'), ", ").concat(_this2.translate('units.m'), "<sup>3</sup></td>\n\t\t\t\t\t\t<td>").concat(_this2.m(gross_volume), "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.age'), "</td>\n\t\t\t\t\t\t<td>").concat(age, "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.basal_area_sum'), ", ").concat(_this2.translate('units.m'), "<sup>2</sup></td>\n\t\t\t\t\t\t<td>").concat(_this2.m(basal_area_sum), "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.dbh'), ", ").concat(_this2.translate('units.cm'), "</td>\n\t\t\t\t\t\t<td>").concat(_this2.fmt(dbh), "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.density'), "</td>\n\t\t\t\t\t\t<td>").concat(_this2.fmt(density), "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.height'), ", ").concat(_this2.translate('units.m'), "</td>\n\t\t\t\t\t\t<td>").concat(_this2.fmt(height), "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.storey.marketability_class'), "</td>\n\t\t\t\t\t\t<td>").concat(marketability_class, "</td>\n\t\t\t\t\t</tr>");
        }).join(''), "</tbody>\n\t\t\t</table>");
      }

      if (Array.isArray(Events)) {
        this._events.innerHTML = "<table cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t\t<tbody>".concat(Events.map(function (_ref4) {
          var name = _ref4.name,
              activity = _ref4.activity,
              fillingpercent = _ref4.fillingpercent;
          return "<tr>\n\t\t\t\t\t\t<td>".concat(name, "</td>\n\t\t\t\t\t\t<td>").concat(activity, "</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>").concat(_this2.translate('stand.percentage'), "</td>\n\t\t\t\t\t\t<td class=\"percentage\">").concat(_this2.fmt(fillingpercent)).concat(_this2.translate('units.pc'), "</td>\n\t\t\t\t\t</tr>");
        }).join(''), "</tbody>\n\t\t\t</table>");
      }
    }
  }, {
    key: "getStyleHook",
    value: function getStyleHook(kind, item) {
      if (kind === 'stands') {
        return item.id === this._gmx_id ? STYLES$3 : {};
      } else {
        return {};
      }
    }
  }, {
    key: "close",
    value: function close() {
      this._gmx_id = null;

      _get(_getPrototypeOf(Stands.prototype), "close", this).call(this);
    }
  }]);

  return Stands;
}(View);

var Stands$1 = /*#__PURE__*/function (_LayerController) {
  _inherits(Stands$1, _LayerController);

  var _super = _createSuper(Stands$1);

  function Stands$1(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layer = _ref.layer,
        legend = _ref.legend,
        path = _ref.path;

    _classCallCheck(this, Stands$1);

    _this = _super.call(this, {
      kind: 'stands',
      map: map,
      content: content,
      notifications: notifications,
      layer: layer,
      legend: legend
    });
    _this._path = path;
    _this._view = _this._content.add(_this._kind, Stands);
    return _this;
  }

  _createClass(Stands$1, [{
    key: "_click",
    value: function () {
      var _click2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var _e$gmx, id, properties, data;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.canClick) {
                  _context.next = 19;
                  break;
                }

                L.DomEvent.stopPropagation(e);
                _e$gmx = e.gmx, id = _e$gmx.id, properties = _e$gmx.properties;

                if (!(this._gmx_id && this._gmx_id === id)) {
                  _context.next = 7;
                  break;
                }

                this._view.close();

                _context.next = 19;
                break;

              case 7:
                _context.next = 9;
                return this.httpGet("".concat(this._path, "/Forest/GetStandInformation?StandID=").concat(properties.id));

              case 9:
                data = _context.sent;

                if (!data) {
                  _context.next = 19;
                  break;
                }

                this._gmx_id = id;

                if (!Array.isArray(data.Stock)) {
                  _context.next = 18;
                  break;
                }

                _context.next = 15;
                return this._view.open(_objectSpread2({
                  gmx_id: this._gmx_id
                }, data));

              case 15:
                this._layer.repaint();

                _context.next = 19;
                break;

              case 18:
                this._notifications.notAvailable.open({
                  gmx_id: this._gmx_id
                });

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _click(_x) {
        return _click2.apply(this, arguments);
      }

      return _click;
    }()
  }]);

  return Stands$1;
}(LayerController);

var floor$8 = Math.floor;

// `Number.isInteger` method implementation
// https://tc39.github.io/ecma262/#sec-number.isinteger
var isInteger = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor$8(it) === it;
};

// `Number.isInteger` method
// https://tc39.github.io/ecma262/#sec-number.isinteger
_export({ target: 'Number', stat: true }, {
  isInteger: isInteger
});

var translate$a = T.getText.bind(T);
T.addText('rus', {
  pager: {
    previous: 'ÐÑÐµÐ´ÑÐ´ÑÑÐ°Ñ',
    next: 'Ð¡Ð»ÐµÐ´ÑÑÑÐ°Ñ'
  }
});

var Pager = /*#__PURE__*/function (_EventTarget) {
  _inherits(Pager, _EventTarget);

  var _super = _createSuper(Pager);

  function Pager(container) {
    var _this;

    _classCallCheck(this, Pager);

    _this = _super.call(this);
    _this._container = container;
    _this._container.innerHTML = "<table class=\"scanex-forestry-pager\" cellpadding=\"0\" cellspacing=\"0\">\n            <tr>\n                <td>\n                    <button class=\"first\">1</button>\n                </td>                \n                <td>\n                    <button class=\"previous\">".concat(translate$a('pager.previous'), "</button>\n                </td>\n                <td>\n                    <input type=\"text\" value=\"\" />\n                </td>\n                <td>\n                    <button class=\"next\">").concat(translate$a('pager.next'), "</button>\n                </td>                \n                <td>\n                    <button class=\"last\"></button>\n                </td>\n            </tr>\n        </table>");

    _this._container.querySelector('.first').addEventListener('click', function (e) {
      e.stopPropagation();
      _this.page = 1;
    });

    _this._container.querySelector('.previous').addEventListener('click', function (e) {
      e.stopPropagation();
      _this.page -= 1;
    });

    _this._container.querySelector('.next').addEventListener('click', function (e) {
      e.stopPropagation();
      _this.page += 1;
    });

    _this._container.querySelector('.last').addEventListener('click', function (e) {
      e.stopPropagation();
      _this.page = _this.pages;
    });

    _this._current = _this._container.querySelector('input');

    _this._current.addEventListener('change', function (e) {
      e.stopPropagation();
      _this.page = parseInt(_this._current.value, 10);
    });

    _this._last = _this._container.querySelector('.last');
    _this._pages = 1;
    _this.page = 1;
    return _this;
  }

  _createClass(Pager, [{
    key: "page",
    get: function get() {
      return this._page;
    },
    set: function set(page) {
      if (Number.isInteger(page) && 1 <= page && page <= this.pages) {
        this._page = page;
        this._current.value = this._page;
        var event = document.createEvent('Event');
        event.initEvent('change', false, false);
        this.dispatchEvent(event);
      } else {
        this._current.value = this._page;
      }
    }
  }, {
    key: "pages",
    get: function get() {
      return this._pages;
    },
    set: function set(pages) {
      if (Number.isInteger(pages) && 1 <= this.page && this.page <= pages) {
        this._pages = pages;
        this._last.innerText = pages;
      }
    }
  }]);

  return Pager;
}(EventTarget);

var strings$g = {
  rus: {
    uploaded: {
      title: 'ÐÐ¾Ð¸ Ð´Ð°Ð½Ð½ÑÐµ',
      type: 'Ð¢Ð¸Ð¿ Ð´Ð°Ð½Ð½ÑÑ',
      date: 'ÐÐ°ÑÐ° Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ',
      name: 'ÐÐ°Ð¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ',
      previous: 'ÐÑÐµÐ´ÑÐ´ÑÑÐ°Ñ',
      next: 'Ð¡Ð»ÐµÐ´ÑÑÑÐ°Ñ',
      add: 'ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ',
      remove: 'Ð£Ð´Ð°Ð»Ð¸ÑÑ'
    }
  }
};

var Uploaded = /*#__PURE__*/function (_BaseView) {
  _inherits(Uploaded, _BaseView);

  var _super = _createSuper(Uploaded);

  function Uploaded(container, _ref) {
    var _this;

    var _ref$columns = _ref.columns,
        columns = _ref$columns === void 0 ? ['type', 'date', 'name'] : _ref$columns,
        _ref$types = _ref.types,
        types = _ref$types === void 0 ? ['shp', 'geojson'] : _ref$types,
        pageSize = _ref.pageSize;

    _classCallCheck(this, Uploaded);

    _this = _super.call(this, container, strings$g);
    _this._columns = columns;
    _this._types = types;
    _this._pageSize = pageSize;
    _this._page = 0;

    _this._container.classList.add('scanex-forestry-uploaded');

    _this._container.innerHTML = "<div class=\"title\">".concat(_this.translate('uploaded.title'), "</div>\n        <div class=\"filter\">\n            <table cellpadding=\"0\" cellspacing=\"0\">\n                <tr>\n                    <td>\n                        <div class=\"name\">\n                            <i class=\"scanex-uploaded-icon search\"></i>\n                            <input type=\"text\" placeholder=\"").concat(_this.translate('uploaded.name'), "\" value=\"\" />\n                        </div>\n                    </td>\n                    <td>\n                        <select>").concat(_this._types.map(function (id) {
      return "<option value=\"".concat(id, "\">").concat(id, "</option>");
    }).join(''), "</select>\n                    </td>\n                    <td>\n                        <div class=\"date\">\n                            <input class=\"datepicker\" type=\"text\" placeholder=\"").concat(_this.translate('uploaded.date'), "\" value=\"\" />\n                            <i class=\"scanex-uploaded-icon calendar\"></i>\n                        </div>\n                    </td>\n                </tr>\n            </table>\n        </div>\n        <div class=\"data\">\n            <table cellpadding=\"0\" cellspacing=\"0\">\n                <thead>\n                    <tr><th></th>").concat(_this._columns.map(function (id) {
      return "<th>".concat(_this.translate("uploaded.".concat(id)), "</th>");
    }).join(''), "</tr>\n                </thead>\n                <tbody class=\"content\"></tbody>\n            </table>\n        </div>\n        <div class=\"footer\">\n            <div class=\"pages\"></div>\n            <button class=\"add\">").concat(_this.translate("uploaded.add"), "</button>\n            <button class=\"remove\">").concat(_this.translate("uploaded.remove"), "</button>\n        </div>");
    _this._date = new pikaday({
      field: _this._container.querySelector('.datepicker'),
      format: 'DD.MM.YYYY',
      yearRange: 20,
      i18n: {
        previousMonth: 'ÐÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ',
        nextMonth: 'Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ',
        months: ['Ð¯Ð½Ð²Ð°ÑÑ', 'Ð¤ÐµÐ²ÑÐ°Ð»Ñ', 'ÐÐ°ÑÑ', 'ÐÐ¿ÑÐµÐ»Ñ', 'ÐÐ°Ð¹', 'ÐÑÐ½Ñ', 'ÐÑÐ»Ñ', 'ÐÐ²Ð³ÑÑÑ', 'Ð¡ÐµÐ½ÑÑÐ±ÑÑ', 'ÐÐºÑÑÐ±ÑÑ', 'ÐÐ¾ÑÐ±ÑÑ', 'ÐÐµÐºÐ°Ð±ÑÑ'],
        weekdays: ['ÐÐ¾ÑÐºÑÐµÑÐµÐ½ÑÐµ', 'ÐÐ¾Ð½ÐµÐ´ÐµÐ»ÑÐ½Ð¸Ðº', 'ÐÑÐ¾ÑÐ½Ð¸Ðº', 'Ð¡ÑÐµÐ´Ð°', 'Ð§ÐµÑÐ²ÐµÑÐ³', 'ÐÑÑÐ½Ð¸ÑÐ°', 'Ð¡ÑÐ±Ð±Ð¾ÑÐ°'],
        weekdaysShort: ['ÐÑ', 'ÐÐ½', 'ÐÑ', 'Ð¡Ñ', 'Ð§Ñ', 'ÐÑ', 'Ð¡Ð±']
      }
    });
    _this._content = _this._container.querySelector('.content');
    _this._pager = new Pager(_this._container.querySelector('.pages'));

    _this._pager.addEventListener('change', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this._page = _this._pager.page;
              _context.next = 3;
              return _this.open();

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));

    _this._pager.pages = 1;

    _this._container.querySelector('.add').addEventListener('click', function (e) {
      e.stopPropagation();

      _this._upload();
    });

    _this._container.querySelector('.remove').addEventListener('click', function (e) {
      e.stopPropagation();
    });

    return _this;
  }

  _createClass(Uploaded, [{
    key: "_upload",
    value: function _upload() {
      var _this2 = this;

      if (!this._files) {
        this._files = document.createElement('input');

        this._files.setAttribute('type', 'file');

        this._files.setAttribute('multiple', 'true');

        this._files.style.visibility = 'hidden';

        this._container.appendChild(this._files);

        this._files.addEventListener('change', function () {
          var event = document.createEvent('Event');
          event.initEvent('upload', false, false);
          event.detail = _this2._files.files;

          _this2.dispatchEvent(event);

          _this2._container.removeChild(_this2._files);

          _this2._files = null;
        });
      }

      this._files.click();
    }
  }, {
    key: "open",
    value: function open(_ref3) {
      var _this3 = this;

      var count = _ref3.count,
          layers = _ref3.layers;

      _get(_getPrototypeOf(Uploaded.prototype), "open", this).call(this);

      this._content.innerHTML = layers.map(function (item) {
        return "<tr>\n                <td>\n                    <i class=\"scanex-uploaded-icon box\"></i>\n                </td>\n                ".concat(_this3._columns.map(function (id) {
          return "<td>".concat(item[id], "</td>");
        }).join(''), "\n            </tr>");
      }).join('');

      var boxes = this._content.querySelectorAll('i');

      var _loop = function _loop(i) {
        var box = boxes[i];
        box.addEventListener('click', function (e) {
          e.stopPropagation();
          var active = !box.classList.contains('active');

          if (active) {
            box.classList.add('active');
          } else {
            box.classList.remove('active');
          }
        });
      };

      for (var i = 0; i < boxes.length; ++i) {
        _loop(i);
      }

      this._pager.pages = Math.ceil(count / this._pageSize);
    }
  }, {
    key: "page",
    get: function get() {
      return this._page;
    }
  }]);

  return Uploaded;
}(View);

var UploadProgress = /*#__PURE__*/function (_EventTarget) {
  _inherits(UploadProgress, _EventTarget);

  var _super = _createSuper(UploadProgress);

  function UploadProgress() {
    _classCallCheck(this, UploadProgress);

    return _super.call(this);
  }

  _createClass(UploadProgress, [{
    key: "start",
    value: function start() {
      var _this = this;

      this._container = document.createElement('div');
      document.body.appendChild(this._container);

      this._container.classList.add('scanex-forestry-progress');

      this._container.innerHTML = "<div>\n            <button class=\"pause\">Pause</button>\n            <button class=\"cancel\">Cancel</button>\n        </div>\n        <ul class=\"files\">\n        </ul>\n        <div class=\"speed\"></div>";
      this._btnPause = this._container.querySelector('.pause');

      this._btnPause.addEventListener('click', function (e) {
        e.stopPropagation();
        var event = document.createEvent('Event');
        event.initEvent('pause', false, false);

        _this.dispatchEvent(event);
      });

      this._btnCancel = this._container.querySelector('.cancel');

      this._btnCancel.addEventListener('click', function (e) {
        e.stopPropagation();
        var event = document.createEvent('Event');
        event.initEvent('cancel', false, false);

        _this.dispatchEvent(event);
      });

      this._files = this._container.querySelector('.files');
      this._speed = this._container.querySelector('.speed');
    }
  }, {
    key: "stop",
    value: function stop() {
      document.body.removeChild(this._container);
    }
  }, {
    key: "status",
    value: function status(index, percent, _status) {
      var row = this._files.querySelector("[data-id=\"".concat(index, "\"]"));

      row.querySelector('.percent').innerText = percent;
      row.querySelector('.status').innerText = _status;
    }
  }, {
    key: "files",
    set: function set(files) {
      this._files.innerHTML = files.map(function (_ref, i) {
        var name = _ref.name;
        return "<li data-id=\"".concat(i, "\">\n                <label class=\"name\">").concat(name, "</label>\n                <label class=\"percent\"></label>\n                <label class=\"status\"></label>\n            </li>");
      }).join('');
    }
  }, {
    key: "speed",
    set: function set(speed) {
      this._speed.innerText = speed;
    }
  }]);

  return UploadProgress;
}(EventTarget);

var translate$b = T.getText.bind(T);

var Uploaded$1 = /*#__PURE__*/function (_Controller) {
  _inherits(Uploaded$1, _Controller);

  var _super = _createSuper(Uploaded$1);

  function Uploaded$1(_ref) {
    var _this;

    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        path = _ref.path,
        _ref$pageSize = _ref.pageSize,
        pageSize = _ref$pageSize === void 0 ? 4 : _ref$pageSize,
        _ref$uploadFileSize = _ref.uploadFileSize,
        uploadFileSize = _ref$uploadFileSize === void 0 ? 1024 : _ref$uploadFileSize;

    _classCallCheck(this, Uploaded$1);

    _this = _super.call(this, {
      map: map,
      content: content,
      notifications: notifications
    });
    _this._path = path;
    _this._pageSize = pageSize;
    _this._uploadFileSize = uploadFileSize;
    _this._progress = new UploadProgress();

    _this._progress.on('pause', function () {
      console.log('pause');
    }).on('cancel', function () {
      console.log('cancel');
    });

    _this._view = _this._content.add('uploaded', Uploaded, {
      pageSize: _this._pageSize
    });

    _this._view.on('upload', /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
        var files;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                files = e.detail;

                _this._progress.start();

                _context.next = 4;
                return _this._createSandbox();

              case 4:
                _this._sandboxId = _context.sent;
                _this._upfiles = _this._createParts(files);
                _this._progress.files = _this._upfiles;

                _this._startUpload();

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());

    return _this;
  }

  _createClass(Uploaded$1, [{
    key: "view",
    value: function () {
      var _view = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var data;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._query(this._view.page);

              case 2:
                data = _context2.sent;

                if (data) {
                  this._view.open(data);
                }

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function view() {
        return _view.apply(this, arguments);
      }

      return view;
    }()
  }, {
    key: "_createSandbox",
    value: function () {
      var _createSandbox2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var data, sandbox;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.httpGet("".concat(this._path, "/sandbox/CreateSandbox"));

              case 2:
                data = _context3.sent;

                if (!data) {
                  _context3.next = 6;
                  break;
                }

                sandbox = data.sandbox;
                return _context3.abrupt("return", sandbox);

              case 6:
                return _context3.abrupt("return");

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _createSandbox() {
        return _createSandbox2.apply(this, arguments);
      }

      return _createSandbox;
    }()
  }, {
    key: "_createParts",
    value: function _createParts(files) {
      var upfiles = [];

      for (var i = 0; i < files.length; i++) {
        var partsCount = Math.ceil(files[i].size / this._uploadFileSize);
        var parts = [];

        for (var _i = 0; _i < partsCount - 1; _i++) {
          parts.push({
            xhr: null,
            status: 'none',
            size: this._uploadFileSize,
            send: 0,
            needSend: this._uploadFileSize
          });
        }

        var lastSize = files[i].size - this._uploadFileSize * (partsCount - 1);
        parts.push({
          xhr: null,
          status: 'none',
          size: lastSize,
          send: 0,
          needSend: lastSize
        }); //ÑÑÐ°ÑÑÑ Ð·Ð°Ð³ÑÑÐ·ÐºÐ¸ ÑÐ°Ð½ÐºÐ°

        var p = {
          item: files[i],
          name: files[i].name,
          parts: parts,
          totalBytes: files[i].size,
          status: 'none' //ÑÑÐ°ÑÑÑ Ð·Ð°Ð³ÑÑÐ·ÐºÐ¸ ÑÐ°Ð¹Ð»Ð°

        };
        upfiles.push(p);
      }

      return upfiles;
    }
  }, {
    key: "_startUpload",
    value: function _startUpload() {
      this._upfilesStatus = "progress";

      for (var i = 0; i < this._upfiles.length; i++) {
        //Ð·Ð°Ð¿ÑÑÐºÐ°ÐµÐ¼ 6 Ð¿Ð¾ÑÐ¾ÐºÐ¾Ð²
        if (this._upfiles[i].status === "error") {
          this._upfiles[i].status = "none";
        }

        var wait = false;

        for (var i1 = 0; i1 < this._upfiles[i].parts.length; i1++) {
          if (this._upfiles[i].parts[i1].status === "error") {
            this._upfiles[i].parts[i1].status = "none"; //Ð¾ÑÐ¼ÐµÐ½ÑÐµÐ¼ Ð¾ÑÐ¸Ð±ÐºÑ
          }

          if (this._upfiles[i].parts[i1].status === "none") {
            wait = true; //ÐµÑÐ»Ð¸ ÐµÑÑÑ Ð½Ðµ Ð¾ÑÐ¾ÑÐ»Ð°Ð½ÑÐµ ÑÐ°Ð½ÐºÐ¸
          }
        }

        var p = this._percent(this._upfiles[i]);

        this._progress.status(i, p, wait ? 'Waiting' : 'Completed');
      }

      for (var _i2 = 0; _i2 < 8; _i2++) {
        //Ð·Ð°Ð¿ÑÑÐºÐ°ÐµÐ¼ 6 Ð¿Ð¾ÑÐ¾ÐºÐ¾Ð²
        this._sendNextPart();
      }

      this._stopSpeedTimer();

      this._speedTimer = setInterval(this._renewSpeedTimer.bind(this), 1000);
    }
  }, {
    key: "_percent",
    value: function _percent(t) {
      return Math.round(t.parts.reduce(function (a, p) {
        return a + p.size / t.totalBytes * (p.send / p.needSend);
      }, 0) * 100);
    }
  }, {
    key: "_sendNextPart",
    value: function _sendNextPart() {
      var _this2 = this;

      if (this._upfilesStatus === 'error') {
        return false;
      }

      var _loop = function _loop(i) {
        var t = _this2._upfiles[i];

        var _loop2 = function _loop2(i1) {
          if (t.parts[i1].status === "none") {
            var startByte = _this2._uploadFileSize * i1;
            var countBytes = _this2._uploadFileSize;

            if (startByte + countBytes > t.totalBytes) {
              countBytes = t.totalBytes - startByte;
            }

            if (t.status === "none") {
              t.status = "progress";

              _this2._progress.status(i1, 0, "0%");
            }

            t.parts[i1].status = "progress";
            var chunk = t.item.slice(startByte, startByte + countBytes + 1);
            var chunkFile = new File([chunk], t.name);
            var fd = new FormData();
            fd.append("sandbox", _this2._sandboxId);
            fd.append("startByte", startByte);
            fd.append("file", chunkFile);
            req = new XMLHttpRequest();
            req.open("post", "".concat(_this2._path, "/sandbox/upload"));
            t.parts[i1].xhr = req;

            req.upload.onerror = function () {
              t.parts[i1].status = 'error';
              t.parts[i1].xhr = null;
              t.status = "error";

              _this2._progress.status(i, 0, 'Error');

              _this2._errorUpload();
            };

            var lastSend = 0;

            req.upload.onprogress = function (event) {
              t.parts[i1].send = event.loaded;
              t.parts[i1].needSend = event.total;

              var p = _this2._percent(t);

              _this2._progress.status(i, p, 'Loading...');

              _this2._currentSendBytes += event.loaded - lastSend; //Ð¿Ð¾Ð´ÑÑÑÑ ÑÐºÐ¾ÑÐ¾ÑÑÐ¸

              lastSend = event.loaded;
            };

            req.onload = function () {
              t.parts[i1].xhr = null;

              if (req.status !== 200) {
                // Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ HTTP-ÑÑÐ°ÑÑÑ Ð¾ÑÐ²ÐµÑÐ°, ÐµÑÐ»Ð¸ ÑÑÐ°ÑÑÑ Ð½Ðµ 200, ÑÐ¾ Ð¿ÑÐ¾Ð¸Ð·Ð¾ÑÐ»Ð° Ð¾ÑÐ¸Ð±ÐºÐ°
                t.parts[i1].status = 'error';
                t.status = "error";

                var p = _this2._percent(t);

                _this2._progress.status(i, p, "Error");

                _this2._errorUpload();
              } else {
                if (_this2._upfilesStatus === "error") {
                  //ÐµÑÐ»Ð¸ ÐºÑÐ¾-ÑÐ¾ Ð³Ð»ÑÐºÐ½ÑÐ» Ð¾ÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð²ÑÑ. ÐÐ¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÑÐ¾ Ð¾ÑÐ¼ÐµÐ½Ð°
                  t.parts[i1].status = 'error';
                  t.status = "error";

                  var _p = _this2._percent(t);

                  _this2._progress.status(i1, _p, "Error");

                  return;
                } // ÐµÑÐ»Ð¸ Ð²ÑÑ Ð¿ÑÐ¾ÑÐ»Ð¾ Ð³Ð»Ð°Ð´ÐºÐ¾, Ð²ÑÐ²Ð¾Ð´Ð¸Ð¼ ÑÐµÐ·ÑÐ»ÑÑÐ°Ñ


                t.parts[i1].status = 'finish';
                var oksum = 0;

                for (var i3 = 0; i3 < t.parts.length; i3++) {
                  if (t.parts[i3].status === "finish") oksum++;
                }

                if (oksum === t.parts.length) {
                  t.status = "finish";

                  var _p2 = _this2._percent(t);

                  _this2._progress.status(i, _p2, "Completed");
                }

                _this2._sendNextPart(); //Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÑÐ¾ Ð²ÑÐµ ÑÐ°Ð¹Ð»Ñ Ð¾ÑÐ¾ÑÐ»Ð°Ð½Ñ


                var sumFilesOk = 0;

                _this2._upfiles.forEach(function (a) {
                  if (a.status === "finish") sumFilesOk++;
                });

                if (sumFilesOk === _this2._upfiles.length) {
                  _this2._finishUpload();
                }
              }
            };

            req.send(fd);
            return {
              v: {
                v: true
              }
            };
          }
        };

        for (var i1 = 0; i1 < t.parts.length; i1++) {
          var _ret2 = _loop2(i1);

          if (_typeof(_ret2) === "object") return _ret2.v;
        }
      };

      for (var i = 0; i < this._upfiles.length; i++) {
        var req;

        var _ret = _loop(i);

        if (_typeof(_ret) === "object") return _ret.v;
      }

      return false;
    }
  }, {
    key: "_stopSpeedTimer",
    value: function _stopSpeedTimer() {
      if (this._speedTimer != null) {
        clearInterval(this._speedTimer);
      }

      this._speedTimer = null;
      this._progress.speed = '';
      this._oldSendBytes = [];
      this._currentSendBytes = 0;
    }
  }, {
    key: "_renewSpeedTimer",
    value: function _renewSpeedTimer() {
      var ready = 0;
      var total = 0;

      for (var i = 0; i < this._upfiles.length; i++) {
        var t = this._upfiles[i];
        total += t.totalBytes;

        for (var i5 = 0; i5 < t.parts.length; i5++) {
          var tp = t.parts[i5];

          if (tp.status === "progress") {
            ready = ready + tp.size * (tp.send / tp.needSend);
          }

          if (tp.status === "finish") ready = ready + tp.size;
        }
      } //Ð¸ÑÑÐ¾ÑÐ¸Ñ ÑÐºÐ¾ÑÐ¾ÑÑÐ¸


      this._oldSendBytes.unshift(this._currentSendBytes);

      if (this._oldSendBytes.length > 5) {
        this._oldSendBytes.length = 5;
      }

      var sumSend = 0;

      this._oldSendBytes.forEach(function (a) {
        return sumSend += a;
      });

      var s = Math.round(sumSend / this._oldSendBytes.length); //Ð±Ð°Ð¹Ñ Ð² ÑÐµÐºÑÐ½Ð´Ñ

      var str = this._roundBytes(s) + "/s";
      this._progress.speed = "Speed " + str + " Progress: " + this._roundBytes(ready) + " of " + this._roundBytes(total);
      this._currentSendBytes = 0;
    }
  }, {
    key: "_roundBytes",
    value: function _roundBytes(s) {
      var str = "";
      if (s > 1024 * 1024 * 1024 * 1024 * 1.2) str = (Math.round(s / (1024 * 1024 * 1024 * 1024) * 100) / 100).toString() + " Tb";else if (s > 1024 * 1024 * 1024 * 1.2) str = (Math.round(s / (1024 * 1024 * 1024) * 100) / 100).toString() + " Gb";else if (s > 1024 * 1024 * 1.2) str = (Math.round(s / (1024 * 1024) * 100) / 100).toString() + " Mb";else if (s > 1024 * 1.2) str = (Math.round(s / 1024 * 100) / 100).toString() + " Kb";else str = Math.round(s).toString() + " b";
      return str;
    }
  }, {
    key: "_errorUpload",
    value: function _errorUpload() {
      if (this._upfilesStatus !== 'error') {
        this._stopSpeedTimer();

        this._upfilesStatus = 'error'; // document.getElementById('global_status').textContent = "Error";
        // document.getElementById("cancel").disabled = true;
        // document.getElementById("resume").disabled = false;
        // document.getElementById("send").disabled = false;
        // document.getElementById("open").disabled = false;

        this._progress.stop();

        this.view();
      }
    }
  }, {
    key: "_finishUpload",
    value: function _finishUpload() {
      if (this._upfilesStatus === 'finish') return;

      if (this._upfilesStatus === 'progress') {
        this._stopSpeedTimer();

        this._upfilesStatus = 'finish'; // document.getElementById('global_status').textContent = "Finish";
        // document.getElementById("cancel").disabled = true;
        // document.getElementById("resume").disabled = true;
        // document.getElementById("send").disabled = false;
        // document.getElementById("open").disabled = false;

        this._progress.stop();

        this.view();
      }
    }
  }, {
    key: "_query",
    value: function () {
      var _query2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(page) {
        var fd, _yield$this$sendForm, Status, Result;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                fd = new FormData();
                fd.append('query', '');
                fd.append('orderby', 'datecreate');
                fd.append('pagesize', this._pageSize.toString());
                fd.append('page', page.toString());
                _context4.next = 7;
                return this.sendForm("".concat(this._path, "/Layer/Search2.ashx?WrapStyle=None"), fd);

              case 7:
                _yield$this$sendForm = _context4.sent;
                Status = _yield$this$sendForm.Status;
                Result = _yield$this$sendForm.Result;

                if (!(Status === 'ok')) {
                  _context4.next = 14;
                  break;
                }

                return _context4.abrupt("return", Result);

              case 14:
                return _context4.abrupt("return", false);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _query(_x2) {
        return _query2.apply(this, arguments);
      }

      return _query;
    }()
  }]);

  return Uploaded$1;
}(Controller);

var Warehouses = /*#__PURE__*/function (_LayerController) {
  _inherits(Warehouses, _LayerController);

  var _super = _createSuper(Warehouses);

  function Warehouses(_ref) {
    var map = _ref.map,
        content = _ref.content,
        notifications = _ref.notifications,
        layer = _ref.layer,
        legend = _ref.legend;

    _classCallCheck(this, Warehouses);

    return _super.call(this, {
      kind: 'warehouses',
      map: map,
      content: content,
      notifications: notifications,
      layer: layer,
      legend: legend
    });
  }

  return Warehouses;
}(LayerController);

var ALLOWED_LAYERS = ['warehouses', 'roads', 'declarations', 'incidents', 'quadrants', 'stands', 'projects', 'plots', 'fires', 'parks', 'forestries_local', 'forestries', 'regions'].reverse();

var Map = /*#__PURE__*/function (_EventTarget) {
  _inherits(Map, _EventTarget);

  var _super = _createSuper(Map);

  function Map(container) {
    var _this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      permissions: {}
    },
        permissions = _ref.permissions,
        _ref$gmxPath = _ref.gmxPath,
        gmxPath = _ref$gmxPath === void 0 ? '/gis' : _ref$gmxPath,
        _ref$apiPath = _ref.apiPath,
        apiPath = _ref$apiPath === void 0 ? '/service' : _ref$apiPath,
        _ref$monPath = _ref.monPath,
        monPath = _ref$monPath === void 0 ? '/monitoring' : _ref$monPath,
        _ref$apiKey = _ref.apiKey,
        apiKey = _ref$apiKey === void 0 ? 'I9ELMZU8GD' : _ref$apiKey;

    _classCallCheck(this, Map);

    _this = _super.call(this);
    _this._layers = {};
    _this._hilited = {};
    _this._permissions = Array.isArray(permissions) && permissions.reduce(function (a, k) {
      a[k] = true;
      return a;
    }, {}) || {};
    _this._container = container;

    _this._container.classList.add('scanex-forestry-map');

    _this._apiKey = apiKey;
    _this._gmxPath = gmxPath;
    _this._apiPath = apiPath;
    _this._monPath = monPath;
    var center = [55.203953, 132.53906];
    var zoom = 5;
    _this._map = L$1.map(_this._container, {
      // renderer: L.canvas(),
      attributionControl: false,
      zoomControl: false
    });

    _this._createCorners();

    _this._setOrigin(center, zoom); // this._map.on('click', async e =>  {
    //     L.DomEvent.stopPropagation(e);
    //     if (!e.gmx && e.originalEvent.target.tagName !== 'g') {
    //         await this.showMain();
    //     }
    // }, this);


    _this._map.addControl(L$1.control.attribution({
      position: 'bottomleft'
    }));

    _this._map.addControl(new gmxCenter());

    _this._map.addControl(new gmxLocation());

    _this._content = new Content();

    _this._content.addTo(_this._map);

    _this._notifications = {
      unAuthorized: _this._content.add('unauthorized', UnAuthorized),
      forbidden: _this._content.add('forbidden', Forbidden),
      loading: _this._content.add('loading', Loading),
      notAvailable: _this._content.add('not-available', NotAvailable),
      notFound: _this._content.add('not-found', NotFound),
      serverError: _this._content.add('server-error', ServerError)
    };
    return _this;
  }

  _createClass(Map, [{
    key: "_createCorners",
    value: function _createCorners() {
      var corners = this._map._controlCorners;
      var parent = this._map._controlContainer;
      var tb = 'leaflet-top leaflet-bottom';
      var lr = 'leaflet-left leaflet-right';
      var classNames = {
        bottom: "leaflet-bottom ".concat(lr),
        gmxbottomleft: 'leaflet-bottom leaflet-left',
        gmxbottomcenter: "leaflet-bottom ".concat(lr),
        gmxbottomright: 'leaflet-bottom leaflet-right',
        center: "".concat(tb, " ").concat(lr),
        right: "leaflet-right ".concat(tb),
        left: "leaflet-left ".concat(tb),
        top: "leaflet-top ".concat(lr)
      };
      Object.keys(classNames).forEach(function (key) {
        if (!corners[key]) {
          corners[key] = L$1.DomUtil.create('div', classNames[key], parent);
        }
      });
      corners.document = document.body;
    }
  }, {
    key: "_setOrigin",
    value: function _setOrigin(center, zoom) {
      var _this2 = this;

      this._map.on('moveend', function (e) {
        var _this2$_map$getCenter = _this2._map.getCenter(),
            lat = _this2$_map$getCenter.lat,
            lng = _this2$_map$getCenter.lng;

        window.localStorage.setItem('center', JSON.stringify([lat, lng]));
      }, this);

      this._map.on('zoomend', function (e) {
        var z = _this2._map.getZoom();

        window.localStorage.setItem('zoom', z.toString());
      }, this);

      var c = window.localStorage.getItem('center');

      try {
        c = c && JSON.parse(c) || center;
      } catch (_unused) {
        c = center;
      }

      var z = window.localStorage.getItem('zoom');
      z = z && parseInt(z, 10) || zoom;

      this._map.setView(c, z);
    }
  }, {
    key: "showMain",
    value: function () {
      var _showMain = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._legend.showPanel(false);

                this._baselayers.showPanel(false);

                this._content.close();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function showMain() {
        return _showMain.apply(this, arguments);
      }

      return showMain;
    }()
  }, {
    key: "showAnalytics",
    value: function () {
      var _showAnalytics = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._permissions.AnaliticData) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 3;
                return this._controllers.reports.view();

              case 3:
                _context2.next = 6;
                break;

              case 5:
                this._notifications.forbidden.open();

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function showAnalytics() {
        return _showAnalytics.apply(this, arguments);
      }

      return showAnalytics;
    }()
  }, {
    key: "showRequests",
    value: function () {
      var _showRequests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this._permissions.ForestProjectsView) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 3;
                return this._controllers.requests.view();

              case 3:
                _context3.next = 6;
                break;

              case 5:
                this._notifications.forbidden.open();

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function showRequests() {
        return _showRequests.apply(this, arguments);
      }

      return showRequests;
    }()
  }, {
    key: "createRequest",
    value: function () {
      var _createRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this._permissions.ApplicationMake) {
                  _context4.next = 5;
                  break;
                }

                _context4.next = 3;
                return this._controllers.projects.create();

              case 3:
                _context4.next = 6;
                break;

              case 5:
                this._notifications.forbidden.open();

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function createRequest() {
        return _createRequest.apply(this, arguments);
      }

      return createRequest;
    }()
  }, {
    key: "showUploaded",
    value: function () {
      var _showUploaded = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function showUploaded() {
        return _showUploaded.apply(this, arguments);
      }

      return showUploaded;
    }()
  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var _this3 = this;

        var mapId;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                window.SELF = this;
                mapId = 'default';
                _context11.next = 4;
                return L$1.gmx.loadMap(mapId, {
                  leafletMap: this._map,
                  hostName: '/',
                  setZIndex: true,
                  gmxEndPoints: {
                    checkVersion: "".concat(this._gmxPath, "/Layer/CheckVersion.ashx"),
                    layerProps: "".concat(this._gmxPath, "/Layer/GetLayerJson.ashx"),
                    searchLayerItem: "".concat(this._gmxPath, "/VectorLayer/Search.ashx"),
                    tileProps: "".concat(this._gmxPath, "/TileSender.ashx"),
                    mapProps: "".concat(this._gmxPath, "/TileSender.ashx")
                  }
                });

              case 4:
                this._gmxMap = _context11.sent;

                this._map.on('zoomend', function (e) {
                  if (_this3._grid) {
                    _this3._grid.repaint();
                  }
                });

                this._zoom = new Zoom();
                this._baselayers = new BaseLayers({
                  apiKey: this._apiKey
                });
                this._legend = new Legend();

                this._baselayers.on('activate', function () {
                  _this3._legend.showPanel(false);
                });

                this._legend.on('activate', function () {
                  _this3._baselayers.showPanel(false);
                });

                this._legend.addTo(this._map);

                this._zoom.addTo(this._map);

                this._baselayers.addTo(this._map);

                this._layers = this._gmxMap.layers // clear map
                .map(function (layer) {
                  if (layer._map) {
                    _this3._map.removeLayer(layer);
                  }

                  return layer;
                }) // retain only defined layers
                .filter(function (layer) {
                  var _layer$getGmxProperti = layer.getGmxProperties(),
                      kind = _layer$getGmxProperti.MetaProperties.kind;

                  return kind && ALLOWED_LAYERS.indexOf(kind.Value) !== -1;
                }).map(function (layer) {
                  if (layer._map && layer._map !== _this3._map) {
                    layer._map.removeLayer(layer);
                  }

                  var _layer$getGmxProperti2 = layer.getGmxProperties(),
                      IsRasterCatalog = _layer$getGmxProperti2.IsRasterCatalog,
                      Temporal = _layer$getGmxProperti2.Temporal,
                      kind = _layer$getGmxProperti2.MetaProperties.kind;

                  return {
                    layer: layer,
                    kind: kind.Value,
                    isRaster: IsRasterCatalog,
                    temporal: Temporal,
                    index: ALLOWED_LAYERS.indexOf(kind.Value)
                  };
                }) // set z-index & options
                .map(function (_ref2) {
                  var layer = _ref2.layer,
                      kind = _ref2.kind,
                      index = _ref2.index,
                      isRaster = _ref2.isRaster,
                      temporal = _ref2.temporal;

                  if (typeof layer.disablePopup === 'function') {
                    layer.disablePopup();
                  }

                  if (temporal && typeof layer.setDateInterval === 'function') {
                    var e = new Date();
                    var b = new Date(e.getTime() - 1000 * 60 * 60 * 24 * 30);
                    layer._gmx.rawProperties.maxShownPeriod = null;
                    layer.setDateInterval(b, e);
                  }

                  if (kind !== 'fires' && typeof layer.setZIndex === 'function') {
                    layer.setZIndex(index);
                  }

                  return {
                    layer: layer,
                    kind: kind
                  };
                }) // create layers cache
                .reduce(function (a, _ref3) {
                  var layer = _ref3.layer,
                      kind = _ref3.kind;
                  a[kind] = layer;
                  return a;
                }, {});
                this._dateInterval = new DateInterval();

                this._map.addControl(this._dateInterval);

                this._controllers = {}; // attach layer controllers        

                if (this._layers.quadrants && this._permissions.ForestBlocks) {
                  this._controllers.quadrants = new Quadrants$2({
                    map: this._map,
                    layer: this._layers.quadrants,
                    legend: this._legend,
                    content: this._content,
                    path: this._apiPath,
                    permissions: this._permissions,
                    notifications: this._notifications
                  });

                  this._controllers.quadrants.on('quadrant:toggle', /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(e) {
                      var _e$detail, gmx_id, forestryID;

                      return regeneratorRuntime.wrap(function _callee6$(_context6) {
                        while (1) {
                          switch (_context6.prev = _context6.next) {
                            case 0:
                              _e$detail = e.detail, gmx_id = _e$detail.gmx_id, forestryID = _e$detail.forestryID;
                              _context6.next = 3;
                              return _this3._controllers.projects.toggleQuadrant({
                                gmx_id: gmx_id,
                                forestryID: forestryID
                              });

                            case 3:
                              _this3._layers.quadrants.repaint();

                            case 4:
                            case "end":
                              return _context6.stop();
                          }
                        }
                      }, _callee6);
                    }));

                    return function (_x) {
                      return _ref4.apply(this, arguments);
                    };
                  }());
                }

                if (this._layers.stands && this._permissions.ForestStands) {
                  this._controllers.stands = new Stands$1({
                    map: this._map,
                    layer: this._layers.stands,
                    legend: this._legend,
                    content: this._content,
                    path: this._apiPath,
                    permissions: this._permissions,
                    notifications: this._notifications
                  });
                }

                if (this._layers.declarations && this._permissions.ForestDeclarations) {
                  this._controllers.declarations = new Declarations({
                    map: this._map,
                    layer: this._layers.declarations,
                    legend: this._legend,
                    content: this._content,
                    path: this._apiPath,
                    notifications: this._notifications
                  });
                }

                if (this._layers.fires && this._permissions.ForestFires) {
                  this._map.addLayer(this._layers.fires);

                  this._controllers.fires = new Fires$1({
                    map: this._map,
                    layers: this._layers,
                    legend: this._legend,
                    content: this._content,
                    path: this._apiPath,
                    permissions: this._permissions,
                    dateInterval: this._dateInterval,
                    notifications: this._notifications
                  });
                }

                if (this._layers.parks && this._permissions.SPNA) {
                  this._controllers.parks = new Parks$1({
                    map: this._map,
                    layer: this._layers.parks,
                    legend: this._legend,
                    content: this._content,
                    path: this._apiPath,
                    notifications: this._notifications
                  });
                }

                if (this._layers.projects && this._permissions.ForestProjectsView) {
                  this._controllers.projects = new Projects({
                    map: this._map,
                    layers: this._layers,
                    legend: this._legend,
                    content: this._content,
                    path: this._apiPath,
                    permissions: this._permissions,
                    notifications: this._notifications
                  });

                  this._controllers.projects.on('create', /*#__PURE__*/function () {
                    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(e) {
                      var event;
                      return regeneratorRuntime.wrap(function _callee7$(_context7) {
                        while (1) {
                          switch (_context7.prev = _context7.next) {
                            case 0:
                              event = document.createEvent('Event');
                              event.initEvent('request:create', false, false);
                              event.detail = e.detail;

                              _this3.dispatchEvent(event);

                            case 4:
                            case "end":
                              return _context7.stop();
                          }
                        }
                      }, _callee7);
                    }));

                    return function (_x2) {
                      return _ref5.apply(this, arguments);
                    };
                  }());

                  this._controllers.projects.on('back', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
                    return regeneratorRuntime.wrap(function _callee8$(_context8) {
                      while (1) {
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            _context8.next = 2;
                            return _this3.showRequests();

                          case 2:
                          case "end":
                            return _context8.stop();
                        }
                      }
                    }, _callee8);
                  })));
                }

                if (this._layers.plots && this._permissions.ForestProjectsView) {
                  this._controllers.plots = new Plots$1({
                    map: this._map,
                    layer: this._layers.plots,
                    legend: this._legend,
                    content: this._content,
                    path: this._apiPath,
                    permissions: this._permissions,
                    notifications: this._notifications
                  });
                }

                if (this._permissions.ForestProjectsView) {
                  this._controllers.requests = new Requests$1({
                    map: this._map,
                    content: this._content,
                    path: this._apiPath,
                    layers: this._layers,
                    legend: this._legend,
                    permissions: this._permissions,
                    notifications: this._notifications
                  });

                  this._controllers.requests.on('view', /*#__PURE__*/function () {
                    var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(e) {
                      var _e$detail2, id, forestryID, _this3$_layers$projec, LayerID, c, z;

                      return regeneratorRuntime.wrap(function _callee9$(_context9) {
                        while (1) {
                          switch (_context9.prev = _context9.next) {
                            case 0:
                              _e$detail2 = e.detail, id = _e$detail2.id, forestryID = _e$detail2.forestryID;
                              _context9.next = 3;
                              return _this3._controllers.projects.view({
                                id: id,
                                forestryID: forestryID
                              });

                            case 3:
                              _this3$_layers$projec = _this3._layers.projects.getGmxProperties(), LayerID = _this3$_layers$projec.LayerID;
                              _context9.prev = 4;
                              _context9.next = 7;
                              return getObjectCenter(_this3._gmxPath, LayerID, id);

                            case 7:
                              c = _context9.sent;
                              z = 10;

                              _this3._map.setView(c, z);

                              _context9.next = 15;
                              break;

                            case 12:
                              _context9.prev = 12;
                              _context9.t0 = _context9["catch"](4);
                              console.log(_context9.t0);

                            case 15:
                            case "end":
                              return _context9.stop();
                          }
                        }
                      }, _callee9, null, [[4, 12]]);
                    }));

                    return function (_x3) {
                      return _ref7.apply(this, arguments);
                    };
                  }());

                  this._controllers.requests.on('create', function () {
                    _this3._controllers.projects.create();
                  });

                  this._controllers.requests.on('edit', /*#__PURE__*/function () {
                    var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(e) {
                      var _e$detail3, id, forestryID, _this3$_layers$projec2, LayerID, c, z;

                      return regeneratorRuntime.wrap(function _callee10$(_context10) {
                        while (1) {
                          switch (_context10.prev = _context10.next) {
                            case 0:
                              _e$detail3 = e.detail, id = _e$detail3.id, forestryID = _e$detail3.forestryID;
                              _context10.next = 3;
                              return _this3._controllers.projects.edit({
                                id: id,
                                forestryID: forestryID
                              });

                            case 3:
                              _this3$_layers$projec2 = _this3._layers.projects.getGmxProperties(), LayerID = _this3$_layers$projec2.LayerID;
                              _context10.prev = 4;
                              _context10.next = 7;
                              return getObjectCenter(_this3._gmxPath, LayerID, id);

                            case 7:
                              c = _context10.sent;
                              z = 10;

                              _this3._map.setView(c, z);

                              _context10.next = 15;
                              break;

                            case 12:
                              _context10.prev = 12;
                              _context10.t0 = _context10["catch"](4);
                              console.log(_context10.t0);

                            case 15:
                            case "end":
                              return _context10.stop();
                          }
                        }
                      }, _callee10, null, [[4, 12]]);
                    }));

                    return function (_x4) {
                      return _ref8.apply(this, arguments);
                    };
                  }());
                }

                if (this._layers.roads) {
                  this._controllers.roads = new Roads({
                    map: this._map,
                    layer: this._layers.roads,
                    legend: this._legend,
                    content: this._content,
                    notifications: this._notifications
                  });
                }

                if (this._layers.warehouses) {
                  this._controllers.warehouses = new Warehouses({
                    map: this._map,
                    layer: this._layers.warehouses,
                    legend: this._legend,
                    content: this._content,
                    notifications: this._notifications
                  });
                }

                if (this._layers.regions || this._layers.forestries || this._layers.forestries_local) {
                  this._controllers.borders = new Borders({
                    map: this._map,
                    layers: this._layers,
                    legend: this._legend,
                    content: this._content,
                    notifications: this._notifications
                  });
                }

                if (this._layers.incidents && this._permissions.ForestIncidents) {
                  this._layers.incidents.verifyRaster = this._gmxMap.layersByID['5728425F25B04F73871EDF47CC8EFBC0'];
                  this._controllers.incidents = new Incidents$1({
                    map: this._map,
                    layer: this._layers.incidents,
                    legend: this._legend,
                    content: this._content,
                    path: this._monPath,
                    permissions: this._permissions,
                    dateInterval: this._dateInterval,
                    notifications: this._notifications
                  });

                  this._controllers.incidents.on('incident:docs', function (e) {
                    var event = document.createEvent('Event');
                    event.initEvent('incident:docs', false, false);
                    event.detail = e.detail;

                    _this3.dispatchEvent(event);
                  });
                }

                if (this._permissions.AnaliticData) {
                  this._controllers.reports = new Reports$1({
                    path: this._apiPath,
                    content: this._content,
                    notifications: this._notifications
                  });
                }

                if (this._permissions.MyData) {
                  this._controllers.uploaded = new Uploaded$1({
                    path: this._gmxPath,
                    content: this._content,
                    notifications: this._notifications
                  });
                }

                this._baselayers.toggle('sputnik');

                this._legend.showPanel(true); // attach legend controller


                this._controllers.legend = new Legend$1({
                  map: this._map,
                  legend: this._legend,
                  tags: ['regions', 'forestries'],
                  notifications: this._notifications
                });

              case 35:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function load() {
        return _load.apply(this, arguments);
      }

      return load;
    }()
  }, {
    key: "unload",
    value: function unload() {
      this._baselayers.unload();
    }
  }, {
    key: "addCRLayer",
    value: function () {
      var _addCRLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(layerID, mapID) {
        var arr, layer;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return L$1.gmx.loadLayers([{
                  hostName: '/',
                  gmxEndPoints: {
                    checkVersion: "".concat(this._gmxPath, "/Layer/CheckVersion.ashx"),
                    layerProps: "".concat(this._gmxPath, "/Layer/GetLayerJson.ashx"),
                    searchLayerItem: "".concat(this._gmxPath, "/VectorLayer/Search.ashx"),
                    tileProps: "".concat(this._gmxPath, "/TileSender.ashx"),
                    mapProps: "".concat(this._gmxPath, "/TileSender.ashx")
                  },
                  mapID: mapID || '3D448C6108A8441CAC25371616B0CBB0',
                  layerID: layerID
                }], {});

              case 2:
                arr = _context12.sent;
                layer = arr[0];

                if (layer) {
                  layer.setZIndexOffset(-500000);

                  this._dateInterval.addLayer(layer);

                  this._map.addLayer(layer);
                }

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function addCRLayer(_x5, _x6) {
        return _addCRLayer.apply(this, arguments);
      }

      return addCRLayer;
    }()
  }, {
    key: "removeCRLayer",
    value: function removeCRLayer(layerID) {
      this._dateInterval.removeLayerByID(layerID);
    }
  }]);

  return Map;
}(EventTarget);

module.exports = Map;
//# sourceMappingURL=forestry.cjs.js.map
